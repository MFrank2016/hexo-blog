<<<<<<< HEAD
{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/0001.png","path":"images/0001.png","modified":0,"renderable":0},{"_id":"source/images/0002.png","path":"images/0002.png","modified":0,"renderable":0},{"_id":"source/images/0005.png","path":"images/0005.png","modified":0,"renderable":0},{"_id":"source/images/0003.png","path":"images/0003.png","modified":0,"renderable":0},{"_id":"source/images/0009.png","path":"images/0009.png","modified":0,"renderable":0},{"_id":"source/images/0012.png","path":"images/0012.png","modified":0,"renderable":0},{"_id":"source/images/0013.png","path":"images/0013.png","modified":0,"renderable":0},{"_id":"source/images/0040.png","path":"images/0040.png","modified":0,"renderable":0},{"_id":"source/images/0019.png","path":"images/0019.png","modified":0,"renderable":0},{"_id":"source/images/0046.png","path":"images/0046.png","modified":0,"renderable":0},{"_id":"source/images/06.png","path":"images/06.png","modified":0,"renderable":0},{"_id":"source/images/0190.png","path":"images/0190.png","modified":0,"renderable":0},{"_id":"source/images/105.png","path":"images/105.png","modified":0,"renderable":0},{"_id":"source/images/148.png","path":"images/148.png","modified":0,"renderable":0},{"_id":"source/images/141.png","path":"images/141.png","modified":0,"renderable":0},{"_id":"source/images/195.png","path":"images/195.png","modified":0,"renderable":0},{"_id":"source/images/2030.png","path":"images/2030.png","modified":0,"renderable":0},{"_id":"source/images/94.png","path":"images/94.png","modified":0,"renderable":0},{"_id":"source/images/8111.png","path":"images/8111.png","modified":0,"renderable":0},{"_id":"source/images/black_smile.png","path":"images/black_smile.png","modified":0,"renderable":0},{"_id":"source/images/black_smile-2.png","path":"images/black_smile-2.png","modified":0,"renderable":0},{"_id":"themes/indigos/source/css/style.less","path":"css/style.less","modified":0,"renderable":1},{"_id":"themes/indigos/source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":1},{"_id":"themes/indigos/source/img/cc.png","path":"img/cc.png","modified":0,"renderable":1},{"_id":"themes/indigos/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/indigos/source/img/img-loading.png","path":"img/img-loading.png","modified":0,"renderable":1},{"_id":"themes/indigos/source/img/brand.jpg","path":"img/brand.jpg","modified":0,"renderable":1},{"_id":"themes/indigos/source/img/img-err.png","path":"img/img-err.png","modified":0,"renderable":1},{"_id":"themes/indigos/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/indigos/source/js/main.min.js","path":"js/main.min.js","modified":0,"renderable":1},{"_id":"themes/indigos/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/indigos/source/js/search.min.js","path":"js/search.min.js","modified":0,"renderable":1},{"_id":"themes/indigos/source/img/alipay.jpg","path":"img/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/indigos/source/img/wechat.jpg","path":"img/wechat.jpg","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Bold.eot","path":"css/fonts/roboto/Roboto-Bold.eot","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Bold.woff","path":"css/fonts/roboto/Roboto-Bold.woff","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Bold.woff2","path":"css/fonts/roboto/Roboto-Bold.woff2","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Light.eot","path":"css/fonts/roboto/Roboto-Light.eot","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Light.woff2","path":"css/fonts/roboto/Roboto-Light.woff2","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Medium.eot","path":"css/fonts/roboto/Roboto-Medium.eot","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Medium.woff2","path":"css/fonts/roboto/Roboto-Medium.woff2","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Regular.eot","path":"css/fonts/roboto/Roboto-Regular.eot","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Light.woff","path":"css/fonts/roboto/Roboto-Light.woff","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Medium.woff","path":"css/fonts/roboto/Roboto-Medium.woff","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Regular.woff2","path":"css/fonts/roboto/Roboto-Regular.woff2","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Thin.eot","path":"css/fonts/roboto/Roboto-Thin.eot","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Thin.woff2","path":"css/fonts/roboto/Roboto-Thin.woff2","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Regular.woff","path":"css/fonts/roboto/Roboto-Regular.woff","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Thin.woff","path":"css/fonts/roboto/Roboto-Thin.woff","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/fontawesome/fontawesome-webfont.woff","path":"css/fonts/fontawesome/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/fontawesome/fontawesome-webfont.woff2","path":"css/fonts/fontawesome/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Light.ttf","path":"css/fonts/roboto/Roboto-Light.ttf","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Regular.ttf","path":"css/fonts/roboto/Roboto-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Bold.ttf","path":"css/fonts/roboto/Roboto-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Medium.ttf","path":"css/fonts/roboto/Roboto-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/fontawesome/FontAwesome.otf","path":"css/fonts/fontawesome/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/fontawesome/fontawesome-webfont.ttf","path":"css/fonts/fontawesome/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Thin.ttf","path":"css/fonts/roboto/Roboto-Thin.ttf","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/fontawesome/fontawesome-webfont.eot","path":"css/fonts/fontawesome/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/indigos/source/css/fonts/fontawesome/fontawesome-webfont.svg","path":"css/fonts/fontawesome/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/indigos/.editorconfig","hash":"9b0445427777519defe360ea38c61729d847b3d3","modified":1559611797645},{"_id":"themes/indigos/package.json","hash":"c795e3100ae3655bfa8b39adcca7333a7925b47f","modified":1559611797660},{"_id":"source/_data/menu.yml","hash":"c37664eeeb90a1a1d6042e423ccae431fe040164","modified":1559611797092},{"_id":"themes/indigos/_config.yml","hash":"20fc84d1de1ee68dde2a944de132749e71178540","modified":1559611797645},{"_id":"themes/indigos/README.md","hash":"4bf26d9b43bf24b8e0a1a0d058437a347972f5e6","modified":1559611797645},{"_id":"source/images/0001.png","hash":"5646e88cc49bea8fb2744a8a131c94b2b55b266f","modified":1546533806575},{"_id":"themes/indigos/LICENSE","hash":"24944bf7920108f5a4790e6071c32e9102760c37","modified":1559611797645},{"_id":"source/images/0002.png","hash":"54f015dd14356d46b4a5eb4c42bb0b296f3c2b68","modified":1546533806575},{"_id":"source/images/0005.png","hash":"fcfdff32f6d724be3c3d12e709f9f3a460a3e274","modified":1546533806575},{"_id":"source/images/0003.png","hash":"7efe69ed1c19533b6bc5b6cb7cb7356303702513","modified":1546533806575},{"_id":"source/images/0009.png","hash":"785e1957c7aea321a1933bbaf37a7e7b834212e6","modified":1546533806575},{"_id":"source/images/0012.png","hash":"15a7c4e801630c8a3f6bb67d0fd18e69eb8eacc7","modified":1546533806575},{"_id":"source/images/0013.png","hash":"7b5bda6e7d94dbeacef12ef060e5e0d8e2fa4d32","modified":1546533806575},{"_id":"source/images/0040.png","hash":"3a4142e60fcb16d71ee8f2eb5e4de31091d2676f","modified":1546533806575},{"_id":"source/images/0019.png","hash":"013380c072a2fe829f2e10dbee5a76554ff20509","modified":1546533806575},{"_id":"source/images/0046.png","hash":"e07f0c042e640e7cd71e132f7f48d6360f09e3ca","modified":1546533806575},{"_id":"source/images/06.png","hash":"54707910862fdf7b148c90e36fa832f10c0d22fb","modified":1546533806575},{"_id":"source/images/0190.png","hash":"c5929d6f6445ef0d9aa017a313d10dff0e6fa553","modified":1546533806575},{"_id":"source/images/105.png","hash":"be0006708b897b95df1253186474048473bb8bbe","modified":1546533806575},{"_id":"source/images/148.png","hash":"5533113be8fff9946f3ebca68666478732c18203","modified":1546533806582},{"_id":"source/images/141.png","hash":"accf4d56385ac11f9ae611c005ee807214bfc1af","modified":1546533806575},{"_id":"source/images/195.png","hash":"240ea388434d019a8cddf1df5f986ec1877bda14","modified":1546533806581},{"_id":"source/images/2030.png","hash":"01e87e34ca69f7d33403860a9d59d0ac809162eb","modified":1546533806834},{"_id":"source/images/94.png","hash":"5da31bf5172d88b611f6c4706effecb82420ea47","modified":1546533806575},{"_id":"source/images/8111.png","hash":"3ee2a0a45a1121730ece4ce28b1f5208063e4c8a","modified":1546533806575},{"_id":"source/images/black_smile.png","hash":"10b24e9659ecc8748fe100c8e97a19dd47e7777b","modified":1546880442646},{"_id":"source/categories/index.md","hash":"1f6f9db5cf4cba5be4d91278021eb9873b80d376","modified":1559611797638},{"_id":"source/tags/index.md","hash":"7c33368714c02998c88ee12fd0c129599c478fa5","modified":1559611797644},{"_id":"themes/indigos/layout/category.ejs","hash":"7ea26a8a935886963eda82f41c7bd5270cf780d9","modified":1559611797659},{"_id":"themes/indigos/layout/index.ejs","hash":"39477807b98b2d2df78f3b82498a11e90be8222c","modified":1559611797659},{"_id":"themes/indigos/layout/layout.ejs","hash":"d52f43fa9572d70cae834e4887c8897b43744805","modified":1559611797659},{"_id":"source/images/black_smile-2.png","hash":"52f607e15843e2dc2a3ccde055811646bdc75e2f","modified":1546880442644},{"_id":"themes/indigos/layout/post.ejs","hash":"afbf8532dc8d148ca4dff2ca127a3382907cf2f5","modified":1559611797660},{"_id":"themes/indigos/layout/tag.ejs","hash":"36786a3de7f6cad58209603f7d84ba23addea174","modified":1559611797660},{"_id":"themes/indigos/layout/categories.ejs","hash":"41783d2069d5080566a99e6312aa2113105f8b41","modified":1559611797658},{"_id":"themes/indigos/scripts/plugins.js","hash":"e439d717513616bedeed37ba9b05117470809b21","modified":1559611797660},{"_id":"themes/indigos/languages/en.yml","hash":"1957d2bfc3a4cef299f4f169b431e9b1128ba162","modified":1559611797646},{"_id":"themes/indigos/languages/ja.yml","hash":"74fd480874bf5e773ba7f9d2a94697cda979091f","modified":1559611797646},{"_id":"themes/indigos/languages/nl-NL","hash":"9085c04491f93066f2369911cc2175b59ae596ad","modified":1559611797646},{"_id":"themes/indigos/languages/zh-CN.yml","hash":"7dc6ae434dde390b6768d244132e23cc78c33817","modified":1559611797646},{"_id":"themes/indigos/languages/zh-TW.yml","hash":"6a9e820be66eb12ae746f2527e0dc1adf927c685","modified":1559611797647},{"_id":"themes/indigos/layout/tags.ejs","hash":"20466446c41409d14a3d42ccaec24a65a045efef","modified":1559611797660},{"_id":"themes/indigos/layout/page.ejs","hash":"afb98face24d39a21ebbbde6592a9afc98572aa4","modified":1559611797659},{"_id":"themes/indigos/layout/archive.ejs","hash":"d039719e21f6a6fa2925b00aaa623a180a78c818","modified":1559611797658},{"_id":"source/_posts/guide/8100.png","hash":"4b620036807df794bb9b8ffed9006704bfbfbbe3","modified":1546439123188},{"_id":"source/_posts/guide/background-skill.md","hash":"dae63e353bf1e3fce1b19380a3a505335c76a33b","modified":1559611797094},{"_id":"source/_posts/guide/8101.png","hash":"985f8790a13d24c512910d43eec74b4fd27a0b29","modified":1546439123188},{"_id":"source/_posts/java/README.md","hash":"e2d55e9c5228873f5a160c3538eb75661a05e800","modified":1559611797094},{"_id":"source/_posts/leetcode/day1-two-sum.md","hash":"3866438a69877182bcb9a56a63a5de60e9ab8f1b","modified":1559611797428},{"_id":"source/_posts/leetcode/day3-longest-substring-without-repeating-characters.md","hash":"62f12547aaab54dcf123116d8153c4f636663ae2","modified":1559611797433},{"_id":"source/_posts/leetcode/complete-knapsack-problem.md","hash":"2ddafe64526c434c894f87ad686bfed261e51365","modified":1559611797423},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem.md","hash":"db605e52222bf8778710967c5e9e396583b7b203","modified":1559611797465},{"_id":"source/_posts/leetcode/day2-add-two-numbers.md","hash":"06ba569efabb399c84182a5eef332ee86a38e2f8","modified":1559611797430},{"_id":"source/_posts/leetcode/leetcode-solo-rank-begin.md","hash":"21a3df500df6300374c1285f060504861c435785","modified":1559611797493},{"_id":"source/_posts/leetcode/multi-knapsack-problem-md.md","hash":"3b665ab46beb6ffa456cd74426b1aecf9c7ffb0e","modified":1559611797493},{"_id":"source/_posts/mysql/mysql-index-introduction.md","hash":"6c4c0d81656aa6809ceecc7f436d84775f903124","modified":1562892719674},{"_id":"source/_posts/leetcode/knapsack-problem-conclusion-md.md","hash":"00bfa02e6140c5831cad7a1be26b4693101ba642","modified":1559611797483},{"_id":"source/_posts/rabbitmq/rabbitmq-how-to-use-dead-letter-queue.md","hash":"3ee32db39964a6e15cf0477646cdc081504f2edb","modified":1562892890853},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem-optimization.md","hash":"00fe177991a1fc9cb4e8a1fa9d42bb8f61d75b2d","modified":1559611797465},{"_id":"source/_posts/reading/java-multithread-programming-guide-in-action-notes.md","hash":"4477b8cf7ded062154ce4741398e369a88461be6","modified":1559611797498},{"_id":"source/_posts/reading/reading-notes.md","hash":"55134d871250639ab3c3d567fb5c57e4d7ce406a","modified":1559611797498},{"_id":"source/_posts/ops/deploy-vuepress-on-centos7.md","hash":"5f392099452f97ee01e91b0df90019385888aca4","modified":1559611797497},{"_id":"source/_posts/reading/the-power-of-habit-digest.md","hash":"d0825c3ecfda83060fbf130215344ab6f964c95a","modified":1559611797588},{"_id":"source/_posts/reading/the-power-of-habit.md","hash":"ac0ea18e07512bc399c19e44b89daaef7d4b9a60","modified":1559611797588},{"_id":"source/_posts/reading/the-art-of-java-multithread-notes.md","hash":"19f09ae18ee064e3567bc2fd6a386ef6cda01411","modified":1559611797499},{"_id":"source/_posts/leetcode/day4-regular-expression-matching.md","hash":"5500948794afa7379235fa6c63b7fe0dbc23ad6f","modified":1559611797438},{"_id":"source/_posts/shell/shell-gotossh.md","hash":"4248f0f6f2dbc6012c3a0b46d91b67a06a517f56","modified":1559611797638},{"_id":"themes/indigos/layout/_partial/archive.ejs","hash":"55cd81ef9183426d6d99fd91550fce0a9cc92aa0","modified":1559611797647},{"_id":"themes/indigos/layout/_partial/after-footer.ejs","hash":"9ac30b9439fab69973cf4722dbf2945a18fd3804","modified":1559611797647},{"_id":"themes/indigos/layout/_partial/footer.ejs","hash":"fdfc37e2a63fec8a258c6ec7059b7f103bd15c3b","modified":1559611797648},{"_id":"themes/indigos/layout/_partial/head.ejs","hash":"02a95a88774cc50dbcc32242b6c8ac7e9d9028bb","modified":1559611797648},{"_id":"source/_posts/shell/gotossh-update.md","hash":"c4dde87c3813fbbb207f201709dc06dc98b3e89a","modified":1559611797588},{"_id":"themes/indigos/layout/_partial/loading.ejs","hash":"bc4cb19b20de55a0332647f4dca9684184383685","modified":1559611797648},{"_id":"themes/indigos/layout/_partial/index-item.ejs","hash":"ec7b3ec79bbbead9c7e43e2e6c6b5c8bef509410","modified":1559611797648},{"_id":"themes/indigos/layout/_partial/paginator.ejs","hash":"dc27242927890f130a64400596b9b7ad5fca8972","modified":1559611797649},{"_id":"themes/indigos/layout/_partial/header.ejs","hash":"6156bf20791e46fc1c5872113276c1c1f5c13773","modified":1559611797648},{"_id":"themes/indigos/layout/_partial/menu.ejs","hash":"d39afaad6b0dd2a3ae27e6db3e9a6cd6014622fa","modified":1559611797649},{"_id":"themes/indigos/layout/_partial/post.ejs","hash":"a87d9b0485b3bf4cdfdad890e5974c43dbaa8240","modified":1559611797653},{"_id":"themes/indigos/layout/_partial/search.ejs","hash":"c2091c621b5480ef1e69d72027028cec8e929892","modified":1559611797658},{"_id":"themes/indigos/layout/_partial/script.ejs","hash":"439d6315a1b16e32b77a68c3f0cb2961d581086a","modified":1559611797657},{"_id":"themes/indigos/layout/_partial/tags-bar.ejs","hash":"19eff4876d31080a427644f7a43fe172d0c008c6","modified":1559611797658},{"_id":"themes/indigos/source/css/style.less","hash":"f22d4146e0bdb4485d33f20080c67ba05724afea","modified":1559611797706},{"_id":"source/_posts/shell/gotossh-v3-md.md","hash":"6258b70b05e5fc57282b1cae0145cf0179fbae01","modified":1559611797612},{"_id":"themes/indigos/source/img/favicon.ico","hash":"c88cd0044daea8f5b87913d71c4ade2aa31387c9","modified":1546439123693},{"_id":"themes/indigos/source/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1546439123692},{"_id":"source/_posts/reading/java-multithread-programming-guide-in-action-digest.md","hash":"e74faadfa23f2942243eefa607c93e0cff8f3e58","modified":1559611797498},{"_id":"themes/indigos/source/img/avatar.jpg","hash":"96f2506c587325147a383aad3ada8d5993e6cdf8","modified":1546439123688},{"_id":"themes/indigos/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1546439123698},{"_id":"themes/indigos/source/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1546439123691},{"_id":"themes/indigos/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1546439123694},{"_id":"themes/indigos/source/js/main.js","hash":"300b2e963683ced162e28afcd24ffc970fc23ac2","modified":1559611797715},{"_id":"themes/indigos/source/js/main.min.js","hash":"8acf4480f8ab859423b8926b9b790c67b5a77276","modified":1559611797716},{"_id":"themes/indigos/source/js/search.js","hash":"a1de7e7a2ef8330ebcd9f3a7a4622b3bac44e4f3","modified":1559611797716},{"_id":"themes/indigos/source/js/search.min.js","hash":"a8a450bb8b1ca9ad577052addcbd3393f1af6c6a","modified":1546439123708},{"_id":"source/_posts/java/basic/java-data-type.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546439123238},{"_id":"source/_posts/java/basic/java-operator.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546439123238},{"_id":"source/_posts/architecture/domain-driven-design/ddd-outline.md","hash":"7da1876f738322838c3f95b119828ed1b21079eb","modified":1559611797093},{"_id":"source/_posts/architecture/domain-driven-design/ddd-steps.md","hash":"50654b4fbb80b2ea369bfa9d4e903621a170dbeb","modified":1559611797093},{"_id":"source/_posts/architecture/domain-driven-design/ddd-recommendation.md","hash":"da1b3d5ae5bb7c1be2de8a067ea8cfaa4562e3a3","modified":1559611797093},{"_id":"source/_posts/java/basic/java-basic.md","hash":"1e5c2b03a04d2843a42a6335fccbe79e32cf3473","modified":1559611797095},{"_id":"source/_posts/java/basic/java-package.md","hash":"3324f94142b709b1b74818930ddfad59646ff15a","modified":1559611797096},{"_id":"source/_posts/java/interview/daily-interview-test.md","hash":"686d8aaededd88b771bb9910e0fa06d46a20c2c0","modified":1559611797099},{"_id":"source/_posts/java/basic/java-simple-structure.md","hash":"e36fb62d8e0cda4b325fe487f518d1101cd282a0","modified":1559611797096},{"_id":"source/_posts/java/basic/java-variable.md","hash":"6196dc65d49ff5b6dd20a3a0f8613cfc978ff5a1","modified":1559611797096},{"_id":"source/_posts/java/basic/java-class.md","hash":"a735f4b9ced30e415619d209d0950fd7c7949e77","modified":1559611797095},{"_id":"source/_posts/java/introduction/java-environment.md","hash":"6e932b774009610cf336ffa5744fbdafb65b9bce","modified":1559611797318},{"_id":"source/_posts/java/introduction/java-environment-mac.md","hash":"2c7fad0283048ef1627f6a85d4b5ace5b73f8585","modified":1559611797294},{"_id":"source/_posts/java/introduction/java-introduction.md","hash":"0a142154036dc85f8a70c54b34a71b2494f0195f","modified":1559611797327},{"_id":"source/_posts/java/introduction/java-primer-conclusion.md","hash":"276caac4416bf9414cf491f84e6a3cf8a83734eb","modified":1559611797327},{"_id":"source/_posts/java/collection/weakhashmap-code-detail.md","hash":"5878ba8564f632288cf018d60ee76e22aa447a7a","modified":1559611797097},{"_id":"source/_posts/java/introduction/java-ide.md","hash":"0c06108d608d86b70d1d7c1e8cf3bacd3baf9b18","modified":1559611797319},{"_id":"source/_posts/java/jvm/garbage-collection.md","hash":"4d2f542bdbf044a2d59d86457d61e5f09fdaaa32","modified":1559611797336},{"_id":"source/_posts/java/jvm/memory-leak.md","hash":"6fb774e8e5aee9bcd545a866948867b6e0be1695","modified":1559611797337},{"_id":"source/_posts/java/jvm/object-self-rescue.md","hash":"47812570e1ecde6fb6447bbcdd40aa2d577f071d","modified":1559611797337},{"_id":"source/_posts/java/jvm/reachable-in-hotspot.md","hash":"00f2fe0b86225e7c2998e3dffb09ba09855df5a2","modified":1559611797337},{"_id":"source/_posts/java/introduction/java-simple-example.md","hash":"91a099885918d748403220b8dcc5f1cc010132ac","modified":1559611797328},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays.md","hash":"17de2d0d8373c0e9a3a5e1b8c1e771d9f10e77ff","modified":1559611797373},{"_id":"source/_posts/java/multithread/multithread-start.md","hash":"198afee17da18d451280b205642ce59d4b0d2dd5","modified":1559611797371},{"_id":"source/_posts/java/jvm/reachable.md","hash":"93b7a49fabc7b4c391eff46e5873699a767483a8","modified":1559611797338},{"_id":"source/_posts/java/reference/final-reference-code-detail.md","hash":"ce8382e86d0788cd23ce2cdac234961d96b3e7f7","modified":1559611797399},{"_id":"source/_posts/java/reference/phantom-reference-code-detail.md","hash":"7d24f9c8efc98fcd45176fde5526e9fbaebfe4dc","modified":1559611797400},{"_id":"source/_posts/java/reference/phantom-reference.md","hash":"238ca98097335009235ad7ba83e7ab742e66bcdf","modified":1559611797400},{"_id":"source/_posts/java/introduction/java-environment-windows.md","hash":"a1398036bf6d0fd3ea3ec401a9ee4b39df7ae061","modified":1559611797315},{"_id":"source/_posts/java/reference/four-kinds-of-reference.md","hash":"d5eb26090aa2c12f3575be7dec5873b86fb4907f","modified":1559611797400},{"_id":"source/_posts/java/reference/reference-code-detail.md","hash":"03a126a8b599927445cc878a540c0bfcae3d7cff","modified":1559611797401},{"_id":"source/_posts/java/introduction/java-started.md","hash":"912d59244794ad3e358d04f6fd784db9ac2e2b81","modified":1559611797329},{"_id":"source/_posts/java/reference/soft-reference.md","hash":"ac99c38c477b043823e220da5c6fda481461d37d","modified":1559611797413},{"_id":"source/_posts/java/reference/strong-reference.md","hash":"42d92a1a8a810d83d076f5fb3c8b65fea859bc53","modified":1559611797414},{"_id":"source/_posts/java/reference/soft-reference-code-detail.md","hash":"d8f3d3b9abadddac3fba6e9f64e3593955175397","modified":1559611797411},{"_id":"source/_posts/java/reference/weak-reference-code-detail.md","hash":"18ebee184f9f3e48018c59a2db529b5f9f4e5200","modified":1559611797414},{"_id":"source/_posts/java/reference/reference-summary.md","hash":"2e3b65c918c34da1e7586a3bd01666f74a83a53f","modified":1559611797410},{"_id":"source/_posts/java/reference/reference-queue-code-detail.md","hash":"6b123862bfb0dabe24c9312b215f4c1dc6e32ab5","modified":1559611797403},{"_id":"source/_posts/leetcode/complete-knapsack-problem/CodeCogsEqn.png","hash":"b7919c258abf6c3629ec728a1f69bc53033682f7","modified":1562165633893},{"_id":"source/_posts/java/reference/weak-reference.md","hash":"3e921493c41966279913504e492d948530e3c997","modified":1559611797415},{"_id":"source/_posts/leetcode/day1-two-sum/exhaust-algorithm.png","hash":"3b8efaf057ad53ea51a96b0616b7f8bfd22816e1","modified":1546615533107},{"_id":"source/_posts/leetcode/day2-add-two-numbers/solution-1.png","hash":"c37a7a043dd0d2a2f62500fea8a7aca36e50819d","modified":1546880442631},{"_id":"source/_posts/leetcode/day1-two-sum/map-solution.png","hash":"b0783ee61fce6885811395c35d0ae4e80285f8c7","modified":1546620270619},{"_id":"source/_posts/leetcode/day2-add-two-numbers/result-5.png","hash":"a06576a002b1e3f3c6faf5e5b208f1e56ffdcb9d","modified":1546880442630},{"_id":"source/_posts/leetcode/day2-add-two-numbers/solution-3.png","hash":"a0cf02fd5abd984375fe184ad4769bee0535795d","modified":1546880442635},{"_id":"source/_posts/leetcode/day3-longest-substring-without-repeating-characters/day3-step-1.png","hash":"559e538203bb5ba394a1847d18d1bc4096e192a0","modified":1550500555644},{"_id":"source/_posts/leetcode/day3-longest-substring-without-repeating-characters/day3-step-4.png","hash":"d3ba153a5016766a8bb7b48f620682d15a4eec28","modified":1550500555654},{"_id":"source/_posts/leetcode/day2-add-two-numbers/solution-2.png","hash":"8323b2f344c772a29efd3e14956843e208985fd7","modified":1546880442634},{"_id":"source/_posts/leetcode/day3-longest-substring-without-repeating-characters/day3-step-3.png","hash":"1a0d033b1a81da9609492f7cf7401bb16b29823f","modified":1550500555650},{"_id":"source/_posts/leetcode/day2-add-two-numbers/solution-4.png","hash":"d7138b9fd24239f3dd038290025303cb708f030b","modified":1546880442638},{"_id":"source/_posts/leetcode/day3-longest-substring-without-repeating-characters/day3-step-6.png","hash":"db7d2f6c169ac060351d7eb3bff1d4a948e0858d","modified":1550500555665},{"_id":"source/_posts/leetcode/day3-longest-substring-without-repeating-characters/day3-step-8.png","hash":"3abc7aa2193431ac85ff49e4498219f89fa93529","modified":1550500555676},{"_id":"source/_posts/leetcode/day3-longest-substring-without-repeating-characters/day3-submit-2.png","hash":"19fc70d759acd618de78e8815bb0050b9a5cc741","modified":1550500555685},{"_id":"source/_posts/leetcode/day3-longest-substring-without-repeating-characters/day3-step-5.png","hash":"02dfd8cc12f9897c0aae5476dc538289fdc3201c","modified":1550500555661},{"_id":"source/_posts/leetcode/day3-longest-substring-without-repeating-characters/day3-submit-1.png","hash":"3ed8a1e50b491c67d72b22d5d68bbb8f9e632b3e","modified":1550500555682},{"_id":"source/_posts/leetcode/day3-longest-substring-without-repeating-characters/day3-step-2.png","hash":"a6de0d88dd139c1b00005c70c25921a5de1e5874","modified":1550500555647},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/result1.png","hash":"96a80b94fa15399f91e674b8ac08b5fd4fae7afc","modified":1553821147571},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/result2.png","hash":"bad7a69287401408d5e4d55009db9712dc66bc74","modified":1553821147574},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/result3.png","hash":"271bb69cdb3c1856e9dc20738763cbb34b544708","modified":1553821147577},{"_id":"source/_posts/python/spider/spider-douban-book.md","hash":"52f7f12a6bb5ed46a739f348d623093caa851f53","modified":1559611797497},{"_id":"source/_posts/shell/gotossh-v3-md/list-all-the-servers.gif","hash":"53c1fc0d0e94da27756c6845cc140330e807160f","modified":1556331388752},{"_id":"source/_posts/shell/gotossh-v3-md/list-all-the-commands.gif","hash":"3ac4b3673a777c70ad514b09a512b0d1ec4fc3e1","modified":1556331388750},{"_id":"themes/indigos/layout/_partial/plugins/disqus.ejs","hash":"4a0c01e4195f685f9825fcd016d01249dbdd52ca","modified":1559611797650},{"_id":"themes/indigos/layout/_partial/plugins/baidu.ejs","hash":"e44d526029f122e9c2c74f3a647c35002c818cbe","modified":1559611797649},{"_id":"themes/indigos/layout/_partial/plugins/dynamic-title.ejs","hash":"23c101d45911eb0846533aaa2d409c43aa5e899a","modified":1559611797650},{"_id":"themes/indigos/layout/_partial/plugins/google-analytics.ejs","hash":"a947f4076b54b48d4df5baf2d5b3c39b632c7576","modified":1559611797650},{"_id":"themes/indigos/layout/_partial/plugins/gitment.ejs","hash":"5723d507eca4390e8e5d18c0770e7953b8c22f5a","modified":1559611797650},{"_id":"themes/indigos/layout/_partial/plugins/hyper-comments.ejs","hash":"e5a83acc7c2e385b0c9abf428e86e8fdfd3a5202","modified":1559611797650},{"_id":"themes/indigos/layout/_partial/plugins/mathjax.ejs","hash":"ea603a057196de53bd6afab1fddb93d11f27eb81","modified":1559611797651},{"_id":"themes/indigos/layout/_partial/plugins/site-visit.ejs","hash":"8fbd0910828f1ab6eba728bdecc9811d623baae2","modified":1559611797651},{"_id":"themes/indigos/layout/_partial/plugins/page-visit.ejs","hash":"2decb77bf3c1a064ea6ce1d4e78892c434d9c884","modified":1559611797651},{"_id":"themes/indigos/layout/_partial/plugins/tajs.ejs","hash":"97b48fe10be1c71d4ff25ccec3bd92d97466c9c5","modified":1559611797652},{"_id":"themes/indigos/layout/_partial/plugins/uyan.ejs","hash":"e370bd04ea5cf1c83e0c20516aff7ba3ca8b2d0b","modified":1559611797652},{"_id":"themes/indigos/layout/_partial/plugins/valine.ejs","hash":"a976ca36bd09aeb2902bf94fcc7a59975ea25148","modified":1559611797652},{"_id":"themes/indigos/layout/_partial/post/category.ejs","hash":"c7476165721a3a5e34d00d8c5c07e1e5474cd800","modified":1559611797653},{"_id":"themes/indigos/layout/_partial/post/comment.ejs","hash":"bcc3bd7a9023d71778f15e98c88552335ae69a69","modified":1559611797654},{"_id":"themes/indigos/layout/_partial/post/copyright.ejs","hash":"5305ed30ee35cf50f87656737d0ffe85f5bfc16b","modified":1559611797654},{"_id":"themes/indigos/layout/_partial/post/date.ejs","hash":"ea85b46e12d3b9c3612eef7aa76289a663fbc096","modified":1559611797654},{"_id":"themes/indigos/layout/_partial/post/head-meta.ejs","hash":"b0c680ce5b8aaf461a6731b1ff1287bd140c168a","modified":1559611797654},{"_id":"themes/indigos/layout/_partial/post/nav.ejs","hash":"11e7d504f7c7a3c4c052da13cfa8ea4862c9383e","modified":1559611797655},{"_id":"themes/indigos/layout/_partial/post/reward-btn.ejs","hash":"41c242fe3159dc68cec8dd00ab6d2663f5a51179","modified":1559611797655},{"_id":"themes/indigos/layout/_partial/post/reward.ejs","hash":"23719e09689b3afbb19214c6603eb02f896cb9ba","modified":1559611797655},{"_id":"themes/indigos/layout/_partial/post/share-fab.ejs","hash":"93482ad7d1e01b966f5ee1c5d12b88564e02b349","modified":1559611797656},{"_id":"themes/indigos/layout/_partial/post/share.ejs","hash":"8df0d7bf6f8e106cdbdac2dd10a97367aa0695f8","modified":1559611797656},{"_id":"themes/indigos/layout/_partial/post/tag.ejs","hash":"b3dc38652c4a018a37418136478dcd522fc49f79","modified":1559611797656},{"_id":"themes/indigos/layout/_partial/post/title.ejs","hash":"062d56cb88ae2be3a6616b911d4ebeffcbfe3cff","modified":1559611797656},{"_id":"themes/indigos/layout/_partial/post/toc.ejs","hash":"ad287a70724eb7cd8cd2a03a45b68032ee99973d","modified":1559611797657},{"_id":"themes/indigos/layout/_partial/post/updated.ejs","hash":"5caa71745aa340ce57938a930f3b898ee7518d74","modified":1559611797657},{"_id":"themes/indigos/source/css/_plugin/valine.less","hash":"ddbb7647d83f732f9b0d5d817d40a748006949cc","modified":1559611797666},{"_id":"themes/indigos/source/css/_partial/archives.less","hash":"7d2a6886265386c640e94ffca3f042675f701a35","modified":1559611797661},{"_id":"themes/indigos/source/css/_partial/article.less","hash":"d476cd3537bcd8a02d055cc223f5c805b8638cc2","modified":1559611797661},{"_id":"themes/indigos/source/css/_partial/gotop.less","hash":"b7db31b9bc563c10b9e3cf3e6d9cfddfeb3e805a","modified":1559611797662},{"_id":"themes/indigos/source/css/_partial/header.less","hash":"90f0948a9182c14b1dac1e9dbed3c883543266f9","modified":1559611797662},{"_id":"themes/indigos/source/css/_partial/highlight.less","hash":"58492b7cdb45fe09b026b2f34e8ae69c2ddb8228","modified":1559611797662},{"_id":"themes/indigos/source/css/_partial/layout.less","hash":"4390ed22abad59c8b28ed1a479a52f15b5f9cf4a","modified":1559611797663},{"_id":"themes/indigos/source/css/_partial/loading.less","hash":"f9d06a1e24fb4857fd18d7a0bfbb3a0ab2d1c742","modified":1559611797663},{"_id":"themes/indigos/source/css/_partial/lightbox.less","hash":"9b961eb1d70e7658f42cf2ca895fa5e35a6b6541","modified":1559611797663},{"_id":"themes/indigos/source/css/_partial/page.less","hash":"e92ccb53e6ac73a51498c6a9672db9d0d2bc7f1a","modified":1559611797663},{"_id":"themes/indigos/source/css/_partial/roboto.less","hash":"2e0469ed8161d5672d903ca1a8027cd65fe007f1","modified":1559611797664},{"_id":"themes/indigos/source/css/_partial/postlist.less","hash":"1c041bf91106808e5480c60d9ece45431bb503b3","modified":1559611797664},{"_id":"themes/indigos/source/css/_partial/reward.less","hash":"4857f90bb57fc22ca3f942d8934d86d5e9e82c1e","modified":1559611797664},{"_id":"themes/indigos/source/css/_partial/search.less","hash":"1d6641ae7568a0153d24beba9fd9704d2b155f6c","modified":1559611797665},{"_id":"themes/indigos/source/css/_partial/tags.less","hash":"959f4373fda6e45f6a4041a995ed3ea8a05a5170","modified":1559611797665},{"_id":"themes/indigos/source/css/_partial/share.less","hash":"27d80bcc96a53dd1e7eaa9a7d746e4b212357302","modified":1559611797665},{"_id":"themes/indigos/source/css/_partial/variable.less","hash":"082896b966ed25b39c74e7b007b4f54c235685a4","modified":1559611797666},{"_id":"themes/indigos/source/img/alipay.jpg","hash":"d2e76219d3f688a805c9f30e004f48e79daf03ab","modified":1546439123687},{"_id":"source/_posts/shell/gotossh-v3-md/scp-jump-server-log.gif","hash":"17168f30b5568ce36602deb8ee4d4c7a8b9c32df","modified":1556331388805},{"_id":"themes/indigos/source/css/_partial/waves.less","hash":"77bfd0b373b0469eb0176167fb076ccda4edf2a7","modified":1559611797666},{"_id":"themes/indigos/source/img/wechat.jpg","hash":"c7887fd95a3383371b957667d4bfbc3c8c2cbe53","modified":1546439123698},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_339C2E86CD88-1.jpeg","hash":"d32fa8f45ebc1d660c76fd23ae6ee87a296989e5","modified":1553821147641},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_9B418BF0E7A5-1.jpeg","hash":"61c0f49bbc8b6840ebe8a95f78a8302e0b5ce2eb","modified":1553821147653},{"_id":"source/_posts/shell/gotossh-v3-md/scp-online-server-file.gif","hash":"4da5e5d7a3b0b7dfec1598120813bd0ff4dc68fc","modified":1556331388808},{"_id":"source/_posts/java/collection/weakhashmap-code-detail/0038.png","hash":"dc8ec7ec15f9d18d028fa4baa7b8edf7dcf9f587","modified":1546698633537},{"_id":"source/_posts/java/introduction/java-environment-mac/12-jdk-mac.png","hash":"79b6a623b06142723ea9dc4981f3ef12ff3bcd75","modified":1546439123278},{"_id":"source/_posts/java/introduction/java-environment-mac/13-jdk-mac.png","hash":"aa4d7a93b28afb3424a5c107724b07cb9cbeed3d","modified":1546439123278},{"_id":"source/_posts/java/collection/weakhashmap-code-detail/weakhashmap-1.png","hash":"2d21b6d2b326191f28c04b070863c03614dc08fe","modified":1546698633539},{"_id":"source/_posts/java/introduction/java-environment-mac/16-jdk-mac.png","hash":"5451e575e4bf08b384335bb070bb46817edad5bd","modified":1546439123288},{"_id":"source/_posts/java/introduction/java-environment-mac/10-jdk-mac.png","hash":"a058e42380742e3be7911c30ea4c54263f2e99e9","modified":1546439123278},{"_id":"source/_posts/java/introduction/java-environment-mac/14-jdk-mac.png","hash":"4bc54995d9f778084a8b486634bc30793f1592f0","modified":1546439123288},{"_id":"source/_posts/java/introduction/java-environment-mac/5-jdk-mac.png","hash":"b65be8a8b49518b8fc8ea4f1c1b7d1113352180c","modified":1546439123308},{"_id":"source/_posts/java/introduction/java-environment-mac/6-jdk-mac.png","hash":"cc0550022513036a612d666bab64f1876d703ec3","modified":1546439123308},{"_id":"source/_posts/java/introduction/java-environment-mac/7-jdk-mac.png","hash":"57310fc56a96be434f0ad69eb6387a82f54d0d5a","modified":1546439123308},{"_id":"source/_posts/java/collection/weakhashmap-code-detail/weakhashmap-2.png","hash":"a97b7673b4d40163640e1a35540c2c2b51c8ed93","modified":1546698633541},{"_id":"source/_posts/java/introduction/java-environment-windows/3-jdk-windows.png","hash":"2a89504a729c391003e94d74941aeada3fde7e4a","modified":1546439123328},{"_id":"source/_posts/java/introduction/java-environment-windows/4-jdk-windows.png","hash":"155d9ca099b6138a5f3c2df3b826f6ce972d847a","modified":1546439123328},{"_id":"themes/indigos/source/css/_partial/fontawesome.less","hash":"ca30b732d2efbb0cd55a272ecdabc97f895aee78","modified":1559611797662},{"_id":"source/_posts/java/introduction/java-environment-windows/5-jdk-windows.png","hash":"ac4f6a18554f2d1aae972e1bf6737dd60551613d","modified":1546439123328},{"_id":"source/_posts/java/introduction/java-environment-mac/8-jdk-mac.png","hash":"52eacf47993855414045b0719196da9001ccb153","modified":1546439123318},{"_id":"source/_posts/java/introduction/java-environment-mac/9-jdk-mac.png","hash":"1c9dbad3045f234695be69fb4c27c0cd53ab1918","modified":1546439123318},{"_id":"source/_posts/java/introduction/java-environment-windows/2-jdk-windows.png","hash":"4d1cb8168cde93a8aabef63c8d12a8ccb56a60e4","modified":1546439123328},{"_id":"source/_posts/java/introduction/java-environment-windows/9-jdk-windows.png","hash":"8defa728fac888e8203a5e6151596c5ce15280d3","modified":1546439123338},{"_id":"source/_posts/java/introduction/java-environment-windows/6-jdk-windows.png","hash":"f26f02913932acf206e345b96a2749c22d68a7c1","modified":1546439123328},{"_id":"source/_posts/java/introduction/java-environment-windows/7-jdk-windows.png","hash":"79f375c43ac760ce5a88aef12df9e788494f0643","modified":1546439123338},{"_id":"source/_posts/java/introduction/java-environment-windows/8-jdk-windows.png","hash":"884e1c6927bf1394dc9941de017deb3b9901daeb","modified":1546439123338},{"_id":"source/_posts/java/introduction/java-ide/java-ide-3.png","hash":"5616c391ba4e9a1341b4c6213758924b9e8124d1","modified":1546439123358},{"_id":"source/_posts/java/introduction/java-ide/java-ide-5.png","hash":"627cfbad99d15a6962df90269eb9df896a6b6021","modified":1546439123358},{"_id":"source/_posts/java/introduction/java-ide/java-ide-6.png","hash":"bc4523f962ca5301e062c864166cf4cc2dfd6f34","modified":1546439123368},{"_id":"source/_posts/java/introduction/java-ide/java-ide-7.png","hash":"db6fcb1e3350c32db0a5ad41400ee7e22023eed1","modified":1546439123368},{"_id":"source/_posts/java/introduction/java-ide/java-ide-8.png","hash":"311e7f7643a2facb45dc3165c938af1bd84b28b7","modified":1546439123368},{"_id":"source/_posts/java/introduction/java-simple-example/java-simple-example-2.png","hash":"404e3de6764fab8a109a7efceabfb4bc6942fb30","modified":1546439123378},{"_id":"source/_posts/java/introduction/java-simple-example/java-simple-example-3.png","hash":"9b42950df71c6cb651d76dec741a4549e4855fd5","modified":1546439123378},{"_id":"source/_posts/java/jvm/reachable/accessibility1.jpg","hash":"36ba36afdaa689c5cadd4919a834569d72fdb478","modified":1546528528863},{"_id":"source/_posts/java/jvm/reachable/accessibility2.png","hash":"281d56cfb09c2ac6654e604869f1c089bb19688b","modified":1546528528862},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/5cdf6a655276187010.png","hash":"31c40871e367cb71244c6e8549c483b71cf262b5","modified":1562165633840},{"_id":"source/_posts/java/introduction/java-ide/java-ide-9.png","hash":"b7cb86602219d3609159f856c4449b7b85ae0aac","modified":1546439123368},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/5cdf7ec98fddd17705.png","hash":"01c4c5eafeb1dc753469677895b8d76b34d4eae3","modified":1562165633847},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/5cdf7f0e86fbc84596.png","hash":"65b03d0d7632771862dce230e74aa9f16d4292e5","modified":1562165633849},{"_id":"source/_posts/java/introduction/java-simple-example/java-simple-example-1.png","hash":"7be12cd9b902847ed3ca8ce7a6f06139103f1180","modified":1546439123378},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/5cdf7f4a7282234332.png","hash":"932ec5b8b6b5710942b97977fd9482aae12f1514","modified":1562165633851},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/5cdf7e9f2047e23793.png","hash":"985f8790a13d24c512910d43eec74b4fd27a0b29","modified":1562165633844},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/black_smile.jpg","hash":"1aea48378b0a27aa6aefd8bd9daab234758f22a4","modified":1562165633853},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/5cdf6a292b1d070453.png","hash":"c1d176ce8d8531bc7aedc5042059d0de466d0c05","modified":1562165633837},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/e8df70b9feab81ccabe8a2821dc2e9880cddc9e4f2ce-zo9QsQ_fw658.jpeg","hash":"a4bdeb9804e3bc479a184a3ce2ff8f4db8d7153c","modified":1562165633888},{"_id":"source/_posts/java/reference/reference-code-detail/reference-2.png","hash":"a8dc3f3b71dcb3ace64dd22fd364972a8b2daf22","modified":1546698633579},{"_id":"source/_posts/java/reference/soft-reference-code-detail/soft-reference-2.png","hash":"f07af2215f65766b68a5c3e932bc01e1ea4a0fc5","modified":1546698633595},{"_id":"source/_posts/java/spring/source-code-analysis/spring-bean-attribute-scope.md","hash":"55890b23d982e0869ba089fcceb2b87b55df7197","modified":1559611797422},{"_id":"source/_posts/java/reference/soft-reference-code-detail/soft-reference-3.png","hash":"39f4779065da2ccd6dd355ff6fd1e72efaf4391f","modified":1546698633601},{"_id":"source/_posts/java/spring/source-code-analysis/spring-bean-attribute-abstract.md","hash":"47fd42dac8cfe40bf424d25d2e4cbf77a8f7bb5f","modified":1559611797416},{"_id":"source/_posts/leetcode/complete-knapsack-problem/IMG_510B188AF928-1.jpeg","hash":"e3b84b5c1721d80fcd21421fc0d3c03397c31062","modified":1562165633897},{"_id":"source/_posts/leetcode/complete-knapsack-problem/IMG_5E156B07E228-1.jpeg","hash":"5e9e32ac8427904315a13e63f6ea1659e5c83a31","modified":1562165633900},{"_id":"source/_posts/leetcode/day3-longest-substring-without-repeating-characters/day3-step-7.png","hash":"62c8c5ac7132440be42826117bae9f8b47ab91b9","modified":1550500555671},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/example1.png","hash":"dda32c7e119dcb0b269c466ad35190eb1c9c9c50","modified":1553821147547},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/example2.png","hash":"a0ced037654761a1ac935eb5163b7c4f2735d8d9","modified":1553821147552},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/example3.png","hash":"ac38425fe1aaea80be4b06bef607c4f4fbb6cdc5","modified":1553821147556},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_007B2F2632D2-1.jpeg","hash":"a886afc0d50b5d55fb0bd7f80911c80ddb12d245","modified":1553821147617},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_13B30A586085-1.jpeg","hash":"97ac09688a58a030dd08163a3b1fbe17763e5b1e","modified":1553821147625},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_2ABCC82C89F7-1.jpeg","hash":"42fe2d940da23209ff873b3b5a46733f701711a9","modified":1553821147637},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_37EAFFF048DB-1.jpeg","hash":"32c7f5e0201113efba7873dba19ca2994c596df8","modified":1553821147645},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_16ACD9FB2E1C-1.jpeg","hash":"8b609a9044ace8b5d2384476dc77e13d9585a635","modified":1553821147632},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_142D1BF09ED7-1.jpeg","hash":"c8a40ab3922b238859ed758f6312c31956aaf7ab","modified":1553821147628},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_ECCF05DEC924-1.jpeg","hash":"611b425e7c449d8b1ac8b83e22784fefff9b7ce6","modified":1553821147669},{"_id":"source/_posts/java/spring/source-code-analysis/spring-bean-attribute.md","hash":"da8379683cb263b1ef74a1d6242056f75e91cb08","modified":1559611797423},{"_id":"source/_posts/java/reference/reference-code-detail/reference-1.png","hash":"90330bc0125b7580e1421a7e3f409e5a703caf8e","modified":1546698633576},{"_id":"source/_posts/leetcode/multi-knapsack-problem/IMG_510B188AF928-1.jpeg","hash":"e3b84b5c1721d80fcd21421fc0d3c03397c31062","modified":1562165633946},{"_id":"source/_posts/leetcode/multi-knapsack-problem/IMG_5E156B07E228-1.jpeg","hash":"5e9e32ac8427904315a13e63f6ea1659e5c83a31","modified":1562165633949},{"_id":"source/_posts/leetcode/knapsack-problem-conclusion/IMG_FEB9666A1155-1.jpeg","hash":"d6c7b383acd67718620f994c9ad446c950d36e16","modified":1562165633940},{"_id":"source/_posts/shell/gotossh-v3-md/login-jump-server.gif","hash":"697ca092e5f311883f5fdd97f0291f012a2f20b5","modified":1556331388766},{"_id":"source/_posts/shell/gotossh-v3-md/login-online-server.gif","hash":"fdd2a5fa10106a1dd5ae1d6b5f513119013e1be8","modified":1556331388789},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1546439123634},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1546439123644},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1546439123644},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1546439123644},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1546439123654},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1546439123654},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1546439123664},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1546439123664},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1546439123654},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1546439123664},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1546439123664},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1546439123674},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1546439123674},{"_id":"source/_posts/java/collection/weakhashmap-code-detail/weakhashmap-3.png","hash":"a1971c4b5102b3a6c222ed1014712e399a6e3ce2","modified":1546698633544},{"_id":"source/_posts/java/collection/weakhashmap-code-detail/weakhashmap-4.png","hash":"ca0ae5597535eb89f027c74cf3e92369cffb0bd4","modified":1546698633548},{"_id":"source/_posts/java/introduction/java-environment-mac/11-jdk-mac.png","hash":"09153cd9a58d2ea84f64bc4105fee92a0691c221","modified":1546439123278},{"_id":"source/_posts/java/introduction/java-environment-mac/15-jdk-mac.png","hash":"115d45c94471ff20db11d361a5111108181273f9","modified":1546439123288},{"_id":"source/_posts/java/introduction/java-environment-windows/1-jdk-windows.png","hash":"8f643602c33a1a98b96e46349952dea4dae4981b","modified":1546439123318},{"_id":"source/_posts/java/introduction/java-ide/java-ide-4.png","hash":"41e84a42900e891648f3b37130a080606f531181","modified":1546439123358},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/5cdf7daf74e9241031.png","hash":"62f8083a628c45dd76c5da72fabd1dbbc3882413","modified":1562165633842},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/carbon (4).png","hash":"34143640204e2fd3f306af145f0c4a8128cb88af","modified":1562165633864},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/carbon (1).png","hash":"6004cb2e74dd5627b4f5fe0e34ba7bd7053d1964","modified":1562165633856},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/carbon (3).png","hash":"263726c337b2f97e315a7005fe4ad21915da8577","modified":1562165633862},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/carbon (7).png","hash":"0b531eb961c87367efa631c64fb06a656eeb3570","modified":1562165633875},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/carbon (8).png","hash":"0d2524fa2e1836a075e32c69d3faf8045478e8af","modified":1562165633878},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1546439123664},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/carbon (9).png","hash":"f5f7746eb83ac4a8801422a3b730ecd399ba1191","modified":1562165633882},{"_id":"source/_posts/leetcode/complete-knapsack-problem/IMG_6B67BF7CC3A7-1.jpeg","hash":"4b557b85348bc8a902e2f28d3d33ebf505822f78","modified":1562165633904},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/example4.png","hash":"b4bd082cda695f391cba78a07d193ef653e598dc","modified":1553821147561},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_04E34B950C69-1.jpeg","hash":"18254fec11dc75a281c7888a9739f4289c2de089","modified":1553821147621},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1546439123674},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_CD2E7F29F646-1.jpeg","hash":"1b6d131d885afb6517dfab9573f26249047ad238","modified":1553821147663},{"_id":"source/_posts/leetcode/knapsack-problem-conclusion/IMG_2CEDE1895234-1.jpeg","hash":"7e7a70908540f6cb421e4daa808a404ab0342a44","modified":1562165633914},{"_id":"source/_posts/leetcode/knapsack-problem-conclusion/IMG_457EBA32EFB1-1.jpeg","hash":"6dc72c7240bc71e70e2d7b3c8411d37fb7b86deb","modified":1562165633919},{"_id":"source/_posts/leetcode/knapsack-problem-conclusion/IMG_9246C78770A7-1.jpeg","hash":"7f557d83a700035d15d0b41ca62db6e9daf23f84","modified":1562165633923},{"_id":"source/_posts/leetcode/knapsack-problem-conclusion/IMG_C91D3F09DB1B-1.jpeg","hash":"0e4ca4bc6515f570f3e7560bbb5df7aa98748a8f","modified":1562165633931},{"_id":"source/_posts/leetcode/knapsack-problem-conclusion/IMG_A41B58306523-1.jpeg","hash":"010d88d4b7c0da5c65b213b381a50bbff2e003ea","modified":1562165633927},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_F047D511640B-1.jpeg","hash":"ff5694f468386d06c7037fc7d9e485110dfb1cac","modified":1553821147673},{"_id":"source/_posts/leetcode/multi-knapsack-problem/IMG_6B67BF7CC3A7-1.jpeg","hash":"4b557b85348bc8a902e2f28d3d33ebf505822f78","modified":1562165633953},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_482BA28A5E66-1.jpeg","hash":"75cb1c8b961cc7807d3375c5bcf99040f0c6a231","modified":1553821147650},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_E5B595A5513F-1.jpeg","hash":"0ba5261b42358309b7de36214f9275972bbd0e53","modified":1553821147666},{"_id":"source/_posts/leetcode/knapsack-problem-conclusion/IMG_E80890942D1C-1.jpeg","hash":"3cec99d2351f852abe31f8eff7e6183d94351db4","modified":1562165633936},{"_id":"source/_posts/shell/gotossh-update/login-server3.gif","hash":"5b27770c73eea62a9947337541d03d3b1f2a5c2c","modified":1553821147693},{"_id":"themes/indigos/source/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1546439123634},{"_id":"themes/indigos/source/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1546439123634},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1546439123654},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1546439123664},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1546439123644},{"_id":"source/_posts/java/introduction/java-started/java-started-1.png","hash":"83c77b655ea24647ff6c55c830924baa4e90b845","modified":1546439123388},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/carbon (2).png","hash":"51d0275bcdf1a206c8f6a3757379facb0ef77af9","modified":1562165633860},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/fib.png","hash":"b126016de12528c6b9f8e0d0a62b6ab9d593ed49","modified":1553821147569},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/solution1-3.png","hash":"738022ef720eb066fa3064debc8e113d98cf4dfb","modified":1553821147593},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/solution2-2.png","hash":"d993f366178f0f1cba86acfa7df692a23cd60f20","modified":1553821147608},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1546439123654},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/solution2-1.png","hash":"416121b91302490bcbf2e5c46be4302c82720b49","modified":1553821147603},{"_id":"source/_posts/shell/gotossh-update/login-server4.gif","hash":"0ca0658dd2201971061ab2f7f36aa39cf4d36ec3","modified":1553821147698},{"_id":"source/_posts/shell/gotossh-v3-md/login-and-view-the-log.gif","hash":"760facffcea818ad86d4d5fa3379cd701aa1266f","modified":1556331388756},{"_id":"themes/indigos/source/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1546439123624},{"_id":"themes/indigos/source/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1546439123634},{"_id":"themes/indigos/source/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1546439123674},{"_id":"source/_posts/java/introduction/java-environment-mac/2-jdk-mac.png","hash":"bef4170c81af99efbdb89dafa2094fd127648889","modified":1546439123288},{"_id":"themes/indigos/source/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1546439123624},{"_id":"source/_posts/java/introduction/java-environment-mac/3-jdk-mac.png","hash":"0b4bb944db5070a12b706f7ffaf451f5d558cfd9","modified":1546439123298},{"_id":"source/_posts/java/introduction/java-ide/java-ide-2.png","hash":"9e81a827e3e5793b7f262df0eda5de1746c65899","modified":1546439123358},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/example5.png","hash":"8152c6859b65aaee0e93af5d3f8f62ef298be3d7","modified":1553821147565},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/solution1-1.png","hash":"528e20077405ad881883b3f3420eb1f50a1d5ccd","modified":1553821147582},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_BFE9B7063670-1.jpeg","hash":"49fcf7097fba4b21429e8d0f9ab8c9d8e3416641","modified":1553821147659},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/carbon (5).png","hash":"897b002b8ecfc3b72d7db84d308bdbc0306e2b34","modified":1562165633868},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/carbon.png","hash":"6606e0b25abc19f312e4b415f26c5ba116b4170a","modified":1562165633886},{"_id":"source/_posts/java/introduction/java-environment-mac/4-jdk-mac.png","hash":"df019bad4cac078997c8a067a59d69be97a34adc","modified":1546439123298},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/carbon (6).png","hash":"2ab560cd392d00e609d7b0415b4a8a17ece13efa","modified":1562165633872},{"_id":"source/_posts/shell/gotossh-update/scp-server3-log.gif","hash":"294dd79b320bc6358c880c50a2d1596887678089","modified":1553821147702},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/solution1-4.png","hash":"c52a83829385942135d81db7722ea5de30e566f7","modified":1553821147599},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/solution1-2.png","hash":"c501ae2762abc3dfaae03bc3d09f01278a3df22c","modified":1553821147587},{"_id":"source/_posts/shell/gotossh-v3-md/login-and-view-the-log2.gif","hash":"bc7937809cde4bb149ca4c5acbc82384697e9d26","modified":1556331388762},{"_id":"source/_posts/shell/gotossh-update/jump.gif","hash":"a03dd35e1dab365e7c59c3f673fb7fc44fdd51d2","modified":1553821147687},{"_id":"source/_posts/shell/gotossh-update/server4-log.gif","hash":"333a950b783e49857be08a31e166b47703126cda","modified":1553821147726},{"_id":"themes/indigos/source/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1559611797671},{"_id":"source/_posts/shell/gotossh-update/server3-log.gif","hash":"a88a6d29cdc855b2c2d0e96f27f725c2b82e0ab0","modified":1553821147719},{"_id":"source/_posts/java/introduction/java-environment-mac/1-jdk-mac.png","hash":"4acf222e3a5d9728d358cd16a2f0d4300ae6700e","modified":1546439123268},{"_id":"source/_posts/java/introduction/java-ide/java-ide-1.png","hash":"ab6bb5ebfc5b292263824a72ba6eeca819f31f14","modified":1546439123348},{"_id":"source/_posts/shell/gotossh-update/scp-server4-log.gif","hash":"56308e22f435b200fe3a7773b73d4bff7c6647d5","modified":1553821147712},{"_id":"source/_posts/shell/gotossh-v3-md/login.gif","hash":"e6a41bf227897792b4447974fe47d62d1b24227f","modified":1556331388802},{"_id":"source/_posts/shell/gotossh-v3-md/login-online-server-and-view-the-log.gif","hash":"01f0cc8dcd4663919e64f1375c45a2dc6f4481bc","modified":1556331388785},{"_id":"public/atom.xml","hash":"37c57320231f0347183ca3431759d72c9936aba1","modified":1562900873255},{"_id":"public/content.json","hash":"7f05191a465bd2f72327dbf706d8f8d0441b2f12","modified":1562900873255},{"_id":"public/categories/index.html","hash":"41fce40e62cb1d07765df6b5576d60addfafda3f","modified":1562900875596},{"_id":"public/uncategorized/java/spring/source-code-analysis/spring-bean-attribute-abstract.html","hash":"708fcc927a6ad8c46b39a0c14858187213a6e956","modified":1562900875597},{"_id":"public/uncategorized/shell/gotossh-update.html","hash":"0f24a5c21d0e927f7402037700f681245c24c6d1","modified":1562900875597},{"_id":"public/uncategorized/leetcode/dp-01-knapsack-problem-optimization.html","hash":"7a9a0301fd07bf5f80cd1ea67aa70ad2c890d0c5","modified":1562900875597},{"_id":"public/programming/leetcode/dp-01-knapsack-problem.html","hash":"c012b87b779df90d00d8dd9cfa0fe371bd8c6f86","modified":1562900875597},{"_id":"public/uncategorized/java/spring/source-code-analysis/spring-bean-attribute-scope.html","hash":"7df20fff21c51bf35b8ea2d2c4e7a550b5f71a47","modified":1562900875597},{"_id":"public/uncategorized/shell/shell-gotossh.html","hash":"bf69b18839cfc5d1dbda2a65ea43737e7c877213","modified":1562900875597},{"_id":"public/uncategorized/java/spring/source-code-analysis/spring-bean-attribute.html","hash":"f9f93623595bb38929a6f92eab1e90ae8ef055e7","modified":1562900875597},{"_id":"public/programming/leetcode/day4-regular-expression-matching.html","hash":"4d4c1a83bbf9be4b95295562e9e8fd0928e3e1fd","modified":1562900875597},{"_id":"public/programming/leetcode/day2-add-two-numbers.html","hash":"e8d999de5579f88740dac2fb00cb350cb0682b41","modified":1562900875597},{"_id":"public/programming/java/collection/weakhashmap-code-detail.html","hash":"ca079d52a431188833cac82796193b6bc953e3dd","modified":1562900875597},{"_id":"public/programming/leetcode/day3-longest-substring-without-repeating-characters.html","hash":"80181752eb26d87684bb62bc26586ef4f38f51cc","modified":1562900875597},{"_id":"public/programming/leetcode/day1-two-sum.html","hash":"f3d7ba74abeb390ddcc93c76a2860083faea54a4","modified":1562900875597},{"_id":"public/tags/index.html","hash":"85ccc12854f76ed0dbd862d924543380f908c31c","modified":1562900875596},{"_id":"public/uncategorized/java/basic/java-data-type.html","hash":"1b72152f82f690d8ba73f37e7a9152dd8f209d1d","modified":1562900875597},{"_id":"public/uncategorized/java/basic/java-operator.html","hash":"98fa9d8612ec2c6ad029e03806f037d2e1f3bf6b","modified":1562900875597},{"_id":"public/programming/java/interview/daily-interview-test.html","hash":"503afbcbbe4d2b9d0b5f0da9e1ad1f948741a16b","modified":1562900875598},{"_id":"public/programming/leetcode/leetcode-solo-rank-begin.html","hash":"32984c44d80917d7c349aebda4002b29d8606bc6","modified":1562900875598},{"_id":"public/programming/java/reference/reference-queue-code-detail.html","hash":"ce4e8b13e628396c2ba388598844d25fb16bdd89","modified":1562900875598},{"_id":"public/programming/java/reference/soft-reference-code-detail.html","hash":"c7a718005f432442521ae58fc1861c05ae2151f2","modified":1562900875598},{"_id":"public/programming/java/reference/soft-reference.html","hash":"3ff67e3222eb98fecae80765333fe1f83177dac5","modified":1562900875598},{"_id":"public/programming/java/reference/weak-reference-code-detail.html","hash":"5886312475a0507fee335aa1b69280e30635bd56","modified":1562900875598},{"_id":"public/programming/java/README.html","hash":"443f81c61e432b0de1f9a917d16fd97612750810","modified":1562900875598},{"_id":"public/programming/java/reference/phantom-reference-code-detail.html","hash":"d030f79bd33ee65450b90c550018d496172b6314","modified":1562900875598},{"_id":"public/programming/java/reference/reference-summary.html","hash":"d084079d6ac65531d9357822ffe10391328dbafa","modified":1562900875598},{"_id":"public/archives/2017/index.html","hash":"628c018d38c693373c5a96bbcb22349fce0b0deb","modified":1562900875595},{"_id":"public/archives/2017/12/index.html","hash":"1e479c1e0990b27c3f533c09fb68d16998317da1","modified":1562900875595},{"_id":"public/archives/2018/page/5/index.html","hash":"c1332e93e422cf2cd5cfda447829bb1fe5101e96","modified":1562900875595},{"_id":"public/archives/2018/12/page/5/index.html","hash":"ba839ebd719ceb545ca632d8ce5fc809b39c9b11","modified":1562900875595},{"_id":"public/tags/reading-notes/index.html","hash":"64220c22f8a5410ba930b8f3febc5c1001b05011","modified":1562900875596},{"_id":"public/tags/interview/index.html","hash":"fe9a7d33bf722b666a66ef3bf3c1775b68d9da36","modified":1562900875596},{"_id":"public/tags/Java集合/index.html","hash":"1de7b36da1416d70d7439b7238748faf9f2cd9a8","modified":1562900875596},{"_id":"public/tags/garbage-collection/index.html","hash":"4c0573ce43e0f7921c439fe4afa31570f5eb2476","modified":1562900875602},{"_id":"public/tags/memory-leak/index.html","hash":"42178735b23c5bcba3c5df3293535ef95339887d","modified":1562900875596},{"_id":"public/tags/虚拟机/index.html","hash":"34dba355238f2d99adea036dbc3d73f024d1af6b","modified":1562900875596},{"_id":"public/uncategorized/rabbitmq/rabbitmq-how-to-use-dead-letter-queue.html","hash":"7ab89564b0a947e1bfd4ea860efdb2aa55071476","modified":1562900875596},{"_id":"public/uncategorized/mysql/mysql-index-introduction.html","hash":"a2b9770f2c44b4507a0afb2a8d7151fec75ed6b0","modified":1562900875596},{"_id":"public/programming/java/problem/the-correct-operation-of-arrays.html","hash":"b888cc5fcddc5d8a54829e5e0ef0f63b80c616ce","modified":1562900875596},{"_id":"public/programming/leetcode/knapsack-problem-conclusion-md.html","hash":"43583e8e4f81a87dd1e7948611baf7cb1144e5fd","modified":1562900875596},{"_id":"public/uncategorized/python/spider/spider-douban-book.html","hash":"917fed0bf4f171596c57492da4d983f5591fb07d","modified":1562900875597},{"_id":"public/programming/leetcode/multi-knapsack-problem-md.html","hash":"c58a953dfe95e452c9e6a5f5fabe5cd8cbd7ee9a","modified":1562900875597},{"_id":"public/programming/leetcode/complete-knapsack-problem.html","hash":"46d34e62c1a90d143b6b27b908865aab26249fa2","modified":1562900875597},{"_id":"public/uncategorized/shell/gotossh-v3-md.html","hash":"849cb543f3f5d7ba641dfac2be4ef99a2033a853","modified":1562900875597},{"_id":"public/programming/java/reference/reference-code-detail.html","hash":"48ba100db832c21d049d96a9c6d86cd5fc7cca3a","modified":1562900875598},{"_id":"public/programming/java/reference/phantom-reference.html","hash":"b51efee0571b9bebfae35ea50bec63995869075c","modified":1562900875598},{"_id":"public/programming/java/reference/weak-reference.html","hash":"a0aca3c41d3af3a887452adf864e38d4b2caa571","modified":1562900875598},{"_id":"public/programming/java/reference/strong-reference.html","hash":"845aea15a1aae9781e369e8fb30af04304204886","modified":1562900875598},{"_id":"public/programming/java/multithread/multithread-start.html","hash":"f496b2253e921abb1a1e1a228a74088ece2ee454","modified":1562900875598},{"_id":"public/programming/java/reference/final-reference-code-detail.html","hash":"894ebea3470d7eb80f2fc5c1facc072b31ee61d9","modified":1562900875599},{"_id":"public/programming/java/basic/java-class.html","hash":"2308b4d3f76303ad1ba27ac900ec442543a9f6bf","modified":1562900875599},{"_id":"public/programming/java/reference/four-kinds-of-reference.html","hash":"5a2f660779d3dc7d640dcad9bfeb1f47b8c3ba06","modified":1562900875599},{"_id":"public/reading/reading/the-art-of-java-multithread-notes.html","hash":"d352ef6e84ecfcda10e5563f1078d4e59b33d076","modified":1562900875597},{"_id":"public/programming/java/basic/java-variable.html","hash":"9da22058ab32571068f89e99d1dee6a05f1d4b15","modified":1562900875599},{"_id":"public/programming/java/basic/java-package.html","hash":"0fdc67fad798209fbb1f5cc53257564f65707157","modified":1562900875599},{"_id":"public/programming/java/basic/java-simple-structure.html","hash":"604d550dfaf6887b1ed0f49d7e36fad5dc2a1836","modified":1562900875599},{"_id":"public/programming/ops/deploy-vuepress-on-centos7.html","hash":"793a9d6ceb861867ffefbd4b22d869e620b7ca70","modified":1562900875599},{"_id":"public/programming/architecture/domain-driven-design/ddd-steps.html","hash":"ef45ae7a3c77d86123ae7e2a45422b8104403f82","modified":1562900875599},{"_id":"public/programming/java/basic/java-basic.html","hash":"94e640ced2c204fa38042d8b26a8990f650c777c","modified":1562900875599},{"_id":"public/programming/architecture/domain-driven-design/ddd-recommendation.html","hash":"9dea60c5ae486fd41e0fab258c6ee013faf196a6","modified":1562900875599},{"_id":"public/programming/architecture/domain-driven-design/ddd-outline.html","hash":"023b136ac83f7dbb811335a3c3cfd186d9d3a081","modified":1562900875599},{"_id":"public/programming/java/jvm/reachable.html","hash":"def2c502e49886b799c78966e70f8161fa404a49","modified":1562900875599},{"_id":"public/programming/java/introduction/java-primer-conclusion.html","hash":"69d1a97c7b26e403cd879159fb3ebb6eb076211a","modified":1562900875599},{"_id":"public/programming/java/introduction/java-simple-example.html","hash":"c1b7131bb008cf804a1f21c01d892cd9b0d8fd73","modified":1562900875599},{"_id":"public/programming/java/introduction/java-introduction.html","hash":"fed4e80da815cf2f1b7041aea529b48a286f3729","modified":1562900875599},{"_id":"public/programming/java/introduction/java-ide.html","hash":"ab746ee638014e2d0f3037c67f3bd5a19ff3fc57","modified":1562900875599},{"_id":"public/programming/java/introduction/java-environment-mac.html","hash":"069696e012f19de5843bef0e2c3ed3a4f2bdcacc","modified":1562900875599},{"_id":"public/programming/java/jvm/reachable-in-hotspot.html","hash":"73650c0a537337571a96769124121a350b41976f","modified":1562900875600},{"_id":"public/programming/java/introduction/java-environment-windows.html","hash":"da2df5226f6e001c7faabd470fcd364bbefdaefa","modified":1562900875599},{"_id":"public/programming/java/introduction/java-environment.html","hash":"96bd21dc8aa11debac7aa56d866bc927e4da32a0","modified":1562900875600},{"_id":"public/programming/java/introduction/java-started.html","hash":"2eee138b1c0e53c8d83c5ee72671463d282a184f","modified":1562900875600},{"_id":"public/reading/reading/java-multithread-programming-guide-in-action-digest.html","hash":"2df58491ad38c793c85a4a56d22bc69b47a0596c","modified":1562900875600},{"_id":"public/reading/reading/the-power-of-habit.html","hash":"c502662f04ac0cf46833353de9f8f5541a9d613e","modified":1562900875600},{"_id":"public/programming/java/jvm/memory-leak.html","hash":"e5a9a28d03e5aec6de046a816e70881d199f0e68","modified":1562900875600},{"_id":"public/reading/reading/java-multithread-programming-guide-in-action-notes.html","hash":"c455fda556f77eea09fe32ca67129c4ccee157b7","modified":1562900875600},{"_id":"public/reading/reading/reading-notes.html","hash":"fc846691b416b4eec70df5d197ed2be5a507d628","modified":1562900875600},{"_id":"public/reading/reading/the-power-of-habit-digest.html","hash":"a8597617073fa55fd7a5922f3f783973261b87d1","modified":1562900875600},{"_id":"public/programming/guide/background-skill.html","hash":"4d657a552605f74b33a478a182737256182c0410","modified":1562900875600},{"_id":"public/programming/java/jvm/object-self-rescue.html","hash":"5d2bdb2d34ea709ba4d09b68a72faa55f0aa186b","modified":1562900875600},{"_id":"public/archives/index.html","hash":"5fdfd4ecc24b9964b37ebac80d116db1bbc5bb95","modified":1562900875600},{"_id":"public/programming/java/jvm/garbage-collection.html","hash":"292ae886fb33569c68ca43046420a206ae9c7c43","modified":1562900875600},{"_id":"public/archives/page/3/index.html","hash":"975f6715893930f2c9d3e03d79a506a72f8055e4","modified":1562900875600},{"_id":"public/archives/page/2/index.html","hash":"02278bc889bea617cc0fcb48ecfc5e0858985f2e","modified":1562900875600},{"_id":"public/archives/page/4/index.html","hash":"ae4f3ba78d2fa043ce93a4cced52b8423173532e","modified":1562900875600},{"_id":"public/archives/page/5/index.html","hash":"4485a011af63e57e9dd6d75caddbc2811c228c36","modified":1562900875600},{"_id":"public/archives/2018/index.html","hash":"7eb72a28bb42950c13d7327919b96ba7bd8b71fe","modified":1562900875601},{"_id":"public/archives/page/6/index.html","hash":"15bb011ecaea1285b230ce6b971bf16a829a9f37","modified":1562900875600},{"_id":"public/archives/2018/page/2/index.html","hash":"812706b6a1c598c4c62894e6af52e097c6e39a78","modified":1562900875601},{"_id":"public/archives/2018/page/4/index.html","hash":"e043dbee5a2bd1176dcac17aad30b5adfa1db542","modified":1562900875601},{"_id":"public/archives/2018/12/index.html","hash":"d2ae2f19ff197f45f2f1f1cc9609868b97c4472e","modified":1562900875601},{"_id":"public/archives/2018/12/page/2/index.html","hash":"0f96fff3e9c2cd5b18d76b7f9cbba227053d1de5","modified":1562900875601},{"_id":"public/archives/2018/page/3/index.html","hash":"790b487b12a01cf5f0dda8fdc53c6aa8d0fe285d","modified":1562900875601},{"_id":"public/archives/2018/12/page/3/index.html","hash":"778e1e0b362735638be3a646f2977236858ee7b6","modified":1562900875601},{"_id":"public/archives/2018/12/page/4/index.html","hash":"40d6908d211f7e27fb8ef11b38801f91dbdb739d","modified":1562900875601},{"_id":"public/archives/2019/index.html","hash":"9e2501ea6dc1cf578927c49872e394075c7aa897","modified":1562900875601},{"_id":"public/archives/2019/page/2/index.html","hash":"f979394ba439aed6388fa8891062525b921254b0","modified":1562900875601},{"_id":"public/archives/2019/01/index.html","hash":"8aa4a04f3e36b74b2f74e816a6acc26465e4e186","modified":1562900875601},{"_id":"public/archives/2019/03/index.html","hash":"13f13ecb225118f44c9f0bd4ffc006433def4d7f","modified":1562900875601},{"_id":"public/categories/programming/index.html","hash":"08c85b9d9603b243b06444b4ea31a981d8c6b330","modified":1562900875602},{"_id":"public/categories/programming/page/2/index.html","hash":"6c65cd757a396f753eb658a77de4bcffb8de1f9d","modified":1562900875603},{"_id":"public/categories/programming/page/3/index.html","hash":"1fe52b0660a7099825258318a3c37361d8dda23f","modified":1562900875603},{"_id":"public/categories/programming/page/4/index.html","hash":"a603c06af49a2b72513a8ce2236d4dc3f0d15e5b","modified":1562900875603},{"_id":"public/categories/reading/index.html","hash":"7bba00d6091bbd83ce6c3663f7710b350c05f2a4","modified":1562900875603},{"_id":"public/categories/programming/page/5/index.html","hash":"282805bca18ee7050fb09140b88af234673220d9","modified":1562900875603},{"_id":"public/tags/java/index.html","hash":"c723f2cf3f0f770dd4c821a271d8afb9b657d6f0","modified":1562900875601},{"_id":"public/tags/java/page/2/index.html","hash":"ec714647719846f4be10c2bfd629c8a9745ae8d5","modified":1562900875601},{"_id":"public/tags/java/page/3/index.html","hash":"63b736caf2260a71579c85fe352c247ab1469a75","modified":1562900875601},{"_id":"public/tags/multithread/index.html","hash":"fbf77a12a25328c1b78bc9014f99f7b3a1cc7b2e","modified":1562900875602},{"_id":"public/tags/java/page/4/index.html","hash":"e4188897ebfe26cfde7e9eb590aa2f638ac785b5","modified":1562900875602},{"_id":"public/tags/java/page/5/index.html","hash":"b8aca7f4de93c30e4a00f0dd6f084b179c35bea0","modified":1562900875602},{"_id":"public/tags/algorithm/index.html","hash":"bc2b3309ac84eef3ccc1e6456aeed10d0e55e997","modified":1562900875602},{"_id":"public/tags/LeetCode/index.html","hash":"b24719fd6a78863c8b6002d308010e7d69a6da4e","modified":1562900875602},{"_id":"public/tags/dynamic-programming/index.html","hash":"e52bd5c844c4bc655d36306c6227f3b8c0fb278d","modified":1562900875602},{"_id":"public/tags/knapsack-problem/index.html","hash":"b587e96005c3ae42cdb5572bc1e46be466410344","modified":1562900875602},{"_id":"public/tags/digest/index.html","hash":"c03569129c8072d36333ef2e766bc58233d362fe","modified":1562900875602},{"_id":"public/tags/enviroment/index.html","hash":"7933b812a21254f19df5538e2e87ee02b73af0e9","modified":1562900875602},{"_id":"public/tags/ddd/index.html","hash":"2e7bc39ae5d2ec7d0ac86600dc083ce4fa1f68a6","modified":1562900875602},{"_id":"public/tags/java-base/index.html","hash":"f89b879480cfe608cf6264fc9699542c04ff8463","modified":1562900875602},{"_id":"public/tags/java-introduction/index.html","hash":"b8b9717ced188104e6553775c7d18fc3513b09fd","modified":1562900875602},{"_id":"public/tags/reference-type/index.html","hash":"157f0fbe046bf1c2be429b1e777e0b751031e460","modified":1562900875602},{"_id":"public/tags/reference-type/page/2/index.html","hash":"6e933b2db6ad0d53e63b6fdc0aa5b1b18ab53b26","modified":1562900875602},{"_id":"public/index.html","hash":"2e34358ef962b7c8be3dd66b0ff0515ff5488f94","modified":1562900875603},{"_id":"public/page/2/index.html","hash":"8cbd006d10992df439efe09cb8649c5d0e0b7c43","modified":1562900875603},{"_id":"public/tags/source-code-analysis/index.html","hash":"feb50c075d9cacda25b62a64b1af6394c019d16c","modified":1562900875602},{"_id":"public/tags/spring/index.html","hash":"1ab56420adcf66331fef72116d434dedc13e54b6","modified":1562900875602},{"_id":"public/page/3/index.html","hash":"ae0054b708ad644453613139319feab048f5cf7f","modified":1562900875603},{"_id":"public/page/4/index.html","hash":"4624b6f801625c3b038de80c0f21ee738ed7f795","modified":1562900875603},{"_id":"public/page/5/index.html","hash":"a1348c14e40598efde9ec5add935d8d963a90b7c","modified":1562900875603},{"_id":"public/page/6/index.html","hash":"e0f58dd0291b5dbc2c403e6d5531a6c0d638d85e","modified":1562900875603},{"_id":"public/archives/2019/page/3/index.html","hash":"ffa1866a4ca43bfd794b937ceb8d8184671f692b","modified":1562900875601},{"_id":"public/archives/2019/04/index.html","hash":"a9ce8730d4d666bd719ca2e2744a7a0819ad52c6","modified":1562900875595},{"_id":"public/archives/2019/05/index.html","hash":"ce1f8eb9c53be2c77edcb09278bd44529e015e47","modified":1562900875595},{"_id":"public/archives/2019/07/index.html","hash":"aaab7d08934ae4abe7e48f63b55913ee82005473","modified":1562900875595},{"_id":"public/tags/mysql/index.html","hash":"b3893944e2de457d5d03df5966cb4d8034b5bbce","modified":1562900875602},{"_id":"public/tags/database/index.html","hash":"6a68233368e30742543d5cb6100fb00a021adfab","modified":1562900875596},{"_id":"public/tags/RabbitMQ/index.html","hash":"834addfeee28b6a725463d05ca1f533c267cc854","modified":1562900875596},{"_id":"public/tags/problem/index.html","hash":"d3ef2c63feb1369e6e6f9063b34272a531d2aa9b","modified":1562900875596},{"_id":"public/tags/spider/index.html","hash":"2a4e1fb08aa9b417fe2f5b70b2c8be94690ea7f2","modified":1562900875596},{"_id":"public/tags/豆瓣/index.html","hash":"751d0eceff3382e1cd6a107815b58262da231ced","modified":1562900875596},{"_id":"public/tags/python/index.html","hash":"001d6ea81af34c59ec0caff2364f4c9a20f67d97","modified":1562900875596},{"_id":"public/archives/page/7/index.html","hash":"65174f985be6e37f5577e64da7ebd8113b07ca34","modified":1562900875601},{"_id":"public/page/7/index.html","hash":"9b8fdd041e38a6a0677c472e64b21444f0cc6040","modified":1562900875603},{"_id":"public/images/0001.png","hash":"5646e88cc49bea8fb2744a8a131c94b2b55b266f","modified":1562900875619},{"_id":"public/images/0002.png","hash":"54f015dd14356d46b4a5eb4c42bb0b296f3c2b68","modified":1562900875619},{"_id":"public/images/0005.png","hash":"fcfdff32f6d724be3c3d12e709f9f3a460a3e274","modified":1562900875619},{"_id":"public/images/0003.png","hash":"7efe69ed1c19533b6bc5b6cb7cb7356303702513","modified":1562900875619},{"_id":"public/images/0009.png","hash":"785e1957c7aea321a1933bbaf37a7e7b834212e6","modified":1562900875619},{"_id":"public/images/0040.png","hash":"3a4142e60fcb16d71ee8f2eb5e4de31091d2676f","modified":1562900875619},{"_id":"public/images/0013.png","hash":"7b5bda6e7d94dbeacef12ef060e5e0d8e2fa4d32","modified":1562900875619},{"_id":"public/images/0012.png","hash":"15a7c4e801630c8a3f6bb67d0fd18e69eb8eacc7","modified":1562900875619},{"_id":"public/images/0019.png","hash":"013380c072a2fe829f2e10dbee5a76554ff20509","modified":1562900875619},{"_id":"public/images/0046.png","hash":"e07f0c042e640e7cd71e132f7f48d6360f09e3ca","modified":1562900875619},{"_id":"public/images/0190.png","hash":"c5929d6f6445ef0d9aa017a313d10dff0e6fa553","modified":1562900875619},{"_id":"public/images/105.png","hash":"be0006708b897b95df1253186474048473bb8bbe","modified":1562900875619},{"_id":"public/images/06.png","hash":"54707910862fdf7b148c90e36fa832f10c0d22fb","modified":1562900875619},{"_id":"public/images/141.png","hash":"accf4d56385ac11f9ae611c005ee807214bfc1af","modified":1562900875619},{"_id":"public/images/148.png","hash":"5533113be8fff9946f3ebca68666478732c18203","modified":1562900875619},{"_id":"public/images/195.png","hash":"240ea388434d019a8cddf1df5f986ec1877bda14","modified":1562900875619},{"_id":"public/images/94.png","hash":"5da31bf5172d88b611f6c4706effecb82420ea47","modified":1562900875619},{"_id":"public/images/2030.png","hash":"01e87e34ca69f7d33403860a9d59d0ac809162eb","modified":1562900875619},{"_id":"public/images/8111.png","hash":"3ee2a0a45a1121730ece4ce28b1f5208063e4c8a","modified":1562900875620},{"_id":"public/img/favicon.ico","hash":"c88cd0044daea8f5b87913d71c4ade2aa31387c9","modified":1562900875620},{"_id":"public/images/black_smile.png","hash":"10b24e9659ecc8748fe100c8e97a19dd47e7777b","modified":1562900875620},{"_id":"public/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1562900875620},{"_id":"public/images/black_smile-2.png","hash":"52f607e15843e2dc2a3ccde055811646bdc75e2f","modified":1562900875620},{"_id":"public/img/avatar.jpg","hash":"96f2506c587325147a383aad3ada8d5993e6cdf8","modified":1562900875620},{"_id":"public/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1562900875620},{"_id":"public/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1562900875620},{"_id":"public/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1562900875620},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1562900875620},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1562900875620},{"_id":"public/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1562900875620},{"_id":"public/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1562900875620},{"_id":"public/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1562900875620},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1562900875620},{"_id":"public/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1562900875620},{"_id":"public/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1562900875620},{"_id":"public/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1562900875620},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1562900875620},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1562900875621},{"_id":"public/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1562900875621},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1562900875621},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1562900875621},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1562900875621},{"_id":"public/programming/leetcode/day1-two-sum/exhaust-algorithm.png","hash":"3b8efaf057ad53ea51a96b0616b7f8bfd22816e1","modified":1562900875621},{"_id":"public/programming/leetcode/day1-two-sum/map-solution.png","hash":"b0783ee61fce6885811395c35d0ae4e80285f8c7","modified":1562900875621},{"_id":"public/programming/leetcode/day2-add-two-numbers/solution-1.png","hash":"c37a7a043dd0d2a2f62500fea8a7aca36e50819d","modified":1562900875621},{"_id":"public/programming/leetcode/day2-add-two-numbers/result-5.png","hash":"a06576a002b1e3f3c6faf5e5b208f1e56ffdcb9d","modified":1562900875621},{"_id":"public/programming/leetcode/day2-add-two-numbers/solution-2.png","hash":"8323b2f344c772a29efd3e14956843e208985fd7","modified":1562900875621},{"_id":"public/programming/leetcode/day2-add-two-numbers/solution-3.png","hash":"a0cf02fd5abd984375fe184ad4769bee0535795d","modified":1562900875621},{"_id":"public/programming/leetcode/complete-knapsack-problem/CodeCogsEqn.png","hash":"b7919c258abf6c3629ec728a1f69bc53033682f7","modified":1562900875621},{"_id":"public/programming/leetcode/day2-add-two-numbers/solution-4.png","hash":"d7138b9fd24239f3dd038290025303cb708f030b","modified":1562900875621},{"_id":"public/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-step-1.png","hash":"559e538203bb5ba394a1847d18d1bc4096e192a0","modified":1562900875621},{"_id":"public/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-step-2.png","hash":"a6de0d88dd139c1b00005c70c25921a5de1e5874","modified":1562900875621},{"_id":"public/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-step-4.png","hash":"d3ba153a5016766a8bb7b48f620682d15a4eec28","modified":1562900875621},{"_id":"public/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-step-3.png","hash":"1a0d033b1a81da9609492f7cf7401bb16b29823f","modified":1562900875621},{"_id":"public/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-step-5.png","hash":"02dfd8cc12f9897c0aae5476dc538289fdc3201c","modified":1562900875622},{"_id":"public/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-step-6.png","hash":"db7d2f6c169ac060351d7eb3bff1d4a948e0858d","modified":1562900875621},{"_id":"public/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-step-8.png","hash":"3abc7aa2193431ac85ff49e4498219f89fa93529","modified":1562900875622},{"_id":"public/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-submit-1.png","hash":"3ed8a1e50b491c67d72b22d5d68bbb8f9e632b3e","modified":1562900875622},{"_id":"public/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-submit-2.png","hash":"19fc70d759acd618de78e8815bb0050b9a5cc741","modified":1562900875622},{"_id":"public/programming/leetcode/day4-regular-expression-matching/result1.png","hash":"96a80b94fa15399f91e674b8ac08b5fd4fae7afc","modified":1562900875622},{"_id":"public/programming/leetcode/day4-regular-expression-matching/result3.png","hash":"271bb69cdb3c1856e9dc20738763cbb34b544708","modified":1562900875622},{"_id":"public/programming/leetcode/day4-regular-expression-matching/result2.png","hash":"bad7a69287401408d5e4d55009db9712dc66bc74","modified":1562900875622},{"_id":"public/uncategorized/shell/gotossh-v3-md/list-all-the-commands.gif","hash":"3ac4b3673a777c70ad514b09a512b0d1ec4fc3e1","modified":1562900875622},{"_id":"public/uncategorized/shell/gotossh-v3-md/list-all-the-servers.gif","hash":"53c1fc0d0e94da27756c6845cc140330e807160f","modified":1562900875622},{"_id":"public/uncategorized/shell/gotossh-v3-md/scp-jump-server-log.gif","hash":"17168f30b5568ce36602deb8ee4d4c7a8b9c32df","modified":1562900875622},{"_id":"public/programming/java/jvm/reachable/accessibility1.jpg","hash":"36ba36afdaa689c5cadd4919a834569d72fdb478","modified":1562900875622},{"_id":"public/programming/java/reference/reference-code-detail/reference-1.png","hash":"90330bc0125b7580e1421a7e3f409e5a703caf8e","modified":1562900875622},{"_id":"public/programming/java/jvm/reachable/accessibility2.png","hash":"281d56cfb09c2ac6654e604869f1c089bb19688b","modified":1562900875622},{"_id":"public/programming/java/reference/reference-code-detail/reference-2.png","hash":"a8dc3f3b71dcb3ace64dd22fd364972a8b2daf22","modified":1562900875622},{"_id":"public/programming/java/reference/soft-reference-code-detail/soft-reference-2.png","hash":"f07af2215f65766b68a5c3e932bc01e1ea4a0fc5","modified":1562900875622},{"_id":"public/programming/java/introduction/java-simple-example/java-simple-example-1.png","hash":"7be12cd9b902847ed3ca8ce7a6f06139103f1180","modified":1562900875622},{"_id":"public/programming/java/reference/soft-reference-code-detail/soft-reference-3.png","hash":"39f4779065da2ccd6dd355ff6fd1e72efaf4391f","modified":1562900875622},{"_id":"public/programming/java/introduction/java-simple-example/java-simple-example-2.png","hash":"404e3de6764fab8a109a7efceabfb4bc6942fb30","modified":1562900875622},{"_id":"public/programming/java/introduction/java-simple-example/java-simple-example-3.png","hash":"9b42950df71c6cb651d76dec741a4549e4855fd5","modified":1562900875623},{"_id":"public/programming/java/collection/weakhashmap-code-detail/weakhashmap-1.png","hash":"2d21b6d2b326191f28c04b070863c03614dc08fe","modified":1562900875623},{"_id":"public/programming/java/collection/weakhashmap-code-detail/weakhashmap-2.png","hash":"a97b7673b4d40163640e1a35540c2c2b51c8ed93","modified":1562900875623},{"_id":"public/programming/java/collection/weakhashmap-code-detail/0038.png","hash":"dc8ec7ec15f9d18d028fa4baa7b8edf7dcf9f587","modified":1562900875623},{"_id":"public/programming/java/introduction/java-ide/java-ide-3.png","hash":"5616c391ba4e9a1341b4c6213758924b9e8124d1","modified":1562900875623},{"_id":"public/programming/java/introduction/java-ide/java-ide-5.png","hash":"627cfbad99d15a6962df90269eb9df896a6b6021","modified":1562900875623},{"_id":"public/programming/java/introduction/java-ide/java-ide-6.png","hash":"bc4523f962ca5301e062c864166cf4cc2dfd6f34","modified":1562900875623},{"_id":"public/programming/java/introduction/java-ide/java-ide-8.png","hash":"311e7f7643a2facb45dc3165c938af1bd84b28b7","modified":1562900875623},{"_id":"public/programming/java/introduction/java-ide/java-ide-7.png","hash":"db6fcb1e3350c32db0a5ad41400ee7e22023eed1","modified":1562900875623},{"_id":"public/programming/java/introduction/java-ide/java-ide-9.png","hash":"b7cb86602219d3609159f856c4449b7b85ae0aac","modified":1562900875623},{"_id":"public/programming/java/introduction/java-environment-windows/2-jdk-windows.png","hash":"4d1cb8168cde93a8aabef63c8d12a8ccb56a60e4","modified":1562900875623},{"_id":"public/programming/java/introduction/java-environment-windows/4-jdk-windows.png","hash":"155d9ca099b6138a5f3c2df3b826f6ce972d847a","modified":1562900875623},{"_id":"public/programming/java/introduction/java-environment-windows/3-jdk-windows.png","hash":"2a89504a729c391003e94d74941aeada3fde7e4a","modified":1562900875623},{"_id":"public/programming/java/introduction/java-environment-windows/5-jdk-windows.png","hash":"ac4f6a18554f2d1aae972e1bf6737dd60551613d","modified":1562900875623},{"_id":"public/programming/java/introduction/java-environment-windows/6-jdk-windows.png","hash":"f26f02913932acf206e345b96a2749c22d68a7c1","modified":1562900875623},{"_id":"public/programming/java/introduction/java-environment-windows/7-jdk-windows.png","hash":"79f375c43ac760ce5a88aef12df9e788494f0643","modified":1562900875623},{"_id":"public/programming/java/introduction/java-environment-windows/8-jdk-windows.png","hash":"884e1c6927bf1394dc9941de017deb3b9901daeb","modified":1562900875623},{"_id":"public/programming/java/introduction/java-environment-windows/9-jdk-windows.png","hash":"8defa728fac888e8203a5e6151596c5ce15280d3","modified":1562900875623},{"_id":"public/programming/java/introduction/java-environment-mac/10-jdk-mac.png","hash":"a058e42380742e3be7911c30ea4c54263f2e99e9","modified":1562900875623},{"_id":"public/programming/java/introduction/java-environment-mac/12-jdk-mac.png","hash":"79b6a623b06142723ea9dc4981f3ef12ff3bcd75","modified":1562900875623},{"_id":"public/programming/java/introduction/java-environment-mac/13-jdk-mac.png","hash":"aa4d7a93b28afb3424a5c107724b07cb9cbeed3d","modified":1562900875623},{"_id":"public/programming/java/introduction/java-environment-mac/14-jdk-mac.png","hash":"4bc54995d9f778084a8b486634bc30793f1592f0","modified":1562900875624},{"_id":"public/programming/java/introduction/java-environment-mac/16-jdk-mac.png","hash":"5451e575e4bf08b384335bb070bb46817edad5bd","modified":1562900875624},{"_id":"public/programming/java/introduction/java-environment-mac/5-jdk-mac.png","hash":"b65be8a8b49518b8fc8ea4f1c1b7d1113352180c","modified":1562900875624},{"_id":"public/programming/java/introduction/java-environment-mac/6-jdk-mac.png","hash":"cc0550022513036a612d666bab64f1876d703ec3","modified":1562900875624},{"_id":"public/programming/java/introduction/java-environment-mac/7-jdk-mac.png","hash":"57310fc56a96be434f0ad69eb6387a82f54d0d5a","modified":1562900875624},{"_id":"public/programming/java/introduction/java-environment-mac/8-jdk-mac.png","hash":"52eacf47993855414045b0719196da9001ccb153","modified":1562900875624},{"_id":"public/programming/java/introduction/java-environment-mac/9-jdk-mac.png","hash":"1c9dbad3045f234695be69fb4c27c0cd53ab1918","modified":1562900875624},{"_id":"public/programming/java/problem/the-correct-operation-of-arrays/5cdf6a292b1d070453.png","hash":"c1d176ce8d8531bc7aedc5042059d0de466d0c05","modified":1562900875624},{"_id":"public/programming/java/problem/the-correct-operation-of-arrays/5cdf6a655276187010.png","hash":"31c40871e367cb71244c6e8549c483b71cf262b5","modified":1562900875624},{"_id":"public/programming/java/problem/the-correct-operation-of-arrays/5cdf7e9f2047e23793.png","hash":"985f8790a13d24c512910d43eec74b4fd27a0b29","modified":1562900875624},{"_id":"public/programming/java/problem/the-correct-operation-of-arrays/5cdf7f0e86fbc84596.png","hash":"65b03d0d7632771862dce230e74aa9f16d4292e5","modified":1562900875624},{"_id":"public/programming/java/problem/the-correct-operation-of-arrays/5cdf7f4a7282234332.png","hash":"932ec5b8b6b5710942b97977fd9482aae12f1514","modified":1562900875624},{"_id":"public/programming/java/problem/the-correct-operation-of-arrays/5cdf7ec98fddd17705.png","hash":"01c4c5eafeb1dc753469677895b8d76b34d4eae3","modified":1562900875624},{"_id":"public/programming/java/problem/the-correct-operation-of-arrays/black_smile.jpg","hash":"1aea48378b0a27aa6aefd8bd9daab234758f22a4","modified":1562900875624},{"_id":"public/programming/java/problem/the-correct-operation-of-arrays/e8df70b9feab81ccabe8a2821dc2e9880cddc9e4f2ce-zo9QsQ_fw658.jpeg","hash":"a4bdeb9804e3bc479a184a3ce2ff8f4db8d7153c","modified":1562900875624},{"_id":"public/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1562900875655},{"_id":"public/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1562900875655},{"_id":"public/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1562900875655},{"_id":"public/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1562900875655},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1562900875654},{"_id":"public/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1562900875655},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1562900875655},{"_id":"public/programming/leetcode/dp-01-knapsack-problem/IMG_339C2E86CD88-1.jpeg","hash":"d32fa8f45ebc1d660c76fd23ae6ee87a296989e5","modified":1562900875655},{"_id":"public/programming/leetcode/dp-01-knapsack-problem/IMG_9B418BF0E7A5-1.jpeg","hash":"61c0f49bbc8b6840ebe8a95f78a8302e0b5ce2eb","modified":1562900875655},{"_id":"public/uncategorized/shell/gotossh-v3-md/scp-online-server-file.gif","hash":"4da5e5d7a3b0b7dfec1598120813bd0ff4dc68fc","modified":1562900875655},{"_id":"public/programming/java/collection/weakhashmap-code-detail/weakhashmap-3.png","hash":"a1971c4b5102b3a6c222ed1014712e399a6e3ce2","modified":1562900875656},{"_id":"public/programming/java/collection/weakhashmap-code-detail/weakhashmap-4.png","hash":"ca0ae5597535eb89f027c74cf3e92369cffb0bd4","modified":1562900875656},{"_id":"public/programming/java/introduction/java-ide/java-ide-4.png","hash":"41e84a42900e891648f3b37130a080606f531181","modified":1562900875656},{"_id":"public/programming/java/introduction/java-environment-windows/1-jdk-windows.png","hash":"8f643602c33a1a98b96e46349952dea4dae4981b","modified":1562900875656},{"_id":"public/programming/java/introduction/java-environment-mac/11-jdk-mac.png","hash":"09153cd9a58d2ea84f64bc4105fee92a0691c221","modified":1562900875656},{"_id":"public/programming/java/introduction/java-environment-mac/15-jdk-mac.png","hash":"115d45c94471ff20db11d361a5111108181273f9","modified":1562900875656},{"_id":"public/programming/java/problem/the-correct-operation-of-arrays/5cdf7daf74e9241031.png","hash":"62f8083a628c45dd76c5da72fabd1dbbc3882413","modified":1562900875656},{"_id":"public/programming/java/problem/the-correct-operation-of-arrays/carbon (1).png","hash":"6004cb2e74dd5627b4f5fe0e34ba7bd7053d1964","modified":1562900875656},{"_id":"public/programming/java/problem/the-correct-operation-of-arrays/carbon (4).png","hash":"34143640204e2fd3f306af145f0c4a8128cb88af","modified":1562900875656},{"_id":"public/programming/java/problem/the-correct-operation-of-arrays/carbon (3).png","hash":"263726c337b2f97e315a7005fe4ad21915da8577","modified":1562900875656},{"_id":"public/programming/java/problem/the-correct-operation-of-arrays/carbon (7).png","hash":"0b531eb961c87367efa631c64fb06a656eeb3570","modified":1562900875656},{"_id":"public/programming/java/problem/the-correct-operation-of-arrays/carbon (8).png","hash":"0d2524fa2e1836a075e32c69d3faf8045478e8af","modified":1562900875656},{"_id":"public/programming/java/problem/the-correct-operation-of-arrays/carbon (9).png","hash":"f5f7746eb83ac4a8801422a3b730ecd399ba1191","modified":1562900875657},{"_id":"public/js/main.min.js","hash":"8acf4480f8ab859423b8926b9b790c67b5a77276","modified":1562900875667},{"_id":"public/js/search.js","hash":"a1de7e7a2ef8330ebcd9f3a7a4622b3bac44e4f3","modified":1562900875667},{"_id":"public/js/search.min.js","hash":"a8a450bb8b1ca9ad577052addcbd3393f1af6c6a","modified":1562900875667},{"_id":"public/js/main.js","hash":"300b2e963683ced162e28afcd24ffc970fc23ac2","modified":1562900875667},{"_id":"public/img/alipay.jpg","hash":"d2e76219d3f688a805c9f30e004f48e79daf03ab","modified":1562900875667},{"_id":"public/img/wechat.jpg","hash":"c7887fd95a3383371b957667d4bfbc3c8c2cbe53","modified":1562900875667},{"_id":"public/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1562900875667},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1562900875667},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1562900875667},{"_id":"public/programming/leetcode/dp-01-knapsack-problem/IMG_ECCF05DEC924-1.jpeg","hash":"611b425e7c449d8b1ac8b83e22784fefff9b7ce6","modified":1562900875668},{"_id":"public/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-step-7.png","hash":"62c8c5ac7132440be42826117bae9f8b47ab91b9","modified":1562900875667},{"_id":"public/programming/leetcode/complete-knapsack-problem/IMG_510B188AF928-1.jpeg","hash":"e3b84b5c1721d80fcd21421fc0d3c03397c31062","modified":1562900875668},{"_id":"public/programming/leetcode/complete-knapsack-problem/IMG_5E156B07E228-1.jpeg","hash":"5e9e32ac8427904315a13e63f6ea1659e5c83a31","modified":1562900875668},{"_id":"public/programming/leetcode/dp-01-knapsack-problem/IMG_007B2F2632D2-1.jpeg","hash":"a886afc0d50b5d55fb0bd7f80911c80ddb12d245","modified":1562900875668},{"_id":"public/programming/leetcode/dp-01-knapsack-problem/IMG_13B30A586085-1.jpeg","hash":"97ac09688a58a030dd08163a3b1fbe17763e5b1e","modified":1562900875668},{"_id":"public/programming/leetcode/dp-01-knapsack-problem/IMG_142D1BF09ED7-1.jpeg","hash":"c8a40ab3922b238859ed758f6312c31956aaf7ab","modified":1562900875669},{"_id":"public/programming/leetcode/dp-01-knapsack-problem/IMG_2ABCC82C89F7-1.jpeg","hash":"42fe2d940da23209ff873b3b5a46733f701711a9","modified":1562900875669},{"_id":"public/programming/leetcode/dp-01-knapsack-problem/IMG_16ACD9FB2E1C-1.jpeg","hash":"8b609a9044ace8b5d2384476dc77e13d9585a635","modified":1562900875669},{"_id":"public/programming/leetcode/dp-01-knapsack-problem/IMG_37EAFFF048DB-1.jpeg","hash":"32c7f5e0201113efba7873dba19ca2994c596df8","modified":1562900875669},{"_id":"public/programming/leetcode/day4-regular-expression-matching/example1.png","hash":"dda32c7e119dcb0b269c466ad35190eb1c9c9c50","modified":1562900875669},{"_id":"public/programming/leetcode/day4-regular-expression-matching/example2.png","hash":"a0ced037654761a1ac935eb5163b7c4f2735d8d9","modified":1562900875669},{"_id":"public/programming/leetcode/day4-regular-expression-matching/example3.png","hash":"ac38425fe1aaea80be4b06bef607c4f4fbb6cdc5","modified":1562900875669},{"_id":"public/programming/java/introduction/java-environment-mac/2-jdk-mac.png","hash":"bef4170c81af99efbdb89dafa2094fd127648889","modified":1562900875668},{"_id":"public/programming/java/introduction/java-started/java-started-1.png","hash":"83c77b655ea24647ff6c55c830924baa4e90b845","modified":1562900875670},{"_id":"public/uncategorized/shell/gotossh-v3-md/login-jump-server.gif","hash":"697ca092e5f311883f5fdd97f0291f012a2f20b5","modified":1562900875669},{"_id":"public/uncategorized/shell/gotossh-v3-md/login-online-server.gif","hash":"fdd2a5fa10106a1dd5ae1d6b5f513119013e1be8","modified":1562900875670},{"_id":"public/programming/java/problem/the-correct-operation-of-arrays/carbon (2).png","hash":"51d0275bcdf1a206c8f6a3757379facb0ef77af9","modified":1562900875670},{"_id":"public/programming/leetcode/complete-knapsack-problem/IMG_6B67BF7CC3A7-1.jpeg","hash":"4b557b85348bc8a902e2f28d3d33ebf505822f78","modified":1562900875681},{"_id":"public/programming/leetcode/dp-01-knapsack-problem/IMG_F047D511640B-1.jpeg","hash":"ff5694f468386d06c7037fc7d9e485110dfb1cac","modified":1562900875680},{"_id":"public/programming/leetcode/dp-01-knapsack-problem/IMG_CD2E7F29F646-1.jpeg","hash":"1b6d131d885afb6517dfab9573f26249047ad238","modified":1562900875680},{"_id":"public/programming/leetcode/dp-01-knapsack-problem/IMG_482BA28A5E66-1.jpeg","hash":"75cb1c8b961cc7807d3375c5bcf99040f0c6a231","modified":1562900875680},{"_id":"public/programming/leetcode/dp-01-knapsack-problem/IMG_04E34B950C69-1.jpeg","hash":"18254fec11dc75a281c7888a9739f4289c2de089","modified":1562900875679},{"_id":"public/programming/leetcode/dp-01-knapsack-problem/IMG_E5B595A5513F-1.jpeg","hash":"0ba5261b42358309b7de36214f9275972bbd0e53","modified":1562900875681},{"_id":"public/uncategorized/shell/gotossh-update/login-server3.gif","hash":"5b27770c73eea62a9947337541d03d3b1f2a5c2c","modified":1562900875681},{"_id":"public/programming/leetcode/day4-regular-expression-matching/example4.png","hash":"b4bd082cda695f391cba78a07d193ef653e598dc","modified":1562900875679},{"_id":"public/programming/java/introduction/java-environment-mac/3-jdk-mac.png","hash":"0b4bb944db5070a12b706f7ffaf451f5d558cfd9","modified":1562900875681},{"_id":"public/programming/java/problem/the-correct-operation-of-arrays/carbon (5).png","hash":"897b002b8ecfc3b72d7db84d308bdbc0306e2b34","modified":1562900875682},{"_id":"public/programming/java/problem/the-correct-operation-of-arrays/carbon.png","hash":"6606e0b25abc19f312e4b415f26c5ba116b4170a","modified":1562900875682},{"_id":"public/programming/java/introduction/java-ide/java-ide-2.png","hash":"9e81a827e3e5793b7f262df0eda5de1746c65899","modified":1562900875681},{"_id":"public/programming/leetcode/day4-regular-expression-matching/solution1-3.png","hash":"738022ef720eb066fa3064debc8e113d98cf4dfb","modified":1562900875692},{"_id":"public/uncategorized/shell/gotossh-update/login-server4.gif","hash":"0ca0658dd2201971061ab2f7f36aa39cf4d36ec3","modified":1562900875692},{"_id":"public/programming/leetcode/day4-regular-expression-matching/fib.png","hash":"b126016de12528c6b9f8e0d0a62b6ab9d593ed49","modified":1562900875692},{"_id":"public/programming/leetcode/day4-regular-expression-matching/solution2-1.png","hash":"416121b91302490bcbf2e5c46be4302c82720b49","modified":1562900875692},{"_id":"public/programming/leetcode/day4-regular-expression-matching/solution2-2.png","hash":"d993f366178f0f1cba86acfa7df692a23cd60f20","modified":1562900875693},{"_id":"public/uncategorized/shell/gotossh-v3-md/login-and-view-the-log.gif","hash":"760facffcea818ad86d4d5fa3379cd701aa1266f","modified":1562900875693},{"_id":"public/programming/java/introduction/java-environment-mac/4-jdk-mac.png","hash":"df019bad4cac078997c8a067a59d69be97a34adc","modified":1562900875693},{"_id":"public/programming/java/problem/the-correct-operation-of-arrays/carbon (6).png","hash":"2ab560cd392d00e609d7b0415b4a8a17ece13efa","modified":1562900875693},{"_id":"public/programming/leetcode/day4-regular-expression-matching/example5.png","hash":"8152c6859b65aaee0e93af5d3f8f62ef298be3d7","modified":1562900875702},{"_id":"public/programming/leetcode/dp-01-knapsack-problem/IMG_BFE9B7063670-1.jpeg","hash":"49fcf7097fba4b21429e8d0f9ab8c9d8e3416641","modified":1562900875702},{"_id":"public/programming/leetcode/day4-regular-expression-matching/solution1-1.png","hash":"528e20077405ad881883b3f3420eb1f50a1d5ccd","modified":1562900875703},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1562900875714},{"_id":"public/uncategorized/shell/gotossh-update/scp-server3-log.gif","hash":"294dd79b320bc6358c880c50a2d1596887678089","modified":1562900875714},{"_id":"public/programming/leetcode/day4-regular-expression-matching/solution1-2.png","hash":"c501ae2762abc3dfaae03bc3d09f01278a3df22c","modified":1562900876022},{"_id":"public/uncategorized/shell/gotossh-v3-md/login-and-view-the-log2.gif","hash":"bc7937809cde4bb149ca4c5acbc82384697e9d26","modified":1562900876023},{"_id":"public/programming/leetcode/day4-regular-expression-matching/solution1-4.png","hash":"c52a83829385942135d81db7722ea5de30e566f7","modified":1562900876023},{"_id":"public/uncategorized/shell/gotossh-update/jump.gif","hash":"a03dd35e1dab365e7c59c3f673fb7fc44fdd51d2","modified":1562900876033},{"_id":"public/uncategorized/shell/gotossh-update/server4-log.gif","hash":"333a950b783e49857be08a31e166b47703126cda","modified":1562900876033},{"_id":"public/css/style.css","hash":"4f59712181405c963fe7e80740071022050bc096","modified":1562900876033},{"_id":"public/programming/java/introduction/java-ide/java-ide-1.png","hash":"ab6bb5ebfc5b292263824a72ba6eeca819f31f14","modified":1562900876047},{"_id":"public/programming/java/introduction/java-environment-mac/1-jdk-mac.png","hash":"4acf222e3a5d9728d358cd16a2f0d4300ae6700e","modified":1562900876047},{"_id":"public/uncategorized/shell/gotossh-update/server3-log.gif","hash":"a88a6d29cdc855b2c2d0e96f27f725c2b82e0ab0","modified":1562900876056},{"_id":"public/uncategorized/shell/gotossh-update/scp-server4-log.gif","hash":"56308e22f435b200fe3a7773b73d4bff7c6647d5","modified":1562900876069},{"_id":"public/uncategorized/shell/gotossh-v3-md/login.gif","hash":"e6a41bf227897792b4447974fe47d62d1b24227f","modified":1562900876074},{"_id":"public/uncategorized/shell/gotossh-v3-md/login-online-server-and-view-the-log.gif","hash":"01f0cc8dcd4663919e64f1375c45a2dc6f4481bc","modified":1562900876077},{"_id":"source/_posts/mysql/index/how-to-insert-10-million-pieces-of-data-into-mysql.md","hash":"0c865c0685f94a2380a76a8e4491f95bd1c05228","modified":1562900638135},{"_id":"source/_posts/mysql/index/mysql-index-01.md","hash":"923aea922100aa4a2898605abdbabbabad759388","modified":1559612466712},{"_id":"public/archives/2019/06/index.html","hash":"d4ae684d1f43f610a1dd857a87213bc2b6d385be","modified":1562900875595},{"_id":"public/tags/index/index.html","hash":"2bcc1554cbd48fb361a152f4279acc83d1dbe3df","modified":1562900875596},{"_id":"public/tags/test/index.html","hash":"c15497992d88d4760583b105ff84d7de94778013","modified":1562900875596},{"_id":"public/uncategorized/mysql/index/how-to-insert-10-million-pieces-of-data-into-mysql.html","hash":"1c75ed6952aa63f01223826787905253971a75c3","modified":1562900875596},{"_id":"public/uncategorized/mysql/index/mysql-index-01.html","hash":"da91d96b10b829618c04666770b0af638cbd9fdd","modified":1562900875596}],"Category":[{"name":"编程","_id":"cjxze3gkm00030cvw03u1c4h3"},{"name":"阅读","_id":"cjxze3gox001h0cvw3ibxwq3f"}],"Data":[{"_id":"menu","data":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}],"Page":[{"layout":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"layout: tags\ncomments: false\n---","date":"2019-06-04T01:29:57.644Z","updated":"2019-06-04T01:29:57.644Z","path":"tags/index.html","_id":"cjxze3g9j00000cvwox4lhog8","title":"","content":"","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":""},{"layout":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"layout: categories\ncomments: false\n---","date":"2019-06-04T01:29:57.638Z","updated":"2019-06-04T01:29:57.638Z","path":"categories/index.html","_id":"cjxze3g9j00010cvw5pg2avpa","title":"","content":"","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":""}],"Post":[{"title":"Java 技术系列文章","date":"2017-12-29T11:55:51.000Z","_content":"\n## 前言\n\n本篇章内容主要介绍Java的各类技术，包括Java的基础部分，容器类，常用类的源码剖析，并发容器，多线程等等。\n\n## Java 开发入门篇\n\n1. [Java开发起航篇](../java/introduction/java-started.md)\n2. [Java开发环境搭建——概念说明](../java/introduction/java-environment.md)\n3. [Java开发环境搭建——Windows篇](../java/introduction/java-environment-windows.md)\n4. [Java开发环境搭建——Mac篇](../java/introduction/java-environment-mac.md)\n5. [Java 集成开发环境—IDEA安装](../java/introduction/java-ide.md)\n6. [Java开发简介](../java/introduction/java-introduction.md)\n7. [Java简单示例](../java/introduction/java-simple-example.md)\n8. [Java入门篇小结](../java/introduction/java-primer-conclusion.md)\n\n## Java 开发基础篇\n\n1. [Java开发基础篇](../java/basic/java-basic.md)\n2. [Java程序基本结构](../java/basic/java-simple-structure.md)\n3. [Java变量](../java/basic/java-variable.md)\n4. [Java中的类与对象](../java/basic/java-class.md)\n5. [package与import](../java/basic/java-package.md)\n6. Java中的注释\n7. 基本数据类型\n8. 运算符\n9. 字符串\n10. 输入与输出\n11. 流程控制\n12. 数组\n13. 类的组成\n14. 对象的创建与初始化\n15. 访问权限\n16. 类的封装\n17. 类的继承\n18. 类的多态\n19. Object类\n20. 枚举类\n21. 反射\n22. 接口\n23. 内部类\n24. 代理\n25. 异常\n26. 断言\n27. 日志\n28. 泛型\n29. 集合\n\n## Java 开发进阶篇\n\n1. Java开发进阶篇\n2. 线程\n3. 线程的生命周期\n4. 线程的同步\n5. 线程安全的集合\n6. 线程池\n7. 同步器\n8. JVM\n9. \n\n## Java集合框架\n\n[WeakHashMap源码详解](../java/collections/weakhashmap-code-detail.md)\n\n\n\n### Java核心技术  \n\n[强引用、软引用、弱引用和虚引用深入探讨](../java/reference/four-kinds-of-reference.md)\n\n\n\n### Java多线程  \n\n\n\n### Java工具类  \n\n\n## Java开发常见问题\n\n\n\n## Java Web 开发篇\n\n::: tip 说明\n本篇章内容主要介绍Java Web开发中经常使用到的技术和框架\n:::\n\n### Java EE  \n\n\n\n### Spring  \n\n\n\n### Spring Boot  \n\n\n\n### Spring  Security\n\n\n\n### Spring  Webflux\n\n\n\n### Mybatis  \n\n\n\n### Hibernate  \n\n\n\n### Spring  Data JPA\n\n\n\n## 架构篇 \n\n::: tip 说明\n本篇章内容主要介绍架构相关的内容\n:::\n\n### 领域驱动设计（Domain-Driven-Design） \n\n1. 初识领域驱动\n\n### 分布式架构 \n\n## 服务器 \n\n\n\n### Netty  \n\n\n\n### Tomcat  \n\n\n\n### Jetty \n\n\n\n### Nginx \n\n\n\n## RPC框架 \n\n\n\n### Dubbo  \n\n\n\n### Thrift  \n\n\n\n### GRPC  \n\n\n\n### SOFARPC  \n\n\n\n### Motan  \n\n\n\n### Ribbon  \n\n\n\n## 消息中间件\n\n\n\n### Kafka  \n\n\n\n### RocketMQ  \n\n\n\n### RabbitMQ  \n\n\n\n### ActiveMQ  \n\n\n\n## 分布式篇 \n\n\n\n### zookeeper  \n\n\n\n### 分布式缓存  \n\n\n\n### 一致性哈希  \n\n\n\n### MyCat  \n\n\n\n### Sharding JDBC  \n\n\n\n### Sharding Sphere  \n\n\n\n## 链路跟踪 \n\n\n\n### SkyWalking  \n\n\n\n### Zipkin  \n\n### Pinpoint\n\n### CAT\n\n## 配置中心\n\n### Apollo  \n\n### Disconf  \n\n### Spring Cloud Config\n\n## 作业调度\n\n### Elastic Job Lite  \n\n### Elastic Job Cloud  \n\n### Quartz  \n\n### XXL-Job  \n\n## 数据库篇\n\n### Redis  \n\n### Mysql  \n\n### MongoDB  \n\n### Memcached  \n\n### Neo4J  \n\n### TiDB  \n\n### HikariCP  \n\n### Druid  \n\n## 数据结构与算法\n\n### 数据结构  \n\n### 算法\n\n### Leecode\n\n## 微服务篇\n\n### Dubbo\n\n### Spring Cloud\n\n## Devops\n\n### Linux\n\n### Nginx\n\n### Docker\n\n### Swarm\n\n### kubernetes\n\n## 持续集成与部署\n\n### Jenkins\n\n### TeamCity\n\n### 自动化测试\n\n## ELK\n\n### Lucene\n\n### ElasticSearch\n\n### Logstash\n\n### Kibana\n\n### Solr\n\n## 数据可视化\n\n### python  \n\n### R\n\n## 大数据\n\n### Hadoop\n\n### HBase  \n\n### Hive  \n\n### Spark  \n\n## 流处理\n\n### Spark Streaming \n\n### Flink\n\n### Storming\n\n## 其它\n\n### UML\n\n<img src=\"8101.png\"/>\n\n想要一起学习交流的小伙伴欢迎加QQ群：529253292","source":"_posts/guide/background-skill.md","raw":"---\ntitle: Java 技术系列文章\ntags: \n - Java\n - 多线程\ncategories: 编程\ndate: 2017-12-29 19:55:51\n---\n\n## 前言\n\n本篇章内容主要介绍Java的各类技术，包括Java的基础部分，容器类，常用类的源码剖析，并发容器，多线程等等。\n\n## Java 开发入门篇\n\n1. [Java开发起航篇](../java/introduction/java-started.md)\n2. [Java开发环境搭建——概念说明](../java/introduction/java-environment.md)\n3. [Java开发环境搭建——Windows篇](../java/introduction/java-environment-windows.md)\n4. [Java开发环境搭建——Mac篇](../java/introduction/java-environment-mac.md)\n5. [Java 集成开发环境—IDEA安装](../java/introduction/java-ide.md)\n6. [Java开发简介](../java/introduction/java-introduction.md)\n7. [Java简单示例](../java/introduction/java-simple-example.md)\n8. [Java入门篇小结](../java/introduction/java-primer-conclusion.md)\n\n## Java 开发基础篇\n\n1. [Java开发基础篇](../java/basic/java-basic.md)\n2. [Java程序基本结构](../java/basic/java-simple-structure.md)\n3. [Java变量](../java/basic/java-variable.md)\n4. [Java中的类与对象](../java/basic/java-class.md)\n5. [package与import](../java/basic/java-package.md)\n6. Java中的注释\n7. 基本数据类型\n8. 运算符\n9. 字符串\n10. 输入与输出\n11. 流程控制\n12. 数组\n13. 类的组成\n14. 对象的创建与初始化\n15. 访问权限\n16. 类的封装\n17. 类的继承\n18. 类的多态\n19. Object类\n20. 枚举类\n21. 反射\n22. 接口\n23. 内部类\n24. 代理\n25. 异常\n26. 断言\n27. 日志\n28. 泛型\n29. 集合\n\n## Java 开发进阶篇\n\n1. Java开发进阶篇\n2. 线程\n3. 线程的生命周期\n4. 线程的同步\n5. 线程安全的集合\n6. 线程池\n7. 同步器\n8. JVM\n9. \n\n## Java集合框架\n\n[WeakHashMap源码详解](../java/collections/weakhashmap-code-detail.md)\n\n\n\n### Java核心技术  \n\n[强引用、软引用、弱引用和虚引用深入探讨](../java/reference/four-kinds-of-reference.md)\n\n\n\n### Java多线程  \n\n\n\n### Java工具类  \n\n\n## Java开发常见问题\n\n\n\n## Java Web 开发篇\n\n::: tip 说明\n本篇章内容主要介绍Java Web开发中经常使用到的技术和框架\n:::\n\n### Java EE  \n\n\n\n### Spring  \n\n\n\n### Spring Boot  \n\n\n\n### Spring  Security\n\n\n\n### Spring  Webflux\n\n\n\n### Mybatis  \n\n\n\n### Hibernate  \n\n\n\n### Spring  Data JPA\n\n\n\n## 架构篇 \n\n::: tip 说明\n本篇章内容主要介绍架构相关的内容\n:::\n\n### 领域驱动设计（Domain-Driven-Design） \n\n1. 初识领域驱动\n\n### 分布式架构 \n\n## 服务器 \n\n\n\n### Netty  \n\n\n\n### Tomcat  \n\n\n\n### Jetty \n\n\n\n### Nginx \n\n\n\n## RPC框架 \n\n\n\n### Dubbo  \n\n\n\n### Thrift  \n\n\n\n### GRPC  \n\n\n\n### SOFARPC  \n\n\n\n### Motan  \n\n\n\n### Ribbon  \n\n\n\n## 消息中间件\n\n\n\n### Kafka  \n\n\n\n### RocketMQ  \n\n\n\n### RabbitMQ  \n\n\n\n### ActiveMQ  \n\n\n\n## 分布式篇 \n\n\n\n### zookeeper  \n\n\n\n### 分布式缓存  \n\n\n\n### 一致性哈希  \n\n\n\n### MyCat  \n\n\n\n### Sharding JDBC  \n\n\n\n### Sharding Sphere  \n\n\n\n## 链路跟踪 \n\n\n\n### SkyWalking  \n\n\n\n### Zipkin  \n\n### Pinpoint\n\n### CAT\n\n## 配置中心\n\n### Apollo  \n\n### Disconf  \n\n### Spring Cloud Config\n\n## 作业调度\n\n### Elastic Job Lite  \n\n### Elastic Job Cloud  \n\n### Quartz  \n\n### XXL-Job  \n\n## 数据库篇\n\n### Redis  \n\n### Mysql  \n\n### MongoDB  \n\n### Memcached  \n\n### Neo4J  \n\n### TiDB  \n\n### HikariCP  \n\n### Druid  \n\n## 数据结构与算法\n\n### 数据结构  \n\n### 算法\n\n### Leecode\n\n## 微服务篇\n\n### Dubbo\n\n### Spring Cloud\n\n## Devops\n\n### Linux\n\n### Nginx\n\n### Docker\n\n### Swarm\n\n### kubernetes\n\n## 持续集成与部署\n\n### Jenkins\n\n### TeamCity\n\n### 自动化测试\n\n## ELK\n\n### Lucene\n\n### ElasticSearch\n\n### Logstash\n\n### Kibana\n\n### Solr\n\n## 数据可视化\n\n### python  \n\n### R\n\n## 大数据\n\n### Hadoop\n\n### HBase  \n\n### Hive  \n\n### Spark  \n\n## 流处理\n\n### Spark Streaming \n\n### Flink\n\n### Storming\n\n## 其它\n\n### UML\n\n<img src=\"8101.png\"/>\n\n想要一起学习交流的小伙伴欢迎加QQ群：529253292","slug":"guide/background-skill","published":1,"updated":"2019-06-04T01:29:57.094Z","_id":"cjxze3gkc00020cvw5rji4j8t","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本篇章内容主要介绍Java的各类技术，包括Java的基础部分，容器类，常用类的源码剖析，并发容器，多线程等等。</p>\n<h2 id=\"Java-开发入门篇\"><a href=\"#Java-开发入门篇\" class=\"headerlink\" title=\"Java 开发入门篇\"></a>Java 开发入门篇</h2><ol>\n<li><a href=\"../java/introduction/java-started.md\">Java开发起航篇</a></li>\n<li><a href=\"../java/introduction/java-environment.md\">Java开发环境搭建——概念说明</a></li>\n<li><a href=\"../java/introduction/java-environment-windows.md\">Java开发环境搭建——Windows篇</a></li>\n<li><a href=\"../java/introduction/java-environment-mac.md\">Java开发环境搭建——Mac篇</a></li>\n<li><a href=\"../java/introduction/java-ide.md\">Java 集成开发环境—IDEA安装</a></li>\n<li><a href=\"../java/introduction/java-introduction.md\">Java开发简介</a></li>\n<li><a href=\"../java/introduction/java-simple-example.md\">Java简单示例</a></li>\n<li><a href=\"../java/introduction/java-primer-conclusion.md\">Java入门篇小结</a></li>\n</ol>\n<h2 id=\"Java-开发基础篇\"><a href=\"#Java-开发基础篇\" class=\"headerlink\" title=\"Java 开发基础篇\"></a>Java 开发基础篇</h2><ol>\n<li><a href=\"../java/basic/java-basic.md\">Java开发基础篇</a></li>\n<li><a href=\"../java/basic/java-simple-structure.md\">Java程序基本结构</a></li>\n<li><a href=\"../java/basic/java-variable.md\">Java变量</a></li>\n<li><a href=\"../java/basic/java-class.md\">Java中的类与对象</a></li>\n<li><a href=\"../java/basic/java-package.md\">package与import</a></li>\n<li>Java中的注释</li>\n<li>基本数据类型</li>\n<li>运算符</li>\n<li>字符串</li>\n<li>输入与输出</li>\n<li>流程控制</li>\n<li>数组</li>\n<li>类的组成</li>\n<li>对象的创建与初始化</li>\n<li>访问权限</li>\n<li>类的封装</li>\n<li>类的继承</li>\n<li>类的多态</li>\n<li>Object类</li>\n<li>枚举类</li>\n<li>反射</li>\n<li>接口</li>\n<li>内部类</li>\n<li>代理</li>\n<li>异常</li>\n<li>断言</li>\n<li>日志</li>\n<li>泛型</li>\n<li>集合</li>\n</ol>\n<h2 id=\"Java-开发进阶篇\"><a href=\"#Java-开发进阶篇\" class=\"headerlink\" title=\"Java 开发进阶篇\"></a>Java 开发进阶篇</h2><ol>\n<li>Java开发进阶篇</li>\n<li>线程</li>\n<li>线程的生命周期</li>\n<li>线程的同步</li>\n<li>线程安全的集合</li>\n<li>线程池</li>\n<li>同步器</li>\n<li>JVM</li>\n<li></li>\n</ol>\n<h2 id=\"Java集合框架\"><a href=\"#Java集合框架\" class=\"headerlink\" title=\"Java集合框架\"></a>Java集合框架</h2><p><a href=\"../java/collections/weakhashmap-code-detail.md\">WeakHashMap源码详解</a></p>\n<h3 id=\"Java核心技术\"><a href=\"#Java核心技术\" class=\"headerlink\" title=\"Java核心技术\"></a>Java核心技术</h3><p><a href=\"../java/reference/four-kinds-of-reference.md\">强引用、软引用、弱引用和虚引用深入探讨</a></p>\n<h3 id=\"Java多线程\"><a href=\"#Java多线程\" class=\"headerlink\" title=\"Java多线程\"></a>Java多线程</h3><h3 id=\"Java工具类\"><a href=\"#Java工具类\" class=\"headerlink\" title=\"Java工具类\"></a>Java工具类</h3><h2 id=\"Java开发常见问题\"><a href=\"#Java开发常见问题\" class=\"headerlink\" title=\"Java开发常见问题\"></a>Java开发常见问题</h2><h2 id=\"Java-Web-开发篇\"><a href=\"#Java-Web-开发篇\" class=\"headerlink\" title=\"Java Web 开发篇\"></a>Java Web 开发篇</h2><p>::: tip 说明<br>本篇章内容主要介绍Java Web开发中经常使用到的技术和框架<br>:::</p>\n<h3 id=\"Java-EE\"><a href=\"#Java-EE\" class=\"headerlink\" title=\"Java EE\"></a>Java EE</h3><h3 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h3><h3 id=\"Spring-Boot\"><a href=\"#Spring-Boot\" class=\"headerlink\" title=\"Spring Boot\"></a>Spring Boot</h3><h3 id=\"Spring-Security\"><a href=\"#Spring-Security\" class=\"headerlink\" title=\"Spring  Security\"></a>Spring  Security</h3><h3 id=\"Spring-Webflux\"><a href=\"#Spring-Webflux\" class=\"headerlink\" title=\"Spring  Webflux\"></a>Spring  Webflux</h3><h3 id=\"Mybatis\"><a href=\"#Mybatis\" class=\"headerlink\" title=\"Mybatis\"></a>Mybatis</h3><h3 id=\"Hibernate\"><a href=\"#Hibernate\" class=\"headerlink\" title=\"Hibernate\"></a>Hibernate</h3><h3 id=\"Spring-Data-JPA\"><a href=\"#Spring-Data-JPA\" class=\"headerlink\" title=\"Spring  Data JPA\"></a>Spring  Data JPA</h3><h2 id=\"架构篇\"><a href=\"#架构篇\" class=\"headerlink\" title=\"架构篇\"></a>架构篇</h2><p>::: tip 说明<br>本篇章内容主要介绍架构相关的内容<br>:::</p>\n<h3 id=\"领域驱动设计（Domain-Driven-Design）\"><a href=\"#领域驱动设计（Domain-Driven-Design）\" class=\"headerlink\" title=\"领域驱动设计（Domain-Driven-Design）\"></a>领域驱动设计（Domain-Driven-Design）</h3><ol>\n<li>初识领域驱动</li>\n</ol>\n<h3 id=\"分布式架构\"><a href=\"#分布式架构\" class=\"headerlink\" title=\"分布式架构\"></a>分布式架构</h3><h2 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h2><h3 id=\"Netty\"><a href=\"#Netty\" class=\"headerlink\" title=\"Netty\"></a>Netty</h3><h3 id=\"Tomcat\"><a href=\"#Tomcat\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h3><h3 id=\"Jetty\"><a href=\"#Jetty\" class=\"headerlink\" title=\"Jetty\"></a>Jetty</h3><h3 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h3><h2 id=\"RPC框架\"><a href=\"#RPC框架\" class=\"headerlink\" title=\"RPC框架\"></a>RPC框架</h2><h3 id=\"Dubbo\"><a href=\"#Dubbo\" class=\"headerlink\" title=\"Dubbo\"></a>Dubbo</h3><h3 id=\"Thrift\"><a href=\"#Thrift\" class=\"headerlink\" title=\"Thrift\"></a>Thrift</h3><h3 id=\"GRPC\"><a href=\"#GRPC\" class=\"headerlink\" title=\"GRPC\"></a>GRPC</h3><h3 id=\"SOFARPC\"><a href=\"#SOFARPC\" class=\"headerlink\" title=\"SOFARPC\"></a>SOFARPC</h3><h3 id=\"Motan\"><a href=\"#Motan\" class=\"headerlink\" title=\"Motan\"></a>Motan</h3><h3 id=\"Ribbon\"><a href=\"#Ribbon\" class=\"headerlink\" title=\"Ribbon\"></a>Ribbon</h3><h2 id=\"消息中间件\"><a href=\"#消息中间件\" class=\"headerlink\" title=\"消息中间件\"></a>消息中间件</h2><h3 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h3><h3 id=\"RocketMQ\"><a href=\"#RocketMQ\" class=\"headerlink\" title=\"RocketMQ\"></a>RocketMQ</h3><h3 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h3><h3 id=\"ActiveMQ\"><a href=\"#ActiveMQ\" class=\"headerlink\" title=\"ActiveMQ\"></a>ActiveMQ</h3><h2 id=\"分布式篇\"><a href=\"#分布式篇\" class=\"headerlink\" title=\"分布式篇\"></a>分布式篇</h2><h3 id=\"zookeeper\"><a href=\"#zookeeper\" class=\"headerlink\" title=\"zookeeper\"></a>zookeeper</h3><h3 id=\"分布式缓存\"><a href=\"#分布式缓存\" class=\"headerlink\" title=\"分布式缓存\"></a>分布式缓存</h3><h3 id=\"一致性哈希\"><a href=\"#一致性哈希\" class=\"headerlink\" title=\"一致性哈希\"></a>一致性哈希</h3><h3 id=\"MyCat\"><a href=\"#MyCat\" class=\"headerlink\" title=\"MyCat\"></a>MyCat</h3><h3 id=\"Sharding-JDBC\"><a href=\"#Sharding-JDBC\" class=\"headerlink\" title=\"Sharding JDBC\"></a>Sharding JDBC</h3><h3 id=\"Sharding-Sphere\"><a href=\"#Sharding-Sphere\" class=\"headerlink\" title=\"Sharding Sphere\"></a>Sharding Sphere</h3><h2 id=\"链路跟踪\"><a href=\"#链路跟踪\" class=\"headerlink\" title=\"链路跟踪\"></a>链路跟踪</h2><h3 id=\"SkyWalking\"><a href=\"#SkyWalking\" class=\"headerlink\" title=\"SkyWalking\"></a>SkyWalking</h3><h3 id=\"Zipkin\"><a href=\"#Zipkin\" class=\"headerlink\" title=\"Zipkin\"></a>Zipkin</h3><h3 id=\"Pinpoint\"><a href=\"#Pinpoint\" class=\"headerlink\" title=\"Pinpoint\"></a>Pinpoint</h3><h3 id=\"CAT\"><a href=\"#CAT\" class=\"headerlink\" title=\"CAT\"></a>CAT</h3><h2 id=\"配置中心\"><a href=\"#配置中心\" class=\"headerlink\" title=\"配置中心\"></a>配置中心</h2><h3 id=\"Apollo\"><a href=\"#Apollo\" class=\"headerlink\" title=\"Apollo\"></a>Apollo</h3><h3 id=\"Disconf\"><a href=\"#Disconf\" class=\"headerlink\" title=\"Disconf\"></a>Disconf</h3><h3 id=\"Spring-Cloud-Config\"><a href=\"#Spring-Cloud-Config\" class=\"headerlink\" title=\"Spring Cloud Config\"></a>Spring Cloud Config</h3><h2 id=\"作业调度\"><a href=\"#作业调度\" class=\"headerlink\" title=\"作业调度\"></a>作业调度</h2><h3 id=\"Elastic-Job-Lite\"><a href=\"#Elastic-Job-Lite\" class=\"headerlink\" title=\"Elastic Job Lite\"></a>Elastic Job Lite</h3><h3 id=\"Elastic-Job-Cloud\"><a href=\"#Elastic-Job-Cloud\" class=\"headerlink\" title=\"Elastic Job Cloud\"></a>Elastic Job Cloud</h3><h3 id=\"Quartz\"><a href=\"#Quartz\" class=\"headerlink\" title=\"Quartz\"></a>Quartz</h3><h3 id=\"XXL-Job\"><a href=\"#XXL-Job\" class=\"headerlink\" title=\"XXL-Job\"></a>XXL-Job</h3><h2 id=\"数据库篇\"><a href=\"#数据库篇\" class=\"headerlink\" title=\"数据库篇\"></a>数据库篇</h2><h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><h3 id=\"Mysql\"><a href=\"#Mysql\" class=\"headerlink\" title=\"Mysql\"></a>Mysql</h3><h3 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h3><h3 id=\"Memcached\"><a href=\"#Memcached\" class=\"headerlink\" title=\"Memcached\"></a>Memcached</h3><h3 id=\"Neo4J\"><a href=\"#Neo4J\" class=\"headerlink\" title=\"Neo4J\"></a>Neo4J</h3><h3 id=\"TiDB\"><a href=\"#TiDB\" class=\"headerlink\" title=\"TiDB\"></a>TiDB</h3><h3 id=\"HikariCP\"><a href=\"#HikariCP\" class=\"headerlink\" title=\"HikariCP\"></a>HikariCP</h3><h3 id=\"Druid\"><a href=\"#Druid\" class=\"headerlink\" title=\"Druid\"></a>Druid</h3><h2 id=\"数据结构与算法\"><a href=\"#数据结构与算法\" class=\"headerlink\" title=\"数据结构与算法\"></a>数据结构与算法</h2><h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><h3 id=\"Leecode\"><a href=\"#Leecode\" class=\"headerlink\" title=\"Leecode\"></a>Leecode</h3><h2 id=\"微服务篇\"><a href=\"#微服务篇\" class=\"headerlink\" title=\"微服务篇\"></a>微服务篇</h2><h3 id=\"Dubbo-1\"><a href=\"#Dubbo-1\" class=\"headerlink\" title=\"Dubbo\"></a>Dubbo</h3><h3 id=\"Spring-Cloud\"><a href=\"#Spring-Cloud\" class=\"headerlink\" title=\"Spring Cloud\"></a>Spring Cloud</h3><h2 id=\"Devops\"><a href=\"#Devops\" class=\"headerlink\" title=\"Devops\"></a>Devops</h2><h3 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h3><h3 id=\"Nginx-1\"><a href=\"#Nginx-1\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h3><h3 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h3><h3 id=\"Swarm\"><a href=\"#Swarm\" class=\"headerlink\" title=\"Swarm\"></a>Swarm</h3><h3 id=\"kubernetes\"><a href=\"#kubernetes\" class=\"headerlink\" title=\"kubernetes\"></a>kubernetes</h3><h2 id=\"持续集成与部署\"><a href=\"#持续集成与部署\" class=\"headerlink\" title=\"持续集成与部署\"></a>持续集成与部署</h2><h3 id=\"Jenkins\"><a href=\"#Jenkins\" class=\"headerlink\" title=\"Jenkins\"></a>Jenkins</h3><h3 id=\"TeamCity\"><a href=\"#TeamCity\" class=\"headerlink\" title=\"TeamCity\"></a>TeamCity</h3><h3 id=\"自动化测试\"><a href=\"#自动化测试\" class=\"headerlink\" title=\"自动化测试\"></a>自动化测试</h3><h2 id=\"ELK\"><a href=\"#ELK\" class=\"headerlink\" title=\"ELK\"></a>ELK</h2><h3 id=\"Lucene\"><a href=\"#Lucene\" class=\"headerlink\" title=\"Lucene\"></a>Lucene</h3><h3 id=\"ElasticSearch\"><a href=\"#ElasticSearch\" class=\"headerlink\" title=\"ElasticSearch\"></a>ElasticSearch</h3><h3 id=\"Logstash\"><a href=\"#Logstash\" class=\"headerlink\" title=\"Logstash\"></a>Logstash</h3><h3 id=\"Kibana\"><a href=\"#Kibana\" class=\"headerlink\" title=\"Kibana\"></a>Kibana</h3><h3 id=\"Solr\"><a href=\"#Solr\" class=\"headerlink\" title=\"Solr\"></a>Solr</h3><h2 id=\"数据可视化\"><a href=\"#数据可视化\" class=\"headerlink\" title=\"数据可视化\"></a>数据可视化</h2><h3 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h3><h3 id=\"R\"><a href=\"#R\" class=\"headerlink\" title=\"R\"></a>R</h3><h2 id=\"大数据\"><a href=\"#大数据\" class=\"headerlink\" title=\"大数据\"></a>大数据</h2><h3 id=\"Hadoop\"><a href=\"#Hadoop\" class=\"headerlink\" title=\"Hadoop\"></a>Hadoop</h3><h3 id=\"HBase\"><a href=\"#HBase\" class=\"headerlink\" title=\"HBase\"></a>HBase</h3><h3 id=\"Hive\"><a href=\"#Hive\" class=\"headerlink\" title=\"Hive\"></a>Hive</h3><h3 id=\"Spark\"><a href=\"#Spark\" class=\"headerlink\" title=\"Spark\"></a>Spark</h3><h2 id=\"流处理\"><a href=\"#流处理\" class=\"headerlink\" title=\"流处理\"></a>流处理</h2><h3 id=\"Spark-Streaming\"><a href=\"#Spark-Streaming\" class=\"headerlink\" title=\"Spark Streaming\"></a>Spark Streaming</h3><h3 id=\"Flink\"><a href=\"#Flink\" class=\"headerlink\" title=\"Flink\"></a>Flink</h3><h3 id=\"Storming\"><a href=\"#Storming\" class=\"headerlink\" title=\"Storming\"></a>Storming</h3><h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><h3 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h3><p><img src=\"8101.png\"></p>\n<p>想要一起学习交流的小伙伴欢迎加QQ群：529253292</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本篇章内容主要介绍Java的各类技术，包括Java的基础部分，容器类，常用类的源码剖析，并发容器，多线程等等。</p>\n<h2 id=\"Java-开发入门篇\"><a href=\"#Java-开发入门篇\" class=\"headerlink\" title=\"Java 开发入门篇\"></a>Java 开发入门篇</h2><ol>\n<li><a href=\"../java/introduction/java-started.md\">Java开发起航篇</a></li>\n<li><a href=\"../java/introduction/java-environment.md\">Java开发环境搭建——概念说明</a></li>\n<li><a href=\"../java/introduction/java-environment-windows.md\">Java开发环境搭建——Windows篇</a></li>\n<li><a href=\"../java/introduction/java-environment-mac.md\">Java开发环境搭建——Mac篇</a></li>\n<li><a href=\"../java/introduction/java-ide.md\">Java 集成开发环境—IDEA安装</a></li>\n<li><a href=\"../java/introduction/java-introduction.md\">Java开发简介</a></li>\n<li><a href=\"../java/introduction/java-simple-example.md\">Java简单示例</a></li>\n<li><a href=\"../java/introduction/java-primer-conclusion.md\">Java入门篇小结</a></li>\n</ol>\n<h2 id=\"Java-开发基础篇\"><a href=\"#Java-开发基础篇\" class=\"headerlink\" title=\"Java 开发基础篇\"></a>Java 开发基础篇</h2><ol>\n<li><a href=\"../java/basic/java-basic.md\">Java开发基础篇</a></li>\n<li><a href=\"../java/basic/java-simple-structure.md\">Java程序基本结构</a></li>\n<li><a href=\"../java/basic/java-variable.md\">Java变量</a></li>\n<li><a href=\"../java/basic/java-class.md\">Java中的类与对象</a></li>\n<li><a href=\"../java/basic/java-package.md\">package与import</a></li>\n<li>Java中的注释</li>\n<li>基本数据类型</li>\n<li>运算符</li>\n<li>字符串</li>\n<li>输入与输出</li>\n<li>流程控制</li>\n<li>数组</li>\n<li>类的组成</li>\n<li>对象的创建与初始化</li>\n<li>访问权限</li>\n<li>类的封装</li>\n<li>类的继承</li>\n<li>类的多态</li>\n<li>Object类</li>\n<li>枚举类</li>\n<li>反射</li>\n<li>接口</li>\n<li>内部类</li>\n<li>代理</li>\n<li>异常</li>\n<li>断言</li>\n<li>日志</li>\n<li>泛型</li>\n<li>集合</li>\n</ol>\n<h2 id=\"Java-开发进阶篇\"><a href=\"#Java-开发进阶篇\" class=\"headerlink\" title=\"Java 开发进阶篇\"></a>Java 开发进阶篇</h2><ol>\n<li>Java开发进阶篇</li>\n<li>线程</li>\n<li>线程的生命周期</li>\n<li>线程的同步</li>\n<li>线程安全的集合</li>\n<li>线程池</li>\n<li>同步器</li>\n<li>JVM</li>\n<li></li>\n</ol>\n<h2 id=\"Java集合框架\"><a href=\"#Java集合框架\" class=\"headerlink\" title=\"Java集合框架\"></a>Java集合框架</h2><p><a href=\"../java/collections/weakhashmap-code-detail.md\">WeakHashMap源码详解</a></p>\n<h3 id=\"Java核心技术\"><a href=\"#Java核心技术\" class=\"headerlink\" title=\"Java核心技术\"></a>Java核心技术</h3><p><a href=\"../java/reference/four-kinds-of-reference.md\">强引用、软引用、弱引用和虚引用深入探讨</a></p>\n<h3 id=\"Java多线程\"><a href=\"#Java多线程\" class=\"headerlink\" title=\"Java多线程\"></a>Java多线程</h3><h3 id=\"Java工具类\"><a href=\"#Java工具类\" class=\"headerlink\" title=\"Java工具类\"></a>Java工具类</h3><h2 id=\"Java开发常见问题\"><a href=\"#Java开发常见问题\" class=\"headerlink\" title=\"Java开发常见问题\"></a>Java开发常见问题</h2><h2 id=\"Java-Web-开发篇\"><a href=\"#Java-Web-开发篇\" class=\"headerlink\" title=\"Java Web 开发篇\"></a>Java Web 开发篇</h2><p>::: tip 说明<br>本篇章内容主要介绍Java Web开发中经常使用到的技术和框架<br>:::</p>\n<h3 id=\"Java-EE\"><a href=\"#Java-EE\" class=\"headerlink\" title=\"Java EE\"></a>Java EE</h3><h3 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h3><h3 id=\"Spring-Boot\"><a href=\"#Spring-Boot\" class=\"headerlink\" title=\"Spring Boot\"></a>Spring Boot</h3><h3 id=\"Spring-Security\"><a href=\"#Spring-Security\" class=\"headerlink\" title=\"Spring  Security\"></a>Spring  Security</h3><h3 id=\"Spring-Webflux\"><a href=\"#Spring-Webflux\" class=\"headerlink\" title=\"Spring  Webflux\"></a>Spring  Webflux</h3><h3 id=\"Mybatis\"><a href=\"#Mybatis\" class=\"headerlink\" title=\"Mybatis\"></a>Mybatis</h3><h3 id=\"Hibernate\"><a href=\"#Hibernate\" class=\"headerlink\" title=\"Hibernate\"></a>Hibernate</h3><h3 id=\"Spring-Data-JPA\"><a href=\"#Spring-Data-JPA\" class=\"headerlink\" title=\"Spring  Data JPA\"></a>Spring  Data JPA</h3><h2 id=\"架构篇\"><a href=\"#架构篇\" class=\"headerlink\" title=\"架构篇\"></a>架构篇</h2><p>::: tip 说明<br>本篇章内容主要介绍架构相关的内容<br>:::</p>\n<h3 id=\"领域驱动设计（Domain-Driven-Design）\"><a href=\"#领域驱动设计（Domain-Driven-Design）\" class=\"headerlink\" title=\"领域驱动设计（Domain-Driven-Design）\"></a>领域驱动设计（Domain-Driven-Design）</h3><ol>\n<li>初识领域驱动</li>\n</ol>\n<h3 id=\"分布式架构\"><a href=\"#分布式架构\" class=\"headerlink\" title=\"分布式架构\"></a>分布式架构</h3><h2 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h2><h3 id=\"Netty\"><a href=\"#Netty\" class=\"headerlink\" title=\"Netty\"></a>Netty</h3><h3 id=\"Tomcat\"><a href=\"#Tomcat\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h3><h3 id=\"Jetty\"><a href=\"#Jetty\" class=\"headerlink\" title=\"Jetty\"></a>Jetty</h3><h3 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h3><h2 id=\"RPC框架\"><a href=\"#RPC框架\" class=\"headerlink\" title=\"RPC框架\"></a>RPC框架</h2><h3 id=\"Dubbo\"><a href=\"#Dubbo\" class=\"headerlink\" title=\"Dubbo\"></a>Dubbo</h3><h3 id=\"Thrift\"><a href=\"#Thrift\" class=\"headerlink\" title=\"Thrift\"></a>Thrift</h3><h3 id=\"GRPC\"><a href=\"#GRPC\" class=\"headerlink\" title=\"GRPC\"></a>GRPC</h3><h3 id=\"SOFARPC\"><a href=\"#SOFARPC\" class=\"headerlink\" title=\"SOFARPC\"></a>SOFARPC</h3><h3 id=\"Motan\"><a href=\"#Motan\" class=\"headerlink\" title=\"Motan\"></a>Motan</h3><h3 id=\"Ribbon\"><a href=\"#Ribbon\" class=\"headerlink\" title=\"Ribbon\"></a>Ribbon</h3><h2 id=\"消息中间件\"><a href=\"#消息中间件\" class=\"headerlink\" title=\"消息中间件\"></a>消息中间件</h2><h3 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h3><h3 id=\"RocketMQ\"><a href=\"#RocketMQ\" class=\"headerlink\" title=\"RocketMQ\"></a>RocketMQ</h3><h3 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h3><h3 id=\"ActiveMQ\"><a href=\"#ActiveMQ\" class=\"headerlink\" title=\"ActiveMQ\"></a>ActiveMQ</h3><h2 id=\"分布式篇\"><a href=\"#分布式篇\" class=\"headerlink\" title=\"分布式篇\"></a>分布式篇</h2><h3 id=\"zookeeper\"><a href=\"#zookeeper\" class=\"headerlink\" title=\"zookeeper\"></a>zookeeper</h3><h3 id=\"分布式缓存\"><a href=\"#分布式缓存\" class=\"headerlink\" title=\"分布式缓存\"></a>分布式缓存</h3><h3 id=\"一致性哈希\"><a href=\"#一致性哈希\" class=\"headerlink\" title=\"一致性哈希\"></a>一致性哈希</h3><h3 id=\"MyCat\"><a href=\"#MyCat\" class=\"headerlink\" title=\"MyCat\"></a>MyCat</h3><h3 id=\"Sharding-JDBC\"><a href=\"#Sharding-JDBC\" class=\"headerlink\" title=\"Sharding JDBC\"></a>Sharding JDBC</h3><h3 id=\"Sharding-Sphere\"><a href=\"#Sharding-Sphere\" class=\"headerlink\" title=\"Sharding Sphere\"></a>Sharding Sphere</h3><h2 id=\"链路跟踪\"><a href=\"#链路跟踪\" class=\"headerlink\" title=\"链路跟踪\"></a>链路跟踪</h2><h3 id=\"SkyWalking\"><a href=\"#SkyWalking\" class=\"headerlink\" title=\"SkyWalking\"></a>SkyWalking</h3><h3 id=\"Zipkin\"><a href=\"#Zipkin\" class=\"headerlink\" title=\"Zipkin\"></a>Zipkin</h3><h3 id=\"Pinpoint\"><a href=\"#Pinpoint\" class=\"headerlink\" title=\"Pinpoint\"></a>Pinpoint</h3><h3 id=\"CAT\"><a href=\"#CAT\" class=\"headerlink\" title=\"CAT\"></a>CAT</h3><h2 id=\"配置中心\"><a href=\"#配置中心\" class=\"headerlink\" title=\"配置中心\"></a>配置中心</h2><h3 id=\"Apollo\"><a href=\"#Apollo\" class=\"headerlink\" title=\"Apollo\"></a>Apollo</h3><h3 id=\"Disconf\"><a href=\"#Disconf\" class=\"headerlink\" title=\"Disconf\"></a>Disconf</h3><h3 id=\"Spring-Cloud-Config\"><a href=\"#Spring-Cloud-Config\" class=\"headerlink\" title=\"Spring Cloud Config\"></a>Spring Cloud Config</h3><h2 id=\"作业调度\"><a href=\"#作业调度\" class=\"headerlink\" title=\"作业调度\"></a>作业调度</h2><h3 id=\"Elastic-Job-Lite\"><a href=\"#Elastic-Job-Lite\" class=\"headerlink\" title=\"Elastic Job Lite\"></a>Elastic Job Lite</h3><h3 id=\"Elastic-Job-Cloud\"><a href=\"#Elastic-Job-Cloud\" class=\"headerlink\" title=\"Elastic Job Cloud\"></a>Elastic Job Cloud</h3><h3 id=\"Quartz\"><a href=\"#Quartz\" class=\"headerlink\" title=\"Quartz\"></a>Quartz</h3><h3 id=\"XXL-Job\"><a href=\"#XXL-Job\" class=\"headerlink\" title=\"XXL-Job\"></a>XXL-Job</h3><h2 id=\"数据库篇\"><a href=\"#数据库篇\" class=\"headerlink\" title=\"数据库篇\"></a>数据库篇</h2><h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><h3 id=\"Mysql\"><a href=\"#Mysql\" class=\"headerlink\" title=\"Mysql\"></a>Mysql</h3><h3 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h3><h3 id=\"Memcached\"><a href=\"#Memcached\" class=\"headerlink\" title=\"Memcached\"></a>Memcached</h3><h3 id=\"Neo4J\"><a href=\"#Neo4J\" class=\"headerlink\" title=\"Neo4J\"></a>Neo4J</h3><h3 id=\"TiDB\"><a href=\"#TiDB\" class=\"headerlink\" title=\"TiDB\"></a>TiDB</h3><h3 id=\"HikariCP\"><a href=\"#HikariCP\" class=\"headerlink\" title=\"HikariCP\"></a>HikariCP</h3><h3 id=\"Druid\"><a href=\"#Druid\" class=\"headerlink\" title=\"Druid\"></a>Druid</h3><h2 id=\"数据结构与算法\"><a href=\"#数据结构与算法\" class=\"headerlink\" title=\"数据结构与算法\"></a>数据结构与算法</h2><h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><h3 id=\"Leecode\"><a href=\"#Leecode\" class=\"headerlink\" title=\"Leecode\"></a>Leecode</h3><h2 id=\"微服务篇\"><a href=\"#微服务篇\" class=\"headerlink\" title=\"微服务篇\"></a>微服务篇</h2><h3 id=\"Dubbo-1\"><a href=\"#Dubbo-1\" class=\"headerlink\" title=\"Dubbo\"></a>Dubbo</h3><h3 id=\"Spring-Cloud\"><a href=\"#Spring-Cloud\" class=\"headerlink\" title=\"Spring Cloud\"></a>Spring Cloud</h3><h2 id=\"Devops\"><a href=\"#Devops\" class=\"headerlink\" title=\"Devops\"></a>Devops</h2><h3 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h3><h3 id=\"Nginx-1\"><a href=\"#Nginx-1\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h3><h3 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h3><h3 id=\"Swarm\"><a href=\"#Swarm\" class=\"headerlink\" title=\"Swarm\"></a>Swarm</h3><h3 id=\"kubernetes\"><a href=\"#kubernetes\" class=\"headerlink\" title=\"kubernetes\"></a>kubernetes</h3><h2 id=\"持续集成与部署\"><a href=\"#持续集成与部署\" class=\"headerlink\" title=\"持续集成与部署\"></a>持续集成与部署</h2><h3 id=\"Jenkins\"><a href=\"#Jenkins\" class=\"headerlink\" title=\"Jenkins\"></a>Jenkins</h3><h3 id=\"TeamCity\"><a href=\"#TeamCity\" class=\"headerlink\" title=\"TeamCity\"></a>TeamCity</h3><h3 id=\"自动化测试\"><a href=\"#自动化测试\" class=\"headerlink\" title=\"自动化测试\"></a>自动化测试</h3><h2 id=\"ELK\"><a href=\"#ELK\" class=\"headerlink\" title=\"ELK\"></a>ELK</h2><h3 id=\"Lucene\"><a href=\"#Lucene\" class=\"headerlink\" title=\"Lucene\"></a>Lucene</h3><h3 id=\"ElasticSearch\"><a href=\"#ElasticSearch\" class=\"headerlink\" title=\"ElasticSearch\"></a>ElasticSearch</h3><h3 id=\"Logstash\"><a href=\"#Logstash\" class=\"headerlink\" title=\"Logstash\"></a>Logstash</h3><h3 id=\"Kibana\"><a href=\"#Kibana\" class=\"headerlink\" title=\"Kibana\"></a>Kibana</h3><h3 id=\"Solr\"><a href=\"#Solr\" class=\"headerlink\" title=\"Solr\"></a>Solr</h3><h2 id=\"数据可视化\"><a href=\"#数据可视化\" class=\"headerlink\" title=\"数据可视化\"></a>数据可视化</h2><h3 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h3><h3 id=\"R\"><a href=\"#R\" class=\"headerlink\" title=\"R\"></a>R</h3><h2 id=\"大数据\"><a href=\"#大数据\" class=\"headerlink\" title=\"大数据\"></a>大数据</h2><h3 id=\"Hadoop\"><a href=\"#Hadoop\" class=\"headerlink\" title=\"Hadoop\"></a>Hadoop</h3><h3 id=\"HBase\"><a href=\"#HBase\" class=\"headerlink\" title=\"HBase\"></a>HBase</h3><h3 id=\"Hive\"><a href=\"#Hive\" class=\"headerlink\" title=\"Hive\"></a>Hive</h3><h3 id=\"Spark\"><a href=\"#Spark\" class=\"headerlink\" title=\"Spark\"></a>Spark</h3><h2 id=\"流处理\"><a href=\"#流处理\" class=\"headerlink\" title=\"流处理\"></a>流处理</h2><h3 id=\"Spark-Streaming\"><a href=\"#Spark-Streaming\" class=\"headerlink\" title=\"Spark Streaming\"></a>Spark Streaming</h3><h3 id=\"Flink\"><a href=\"#Flink\" class=\"headerlink\" title=\"Flink\"></a>Flink</h3><h3 id=\"Storming\"><a href=\"#Storming\" class=\"headerlink\" title=\"Storming\"></a>Storming</h3><h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><h3 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h3><p><img src=\"8101.png\"></p>\n<p>想要一起学习交流的小伙伴欢迎加QQ群：529253292</p>\n"},{"title":"Java核心技术","date":"2018-12-29T12:20:51.000Z","_content":"\n> 不忘初心，方得始终。\n\n## 说明\n\n本篇章内容主要介绍与Java相关的基础内容，包括Java的入门、基础部分，Java中的容器类，常用类的源码剖析，nio，并发容器，多线程等等。\n\n<LabelBlock>Java 开发入门篇  </LabelBlock>\n\n1. [Java开发起航篇](../java/introduction/java-started.md)\n2. [Java开发环境搭建——概念说明](../java/introduction/java-environment.md)\n3. [Java开发环境搭建——Windows篇](../java/introduction/java-environment-windows.md)\n4. [Java开发环境搭建——Mac篇](../java/introduction/java-environment-mac.md)\n5. [Java 集成开发环境—IDEA安装](../java/introduction/java-ide.md)\n6. [Java开发简介](../java/introduction/java-introduction.md)\n7. [Java简单示例](../java/introduction/java-simple-example.md)\n8. [Java中的package与import](../java/introduction/java-package.md)\n9. [Java入门篇小结](../java/introduction/java-primer-conclusion.md)\n\n<LabelBlock>Java 开发基础篇  </LabelBlock>\n\n1. [Java开发基础篇](../java/basic/java-basic.md)\n2. [Java程序基本结构](../java/basic/java-simple-structure.md)\n3. [Java变量](../java/basic/java-variable.md)\n4. [Java中的类与对象](../java/basic/java-class.md)\n5. Java中的注释\n6. 基本数据类型\n7. 运算符\n8. 字符串\n9. 输入与输出\n10. 流程控制\n11. 数组\n12. 类的组成\n13. 对象的创建与初始化\n14. 访问权限\n15. 类的封装\n16. 类的继承\n17. 类的多态\n18. Object类\n19. 枚举类\n20. 反射\n21. 接口\n22. 内部类\n23. 代理\n24. 异常\n25. 断言\n26. 日志\n27. 泛型\n28. 集合\n\n<LabelBlock>Java 开发进阶篇  </LabelBlock>\n\n1. Java开发进阶篇\n2. 线程\n3. 线程的生命周期\n4. 线程的同步\n5. 线程安全的集合\n6. 线程池\n7. 同步器\n8. JVM\n9. \n\n<LabelBlock>Java集合框架  </LabelBlock>\n\n[WeakHashMap源码详解](../java/collections/weakhashmap-code-detail.md)\n\n<LabelBlock>Java引用类型  </LabelBlock>\n\n1. [强引用、软引用、弱引用和虚引用深入探讨](../java/reference/four-kinds-of-reference.md)\n2. [强引用](../java/reference/strong-reference.md)\n3. [软引用](../java/reference/soft-reference.md)\n4. [弱引用](../java/reference/weak-reference.md)\n5. [虚引用](../java/reference/phantom-reference.md)\n6. [Reference源码详解](../java/reference/reference-code-detail.md)\n7. [ReferenceQueue源码详解](../java/reference/reference-queue-code-detail.md)\n8. [SoftReference源码详解](../java/reference/soft-reference-code-detail.md)\n9. [WeakReference源码详解](../java/reference/weak-reference-code-detail.md)\n10. [PhantomReference源码详解](../java/reference/phantom-reference-code-detail.md)\n11. [FinalReference 与 Finalizer 详解](../java/reference/final-reference-code-detail.md)\n12. [四种引用类型总结](../java/reference/reference-summary.md)\n","source":"_posts/java/README.md","raw":"---\ntitle: Java核心技术\ntags: \n - Java\ncategories: 编程\ndate: 2018-12-29 20:20:51\n---\n\n> 不忘初心，方得始终。\n\n## 说明\n\n本篇章内容主要介绍与Java相关的基础内容，包括Java的入门、基础部分，Java中的容器类，常用类的源码剖析，nio，并发容器，多线程等等。\n\n<LabelBlock>Java 开发入门篇  </LabelBlock>\n\n1. [Java开发起航篇](../java/introduction/java-started.md)\n2. [Java开发环境搭建——概念说明](../java/introduction/java-environment.md)\n3. [Java开发环境搭建——Windows篇](../java/introduction/java-environment-windows.md)\n4. [Java开发环境搭建——Mac篇](../java/introduction/java-environment-mac.md)\n5. [Java 集成开发环境—IDEA安装](../java/introduction/java-ide.md)\n6. [Java开发简介](../java/introduction/java-introduction.md)\n7. [Java简单示例](../java/introduction/java-simple-example.md)\n8. [Java中的package与import](../java/introduction/java-package.md)\n9. [Java入门篇小结](../java/introduction/java-primer-conclusion.md)\n\n<LabelBlock>Java 开发基础篇  </LabelBlock>\n\n1. [Java开发基础篇](../java/basic/java-basic.md)\n2. [Java程序基本结构](../java/basic/java-simple-structure.md)\n3. [Java变量](../java/basic/java-variable.md)\n4. [Java中的类与对象](../java/basic/java-class.md)\n5. Java中的注释\n6. 基本数据类型\n7. 运算符\n8. 字符串\n9. 输入与输出\n10. 流程控制\n11. 数组\n12. 类的组成\n13. 对象的创建与初始化\n14. 访问权限\n15. 类的封装\n16. 类的继承\n17. 类的多态\n18. Object类\n19. 枚举类\n20. 反射\n21. 接口\n22. 内部类\n23. 代理\n24. 异常\n25. 断言\n26. 日志\n27. 泛型\n28. 集合\n\n<LabelBlock>Java 开发进阶篇  </LabelBlock>\n\n1. Java开发进阶篇\n2. 线程\n3. 线程的生命周期\n4. 线程的同步\n5. 线程安全的集合\n6. 线程池\n7. 同步器\n8. JVM\n9. \n\n<LabelBlock>Java集合框架  </LabelBlock>\n\n[WeakHashMap源码详解](../java/collections/weakhashmap-code-detail.md)\n\n<LabelBlock>Java引用类型  </LabelBlock>\n\n1. [强引用、软引用、弱引用和虚引用深入探讨](../java/reference/four-kinds-of-reference.md)\n2. [强引用](../java/reference/strong-reference.md)\n3. [软引用](../java/reference/soft-reference.md)\n4. [弱引用](../java/reference/weak-reference.md)\n5. [虚引用](../java/reference/phantom-reference.md)\n6. [Reference源码详解](../java/reference/reference-code-detail.md)\n7. [ReferenceQueue源码详解](../java/reference/reference-queue-code-detail.md)\n8. [SoftReference源码详解](../java/reference/soft-reference-code-detail.md)\n9. [WeakReference源码详解](../java/reference/weak-reference-code-detail.md)\n10. [PhantomReference源码详解](../java/reference/phantom-reference-code-detail.md)\n11. [FinalReference 与 Finalizer 详解](../java/reference/final-reference-code-detail.md)\n12. [四种引用类型总结](../java/reference/reference-summary.md)\n","slug":"java/README","published":1,"updated":"2019-06-04T01:29:57.094Z","_id":"cjxze3gkw00090cvwyi34fcxb","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>不忘初心，方得始终。</p>\n</blockquote>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>本篇章内容主要介绍与Java相关的基础内容，包括Java的入门、基础部分，Java中的容器类，常用类的源码剖析，nio，并发容器，多线程等等。</p>\n<labelblock>Java 开发入门篇  </labelblock>\n\n<ol>\n<li><a href=\"../java/introduction/java-started.md\">Java开发起航篇</a></li>\n<li><a href=\"../java/introduction/java-environment.md\">Java开发环境搭建——概念说明</a></li>\n<li><a href=\"../java/introduction/java-environment-windows.md\">Java开发环境搭建——Windows篇</a></li>\n<li><a href=\"../java/introduction/java-environment-mac.md\">Java开发环境搭建——Mac篇</a></li>\n<li><a href=\"../java/introduction/java-ide.md\">Java 集成开发环境—IDEA安装</a></li>\n<li><a href=\"../java/introduction/java-introduction.md\">Java开发简介</a></li>\n<li><a href=\"../java/introduction/java-simple-example.md\">Java简单示例</a></li>\n<li><a href=\"../java/introduction/java-package.md\">Java中的package与import</a></li>\n<li><a href=\"../java/introduction/java-primer-conclusion.md\">Java入门篇小结</a></li>\n</ol>\n<labelblock>Java 开发基础篇  </labelblock>\n\n<ol>\n<li><a href=\"../java/basic/java-basic.md\">Java开发基础篇</a></li>\n<li><a href=\"../java/basic/java-simple-structure.md\">Java程序基本结构</a></li>\n<li><a href=\"../java/basic/java-variable.md\">Java变量</a></li>\n<li><a href=\"../java/basic/java-class.md\">Java中的类与对象</a></li>\n<li>Java中的注释</li>\n<li>基本数据类型</li>\n<li>运算符</li>\n<li>字符串</li>\n<li>输入与输出</li>\n<li>流程控制</li>\n<li>数组</li>\n<li>类的组成</li>\n<li>对象的创建与初始化</li>\n<li>访问权限</li>\n<li>类的封装</li>\n<li>类的继承</li>\n<li>类的多态</li>\n<li>Object类</li>\n<li>枚举类</li>\n<li>反射</li>\n<li>接口</li>\n<li>内部类</li>\n<li>代理</li>\n<li>异常</li>\n<li>断言</li>\n<li>日志</li>\n<li>泛型</li>\n<li>集合</li>\n</ol>\n<labelblock>Java 开发进阶篇  </labelblock>\n\n<ol>\n<li>Java开发进阶篇</li>\n<li>线程</li>\n<li>线程的生命周期</li>\n<li>线程的同步</li>\n<li>线程安全的集合</li>\n<li>线程池</li>\n<li>同步器</li>\n<li>JVM</li>\n<li></li>\n</ol>\n<labelblock>Java集合框架  </labelblock>\n\n<p><a href=\"../java/collections/weakhashmap-code-detail.md\">WeakHashMap源码详解</a></p>\n<labelblock>Java引用类型  </labelblock>\n\n<ol>\n<li><a href=\"../java/reference/four-kinds-of-reference.md\">强引用、软引用、弱引用和虚引用深入探讨</a></li>\n<li><a href=\"../java/reference/strong-reference.md\">强引用</a></li>\n<li><a href=\"../java/reference/soft-reference.md\">软引用</a></li>\n<li><a href=\"../java/reference/weak-reference.md\">弱引用</a></li>\n<li><a href=\"../java/reference/phantom-reference.md\">虚引用</a></li>\n<li><a href=\"../java/reference/reference-code-detail.md\">Reference源码详解</a></li>\n<li><a href=\"../java/reference/reference-queue-code-detail.md\">ReferenceQueue源码详解</a></li>\n<li><a href=\"../java/reference/soft-reference-code-detail.md\">SoftReference源码详解</a></li>\n<li><a href=\"../java/reference/weak-reference-code-detail.md\">WeakReference源码详解</a></li>\n<li><a href=\"../java/reference/phantom-reference-code-detail.md\">PhantomReference源码详解</a></li>\n<li><a href=\"../java/reference/final-reference-code-detail.md\">FinalReference 与 Finalizer 详解</a></li>\n<li><a href=\"../java/reference/reference-summary.md\">四种引用类型总结</a></li>\n</ol>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<blockquote>\n<p>不忘初心，方得始终。</p>\n</blockquote>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>本篇章内容主要介绍与Java相关的基础内容，包括Java的入门、基础部分，Java中的容器类，常用类的源码剖析，nio，并发容器，多线程等等。</p>\n<labelblock>Java 开发入门篇  </labelblock>\n\n<ol>\n<li><a href=\"../java/introduction/java-started.md\">Java开发起航篇</a></li>\n<li><a href=\"../java/introduction/java-environment.md\">Java开发环境搭建——概念说明</a></li>\n<li><a href=\"../java/introduction/java-environment-windows.md\">Java开发环境搭建——Windows篇</a></li>\n<li><a href=\"../java/introduction/java-environment-mac.md\">Java开发环境搭建——Mac篇</a></li>\n<li><a href=\"../java/introduction/java-ide.md\">Java 集成开发环境—IDEA安装</a></li>\n<li><a href=\"../java/introduction/java-introduction.md\">Java开发简介</a></li>\n<li><a href=\"../java/introduction/java-simple-example.md\">Java简单示例</a></li>\n<li><a href=\"../java/introduction/java-package.md\">Java中的package与import</a></li>\n<li><a href=\"../java/introduction/java-primer-conclusion.md\">Java入门篇小结</a></li>\n</ol>\n<labelblock>Java 开发基础篇  </labelblock>\n\n<ol>\n<li><a href=\"../java/basic/java-basic.md\">Java开发基础篇</a></li>\n<li><a href=\"../java/basic/java-simple-structure.md\">Java程序基本结构</a></li>\n<li><a href=\"../java/basic/java-variable.md\">Java变量</a></li>\n<li><a href=\"../java/basic/java-class.md\">Java中的类与对象</a></li>\n<li>Java中的注释</li>\n<li>基本数据类型</li>\n<li>运算符</li>\n<li>字符串</li>\n<li>输入与输出</li>\n<li>流程控制</li>\n<li>数组</li>\n<li>类的组成</li>\n<li>对象的创建与初始化</li>\n<li>访问权限</li>\n<li>类的封装</li>\n<li>类的继承</li>\n<li>类的多态</li>\n<li>Object类</li>\n<li>枚举类</li>\n<li>反射</li>\n<li>接口</li>\n<li>内部类</li>\n<li>代理</li>\n<li>异常</li>\n<li>断言</li>\n<li>日志</li>\n<li>泛型</li>\n<li>集合</li>\n</ol>\n<labelblock>Java 开发进阶篇  </labelblock>\n\n<ol>\n<li>Java开发进阶篇</li>\n<li>线程</li>\n<li>线程的生命周期</li>\n<li>线程的同步</li>\n<li>线程安全的集合</li>\n<li>线程池</li>\n<li>同步器</li>\n<li>JVM</li>\n<li></li>\n</ol>\n<labelblock>Java集合框架  </labelblock>\n\n<p><a href=\"../java/collections/weakhashmap-code-detail.md\">WeakHashMap源码详解</a></p>\n<labelblock>Java引用类型  </labelblock>\n\n<ol>\n<li><a href=\"../java/reference/four-kinds-of-reference.md\">强引用、软引用、弱引用和虚引用深入探讨</a></li>\n<li><a href=\"../java/reference/strong-reference.md\">强引用</a></li>\n<li><a href=\"../java/reference/soft-reference.md\">软引用</a></li>\n<li><a href=\"../java/reference/weak-reference.md\">弱引用</a></li>\n<li><a href=\"../java/reference/phantom-reference.md\">虚引用</a></li>\n<li><a href=\"../java/reference/reference-code-detail.md\">Reference源码详解</a></li>\n<li><a href=\"../java/reference/reference-queue-code-detail.md\">ReferenceQueue源码详解</a></li>\n<li><a href=\"../java/reference/soft-reference-code-detail.md\">SoftReference源码详解</a></li>\n<li><a href=\"../java/reference/weak-reference-code-detail.md\">WeakReference源码详解</a></li>\n<li><a href=\"../java/reference/phantom-reference-code-detail.md\">PhantomReference源码详解</a></li>\n<li><a href=\"../java/reference/final-reference-code-detail.md\">FinalReference 与 Finalizer 详解</a></li>\n<li><a href=\"../java/reference/reference-summary.md\">四种引用类型总结</a></li>\n</ol>\n"},{"title":"【LeetCode】两数之和","date":"2019-01-04T17:00:00.000Z","_content":"\n## 题目说明\n\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n示例:\n\n```bash\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n```\n\n## 解题思路1：穷举法\n\n从题目意思理解，就是从给定的整数数组中找到两个整数，使得它们的和与给定的数相等。那最简单粗暴的方式就是枚举了，嗯，先来试试最简单的。\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        return exhaustAlgorithm(nums,target);\n    }\n    // 穷举法\n    private int[] exhaustAlgorithm(int[] nums, int target){\n        int length = nums.length;\n        int i = 0;\n        int j = 1;\n        while (nums[i] + nums[j] != target) {\n            j++;\n            if (j >= length){\n                i++;\n                if (i >= length - 1){\n                    break;\n                }\n                j = i + 1;\n            }\n        }\n        // 说明不存在这样的组合\n        if (nums[i] + nums[j] != target) return null;\n        int[] result = {i,j};\n        return result;\n    }\n}\n```\n\n时间复杂度：$O(n^2)$\n\n运行结果如下：\n\n{% asset_img exhaust-algorithm.png exhaust-algorithm %}\n\n80ms，才击败了11.13%的用户，说明优化空间还很大。\n\n## 解题思路2：倒推法\n\n穷举法的效率一般都比较差，所以需要尝试一些新姿势。我们再来分析一下上面的穷举算法，要从一个集合中找出两个数，使得它们的和与给出的数`target`相等，使用穷举算法时，当我们选出第一个数`a`后，需要循环遍历之后的数，然后一一进行加和判断，但实际上，我们只需要知道剩下的数里，有没有数等于`target - a`即可，而每次从数组中找到某个数是否存在，都需要遍历一次，因此，更好的做法是将数与对应的序号存到一个map中，这样就能将查找效率从$O(n)$提高到$O(1)$。\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        return mapSolution(nums,target);\n    }\n    // 倒推法\n    private int[] mapSolution(int[] nums, int target){\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++){\n            map.put(nums[i],i);\n        }\n\n        for (int i = 0; i < nums.length; i++){\n            int num = target - nums[i];\n            // 判断num是否存在，如果已经存在，则直接返回\n            if (map.get(num) != null){\n                return new int[] { map.get(num), i};\n            }\n        }\n        return null;\n    }\n}\n```\n\n这里我们对nums数组进行了两次遍历，第一次遍历是将所有元素都存入map中，第二次遍历是查找目标的整数对是否存在。\n\n但再仔细想想，是否还能再优化呢？\n\n答案是肯定的，在这个题中，要寻找的整数是成对存在的，所以我们可以只进行一次遍历。\n\n如果`target`减去当前遍历数值后的数不存在于`map`中，则将当前数值与序号的映射关系存入`map`中。也许你会问，那找到第一个要寻找的数时，第二个数显然还不在`map`中，那怎么办呢？别着急，前面已经说过了，因为要寻找的数是成对存在的，这里我们假设为`a`和`b`，所以遇到第一个数`a`时，由于`b`还没有存入`map`，所以先将`a`存入`map`中，我们在找到第二个数`b`后，此时`a`已经在`map`中了，所以就能在一次遍历中顺利找到了这对我们想要的整数了。\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        return mapSolution(nums,target);\n    }\n    // 倒推法\n    private int[] mapSolution(int[] nums, int target){\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++){\n            int num = target - nums[i];\n            // 判断num是否存在，如果已经存在，则直接返回\n            if (map.get(num) != null){\n                return new int[] { map.get(num), i};\n            }\n            // 不存在则当前数值与序号的映射关系存入map中\n            map.put(nums[i], i);\n        }\n        return null;\n    }\n}\n```\n\n时间复杂度：$O(n)$\n\n空间复杂度：$O(n)$\n\n运行结果如下：\n\n{% asset_img map-solution.png map-solution %}\n\n一下降到了9ms，效率大大提升，击败85%的用户，嗯，看来效果确实很显著。\n\n[本题中文链接](https://leetcode-cn.com/problems/two-sum/solution/)\n\n[本题英文链接](https://leetcode.com/problems/two-sum/solution/)\n\n如果你有更好的想法，也欢迎留言交流讨论~","source":"_posts/leetcode/day1-two-sum.md","raw":"---\ntitle: 【LeetCode】两数之和\ntags: \n - Java\n - 算法\n - LeetCode\ncategories: 编程\ndate: 2019-01-05 01:00:00\n---\n\n## 题目说明\n\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n示例:\n\n```bash\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n```\n\n## 解题思路1：穷举法\n\n从题目意思理解，就是从给定的整数数组中找到两个整数，使得它们的和与给定的数相等。那最简单粗暴的方式就是枚举了，嗯，先来试试最简单的。\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        return exhaustAlgorithm(nums,target);\n    }\n    // 穷举法\n    private int[] exhaustAlgorithm(int[] nums, int target){\n        int length = nums.length;\n        int i = 0;\n        int j = 1;\n        while (nums[i] + nums[j] != target) {\n            j++;\n            if (j >= length){\n                i++;\n                if (i >= length - 1){\n                    break;\n                }\n                j = i + 1;\n            }\n        }\n        // 说明不存在这样的组合\n        if (nums[i] + nums[j] != target) return null;\n        int[] result = {i,j};\n        return result;\n    }\n}\n```\n\n时间复杂度：$O(n^2)$\n\n运行结果如下：\n\n{% asset_img exhaust-algorithm.png exhaust-algorithm %}\n\n80ms，才击败了11.13%的用户，说明优化空间还很大。\n\n## 解题思路2：倒推法\n\n穷举法的效率一般都比较差，所以需要尝试一些新姿势。我们再来分析一下上面的穷举算法，要从一个集合中找出两个数，使得它们的和与给出的数`target`相等，使用穷举算法时，当我们选出第一个数`a`后，需要循环遍历之后的数，然后一一进行加和判断，但实际上，我们只需要知道剩下的数里，有没有数等于`target - a`即可，而每次从数组中找到某个数是否存在，都需要遍历一次，因此，更好的做法是将数与对应的序号存到一个map中，这样就能将查找效率从$O(n)$提高到$O(1)$。\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        return mapSolution(nums,target);\n    }\n    // 倒推法\n    private int[] mapSolution(int[] nums, int target){\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++){\n            map.put(nums[i],i);\n        }\n\n        for (int i = 0; i < nums.length; i++){\n            int num = target - nums[i];\n            // 判断num是否存在，如果已经存在，则直接返回\n            if (map.get(num) != null){\n                return new int[] { map.get(num), i};\n            }\n        }\n        return null;\n    }\n}\n```\n\n这里我们对nums数组进行了两次遍历，第一次遍历是将所有元素都存入map中，第二次遍历是查找目标的整数对是否存在。\n\n但再仔细想想，是否还能再优化呢？\n\n答案是肯定的，在这个题中，要寻找的整数是成对存在的，所以我们可以只进行一次遍历。\n\n如果`target`减去当前遍历数值后的数不存在于`map`中，则将当前数值与序号的映射关系存入`map`中。也许你会问，那找到第一个要寻找的数时，第二个数显然还不在`map`中，那怎么办呢？别着急，前面已经说过了，因为要寻找的数是成对存在的，这里我们假设为`a`和`b`，所以遇到第一个数`a`时，由于`b`还没有存入`map`，所以先将`a`存入`map`中，我们在找到第二个数`b`后，此时`a`已经在`map`中了，所以就能在一次遍历中顺利找到了这对我们想要的整数了。\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        return mapSolution(nums,target);\n    }\n    // 倒推法\n    private int[] mapSolution(int[] nums, int target){\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++){\n            int num = target - nums[i];\n            // 判断num是否存在，如果已经存在，则直接返回\n            if (map.get(num) != null){\n                return new int[] { map.get(num), i};\n            }\n            // 不存在则当前数值与序号的映射关系存入map中\n            map.put(nums[i], i);\n        }\n        return null;\n    }\n}\n```\n\n时间复杂度：$O(n)$\n\n空间复杂度：$O(n)$\n\n运行结果如下：\n\n{% asset_img map-solution.png map-solution %}\n\n一下降到了9ms，效率大大提升，击败85%的用户，嗯，看来效果确实很显著。\n\n[本题中文链接](https://leetcode-cn.com/problems/two-sum/solution/)\n\n[本题英文链接](https://leetcode.com/problems/two-sum/solution/)\n\n如果你有更好的想法，也欢迎留言交流讨论~","slug":"leetcode/day1-two-sum","published":1,"updated":"2019-06-04T01:29:57.428Z","_id":"cjxze3gkw000a0cvw568fw4pv","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"题目说明\"><a href=\"#题目说明\" class=\"headerlink\" title=\"题目说明\"></a>题目说明</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>\n<p>示例:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class=\"line\"></span><br><span class=\"line\">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class=\"line\">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>\n<h2 id=\"解题思路1：穷举法\"><a href=\"#解题思路1：穷举法\" class=\"headerlink\" title=\"解题思路1：穷举法\"></a>解题思路1：穷举法</h2><p>从题目意思理解，就是从给定的整数数组中找到两个整数，使得它们的和与给定的数相等。那最简单粗暴的方式就是枚举了，嗯，先来试试最简单的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> exhaustAlgorithm(nums,target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 穷举法</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] exhaustAlgorithm(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (nums[i] + nums[j] != target) &#123;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j &gt;= length)&#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &gt;= length - <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                j = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 说明不存在这样的组合</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] + nums[j] != target) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] result = &#123;i,j&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度：$O(n^2)$</p>\n<p>运行结果如下：</p>\n<img src=\"/programming/leetcode/day1-two-sum/exhaust-algorithm.png\" title=\"exhaust-algorithm\">\n<p>80ms，才击败了11.13%的用户，说明优化空间还很大。</p>\n<h2 id=\"解题思路2：倒推法\"><a href=\"#解题思路2：倒推法\" class=\"headerlink\" title=\"解题思路2：倒推法\"></a>解题思路2：倒推法</h2><p>穷举法的效率一般都比较差，所以需要尝试一些新姿势。我们再来分析一下上面的穷举算法，要从一个集合中找出两个数，使得它们的和与给出的数<code>target</code>相等，使用穷举算法时，当我们选出第一个数<code>a</code>后，需要循环遍历之后的数，然后一一进行加和判断，但实际上，我们只需要知道剩下的数里，有没有数等于<code>target - a</code>即可，而每次从数组中找到某个数是否存在，都需要遍历一次，因此，更好的做法是将数与对应的序号存到一个map中，这样就能将查找效率从$O(n)$提高到$O(1)$。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mapSolution(nums,target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 倒推法</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] mapSolution(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)&#123;</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\">            map.put(nums[i],i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> num = target - nums[i];</span><br><span class=\"line\">            <span class=\"comment\">// 判断num是否存在，如果已经存在，则直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.get(num) != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123; map.get(num), i&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们对nums数组进行了两次遍历，第一次遍历是将所有元素都存入map中，第二次遍历是查找目标的整数对是否存在。</p>\n<p>但再仔细想想，是否还能再优化呢？</p>\n<p>答案是肯定的，在这个题中，要寻找的整数是成对存在的，所以我们可以只进行一次遍历。</p>\n<p>如果<code>target</code>减去当前遍历数值后的数不存在于<code>map</code>中，则将当前数值与序号的映射关系存入<code>map</code>中。也许你会问，那找到第一个要寻找的数时，第二个数显然还不在<code>map</code>中，那怎么办呢？别着急，前面已经说过了，因为要寻找的数是成对存在的，这里我们假设为<code>a</code>和<code>b</code>，所以遇到第一个数<code>a</code>时，由于<code>b</code>还没有存入<code>map</code>，所以先将<code>a</code>存入<code>map</code>中，我们在找到第二个数<code>b</code>后，此时<code>a</code>已经在<code>map</code>中了，所以就能在一次遍历中顺利找到了这对我们想要的整数了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mapSolution(nums,target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 倒推法</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] mapSolution(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)&#123;</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> num = target - nums[i];</span><br><span class=\"line\">            <span class=\"comment\">// 判断num是否存在，如果已经存在，则直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.get(num) != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123; map.get(num), i&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 不存在则当前数值与序号的映射关系存入map中</span></span><br><span class=\"line\">            map.put(nums[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度：$O(n)$</p>\n<p>空间复杂度：$O(n)$</p>\n<p>运行结果如下：</p>\n<img src=\"/programming/leetcode/day1-two-sum/map-solution.png\" title=\"map-solution\">\n<p>一下降到了9ms，效率大大提升，击败85%的用户，嗯，看来效果确实很显著。</p>\n<p><a href=\"https://leetcode-cn.com/problems/two-sum/solution/\" target=\"_blank\" rel=\"noopener\">本题中文链接</a></p>\n<p><a href=\"https://leetcode.com/problems/two-sum/solution/\" target=\"_blank\" rel=\"noopener\">本题英文链接</a></p>\n<p>如果你有更好的想法，也欢迎留言交流讨论~</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"题目说明\"><a href=\"#题目说明\" class=\"headerlink\" title=\"题目说明\"></a>题目说明</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>\n<p>示例:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class=\"line\"></span><br><span class=\"line\">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class=\"line\">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>\n<h2 id=\"解题思路1：穷举法\"><a href=\"#解题思路1：穷举法\" class=\"headerlink\" title=\"解题思路1：穷举法\"></a>解题思路1：穷举法</h2><p>从题目意思理解，就是从给定的整数数组中找到两个整数，使得它们的和与给定的数相等。那最简单粗暴的方式就是枚举了，嗯，先来试试最简单的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> exhaustAlgorithm(nums,target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 穷举法</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] exhaustAlgorithm(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (nums[i] + nums[j] != target) &#123;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j &gt;= length)&#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &gt;= length - <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                j = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 说明不存在这样的组合</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] + nums[j] != target) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] result = &#123;i,j&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度：$O(n^2)$</p>\n<p>运行结果如下：</p>\n<img src=\"/programming/leetcode/day1-two-sum/exhaust-algorithm.png\" title=\"exhaust-algorithm\">\n<p>80ms，才击败了11.13%的用户，说明优化空间还很大。</p>\n<h2 id=\"解题思路2：倒推法\"><a href=\"#解题思路2：倒推法\" class=\"headerlink\" title=\"解题思路2：倒推法\"></a>解题思路2：倒推法</h2><p>穷举法的效率一般都比较差，所以需要尝试一些新姿势。我们再来分析一下上面的穷举算法，要从一个集合中找出两个数，使得它们的和与给出的数<code>target</code>相等，使用穷举算法时，当我们选出第一个数<code>a</code>后，需要循环遍历之后的数，然后一一进行加和判断，但实际上，我们只需要知道剩下的数里，有没有数等于<code>target - a</code>即可，而每次从数组中找到某个数是否存在，都需要遍历一次，因此，更好的做法是将数与对应的序号存到一个map中，这样就能将查找效率从$O(n)$提高到$O(1)$。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mapSolution(nums,target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 倒推法</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] mapSolution(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)&#123;</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\">            map.put(nums[i],i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> num = target - nums[i];</span><br><span class=\"line\">            <span class=\"comment\">// 判断num是否存在，如果已经存在，则直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.get(num) != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123; map.get(num), i&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们对nums数组进行了两次遍历，第一次遍历是将所有元素都存入map中，第二次遍历是查找目标的整数对是否存在。</p>\n<p>但再仔细想想，是否还能再优化呢？</p>\n<p>答案是肯定的，在这个题中，要寻找的整数是成对存在的，所以我们可以只进行一次遍历。</p>\n<p>如果<code>target</code>减去当前遍历数值后的数不存在于<code>map</code>中，则将当前数值与序号的映射关系存入<code>map</code>中。也许你会问，那找到第一个要寻找的数时，第二个数显然还不在<code>map</code>中，那怎么办呢？别着急，前面已经说过了，因为要寻找的数是成对存在的，这里我们假设为<code>a</code>和<code>b</code>，所以遇到第一个数<code>a</code>时，由于<code>b</code>还没有存入<code>map</code>，所以先将<code>a</code>存入<code>map</code>中，我们在找到第二个数<code>b</code>后，此时<code>a</code>已经在<code>map</code>中了，所以就能在一次遍历中顺利找到了这对我们想要的整数了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mapSolution(nums,target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 倒推法</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] mapSolution(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)&#123;</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> num = target - nums[i];</span><br><span class=\"line\">            <span class=\"comment\">// 判断num是否存在，如果已经存在，则直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.get(num) != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123; map.get(num), i&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 不存在则当前数值与序号的映射关系存入map中</span></span><br><span class=\"line\">            map.put(nums[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度：$O(n)$</p>\n<p>空间复杂度：$O(n)$</p>\n<p>运行结果如下：</p>\n<img src=\"/programming/leetcode/day1-two-sum/map-solution.png\" title=\"map-solution\">\n<p>一下降到了9ms，效率大大提升，击败85%的用户，嗯，看来效果确实很显著。</p>\n<p><a href=\"https://leetcode-cn.com/problems/two-sum/solution/\" target=\"_blank\" rel=\"noopener\">本题中文链接</a></p>\n<p><a href=\"https://leetcode.com/problems/two-sum/solution/\" target=\"_blank\" rel=\"noopener\">本题英文链接</a></p>\n<p>如果你有更好的想法，也欢迎留言交流讨论~</p>\n"},{"title":"【LeetCode】无重复字符串最长子串","date":"2019-01-08T12:00:00.000Z","_content":"\n## 题目描述\n\n给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n\n示例 1:\n\n```bash\n输入: \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n```\n\n示例 2:\n\n```bash\n输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n```\n\n示例 3:\n\n```bash\n输入: \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n```\n\n## 题目解析\n\n这道题的目标是找出最长子串，并且该子串必须不包含重复字符，而且这个子串必须是原字符串中连续的一部分（见示例3中的解释说明）。\n\n拿到题目时先不要心急想什么骚操作，我们先从最普通的操作开始把题目解出来，然后再来看如何优化。\n\n接下来，我们画图分析一下，先随便弄一个长相普通的字符串：`frankissohandsome`，我们要从中找出我们想要的子串，那少不了需要遍历，我们设置两个变量`from`，`to`，分别存储寻找的目标子串在原字符串中的首尾位置。\n\n首先，`from`和`to`的初始值都为0（String的序号从0开始），子串长度`length = 1`，最大子串长度`maxLength = 1`。\n\n{% asset_img day3-step-1.png day3-step-1 %}\n\n然后，我们将`to`的指向往后移动，并判断新遍历的字符是否已经存在于子串中，如果不存在，则将其加入子串中，并将`length`进行自增。\n\n{% asset_img day3-step-2.png day3-step-2 %}\n\n直到找到一个已存在于子串中的字符，或者`to`到达字符串的末尾。这里，我们找到了一个重复的`s`，序号为`7`，此时的子串为`frankis`，将此时的子串长度与最大子串长度相比较（目前为`0`），如果比最大子串长度大，则将最大子串长度设置为当前子串长度`7`。\n\n{% asset_img day3-step-3.png day3-step-3 %}\n\n接下来，我们继续寻找符合条件的子串，这里比较关键的一点是下一个子串的起始位置，这里我们将`from`直接跳到了序号为`7`的位置，因为包含`ss`的子串显然都不能满足要求。\n\n{% asset_img day3-step-4.png day3-step-4 %}\n\n然后我们依照之前的方法，找到第二个候选的子串`sohand`，长度为`6`，比目前的最大子串长度小，所以不是目标子串。\n\n{% asset_img day3-step-5.png day3-step-5 %}\n\n接着继续寻找，找到另一个候选子串`ohands`，长度小于最大子串长度，不是我们的目标子串。\n\n{% asset_img day3-step-6.png day3-step-6 %}\n\n继续寻找。\n\n{% asset_img day3-step-7.png day3-step-7 %}\n\n`to`到达了字符串末尾，找到另一个候选子串`handsome`，长度大于最大子串长度，这就是我们的目标子串。\n\n{% asset_img day3-step-8.png day3-step-8 %}\n\n于是我们的最大子串长度就轻松加愉快的找到了。接下来的事情就是把上面的思路转化成代码。\n\n这里只需要注意一下`from`的跳转即可，每次跳转的序号为`to`指向的字符在子串中出现的位置 + 1。\n\n## 常规解法\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if (s == null || s.length() == 0) return 0;\n        int from = 0, to = 1, length = 1, maxLength = 1;\n        // to遍历直到字符串末尾\n        while (to < s.length()){\n            int site = s.substring(from, to).indexOf(s.charAt(to));\n            if (site != -1){\n                // to指向的字符已存在\n                length = to - from;\n                if (length > maxLength) maxLength = length;\n                // from 跳转到site+1的位置\n                from = from + site + 1;\n            }\n            to++;\n        }\n        // 处理最后一个子串\n        if (to - from > maxLength) {\n            maxLength = to - from;\n        }\n        return maxLength;\n    }\n}\n```\n\n这里没有什么骚操作，考虑好边界情况就行了。有一个小细节需要注意，`site`代表的是子串中字符出现的位置，不是原字符串中的位置，因此`from`在跳转时，需要加上自身原来的序号。还有最后一个子串的处理不要忘记，因为当`to`遍历到字符串末尾时，会结束循环，最后一个子串将不会在循环内处理。\n\n让我们提交一下：\n\n{% asset_img day3-submit-1.png day3-submit-1 %}\n\n击败了`73%`的用户，还不错。\n\n## 常规解法优化\n\n想想看，还有没有优化的空间呢？\n\n那肯定是有的，首先我们想一想，当我们找到的最大子串长度已经比`from`所在位置到字符串末尾的位置还要长了，那就没有必要再继续下去了。\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if (s == null || s.length() == 0) return 0;\n        int from = 0, to = 1, length = 1, maxLength = 0;\n        // to遍历直到字符串末尾\n        while (to < s.length()){\n            int site = s.substring(from, to).indexOf(s.charAt(to));\n            if (site != -1){\n                // to指向的字符已存在\n                length = to - from;\n                if (length > maxLength) {\n                    maxLength = length;\n                }\n                // 判断是否需要继续遍历\n                if (maxLength > s.length() - from + 1) return maxLength;\n                from = from + site + 1;\n            }\n            to++;\n        }\n        // 处理最后一个子串\n        if (to - from > maxLength) {\n            maxLength = to - from;\n        }\n        return maxLength;\n    }\n}\n```\n\n另外要处理类似`bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb`这样的字符串，上面的方法还是有很大优化空间的，我们可以用一个`HashSet`来存储所有元素，利用其特性进行去重，如果找到的子串长度已经等于`HashSet`中的元素个数了，那就不用再继续查找了。\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if (s == null || s.length() == 0) return 0;\n        int from = 0, to = 1, length = 1, maxLength = 0;\n        Set<Character> set = new HashSet<>();\n        for (int i = 0; i < s.length(); i++){\n            set.add(s.charAt(i));\n        }\n        // to遍历直到字符串末尾\n        while (to < s.length()){\n            int site = s.substring(from, to).indexOf(s.charAt(to));\n            if (site != -1){\n                // to指向的字符已存在\n                length = to - from;\n                if (length > maxLength) {\n                    maxLength = length;\n                }\n                if (maxLength > s.length() - from + 1) return maxLength;\n                if (maxLength >= set.size()) return maxLength;\n                from = from + site + 1;\n            }\n            to++;\n        }\n        // 处理最后一个子串\n        if (to - from > maxLength) {\n            maxLength = to - from;\n        }\n        return maxLength;\n    }\n}\n```\n\n再提交一下：\n\n{% asset_img day3-submit-2.png day3-submit-2 %}\n\n哈哈哈哈，翻车了，所以这里引入一个`HashSet`用空间来换时间的方式不一定合适，看来测试用例里像`bbbbbbbbbbbbbb`这样的用例并不多啊。\n\n那么今天的翻车就到此为止了，如果觉得对你有帮助的话记得点个关注哦。\n","source":"_posts/leetcode/day3-longest-substring-without-repeating-characters.md","raw":"---\ntitle: 【LeetCode】无重复字符串最长子串\ntags: \n - Java\n - 算法\n - LeetCode\ncategories: 编程\ndate: 2019-01-08 20:00:00\n---\n\n## 题目描述\n\n给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n\n示例 1:\n\n```bash\n输入: \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n```\n\n示例 2:\n\n```bash\n输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n```\n\n示例 3:\n\n```bash\n输入: \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n```\n\n## 题目解析\n\n这道题的目标是找出最长子串，并且该子串必须不包含重复字符，而且这个子串必须是原字符串中连续的一部分（见示例3中的解释说明）。\n\n拿到题目时先不要心急想什么骚操作，我们先从最普通的操作开始把题目解出来，然后再来看如何优化。\n\n接下来，我们画图分析一下，先随便弄一个长相普通的字符串：`frankissohandsome`，我们要从中找出我们想要的子串，那少不了需要遍历，我们设置两个变量`from`，`to`，分别存储寻找的目标子串在原字符串中的首尾位置。\n\n首先，`from`和`to`的初始值都为0（String的序号从0开始），子串长度`length = 1`，最大子串长度`maxLength = 1`。\n\n{% asset_img day3-step-1.png day3-step-1 %}\n\n然后，我们将`to`的指向往后移动，并判断新遍历的字符是否已经存在于子串中，如果不存在，则将其加入子串中，并将`length`进行自增。\n\n{% asset_img day3-step-2.png day3-step-2 %}\n\n直到找到一个已存在于子串中的字符，或者`to`到达字符串的末尾。这里，我们找到了一个重复的`s`，序号为`7`，此时的子串为`frankis`，将此时的子串长度与最大子串长度相比较（目前为`0`），如果比最大子串长度大，则将最大子串长度设置为当前子串长度`7`。\n\n{% asset_img day3-step-3.png day3-step-3 %}\n\n接下来，我们继续寻找符合条件的子串，这里比较关键的一点是下一个子串的起始位置，这里我们将`from`直接跳到了序号为`7`的位置，因为包含`ss`的子串显然都不能满足要求。\n\n{% asset_img day3-step-4.png day3-step-4 %}\n\n然后我们依照之前的方法，找到第二个候选的子串`sohand`，长度为`6`，比目前的最大子串长度小，所以不是目标子串。\n\n{% asset_img day3-step-5.png day3-step-5 %}\n\n接着继续寻找，找到另一个候选子串`ohands`，长度小于最大子串长度，不是我们的目标子串。\n\n{% asset_img day3-step-6.png day3-step-6 %}\n\n继续寻找。\n\n{% asset_img day3-step-7.png day3-step-7 %}\n\n`to`到达了字符串末尾，找到另一个候选子串`handsome`，长度大于最大子串长度，这就是我们的目标子串。\n\n{% asset_img day3-step-8.png day3-step-8 %}\n\n于是我们的最大子串长度就轻松加愉快的找到了。接下来的事情就是把上面的思路转化成代码。\n\n这里只需要注意一下`from`的跳转即可，每次跳转的序号为`to`指向的字符在子串中出现的位置 + 1。\n\n## 常规解法\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if (s == null || s.length() == 0) return 0;\n        int from = 0, to = 1, length = 1, maxLength = 1;\n        // to遍历直到字符串末尾\n        while (to < s.length()){\n            int site = s.substring(from, to).indexOf(s.charAt(to));\n            if (site != -1){\n                // to指向的字符已存在\n                length = to - from;\n                if (length > maxLength) maxLength = length;\n                // from 跳转到site+1的位置\n                from = from + site + 1;\n            }\n            to++;\n        }\n        // 处理最后一个子串\n        if (to - from > maxLength) {\n            maxLength = to - from;\n        }\n        return maxLength;\n    }\n}\n```\n\n这里没有什么骚操作，考虑好边界情况就行了。有一个小细节需要注意，`site`代表的是子串中字符出现的位置，不是原字符串中的位置，因此`from`在跳转时，需要加上自身原来的序号。还有最后一个子串的处理不要忘记，因为当`to`遍历到字符串末尾时，会结束循环，最后一个子串将不会在循环内处理。\n\n让我们提交一下：\n\n{% asset_img day3-submit-1.png day3-submit-1 %}\n\n击败了`73%`的用户，还不错。\n\n## 常规解法优化\n\n想想看，还有没有优化的空间呢？\n\n那肯定是有的，首先我们想一想，当我们找到的最大子串长度已经比`from`所在位置到字符串末尾的位置还要长了，那就没有必要再继续下去了。\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if (s == null || s.length() == 0) return 0;\n        int from = 0, to = 1, length = 1, maxLength = 0;\n        // to遍历直到字符串末尾\n        while (to < s.length()){\n            int site = s.substring(from, to).indexOf(s.charAt(to));\n            if (site != -1){\n                // to指向的字符已存在\n                length = to - from;\n                if (length > maxLength) {\n                    maxLength = length;\n                }\n                // 判断是否需要继续遍历\n                if (maxLength > s.length() - from + 1) return maxLength;\n                from = from + site + 1;\n            }\n            to++;\n        }\n        // 处理最后一个子串\n        if (to - from > maxLength) {\n            maxLength = to - from;\n        }\n        return maxLength;\n    }\n}\n```\n\n另外要处理类似`bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb`这样的字符串，上面的方法还是有很大优化空间的，我们可以用一个`HashSet`来存储所有元素，利用其特性进行去重，如果找到的子串长度已经等于`HashSet`中的元素个数了，那就不用再继续查找了。\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if (s == null || s.length() == 0) return 0;\n        int from = 0, to = 1, length = 1, maxLength = 0;\n        Set<Character> set = new HashSet<>();\n        for (int i = 0; i < s.length(); i++){\n            set.add(s.charAt(i));\n        }\n        // to遍历直到字符串末尾\n        while (to < s.length()){\n            int site = s.substring(from, to).indexOf(s.charAt(to));\n            if (site != -1){\n                // to指向的字符已存在\n                length = to - from;\n                if (length > maxLength) {\n                    maxLength = length;\n                }\n                if (maxLength > s.length() - from + 1) return maxLength;\n                if (maxLength >= set.size()) return maxLength;\n                from = from + site + 1;\n            }\n            to++;\n        }\n        // 处理最后一个子串\n        if (to - from > maxLength) {\n            maxLength = to - from;\n        }\n        return maxLength;\n    }\n}\n```\n\n再提交一下：\n\n{% asset_img day3-submit-2.png day3-submit-2 %}\n\n哈哈哈哈，翻车了，所以这里引入一个`HashSet`用空间来换时间的方式不一定合适，看来测试用例里像`bbbbbbbbbbbbbb`这样的用例并不多啊。\n\n那么今天的翻车就到此为止了，如果觉得对你有帮助的话记得点个关注哦。\n","slug":"leetcode/day3-longest-substring-without-repeating-characters","published":1,"updated":"2019-06-04T01:29:57.433Z","_id":"cjxze3gkw000c0cvwhvfuzczx","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>\n<p>示例 1:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"string\">\"abcabcbb\"</span></span><br><span class=\"line\">输出: 3 </span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 <span class=\"string\">\"abc\"</span>，所以其长度为 3。</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"string\">\"bbbbb\"</span></span><br><span class=\"line\">输出: 1</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 <span class=\"string\">\"b\"</span>，所以其长度为 1。</span><br></pre></td></tr></table></figure>\n<p>示例 3:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"string\">\"pwwkew\"</span></span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 <span class=\"string\">\"wke\"</span>，所以其长度为 3。</span><br><span class=\"line\">     请注意，你的答案必须是 子串 的长度，<span class=\"string\">\"pwke\"</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>\n<h2 id=\"题目解析\"><a href=\"#题目解析\" class=\"headerlink\" title=\"题目解析\"></a>题目解析</h2><p>这道题的目标是找出最长子串，并且该子串必须不包含重复字符，而且这个子串必须是原字符串中连续的一部分（见示例3中的解释说明）。</p>\n<p>拿到题目时先不要心急想什么骚操作，我们先从最普通的操作开始把题目解出来，然后再来看如何优化。</p>\n<p>接下来，我们画图分析一下，先随便弄一个长相普通的字符串：<code>frankissohandsome</code>，我们要从中找出我们想要的子串，那少不了需要遍历，我们设置两个变量<code>from</code>，<code>to</code>，分别存储寻找的目标子串在原字符串中的首尾位置。</p>\n<p>首先，<code>from</code>和<code>to</code>的初始值都为0（String的序号从0开始），子串长度<code>length = 1</code>，最大子串长度<code>maxLength = 1</code>。</p>\n<img src=\"/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-step-1.png\" title=\"day3-step-1\">\n<p>然后，我们将<code>to</code>的指向往后移动，并判断新遍历的字符是否已经存在于子串中，如果不存在，则将其加入子串中，并将<code>length</code>进行自增。</p>\n<img src=\"/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-step-2.png\" title=\"day3-step-2\">\n<p>直到找到一个已存在于子串中的字符，或者<code>to</code>到达字符串的末尾。这里，我们找到了一个重复的<code>s</code>，序号为<code>7</code>，此时的子串为<code>frankis</code>，将此时的子串长度与最大子串长度相比较（目前为<code>0</code>），如果比最大子串长度大，则将最大子串长度设置为当前子串长度<code>7</code>。</p>\n<img src=\"/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-step-3.png\" title=\"day3-step-3\">\n<p>接下来，我们继续寻找符合条件的子串，这里比较关键的一点是下一个子串的起始位置，这里我们将<code>from</code>直接跳到了序号为<code>7</code>的位置，因为包含<code>ss</code>的子串显然都不能满足要求。</p>\n<img src=\"/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-step-4.png\" title=\"day3-step-4\">\n<p>然后我们依照之前的方法，找到第二个候选的子串<code>sohand</code>，长度为<code>6</code>，比目前的最大子串长度小，所以不是目标子串。</p>\n<img src=\"/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-step-5.png\" title=\"day3-step-5\">\n<p>接着继续寻找，找到另一个候选子串<code>ohands</code>，长度小于最大子串长度，不是我们的目标子串。</p>\n<img src=\"/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-step-6.png\" title=\"day3-step-6\">\n<p>继续寻找。</p>\n<img src=\"/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-step-7.png\" title=\"day3-step-7\">\n<p><code>to</code>到达了字符串末尾，找到另一个候选子串<code>handsome</code>，长度大于最大子串长度，这就是我们的目标子串。</p>\n<img src=\"/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-step-8.png\" title=\"day3-step-8\">\n<p>于是我们的最大子串长度就轻松加愉快的找到了。接下来的事情就是把上面的思路转化成代码。</p>\n<p>这里只需要注意一下<code>from</code>的跳转即可，每次跳转的序号为<code>to</code>指向的字符在子串中出现的位置 + 1。</p>\n<h2 id=\"常规解法\"><a href=\"#常规解法\" class=\"headerlink\" title=\"常规解法\"></a>常规解法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.length() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> from = <span class=\"number\">0</span>, to = <span class=\"number\">1</span>, length = <span class=\"number\">1</span>, maxLength = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// to遍历直到字符串末尾</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (to &lt; s.length())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> site = s.substring(from, to).indexOf(s.charAt(to));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (site != -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// to指向的字符已存在</span></span><br><span class=\"line\">                length = to - from;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (length &gt; maxLength) maxLength = length;</span><br><span class=\"line\">                <span class=\"comment\">// from 跳转到site+1的位置</span></span><br><span class=\"line\">                from = from + site + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            to++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 处理最后一个子串</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (to - from &gt; maxLength) &#123;</span><br><span class=\"line\">            maxLength = to - from;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxLength;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里没有什么骚操作，考虑好边界情况就行了。有一个小细节需要注意，<code>site</code>代表的是子串中字符出现的位置，不是原字符串中的位置，因此<code>from</code>在跳转时，需要加上自身原来的序号。还有最后一个子串的处理不要忘记，因为当<code>to</code>遍历到字符串末尾时，会结束循环，最后一个子串将不会在循环内处理。</p>\n<p>让我们提交一下：</p>\n<img src=\"/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-submit-1.png\" title=\"day3-submit-1\">\n<p>击败了<code>73%</code>的用户，还不错。</p>\n<h2 id=\"常规解法优化\"><a href=\"#常规解法优化\" class=\"headerlink\" title=\"常规解法优化\"></a>常规解法优化</h2><p>想想看，还有没有优化的空间呢？</p>\n<p>那肯定是有的，首先我们想一想，当我们找到的最大子串长度已经比<code>from</code>所在位置到字符串末尾的位置还要长了，那就没有必要再继续下去了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.length() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> from = <span class=\"number\">0</span>, to = <span class=\"number\">1</span>, length = <span class=\"number\">1</span>, maxLength = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// to遍历直到字符串末尾</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (to &lt; s.length())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> site = s.substring(from, to).indexOf(s.charAt(to));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (site != -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// to指向的字符已存在</span></span><br><span class=\"line\">                length = to - from;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (length &gt; maxLength) &#123;</span><br><span class=\"line\">                    maxLength = length;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 判断是否需要继续遍历</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (maxLength &gt; s.length() - from + <span class=\"number\">1</span>) <span class=\"keyword\">return</span> maxLength;</span><br><span class=\"line\">                from = from + site + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            to++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 处理最后一个子串</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (to - from &gt; maxLength) &#123;</span><br><span class=\"line\">            maxLength = to - from;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxLength;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外要处理类似<code>bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb</code>这样的字符串，上面的方法还是有很大优化空间的，我们可以用一个<code>HashSet</code>来存储所有元素，利用其特性进行去重，如果找到的子串长度已经等于<code>HashSet</code>中的元素个数了，那就不用再继续查找了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.length() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> from = <span class=\"number\">0</span>, to = <span class=\"number\">1</span>, length = <span class=\"number\">1</span>, maxLength = <span class=\"number\">0</span>;</span><br><span class=\"line\">        Set&lt;Character&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class=\"line\">            set.add(s.charAt(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// to遍历直到字符串末尾</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (to &lt; s.length())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> site = s.substring(from, to).indexOf(s.charAt(to));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (site != -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// to指向的字符已存在</span></span><br><span class=\"line\">                length = to - from;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (length &gt; maxLength) &#123;</span><br><span class=\"line\">                    maxLength = length;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (maxLength &gt; s.length() - from + <span class=\"number\">1</span>) <span class=\"keyword\">return</span> maxLength;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (maxLength &gt;= set.size()) <span class=\"keyword\">return</span> maxLength;</span><br><span class=\"line\">                from = from + site + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            to++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 处理最后一个子串</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (to - from &gt; maxLength) &#123;</span><br><span class=\"line\">            maxLength = to - from;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxLength;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再提交一下：</p>\n<img src=\"/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-submit-2.png\" title=\"day3-submit-2\">\n<p>哈哈哈哈，翻车了，所以这里引入一个<code>HashSet</code>用空间来换时间的方式不一定合适，看来测试用例里像<code>bbbbbbbbbbbbbb</code>这样的用例并不多啊。</p>\n<p>那么今天的翻车就到此为止了，如果觉得对你有帮助的话记得点个关注哦。</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>\n<p>示例 1:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"string\">\"abcabcbb\"</span></span><br><span class=\"line\">输出: 3 </span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 <span class=\"string\">\"abc\"</span>，所以其长度为 3。</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"string\">\"bbbbb\"</span></span><br><span class=\"line\">输出: 1</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 <span class=\"string\">\"b\"</span>，所以其长度为 1。</span><br></pre></td></tr></table></figure>\n<p>示例 3:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"string\">\"pwwkew\"</span></span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 <span class=\"string\">\"wke\"</span>，所以其长度为 3。</span><br><span class=\"line\">     请注意，你的答案必须是 子串 的长度，<span class=\"string\">\"pwke\"</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>\n<h2 id=\"题目解析\"><a href=\"#题目解析\" class=\"headerlink\" title=\"题目解析\"></a>题目解析</h2><p>这道题的目标是找出最长子串，并且该子串必须不包含重复字符，而且这个子串必须是原字符串中连续的一部分（见示例3中的解释说明）。</p>\n<p>拿到题目时先不要心急想什么骚操作，我们先从最普通的操作开始把题目解出来，然后再来看如何优化。</p>\n<p>接下来，我们画图分析一下，先随便弄一个长相普通的字符串：<code>frankissohandsome</code>，我们要从中找出我们想要的子串，那少不了需要遍历，我们设置两个变量<code>from</code>，<code>to</code>，分别存储寻找的目标子串在原字符串中的首尾位置。</p>\n<p>首先，<code>from</code>和<code>to</code>的初始值都为0（String的序号从0开始），子串长度<code>length = 1</code>，最大子串长度<code>maxLength = 1</code>。</p>\n<img src=\"/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-step-1.png\" title=\"day3-step-1\">\n<p>然后，我们将<code>to</code>的指向往后移动，并判断新遍历的字符是否已经存在于子串中，如果不存在，则将其加入子串中，并将<code>length</code>进行自增。</p>\n<img src=\"/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-step-2.png\" title=\"day3-step-2\">\n<p>直到找到一个已存在于子串中的字符，或者<code>to</code>到达字符串的末尾。这里，我们找到了一个重复的<code>s</code>，序号为<code>7</code>，此时的子串为<code>frankis</code>，将此时的子串长度与最大子串长度相比较（目前为<code>0</code>），如果比最大子串长度大，则将最大子串长度设置为当前子串长度<code>7</code>。</p>\n<img src=\"/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-step-3.png\" title=\"day3-step-3\">\n<p>接下来，我们继续寻找符合条件的子串，这里比较关键的一点是下一个子串的起始位置，这里我们将<code>from</code>直接跳到了序号为<code>7</code>的位置，因为包含<code>ss</code>的子串显然都不能满足要求。</p>\n<img src=\"/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-step-4.png\" title=\"day3-step-4\">\n<p>然后我们依照之前的方法，找到第二个候选的子串<code>sohand</code>，长度为<code>6</code>，比目前的最大子串长度小，所以不是目标子串。</p>\n<img src=\"/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-step-5.png\" title=\"day3-step-5\">\n<p>接着继续寻找，找到另一个候选子串<code>ohands</code>，长度小于最大子串长度，不是我们的目标子串。</p>\n<img src=\"/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-step-6.png\" title=\"day3-step-6\">\n<p>继续寻找。</p>\n<img src=\"/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-step-7.png\" title=\"day3-step-7\">\n<p><code>to</code>到达了字符串末尾，找到另一个候选子串<code>handsome</code>，长度大于最大子串长度，这就是我们的目标子串。</p>\n<img src=\"/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-step-8.png\" title=\"day3-step-8\">\n<p>于是我们的最大子串长度就轻松加愉快的找到了。接下来的事情就是把上面的思路转化成代码。</p>\n<p>这里只需要注意一下<code>from</code>的跳转即可，每次跳转的序号为<code>to</code>指向的字符在子串中出现的位置 + 1。</p>\n<h2 id=\"常规解法\"><a href=\"#常规解法\" class=\"headerlink\" title=\"常规解法\"></a>常规解法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.length() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> from = <span class=\"number\">0</span>, to = <span class=\"number\">1</span>, length = <span class=\"number\">1</span>, maxLength = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// to遍历直到字符串末尾</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (to &lt; s.length())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> site = s.substring(from, to).indexOf(s.charAt(to));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (site != -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// to指向的字符已存在</span></span><br><span class=\"line\">                length = to - from;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (length &gt; maxLength) maxLength = length;</span><br><span class=\"line\">                <span class=\"comment\">// from 跳转到site+1的位置</span></span><br><span class=\"line\">                from = from + site + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            to++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 处理最后一个子串</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (to - from &gt; maxLength) &#123;</span><br><span class=\"line\">            maxLength = to - from;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxLength;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里没有什么骚操作，考虑好边界情况就行了。有一个小细节需要注意，<code>site</code>代表的是子串中字符出现的位置，不是原字符串中的位置，因此<code>from</code>在跳转时，需要加上自身原来的序号。还有最后一个子串的处理不要忘记，因为当<code>to</code>遍历到字符串末尾时，会结束循环，最后一个子串将不会在循环内处理。</p>\n<p>让我们提交一下：</p>\n<img src=\"/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-submit-1.png\" title=\"day3-submit-1\">\n<p>击败了<code>73%</code>的用户，还不错。</p>\n<h2 id=\"常规解法优化\"><a href=\"#常规解法优化\" class=\"headerlink\" title=\"常规解法优化\"></a>常规解法优化</h2><p>想想看，还有没有优化的空间呢？</p>\n<p>那肯定是有的，首先我们想一想，当我们找到的最大子串长度已经比<code>from</code>所在位置到字符串末尾的位置还要长了，那就没有必要再继续下去了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.length() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> from = <span class=\"number\">0</span>, to = <span class=\"number\">1</span>, length = <span class=\"number\">1</span>, maxLength = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// to遍历直到字符串末尾</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (to &lt; s.length())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> site = s.substring(from, to).indexOf(s.charAt(to));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (site != -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// to指向的字符已存在</span></span><br><span class=\"line\">                length = to - from;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (length &gt; maxLength) &#123;</span><br><span class=\"line\">                    maxLength = length;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 判断是否需要继续遍历</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (maxLength &gt; s.length() - from + <span class=\"number\">1</span>) <span class=\"keyword\">return</span> maxLength;</span><br><span class=\"line\">                from = from + site + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            to++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 处理最后一个子串</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (to - from &gt; maxLength) &#123;</span><br><span class=\"line\">            maxLength = to - from;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxLength;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外要处理类似<code>bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb</code>这样的字符串，上面的方法还是有很大优化空间的，我们可以用一个<code>HashSet</code>来存储所有元素，利用其特性进行去重，如果找到的子串长度已经等于<code>HashSet</code>中的元素个数了，那就不用再继续查找了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.length() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> from = <span class=\"number\">0</span>, to = <span class=\"number\">1</span>, length = <span class=\"number\">1</span>, maxLength = <span class=\"number\">0</span>;</span><br><span class=\"line\">        Set&lt;Character&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class=\"line\">            set.add(s.charAt(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// to遍历直到字符串末尾</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (to &lt; s.length())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> site = s.substring(from, to).indexOf(s.charAt(to));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (site != -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// to指向的字符已存在</span></span><br><span class=\"line\">                length = to - from;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (length &gt; maxLength) &#123;</span><br><span class=\"line\">                    maxLength = length;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (maxLength &gt; s.length() - from + <span class=\"number\">1</span>) <span class=\"keyword\">return</span> maxLength;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (maxLength &gt;= set.size()) <span class=\"keyword\">return</span> maxLength;</span><br><span class=\"line\">                from = from + site + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            to++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 处理最后一个子串</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (to - from &gt; maxLength) &#123;</span><br><span class=\"line\">            maxLength = to - from;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxLength;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再提交一下：</p>\n<img src=\"/programming/leetcode/day3-longest-substring-without-repeating-characters/day3-submit-2.png\" title=\"day3-submit-2\">\n<p>哈哈哈哈，翻车了，所以这里引入一个<code>HashSet</code>用空间来换时间的方式不一定合适，看来测试用例里像<code>bbbbbbbbbbbbbb</code>这样的用例并不多啊。</p>\n<p>那么今天的翻车就到此为止了，如果觉得对你有帮助的话记得点个关注哦。</p>\n"},{"title":"【动态规划】完全背包问题","date":"2019-05-02T01:17:09.000Z","_content":"\n## 说明\n\n在上一篇中，我们对01背包问题进行了比较深入的研究，这一篇里，我们来聊聊另一个背包问题：完全背包。\n\n![](https://i.loli.net/2019/05/02/5ccaec8a22bb9.png)\n\n## 完全背包\n\n有N种物品和一个容量为T的背包，每种物品都就可以选择任意多个，第i种物品的价值为P[i]，体积为V[i]，求解：选哪些物品放入背包，可以使得这些物品的价值最大，并且体积总和不超过背包容量。\n\n跟01背包一样，完全背包也是一个很经典的动态规划问题，不同的地方在于01背包问题中，每件物品最多选择一件，而在完全背包问题中，只要背包装得下，每件物品可以选择任意多件。从每件物品的角度来说，与之相关的策略已经不再是选或者不选了，而是有取0件、取1件、取2件...直到取⌊T/Vi⌋（向下取整）件。\n\n## 贪心算法\n\n看到可以选择任意多件，你也许会想，那还不容易，选性价比最高的就好了。\n\n![](https://i.loli.net/2019/03/14/5c8a564a63265.png)\n\n于是开启贪婪模式，把每种物品的价格除以体积来算出它们各自的性价比，然后只选择性价比最高的物品放入背包中。\n\n嗯，听起来好像没什么毛病，但仍旧有一个问题，那就是同一种物品虽然可以选择任意多件，但仍旧只能以件为单位，也就是说单个物品是无法拆分的，不能选择半件，只能多选一件或者少选一件。这样就造成了一个问题，往往无法用性价比最高的物品来装满整个背包，比如背包空间为10，性价比最高的物品占用空间为7，那么剩下的空间该如何填充呢？\n\n你当然会想到用性价比第二高的物品填充，如果仍旧无法填满，那就依次用第三、第四性价比物品来填充。\n\n听起来似乎可行，但我只需要举一个反例便能证明这个策略行不通。\n\n想要举反例很简单，比如只有两个物品：物品A：价值5，体积5，物品B：价值8：体积7，背包容量为10，物品B的性价比显然要比物品A高，那么用贪心算法必然会选择放入一个物品B，此时，剩余的空间已无法装下A或者B，所以得到的最高价值为8，而实际上，选择放入两个物品A即可得到更高的价值10。所以这里贪心算法并不适用。\n\n![](https://i.loli.net/2019/03/14/5c8a56a150bc1.png)\n\n## 递归法\n\n像上一篇中的那样，我们只需要找到递推关系式，就很容易使用递归解法来求解了。\n\n用ks(i,t)表示前i种物品放入一个容量为t的背包获得的最大价值，那么对于第i种物品，我们有k种选择，0 <= k * V[i] <= t，即可以选择0、1、2...k个第i种物品，所以递推表达式为：\n\n```\nks(i,t) = max{ks(i-1, t - V[i] * k) + P[i] * k}; （0 <= k * V[i] <= t）\n```\n\n同时，ks(0,t)=0;ks(i,0)=0;\n\n使用上面的栗子，我们可以先用递归来求解：\n\n```java\npublic static class Knapsack {\n    private static int[] P={0,5,8};\n    private static int[] V={0,5,7};\n    private static int T = 10;\n\n    @Test\n    public void soleve1() {\n        int result = ks(P.length - 1,10);\n        System.out.println(\"最大价值为：\" + result);\n    }\n\n    private int ks(int i, int t){\n        int result = 0;\n        if (i == 0 || t == 0){\n            // 初始条件\n            result = 0;\n        } else if(V[i] > t){\n            // 装不下该珠宝\n            result = ks(i-1, t);\n        } else {\n            // 可以装下\n            // 取k个物品i，取其中使得总价值最大的k\n            for (int k = 0; k * V[i] <= t; k++){\n                int tmp2 = ks(i-1, t - V[i] * k) + P[i] * k;\n                if (tmp2 > result){\n                    result = tmp2;\n                }\n            }\n        }\n        return result;\n    }\n}\n\n```\n\n同样，这里的数组P和V分别添加了一个元素0，是为了减少越界判断而做的简单处理，运行如下：\n\n```\n最大价值为：11\n```\n\n如果你对比一下01背包问题中的递归解法，就会发现唯一的区别便是这里多了一层循环，因为01背包中，对于第i个物品只有选和不选两种情况，只需要从这两种选择中选出最优的即可，而完全背包问题则需要在k种选择中选出最优解，这便是最内层循环在做的事情。\n\n```java\nfor (int k = 0; k * V[i] <= t; k++){\n    // 选取k个第i件商品的最优价值为tmp2\n    int tmp2 = ks(i-1, t - V[i] * k) + P[i] * k;\n    if (tmp2 > result){\n        // 从中拿出最大的值即为最优解\n        result = tmp2;\n    }\n}\n```\n\n## 最优化原理和无后效性\n\n那这个问题可以不可以像01背包问题一样使用动态规划来求解呢？来证明一下即可。\n\n首先，先用反证法证明最优化原理：\n\n假设完全背包的最优解为F(n1,n2,...,nN)（n1，n2 分别代表第1、第2件物品的选取数量），完全背包的子问题为，将前i种物品放入容量为t的背包并取得最大价值，其对应的解为：F(n1,n2,...,ni)，假设该解不是子问题的最优解，即存在另一组解F(m1,m2,...,mi)，使得F(m1,m2,...,mi) > F(n1,n2,...,ni)，那么F(m1,m2,...,mi,...,nN) 必然大于 F(n1,n2,...,nN)，因此 F(n1,n2,...,nN) 不是原问题的最优解，与原假设不符，所以F(n1,n2,...,ni)必然是子问题的最优解。\n\n再来看看无后效性：\n\n对于子问题的任意解，都不会影响后续子问题的解，也就是说，前i种物品如何选择，只要最终的剩余背包空间不变，就不会影响后面物品的选择。即满足无后效性。\n\n因此，完全背包问题也可以使用动态规划来解决。\n\n![](https://i.loli.net/2019/05/02/5ccaece849f09.png)\n\n## 动态规划\n\n既然知道了可以使用动态规划求解，接下来就是要找到这个问题的状态转移方程。\n\n其实前面的递推法中，已经找到了递推关系式，它便已经是我们需要的状态转移方程。\n\n### 自上而下记忆法\n\n```java\nks(i,t) = max{ks(i-1, t - V[i] * k) + P[i] * k}; （0 <= k * V[i] <= t）\n```\n\n```java\npublic static class Knapsack {\n    private static int[] P={0,5,8};\n    private static int[] V={0,5,7};\n    private static int T = 10;\n\n    private Integer[][] results = new Integer[P.length + 1][T + 1];\n\n    @Test\n    public void solve2() {\n        int result = ks2(P.length - 1,10);\n        System.out.println(\"最大价值为：\" + result);\n    }\n\n    private int ks2(int i, int t){\n        // 如果该结果已经被计算，那么直接返回\n        if (results[i][t] != null) return results[i][t];\n        int result = 0;\n        if (i == 0 || t == 0){\n            // 初始条件\n            result = 0;\n        } else if(V[i] > t){\n            // 装不下该珠宝\n            result = ks2(i-1, t);\n        } else {\n            // 可以装下\n            // 取k个物品，取其中使得价值最大的\n            for (int k = 0; k * V[i] <= t; k++){\n                int tmp2 = ks2(i-1, t - V[i] * k) + P[i] * k;\n                if (tmp2 > result){\n                    result = tmp2;\n                }\n            }\n        }\n        results[i][t] = result;\n        return result;\n    }\n}\n```\n\n找出递归解法后，动态规划的解法其实就很简单了，只是多使用了一个二维数组来存储中间的解。\n\n### 自下而上填表法\n\n最后，还可以使用填表法来解决，此时需要将数组P和V额外添加的元素0去掉。\n\n为了方便理解，还是再画一个图吧：\n\n{% asset_img IMG_5E156B07E228-1.jpeg img %}\n\n对于第i种物品，我们可以选择的目标其实是从上一层中的某几个位置挑选出价值最高的一个。\n\n{% asset_img IMG_6B67BF7CC3A7-1.jpeg img %}\n\n这里当t=10时，因为最多只能放得下1个i2物品，所以只需要将两个数值进行比较，如果t=14，那么就需要将取0个、1个和两个i2物品的情况进行比较，然后选出最大值。\n\n```java\npublic static class Knapsack {\n    private static int[] P={5,8};\n    private static int[] V={5,7};\n    private static int T = 10;\n\n    private int[][] dp = new int[P.length + 1][T + 1];\n\n    @Test\n    public void solve3() {\n        for (int i = 0; i < P.length; i++){\n            for (int j = 0; j <= T; j++){\n                for (int k = 0; k * V[i] <= j; k++){\n                    dp[i+1][j] = Math.max(dp[i+1][j], dp[i][j-k * V[i]] + k * P[i]);\n                }\n            }\n        }\n        System.out.println(\"最大价值为：\" + dp[P.length][T]);\n    }\n}\n```\n\n跟01背包问题一样，完全背包的空间复杂度也可以进行优化，具体思路这里就不重复介绍了，可以翻看前面的01背包问题优化篇。\n\n优化后的状态转移方程为：\n\n```\nks(t) = max{ks(t), ks(t - Vi) + Pi}\n```\n\n```java\npublic static class Knapsack {\n    private static int[] P={0,5,8};\n    private static int[] V={0,5,7};\n    private static int T = 10;\n\n    private int[] newResults = new int[T + 1];\n\n    @Test\n    public void resolve4() {\n        int result = ksp(P.length,T);\n        System.out.println(result);\n    }\n\n    private int ksp(int i, int t){\n        // 开始填表\n        for (int m = 0; m < i; m++){\n            for (int n = V[m]; n <= t; n++){\n                newResults[n] = Math.max(newResults[n] , newResults[n - V[m]] + P[m]);\n            }\n            // 可以在这里输出中间结果\n            System.out.println(JSON.toJSONString(newResults));\n        }\n        return newResults[newResults.length - 1];\n    }\n}\n```\n\n输出如下：\n\n```\n[0,0,0,0,0,0,0,0,0,0,0]\n[0,0,0,0,0,5,5,5,5,5,10]\n[0,0,0,0,0,5,5,8,8,8,10]\n10\n```\n\n其实完全背包问题也可以转化成01背包问题来求解，因为第i件物品最多选 ⌊T/Vi⌋(向下取整) 件，于是可以把第i种物品转化为⌊T/Vi⌋件体积和价值相同的物品，然后再来求解这个01背包问题。具体方法这里就不多说了，留给大家自行解决。如果遇到问题，可以翻开前面关于01背包问题的两篇文章。\n\n## 总结\n\n完全背包问题跟01背包有很多相似之处，比较一下他们的状态转移方程以及各种解法，就会发现他们其实是异父异母的亲兄弟。\n\n![](https://i.loli.net/2019/05/02/5ccaee9d39578.png)\n\n这两个背包问题的关键都在于状态转移方程的寻找，如果对于类似的问题没有思路，可以先尝试找出递归解法，然后自上而下的记忆法便水到渠成了。\n\n当然，最重要的还是解题思路，理解记忆法和填表法的精髓，有助于之后举一反三，去解决类似的延伸问题。\n\n关于完全背包问题的解析到此就结束了，祝大家五一愉快！\n\n![](https://i.loli.net/2019/03/14/5c8a580b1789e.png)\n\n如果有疑问或者有什么想法，也欢迎关注我的公众号进行留言交流：\n\n![](https://i.loli.net/2019/03/14/5c8a58ba229ca.png)","source":"_posts/leetcode/complete-knapsack-problem.md","raw":"---\ntitle: 【动态规划】完全背包问题\ndate: 2019-05-02 09:17:09\ntags:\n - Java\n - 算法\n - 动态规划\n - 背包问题\ncategories: 编程\n---\n\n## 说明\n\n在上一篇中，我们对01背包问题进行了比较深入的研究，这一篇里，我们来聊聊另一个背包问题：完全背包。\n\n![](https://i.loli.net/2019/05/02/5ccaec8a22bb9.png)\n\n## 完全背包\n\n有N种物品和一个容量为T的背包，每种物品都就可以选择任意多个，第i种物品的价值为P[i]，体积为V[i]，求解：选哪些物品放入背包，可以使得这些物品的价值最大，并且体积总和不超过背包容量。\n\n跟01背包一样，完全背包也是一个很经典的动态规划问题，不同的地方在于01背包问题中，每件物品最多选择一件，而在完全背包问题中，只要背包装得下，每件物品可以选择任意多件。从每件物品的角度来说，与之相关的策略已经不再是选或者不选了，而是有取0件、取1件、取2件...直到取⌊T/Vi⌋（向下取整）件。\n\n## 贪心算法\n\n看到可以选择任意多件，你也许会想，那还不容易，选性价比最高的就好了。\n\n![](https://i.loli.net/2019/03/14/5c8a564a63265.png)\n\n于是开启贪婪模式，把每种物品的价格除以体积来算出它们各自的性价比，然后只选择性价比最高的物品放入背包中。\n\n嗯，听起来好像没什么毛病，但仍旧有一个问题，那就是同一种物品虽然可以选择任意多件，但仍旧只能以件为单位，也就是说单个物品是无法拆分的，不能选择半件，只能多选一件或者少选一件。这样就造成了一个问题，往往无法用性价比最高的物品来装满整个背包，比如背包空间为10，性价比最高的物品占用空间为7，那么剩下的空间该如何填充呢？\n\n你当然会想到用性价比第二高的物品填充，如果仍旧无法填满，那就依次用第三、第四性价比物品来填充。\n\n听起来似乎可行，但我只需要举一个反例便能证明这个策略行不通。\n\n想要举反例很简单，比如只有两个物品：物品A：价值5，体积5，物品B：价值8：体积7，背包容量为10，物品B的性价比显然要比物品A高，那么用贪心算法必然会选择放入一个物品B，此时，剩余的空间已无法装下A或者B，所以得到的最高价值为8，而实际上，选择放入两个物品A即可得到更高的价值10。所以这里贪心算法并不适用。\n\n![](https://i.loli.net/2019/03/14/5c8a56a150bc1.png)\n\n## 递归法\n\n像上一篇中的那样，我们只需要找到递推关系式，就很容易使用递归解法来求解了。\n\n用ks(i,t)表示前i种物品放入一个容量为t的背包获得的最大价值，那么对于第i种物品，我们有k种选择，0 <= k * V[i] <= t，即可以选择0、1、2...k个第i种物品，所以递推表达式为：\n\n```\nks(i,t) = max{ks(i-1, t - V[i] * k) + P[i] * k}; （0 <= k * V[i] <= t）\n```\n\n同时，ks(0,t)=0;ks(i,0)=0;\n\n使用上面的栗子，我们可以先用递归来求解：\n\n```java\npublic static class Knapsack {\n    private static int[] P={0,5,8};\n    private static int[] V={0,5,7};\n    private static int T = 10;\n\n    @Test\n    public void soleve1() {\n        int result = ks(P.length - 1,10);\n        System.out.println(\"最大价值为：\" + result);\n    }\n\n    private int ks(int i, int t){\n        int result = 0;\n        if (i == 0 || t == 0){\n            // 初始条件\n            result = 0;\n        } else if(V[i] > t){\n            // 装不下该珠宝\n            result = ks(i-1, t);\n        } else {\n            // 可以装下\n            // 取k个物品i，取其中使得总价值最大的k\n            for (int k = 0; k * V[i] <= t; k++){\n                int tmp2 = ks(i-1, t - V[i] * k) + P[i] * k;\n                if (tmp2 > result){\n                    result = tmp2;\n                }\n            }\n        }\n        return result;\n    }\n}\n\n```\n\n同样，这里的数组P和V分别添加了一个元素0，是为了减少越界判断而做的简单处理，运行如下：\n\n```\n最大价值为：11\n```\n\n如果你对比一下01背包问题中的递归解法，就会发现唯一的区别便是这里多了一层循环，因为01背包中，对于第i个物品只有选和不选两种情况，只需要从这两种选择中选出最优的即可，而完全背包问题则需要在k种选择中选出最优解，这便是最内层循环在做的事情。\n\n```java\nfor (int k = 0; k * V[i] <= t; k++){\n    // 选取k个第i件商品的最优价值为tmp2\n    int tmp2 = ks(i-1, t - V[i] * k) + P[i] * k;\n    if (tmp2 > result){\n        // 从中拿出最大的值即为最优解\n        result = tmp2;\n    }\n}\n```\n\n## 最优化原理和无后效性\n\n那这个问题可以不可以像01背包问题一样使用动态规划来求解呢？来证明一下即可。\n\n首先，先用反证法证明最优化原理：\n\n假设完全背包的最优解为F(n1,n2,...,nN)（n1，n2 分别代表第1、第2件物品的选取数量），完全背包的子问题为，将前i种物品放入容量为t的背包并取得最大价值，其对应的解为：F(n1,n2,...,ni)，假设该解不是子问题的最优解，即存在另一组解F(m1,m2,...,mi)，使得F(m1,m2,...,mi) > F(n1,n2,...,ni)，那么F(m1,m2,...,mi,...,nN) 必然大于 F(n1,n2,...,nN)，因此 F(n1,n2,...,nN) 不是原问题的最优解，与原假设不符，所以F(n1,n2,...,ni)必然是子问题的最优解。\n\n再来看看无后效性：\n\n对于子问题的任意解，都不会影响后续子问题的解，也就是说，前i种物品如何选择，只要最终的剩余背包空间不变，就不会影响后面物品的选择。即满足无后效性。\n\n因此，完全背包问题也可以使用动态规划来解决。\n\n![](https://i.loli.net/2019/05/02/5ccaece849f09.png)\n\n## 动态规划\n\n既然知道了可以使用动态规划求解，接下来就是要找到这个问题的状态转移方程。\n\n其实前面的递推法中，已经找到了递推关系式，它便已经是我们需要的状态转移方程。\n\n### 自上而下记忆法\n\n```java\nks(i,t) = max{ks(i-1, t - V[i] * k) + P[i] * k}; （0 <= k * V[i] <= t）\n```\n\n```java\npublic static class Knapsack {\n    private static int[] P={0,5,8};\n    private static int[] V={0,5,7};\n    private static int T = 10;\n\n    private Integer[][] results = new Integer[P.length + 1][T + 1];\n\n    @Test\n    public void solve2() {\n        int result = ks2(P.length - 1,10);\n        System.out.println(\"最大价值为：\" + result);\n    }\n\n    private int ks2(int i, int t){\n        // 如果该结果已经被计算，那么直接返回\n        if (results[i][t] != null) return results[i][t];\n        int result = 0;\n        if (i == 0 || t == 0){\n            // 初始条件\n            result = 0;\n        } else if(V[i] > t){\n            // 装不下该珠宝\n            result = ks2(i-1, t);\n        } else {\n            // 可以装下\n            // 取k个物品，取其中使得价值最大的\n            for (int k = 0; k * V[i] <= t; k++){\n                int tmp2 = ks2(i-1, t - V[i] * k) + P[i] * k;\n                if (tmp2 > result){\n                    result = tmp2;\n                }\n            }\n        }\n        results[i][t] = result;\n        return result;\n    }\n}\n```\n\n找出递归解法后，动态规划的解法其实就很简单了，只是多使用了一个二维数组来存储中间的解。\n\n### 自下而上填表法\n\n最后，还可以使用填表法来解决，此时需要将数组P和V额外添加的元素0去掉。\n\n为了方便理解，还是再画一个图吧：\n\n{% asset_img IMG_5E156B07E228-1.jpeg img %}\n\n对于第i种物品，我们可以选择的目标其实是从上一层中的某几个位置挑选出价值最高的一个。\n\n{% asset_img IMG_6B67BF7CC3A7-1.jpeg img %}\n\n这里当t=10时，因为最多只能放得下1个i2物品，所以只需要将两个数值进行比较，如果t=14，那么就需要将取0个、1个和两个i2物品的情况进行比较，然后选出最大值。\n\n```java\npublic static class Knapsack {\n    private static int[] P={5,8};\n    private static int[] V={5,7};\n    private static int T = 10;\n\n    private int[][] dp = new int[P.length + 1][T + 1];\n\n    @Test\n    public void solve3() {\n        for (int i = 0; i < P.length; i++){\n            for (int j = 0; j <= T; j++){\n                for (int k = 0; k * V[i] <= j; k++){\n                    dp[i+1][j] = Math.max(dp[i+1][j], dp[i][j-k * V[i]] + k * P[i]);\n                }\n            }\n        }\n        System.out.println(\"最大价值为：\" + dp[P.length][T]);\n    }\n}\n```\n\n跟01背包问题一样，完全背包的空间复杂度也可以进行优化，具体思路这里就不重复介绍了，可以翻看前面的01背包问题优化篇。\n\n优化后的状态转移方程为：\n\n```\nks(t) = max{ks(t), ks(t - Vi) + Pi}\n```\n\n```java\npublic static class Knapsack {\n    private static int[] P={0,5,8};\n    private static int[] V={0,5,7};\n    private static int T = 10;\n\n    private int[] newResults = new int[T + 1];\n\n    @Test\n    public void resolve4() {\n        int result = ksp(P.length,T);\n        System.out.println(result);\n    }\n\n    private int ksp(int i, int t){\n        // 开始填表\n        for (int m = 0; m < i; m++){\n            for (int n = V[m]; n <= t; n++){\n                newResults[n] = Math.max(newResults[n] , newResults[n - V[m]] + P[m]);\n            }\n            // 可以在这里输出中间结果\n            System.out.println(JSON.toJSONString(newResults));\n        }\n        return newResults[newResults.length - 1];\n    }\n}\n```\n\n输出如下：\n\n```\n[0,0,0,0,0,0,0,0,0,0,0]\n[0,0,0,0,0,5,5,5,5,5,10]\n[0,0,0,0,0,5,5,8,8,8,10]\n10\n```\n\n其实完全背包问题也可以转化成01背包问题来求解，因为第i件物品最多选 ⌊T/Vi⌋(向下取整) 件，于是可以把第i种物品转化为⌊T/Vi⌋件体积和价值相同的物品，然后再来求解这个01背包问题。具体方法这里就不多说了，留给大家自行解决。如果遇到问题，可以翻开前面关于01背包问题的两篇文章。\n\n## 总结\n\n完全背包问题跟01背包有很多相似之处，比较一下他们的状态转移方程以及各种解法，就会发现他们其实是异父异母的亲兄弟。\n\n![](https://i.loli.net/2019/05/02/5ccaee9d39578.png)\n\n这两个背包问题的关键都在于状态转移方程的寻找，如果对于类似的问题没有思路，可以先尝试找出递归解法，然后自上而下的记忆法便水到渠成了。\n\n当然，最重要的还是解题思路，理解记忆法和填表法的精髓，有助于之后举一反三，去解决类似的延伸问题。\n\n关于完全背包问题的解析到此就结束了，祝大家五一愉快！\n\n![](https://i.loli.net/2019/03/14/5c8a580b1789e.png)\n\n如果有疑问或者有什么想法，也欢迎关注我的公众号进行留言交流：\n\n![](https://i.loli.net/2019/03/14/5c8a58ba229ca.png)","slug":"leetcode/complete-knapsack-problem","published":1,"updated":"2019-06-04T01:29:57.423Z","_id":"cjxze3gno000q0cvw8bbq0vax","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>在上一篇中，我们对01背包问题进行了比较深入的研究，这一篇里，我们来聊聊另一个背包问题：完全背包。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/02/5ccaec8a22bb9.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h2 id=\"完全背包\"><a href=\"#完全背包\" class=\"headerlink\" title=\"完全背包\"></a>完全背包</h2><p>有N种物品和一个容量为T的背包，每种物品都就可以选择任意多个，第i种物品的价值为P[i]，体积为V[i]，求解：选哪些物品放入背包，可以使得这些物品的价值最大，并且体积总和不超过背包容量。</p>\n<p>跟01背包一样，完全背包也是一个很经典的动态规划问题，不同的地方在于01背包问题中，每件物品最多选择一件，而在完全背包问题中，只要背包装得下，每件物品可以选择任意多件。从每件物品的角度来说，与之相关的策略已经不再是选或者不选了，而是有取0件、取1件、取2件…直到取⌊T/Vi⌋（向下取整）件。</p>\n<h2 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h2><p>看到可以选择任意多件，你也许会想，那还不容易，选性价比最高的就好了。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a564a63265.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>于是开启贪婪模式，把每种物品的价格除以体积来算出它们各自的性价比，然后只选择性价比最高的物品放入背包中。</p>\n<p>嗯，听起来好像没什么毛病，但仍旧有一个问题，那就是同一种物品虽然可以选择任意多件，但仍旧只能以件为单位，也就是说单个物品是无法拆分的，不能选择半件，只能多选一件或者少选一件。这样就造成了一个问题，往往无法用性价比最高的物品来装满整个背包，比如背包空间为10，性价比最高的物品占用空间为7，那么剩下的空间该如何填充呢？</p>\n<p>你当然会想到用性价比第二高的物品填充，如果仍旧无法填满，那就依次用第三、第四性价比物品来填充。</p>\n<p>听起来似乎可行，但我只需要举一个反例便能证明这个策略行不通。</p>\n<p>想要举反例很简单，比如只有两个物品：物品A：价值5，体积5，物品B：价值8：体积7，背包容量为10，物品B的性价比显然要比物品A高，那么用贪心算法必然会选择放入一个物品B，此时，剩余的空间已无法装下A或者B，所以得到的最高价值为8，而实际上，选择放入两个物品A即可得到更高的价值10。所以这里贪心算法并不适用。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a56a150bc1.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h2 id=\"递归法\"><a href=\"#递归法\" class=\"headerlink\" title=\"递归法\"></a>递归法</h2><p>像上一篇中的那样，我们只需要找到递推关系式，就很容易使用递归解法来求解了。</p>\n<p>用ks(i,t)表示前i种物品放入一个容量为t的背包获得的最大价值，那么对于第i种物品，我们有k种选择，0 &lt;= k * V[i] &lt;= t，即可以选择0、1、2…k个第i种物品，所以递推表达式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ks(i,t) = max&#123;ks(i-1, t - V[i] * k) + P[i] * k&#125;; （0 &lt;= k * V[i] &lt;= t）</span><br></pre></td></tr></table></figure>\n<p>同时，ks(0,t)=0;ks(i,0)=0;</p>\n<p>使用上面的栗子，我们可以先用递归来求解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Knapsack</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] P=&#123;<span class=\"number\">0</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] V=&#123;<span class=\"number\">0</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> T = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">soleve1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ks(P.length - <span class=\"number\">1</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"最大价值为：\"</span> + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">ks</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> t)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || t == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 初始条件</span></span><br><span class=\"line\">            result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(V[i] &gt; t)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 装不下该珠宝</span></span><br><span class=\"line\">            result = ks(i-<span class=\"number\">1</span>, t);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 可以装下</span></span><br><span class=\"line\">            <span class=\"comment\">// 取k个物品i，取其中使得总价值最大的k</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k * V[i] &lt;= t; k++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> tmp2 = ks(i-<span class=\"number\">1</span>, t - V[i] * k) + P[i] * k;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp2 &gt; result)&#123;</span><br><span class=\"line\">                    result = tmp2;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样，这里的数组P和V分别添加了一个元素0，是为了减少越界判断而做的简单处理，运行如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最大价值为：11</span><br></pre></td></tr></table></figure>\n<p>如果你对比一下01背包问题中的递归解法，就会发现唯一的区别便是这里多了一层循环，因为01背包中，对于第i个物品只有选和不选两种情况，只需要从这两种选择中选出最优的即可，而完全背包问题则需要在k种选择中选出最优解，这便是最内层循环在做的事情。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k * V[i] &lt;= t; k++)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 选取k个第i件商品的最优价值为tmp2</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp2 = ks(i-<span class=\"number\">1</span>, t - V[i] * k) + P[i] * k;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tmp2 &gt; result)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从中拿出最大的值即为最优解</span></span><br><span class=\"line\">        result = tmp2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"最优化原理和无后效性\"><a href=\"#最优化原理和无后效性\" class=\"headerlink\" title=\"最优化原理和无后效性\"></a>最优化原理和无后效性</h2><p>那这个问题可以不可以像01背包问题一样使用动态规划来求解呢？来证明一下即可。</p>\n<p>首先，先用反证法证明最优化原理：</p>\n<p>假设完全背包的最优解为F(n1,n2,…,nN)（n1，n2 分别代表第1、第2件物品的选取数量），完全背包的子问题为，将前i种物品放入容量为t的背包并取得最大价值，其对应的解为：F(n1,n2,…,ni)，假设该解不是子问题的最优解，即存在另一组解F(m1,m2,…,mi)，使得F(m1,m2,…,mi) &gt; F(n1,n2,…,ni)，那么F(m1,m2,…,mi,…,nN) 必然大于 F(n1,n2,…,nN)，因此 F(n1,n2,…,nN) 不是原问题的最优解，与原假设不符，所以F(n1,n2,…,ni)必然是子问题的最优解。</p>\n<p>再来看看无后效性：</p>\n<p>对于子问题的任意解，都不会影响后续子问题的解，也就是说，前i种物品如何选择，只要最终的剩余背包空间不变，就不会影响后面物品的选择。即满足无后效性。</p>\n<p>因此，完全背包问题也可以使用动态规划来解决。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/02/5ccaece849f09.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><p>既然知道了可以使用动态规划求解，接下来就是要找到这个问题的状态转移方程。</p>\n<p>其实前面的递推法中，已经找到了递推关系式，它便已经是我们需要的状态转移方程。</p>\n<h3 id=\"自上而下记忆法\"><a href=\"#自上而下记忆法\" class=\"headerlink\" title=\"自上而下记忆法\"></a>自上而下记忆法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ks(i,t) = max&#123;ks(i-<span class=\"number\">1</span>, t - V[i] * k) + P[i] * k&#125;; （<span class=\"number\">0</span> &lt;= k * V[i] &lt;= t）</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Knapsack</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] P=&#123;<span class=\"number\">0</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] V=&#123;<span class=\"number\">0</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> T = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer[][] results = <span class=\"keyword\">new</span> Integer[P.length + <span class=\"number\">1</span>][T + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">solve2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ks2(P.length - <span class=\"number\">1</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"最大价值为：\"</span> + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">ks2</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> t)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果该结果已经被计算，那么直接返回</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (results[i][t] != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> results[i][t];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || t == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 初始条件</span></span><br><span class=\"line\">            result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(V[i] &gt; t)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 装不下该珠宝</span></span><br><span class=\"line\">            result = ks2(i-<span class=\"number\">1</span>, t);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 可以装下</span></span><br><span class=\"line\">            <span class=\"comment\">// 取k个物品，取其中使得价值最大的</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k * V[i] &lt;= t; k++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> tmp2 = ks2(i-<span class=\"number\">1</span>, t - V[i] * k) + P[i] * k;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp2 &gt; result)&#123;</span><br><span class=\"line\">                    result = tmp2;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        results[i][t] = result;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>找出递归解法后，动态规划的解法其实就很简单了，只是多使用了一个二维数组来存储中间的解。</p>\n<h3 id=\"自下而上填表法\"><a href=\"#自下而上填表法\" class=\"headerlink\" title=\"自下而上填表法\"></a>自下而上填表法</h3><p>最后，还可以使用填表法来解决，此时需要将数组P和V额外添加的元素0去掉。</p>\n<p>为了方便理解，还是再画一个图吧：</p>\n<img src=\"/programming/leetcode/complete-knapsack-problem/IMG_5E156B07E228-1.jpeg\" title=\"img\">\n<p>对于第i种物品，我们可以选择的目标其实是从上一层中的某几个位置挑选出价值最高的一个。</p>\n<img src=\"/programming/leetcode/complete-knapsack-problem/IMG_6B67BF7CC3A7-1.jpeg\" title=\"img\">\n<p>这里当t=10时，因为最多只能放得下1个i2物品，所以只需要将两个数值进行比较，如果t=14，那么就需要将取0个、1个和两个i2物品的情况进行比较，然后选出最大值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Knapsack</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] P=&#123;<span class=\"number\">5</span>,<span class=\"number\">8</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] V=&#123;<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> T = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[P.length + <span class=\"number\">1</span>][T + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">solve3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; P.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= T; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k * V[i] &lt;= j; k++)&#123;</span><br><span class=\"line\">                    dp[i+<span class=\"number\">1</span>][j] = Math.max(dp[i+<span class=\"number\">1</span>][j], dp[i][j-k * V[i]] + k * P[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"最大价值为：\"</span> + dp[P.length][T]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>跟01背包问题一样，完全背包的空间复杂度也可以进行优化，具体思路这里就不重复介绍了，可以翻看前面的01背包问题优化篇。</p>\n<p>优化后的状态转移方程为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ks(t) = max&#123;ks(t), ks(t - Vi) + Pi&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Knapsack</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] P=&#123;<span class=\"number\">0</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] V=&#123;<span class=\"number\">0</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> T = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] newResults = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[T + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">resolve4</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ksp(P.length,T);</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">ksp</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> t)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 开始填表</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> m = <span class=\"number\">0</span>; m &lt; i; m++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> n = V[m]; n &lt;= t; n++)&#123;</span><br><span class=\"line\">                newResults[n] = Math.max(newResults[n] , newResults[n - V[m]] + P[m]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 可以在这里输出中间结果</span></span><br><span class=\"line\">            System.out.println(JSON.toJSONString(newResults));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newResults[newResults.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0,0,0,0,0,0,0,0,0,0,0]</span><br><span class=\"line\">[0,0,0,0,0,5,5,5,5,5,10]</span><br><span class=\"line\">[0,0,0,0,0,5,5,8,8,8,10]</span><br><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<p>其实完全背包问题也可以转化成01背包问题来求解，因为第i件物品最多选 ⌊T/Vi⌋(向下取整) 件，于是可以把第i种物品转化为⌊T/Vi⌋件体积和价值相同的物品，然后再来求解这个01背包问题。具体方法这里就不多说了，留给大家自行解决。如果遇到问题，可以翻开前面关于01背包问题的两篇文章。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>完全背包问题跟01背包有很多相似之处，比较一下他们的状态转移方程以及各种解法，就会发现他们其实是异父异母的亲兄弟。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/02/5ccaee9d39578.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>这两个背包问题的关键都在于状态转移方程的寻找，如果对于类似的问题没有思路，可以先尝试找出递归解法，然后自上而下的记忆法便水到渠成了。</p>\n<p>当然，最重要的还是解题思路，理解记忆法和填表法的精髓，有助于之后举一反三，去解决类似的延伸问题。</p>\n<p>关于完全背包问题的解析到此就结束了，祝大家五一愉快！</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a580b1789e.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>如果有疑问或者有什么想法，也欢迎关注我的公众号进行留言交流：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a58ba229ca.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>在上一篇中，我们对01背包问题进行了比较深入的研究，这一篇里，我们来聊聊另一个背包问题：完全背包。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/02/5ccaec8a22bb9.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h2 id=\"完全背包\"><a href=\"#完全背包\" class=\"headerlink\" title=\"完全背包\"></a>完全背包</h2><p>有N种物品和一个容量为T的背包，每种物品都就可以选择任意多个，第i种物品的价值为P[i]，体积为V[i]，求解：选哪些物品放入背包，可以使得这些物品的价值最大，并且体积总和不超过背包容量。</p>\n<p>跟01背包一样，完全背包也是一个很经典的动态规划问题，不同的地方在于01背包问题中，每件物品最多选择一件，而在完全背包问题中，只要背包装得下，每件物品可以选择任意多件。从每件物品的角度来说，与之相关的策略已经不再是选或者不选了，而是有取0件、取1件、取2件…直到取⌊T/Vi⌋（向下取整）件。</p>\n<h2 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h2><p>看到可以选择任意多件，你也许会想，那还不容易，选性价比最高的就好了。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a564a63265.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>于是开启贪婪模式，把每种物品的价格除以体积来算出它们各自的性价比，然后只选择性价比最高的物品放入背包中。</p>\n<p>嗯，听起来好像没什么毛病，但仍旧有一个问题，那就是同一种物品虽然可以选择任意多件，但仍旧只能以件为单位，也就是说单个物品是无法拆分的，不能选择半件，只能多选一件或者少选一件。这样就造成了一个问题，往往无法用性价比最高的物品来装满整个背包，比如背包空间为10，性价比最高的物品占用空间为7，那么剩下的空间该如何填充呢？</p>\n<p>你当然会想到用性价比第二高的物品填充，如果仍旧无法填满，那就依次用第三、第四性价比物品来填充。</p>\n<p>听起来似乎可行，但我只需要举一个反例便能证明这个策略行不通。</p>\n<p>想要举反例很简单，比如只有两个物品：物品A：价值5，体积5，物品B：价值8：体积7，背包容量为10，物品B的性价比显然要比物品A高，那么用贪心算法必然会选择放入一个物品B，此时，剩余的空间已无法装下A或者B，所以得到的最高价值为8，而实际上，选择放入两个物品A即可得到更高的价值10。所以这里贪心算法并不适用。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a56a150bc1.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h2 id=\"递归法\"><a href=\"#递归法\" class=\"headerlink\" title=\"递归法\"></a>递归法</h2><p>像上一篇中的那样，我们只需要找到递推关系式，就很容易使用递归解法来求解了。</p>\n<p>用ks(i,t)表示前i种物品放入一个容量为t的背包获得的最大价值，那么对于第i种物品，我们有k种选择，0 &lt;= k * V[i] &lt;= t，即可以选择0、1、2…k个第i种物品，所以递推表达式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ks(i,t) = max&#123;ks(i-1, t - V[i] * k) + P[i] * k&#125;; （0 &lt;= k * V[i] &lt;= t）</span><br></pre></td></tr></table></figure>\n<p>同时，ks(0,t)=0;ks(i,0)=0;</p>\n<p>使用上面的栗子，我们可以先用递归来求解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Knapsack</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] P=&#123;<span class=\"number\">0</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] V=&#123;<span class=\"number\">0</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> T = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">soleve1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ks(P.length - <span class=\"number\">1</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"最大价值为：\"</span> + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">ks</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> t)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || t == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 初始条件</span></span><br><span class=\"line\">            result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(V[i] &gt; t)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 装不下该珠宝</span></span><br><span class=\"line\">            result = ks(i-<span class=\"number\">1</span>, t);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 可以装下</span></span><br><span class=\"line\">            <span class=\"comment\">// 取k个物品i，取其中使得总价值最大的k</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k * V[i] &lt;= t; k++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> tmp2 = ks(i-<span class=\"number\">1</span>, t - V[i] * k) + P[i] * k;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp2 &gt; result)&#123;</span><br><span class=\"line\">                    result = tmp2;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样，这里的数组P和V分别添加了一个元素0，是为了减少越界判断而做的简单处理，运行如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最大价值为：11</span><br></pre></td></tr></table></figure>\n<p>如果你对比一下01背包问题中的递归解法，就会发现唯一的区别便是这里多了一层循环，因为01背包中，对于第i个物品只有选和不选两种情况，只需要从这两种选择中选出最优的即可，而完全背包问题则需要在k种选择中选出最优解，这便是最内层循环在做的事情。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k * V[i] &lt;= t; k++)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 选取k个第i件商品的最优价值为tmp2</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp2 = ks(i-<span class=\"number\">1</span>, t - V[i] * k) + P[i] * k;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tmp2 &gt; result)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从中拿出最大的值即为最优解</span></span><br><span class=\"line\">        result = tmp2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"最优化原理和无后效性\"><a href=\"#最优化原理和无后效性\" class=\"headerlink\" title=\"最优化原理和无后效性\"></a>最优化原理和无后效性</h2><p>那这个问题可以不可以像01背包问题一样使用动态规划来求解呢？来证明一下即可。</p>\n<p>首先，先用反证法证明最优化原理：</p>\n<p>假设完全背包的最优解为F(n1,n2,…,nN)（n1，n2 分别代表第1、第2件物品的选取数量），完全背包的子问题为，将前i种物品放入容量为t的背包并取得最大价值，其对应的解为：F(n1,n2,…,ni)，假设该解不是子问题的最优解，即存在另一组解F(m1,m2,…,mi)，使得F(m1,m2,…,mi) &gt; F(n1,n2,…,ni)，那么F(m1,m2,…,mi,…,nN) 必然大于 F(n1,n2,…,nN)，因此 F(n1,n2,…,nN) 不是原问题的最优解，与原假设不符，所以F(n1,n2,…,ni)必然是子问题的最优解。</p>\n<p>再来看看无后效性：</p>\n<p>对于子问题的任意解，都不会影响后续子问题的解，也就是说，前i种物品如何选择，只要最终的剩余背包空间不变，就不会影响后面物品的选择。即满足无后效性。</p>\n<p>因此，完全背包问题也可以使用动态规划来解决。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/02/5ccaece849f09.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><p>既然知道了可以使用动态规划求解，接下来就是要找到这个问题的状态转移方程。</p>\n<p>其实前面的递推法中，已经找到了递推关系式，它便已经是我们需要的状态转移方程。</p>\n<h3 id=\"自上而下记忆法\"><a href=\"#自上而下记忆法\" class=\"headerlink\" title=\"自上而下记忆法\"></a>自上而下记忆法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ks(i,t) = max&#123;ks(i-<span class=\"number\">1</span>, t - V[i] * k) + P[i] * k&#125;; （<span class=\"number\">0</span> &lt;= k * V[i] &lt;= t）</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Knapsack</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] P=&#123;<span class=\"number\">0</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] V=&#123;<span class=\"number\">0</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> T = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer[][] results = <span class=\"keyword\">new</span> Integer[P.length + <span class=\"number\">1</span>][T + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">solve2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ks2(P.length - <span class=\"number\">1</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"最大价值为：\"</span> + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">ks2</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> t)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果该结果已经被计算，那么直接返回</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (results[i][t] != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> results[i][t];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || t == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 初始条件</span></span><br><span class=\"line\">            result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(V[i] &gt; t)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 装不下该珠宝</span></span><br><span class=\"line\">            result = ks2(i-<span class=\"number\">1</span>, t);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 可以装下</span></span><br><span class=\"line\">            <span class=\"comment\">// 取k个物品，取其中使得价值最大的</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k * V[i] &lt;= t; k++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> tmp2 = ks2(i-<span class=\"number\">1</span>, t - V[i] * k) + P[i] * k;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp2 &gt; result)&#123;</span><br><span class=\"line\">                    result = tmp2;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        results[i][t] = result;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>找出递归解法后，动态规划的解法其实就很简单了，只是多使用了一个二维数组来存储中间的解。</p>\n<h3 id=\"自下而上填表法\"><a href=\"#自下而上填表法\" class=\"headerlink\" title=\"自下而上填表法\"></a>自下而上填表法</h3><p>最后，还可以使用填表法来解决，此时需要将数组P和V额外添加的元素0去掉。</p>\n<p>为了方便理解，还是再画一个图吧：</p>\n<img src=\"/programming/leetcode/complete-knapsack-problem/IMG_5E156B07E228-1.jpeg\" title=\"img\">\n<p>对于第i种物品，我们可以选择的目标其实是从上一层中的某几个位置挑选出价值最高的一个。</p>\n<img src=\"/programming/leetcode/complete-knapsack-problem/IMG_6B67BF7CC3A7-1.jpeg\" title=\"img\">\n<p>这里当t=10时，因为最多只能放得下1个i2物品，所以只需要将两个数值进行比较，如果t=14，那么就需要将取0个、1个和两个i2物品的情况进行比较，然后选出最大值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Knapsack</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] P=&#123;<span class=\"number\">5</span>,<span class=\"number\">8</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] V=&#123;<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> T = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[P.length + <span class=\"number\">1</span>][T + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">solve3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; P.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= T; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k * V[i] &lt;= j; k++)&#123;</span><br><span class=\"line\">                    dp[i+<span class=\"number\">1</span>][j] = Math.max(dp[i+<span class=\"number\">1</span>][j], dp[i][j-k * V[i]] + k * P[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"最大价值为：\"</span> + dp[P.length][T]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>跟01背包问题一样，完全背包的空间复杂度也可以进行优化，具体思路这里就不重复介绍了，可以翻看前面的01背包问题优化篇。</p>\n<p>优化后的状态转移方程为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ks(t) = max&#123;ks(t), ks(t - Vi) + Pi&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Knapsack</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] P=&#123;<span class=\"number\">0</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] V=&#123;<span class=\"number\">0</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> T = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] newResults = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[T + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">resolve4</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ksp(P.length,T);</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">ksp</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> t)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 开始填表</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> m = <span class=\"number\">0</span>; m &lt; i; m++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> n = V[m]; n &lt;= t; n++)&#123;</span><br><span class=\"line\">                newResults[n] = Math.max(newResults[n] , newResults[n - V[m]] + P[m]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 可以在这里输出中间结果</span></span><br><span class=\"line\">            System.out.println(JSON.toJSONString(newResults));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newResults[newResults.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0,0,0,0,0,0,0,0,0,0,0]</span><br><span class=\"line\">[0,0,0,0,0,5,5,5,5,5,10]</span><br><span class=\"line\">[0,0,0,0,0,5,5,8,8,8,10]</span><br><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<p>其实完全背包问题也可以转化成01背包问题来求解，因为第i件物品最多选 ⌊T/Vi⌋(向下取整) 件，于是可以把第i种物品转化为⌊T/Vi⌋件体积和价值相同的物品，然后再来求解这个01背包问题。具体方法这里就不多说了，留给大家自行解决。如果遇到问题，可以翻开前面关于01背包问题的两篇文章。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>完全背包问题跟01背包有很多相似之处，比较一下他们的状态转移方程以及各种解法，就会发现他们其实是异父异母的亲兄弟。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/02/5ccaee9d39578.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>这两个背包问题的关键都在于状态转移方程的寻找，如果对于类似的问题没有思路，可以先尝试找出递归解法，然后自上而下的记忆法便水到渠成了。</p>\n<p>当然，最重要的还是解题思路，理解记忆法和填表法的精髓，有助于之后举一反三，去解决类似的延伸问题。</p>\n<p>关于完全背包问题的解析到此就结束了，祝大家五一愉快！</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a580b1789e.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>如果有疑问或者有什么想法，也欢迎关注我的公众号进行留言交流：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a58ba229ca.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>"},{"title":"【LeetCode】两数相加","date":"2019-01-06T12:00:00.000Z","_content":"\n## 题目描述\n\n给出两个`非空`的链表用来表示两个非负的整数。其中，它们各自的位数是按照`逆序`的方式存储的，并且它们的每个节点只能存储`一位`数字。\n\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n\n您可以假设除了数字`0`之外，这两个数都不会以`0`开头。\n\n示例：\n\n```bash\n输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)\n输出：7 -> 0 -> 8\n原因：342 + 465 = 807\n```\n\n## 题目解析\n\n这个题目的意思看起来其实很简单，提供了两个链表，每个链表代表一个非负整数，它们各自的位数是按照`逆序`方式存储的，例如：`(2 -> 4 -> 3)`代表整数`342`，`(5 -> 6 -> 4)`则代表整数`465`，两数相加的结果自然是807，这就是我们要给出的答案，但是要用链表的形式返回`7 -> 0 -> 8`。题目中说明了是非空链表，所以就不用考虑链表为null的情况了。\n\n乍眼一看，很简单啊，不就是把两个数相加嘛，我先把它整成整数，然后相加，最后把结果整成链表，完美，哈哈哈哈，简直被自己的聪明才智给折服。\n\n### 翻车尝试1：虾扯蛋法\n\n```java\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode head1 = l1;\n        ListNode head2 = l2;\n        int i = 0;\n        int j = 0;\n        int index = 0;\n        // 将链表l1转化为整数\n        while (head1 != null) {\n            i += head1.val * Math.pow(10, index);\n            index++;\n            head1 = head1.next;\n        }\n        index = 0;\n        // 将链表l2转化为整数\n        while (head2 != null) {\n            j += head2.val * Math.pow(10, index);\n            index++;\n            head2 = head2.next;\n        }\n        int sum = i + j;\n        ListNode newHead = new ListNode(0);\n        ListNode tmpHead = newHead;\n        int sign = 0;\n        // 将结果转化为链表\n        while (sum > 0 || sign == 0) {\n            int tmp = sum % 10;\n            sum = sum / 10;\n            tmpHead.next = new ListNode(tmp);\n            tmpHead = tmpHead.next;\n            sign++;\n        }\n        return newHead.next;\n    }\n}\n```\n\n简直轻松加愉快，让我们来提交一下。\n\n{% asset_img solution-1.png solution-1 %}\n\n![](/images/black_smile.png)\n\n怎么肥四，小老弟，翻车了啊。让我们看看错误原因：\n\n```bash\n输入：\n[9]\n[1,9,9,9,9,9,9,9,9,9]\n输出：\n[0]\n预期：\n[0,0,0,0,0,0,0,0,0,0,1]\n```\n\n看样子应该是整数型溢出了。。。难不倒我，改成long型不就完事了。\n\n### 翻车尝试2：虾扯蛋升级法\n\n```java\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode head1 = l1;\n        ListNode head2 = l2;\n        long i = 0;\n        long j = 0;\n        long index = 0;\n        while (head1 != null) {\n            i += head1.val * Math.pow(10, index);\n            index++;\n            head1 = head1.next;\n        }\n        index = 0;\n        while (head2 != null) {\n            j += head2.val * Math.pow(10, index);\n            index++;\n            head2 = head2.next;\n        }\n        long sum = i + j;\n        ListNode newHead = new ListNode(0);\n        ListNode tmpHead = newHead;\n        int sign = 0;\n        while (sum > 0 || sign == 0) {\n            int tmp = (int)(sum % 10);\n            sum = sum / 10;\n            tmpHead.next = new ListNode(tmp);\n            tmpHead = tmpHead.next;\n            sign++;\n        }\n        return newHead.next;\n    }\n}\n```\n这次总没事了吧，再提交一下：\n\n{% asset_img solution-2.png solution-2 %}\n\n![](/images/black_smile-2.png)\n\n这个磨人的小妖精，整出个这么大的数来折腾我，long型也溢出了。。。\n\n逼我用绝招，是时候祭出我的`BigInteger`了。\n\n### 翻车尝试3：虾扯蛋终极法\n\n```java\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode head1 = l1;\n        ListNode head2 = l2;\n        BigInteger i = new BigInteger(0);\n        BigInteger j = new BigInteger(0);\n        long index = 0;\n        while (head1 != null) {\n            i.add(BigInteger.valueOf(head1.val * Math.pow(10, index)));\n            index++;\n            head1 = head1.next;\n        }\n        index = 0;\n        while (head2 != null) {\n            j.add(BigInteger.valueOf(head2.val * Math.pow(10, index)));\n            index++;\n            head2 = head2.next;\n        }\n        BigInteger sum = i.add(j);\n        ListNode newHead = new ListNode(0);\n        ListNode tmpHead = newHead;\n        int sign = 0;\n        while (sum.compareTo(0) == 1 || sign == 0) {\n            int tmp = sum.mod(10).intValue();\n            sum = sum.divide(10);\n            tmpHead.next = new ListNode(tmp);\n            tmpHead = tmpHead.next;\n            sign++;\n        }\n        return newHead.next;\n    }\n}\n```\n\n这次，连编译都不通过了，emmmm，看来不准用`BigInteger`这个类。\n\n{% asset_img solution-3.png solution-3 %}\n\n## 常规解法\n\n既然邪门歪道走不通，那就还是用常规操作来解决吧，仔细想想，其实也很简单，我们从两个链表的头节点开始，一起遍历，将相加得到的结果存入新的链表中即可。\n\n{% asset_img solution-4.png solution-4 %}\n\n这里需要注意的就是要考虑进位的情况，比如：`4 + 6 = 10`，那么在处理后一个节点`3 + 4`的时候，需要再加1，因此需要有一个进位标志来表示是否需要进位。\n\n另外，两个链表的长度并不一定相等，需要考虑像上面那样一个很长，一个很短，而且后续一直进位的情况：\n\n```bash\n[9]\n[1,9,9,9,9,9,9,9,9,9]\n```\n\n所以我们可以定义一个叫`carry`的变量来表示是否需要进位。\n\n```java\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode head1 = l1;\n        ListNode head2 = l2;\n        ListNode newHead = new ListNode(0);\n        ListNode head3 = newHead;\n        // 进位标志\n        boolean carry = false;\n        while (head1 != null || head2 != null) {\n            // 获取对应位置的值然后相加\n            int x = (head1 != null) ? head1.val : 0;\n            int y = (head2 != null) ? head2.val : 0;\n            int sum = carry ? (x + y + 1) : (x + y);\n            // 处理进位\n            if (sum >= 10){\n                sum -= 10;\n                carry = true;\n            } else {\n                carry = false;\n            }\n            // 新增节点\n            head3.next = new ListNode(sum % 10);\n            head3 = head3.next;\n            if (head1 != null) head1 = head1.next;\n            if (head2 != null) head2 = head2.next;\n        }\n        if (carry) {\n            head3.next = new ListNode(1);\n        }\n        return newHead.next;\n    }\n}\n```\n\n{% asset_img result-5.png result-5 %}\n\n嗯，这下就没什么问题了。😜\n\n[本题中文版链接](https://leetcode-cn.com/problems/add-two-numbers/)\n\n[本题英文版链接](https://leetcode.com/problems/add-two-numbers/)\n\n如果你有更好的解法，欢迎留言讨论~","source":"_posts/leetcode/day2-add-two-numbers.md","raw":"---\ntitle: 【LeetCode】两数相加\ntags: \n - Java\n - 算法\n - LeetCode\ncategories: 编程\ndate: 2019-01-06 20:00:00\n---\n\n## 题目描述\n\n给出两个`非空`的链表用来表示两个非负的整数。其中，它们各自的位数是按照`逆序`的方式存储的，并且它们的每个节点只能存储`一位`数字。\n\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n\n您可以假设除了数字`0`之外，这两个数都不会以`0`开头。\n\n示例：\n\n```bash\n输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)\n输出：7 -> 0 -> 8\n原因：342 + 465 = 807\n```\n\n## 题目解析\n\n这个题目的意思看起来其实很简单，提供了两个链表，每个链表代表一个非负整数，它们各自的位数是按照`逆序`方式存储的，例如：`(2 -> 4 -> 3)`代表整数`342`，`(5 -> 6 -> 4)`则代表整数`465`，两数相加的结果自然是807，这就是我们要给出的答案，但是要用链表的形式返回`7 -> 0 -> 8`。题目中说明了是非空链表，所以就不用考虑链表为null的情况了。\n\n乍眼一看，很简单啊，不就是把两个数相加嘛，我先把它整成整数，然后相加，最后把结果整成链表，完美，哈哈哈哈，简直被自己的聪明才智给折服。\n\n### 翻车尝试1：虾扯蛋法\n\n```java\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode head1 = l1;\n        ListNode head2 = l2;\n        int i = 0;\n        int j = 0;\n        int index = 0;\n        // 将链表l1转化为整数\n        while (head1 != null) {\n            i += head1.val * Math.pow(10, index);\n            index++;\n            head1 = head1.next;\n        }\n        index = 0;\n        // 将链表l2转化为整数\n        while (head2 != null) {\n            j += head2.val * Math.pow(10, index);\n            index++;\n            head2 = head2.next;\n        }\n        int sum = i + j;\n        ListNode newHead = new ListNode(0);\n        ListNode tmpHead = newHead;\n        int sign = 0;\n        // 将结果转化为链表\n        while (sum > 0 || sign == 0) {\n            int tmp = sum % 10;\n            sum = sum / 10;\n            tmpHead.next = new ListNode(tmp);\n            tmpHead = tmpHead.next;\n            sign++;\n        }\n        return newHead.next;\n    }\n}\n```\n\n简直轻松加愉快，让我们来提交一下。\n\n{% asset_img solution-1.png solution-1 %}\n\n![](/images/black_smile.png)\n\n怎么肥四，小老弟，翻车了啊。让我们看看错误原因：\n\n```bash\n输入：\n[9]\n[1,9,9,9,9,9,9,9,9,9]\n输出：\n[0]\n预期：\n[0,0,0,0,0,0,0,0,0,0,1]\n```\n\n看样子应该是整数型溢出了。。。难不倒我，改成long型不就完事了。\n\n### 翻车尝试2：虾扯蛋升级法\n\n```java\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode head1 = l1;\n        ListNode head2 = l2;\n        long i = 0;\n        long j = 0;\n        long index = 0;\n        while (head1 != null) {\n            i += head1.val * Math.pow(10, index);\n            index++;\n            head1 = head1.next;\n        }\n        index = 0;\n        while (head2 != null) {\n            j += head2.val * Math.pow(10, index);\n            index++;\n            head2 = head2.next;\n        }\n        long sum = i + j;\n        ListNode newHead = new ListNode(0);\n        ListNode tmpHead = newHead;\n        int sign = 0;\n        while (sum > 0 || sign == 0) {\n            int tmp = (int)(sum % 10);\n            sum = sum / 10;\n            tmpHead.next = new ListNode(tmp);\n            tmpHead = tmpHead.next;\n            sign++;\n        }\n        return newHead.next;\n    }\n}\n```\n这次总没事了吧，再提交一下：\n\n{% asset_img solution-2.png solution-2 %}\n\n![](/images/black_smile-2.png)\n\n这个磨人的小妖精，整出个这么大的数来折腾我，long型也溢出了。。。\n\n逼我用绝招，是时候祭出我的`BigInteger`了。\n\n### 翻车尝试3：虾扯蛋终极法\n\n```java\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode head1 = l1;\n        ListNode head2 = l2;\n        BigInteger i = new BigInteger(0);\n        BigInteger j = new BigInteger(0);\n        long index = 0;\n        while (head1 != null) {\n            i.add(BigInteger.valueOf(head1.val * Math.pow(10, index)));\n            index++;\n            head1 = head1.next;\n        }\n        index = 0;\n        while (head2 != null) {\n            j.add(BigInteger.valueOf(head2.val * Math.pow(10, index)));\n            index++;\n            head2 = head2.next;\n        }\n        BigInteger sum = i.add(j);\n        ListNode newHead = new ListNode(0);\n        ListNode tmpHead = newHead;\n        int sign = 0;\n        while (sum.compareTo(0) == 1 || sign == 0) {\n            int tmp = sum.mod(10).intValue();\n            sum = sum.divide(10);\n            tmpHead.next = new ListNode(tmp);\n            tmpHead = tmpHead.next;\n            sign++;\n        }\n        return newHead.next;\n    }\n}\n```\n\n这次，连编译都不通过了，emmmm，看来不准用`BigInteger`这个类。\n\n{% asset_img solution-3.png solution-3 %}\n\n## 常规解法\n\n既然邪门歪道走不通，那就还是用常规操作来解决吧，仔细想想，其实也很简单，我们从两个链表的头节点开始，一起遍历，将相加得到的结果存入新的链表中即可。\n\n{% asset_img solution-4.png solution-4 %}\n\n这里需要注意的就是要考虑进位的情况，比如：`4 + 6 = 10`，那么在处理后一个节点`3 + 4`的时候，需要再加1，因此需要有一个进位标志来表示是否需要进位。\n\n另外，两个链表的长度并不一定相等，需要考虑像上面那样一个很长，一个很短，而且后续一直进位的情况：\n\n```bash\n[9]\n[1,9,9,9,9,9,9,9,9,9]\n```\n\n所以我们可以定义一个叫`carry`的变量来表示是否需要进位。\n\n```java\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode head1 = l1;\n        ListNode head2 = l2;\n        ListNode newHead = new ListNode(0);\n        ListNode head3 = newHead;\n        // 进位标志\n        boolean carry = false;\n        while (head1 != null || head2 != null) {\n            // 获取对应位置的值然后相加\n            int x = (head1 != null) ? head1.val : 0;\n            int y = (head2 != null) ? head2.val : 0;\n            int sum = carry ? (x + y + 1) : (x + y);\n            // 处理进位\n            if (sum >= 10){\n                sum -= 10;\n                carry = true;\n            } else {\n                carry = false;\n            }\n            // 新增节点\n            head3.next = new ListNode(sum % 10);\n            head3 = head3.next;\n            if (head1 != null) head1 = head1.next;\n            if (head2 != null) head2 = head2.next;\n        }\n        if (carry) {\n            head3.next = new ListNode(1);\n        }\n        return newHead.next;\n    }\n}\n```\n\n{% asset_img result-5.png result-5 %}\n\n嗯，这下就没什么问题了。😜\n\n[本题中文版链接](https://leetcode-cn.com/problems/add-two-numbers/)\n\n[本题英文版链接](https://leetcode.com/problems/add-two-numbers/)\n\n如果你有更好的解法，欢迎留言讨论~","slug":"leetcode/day2-add-two-numbers","published":1,"updated":"2019-06-04T01:29:57.430Z","_id":"cjxze3gno000r0cvwwkqf9oyy","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给出两个<code>非空</code>的链表用来表示两个非负的整数。其中，它们各自的位数是按照<code>逆序</code>的方式存储的，并且它们的每个节点只能存储<code>一位</code>数字。</p>\n<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>\n<p>您可以假设除了数字<code>0</code>之外，这两个数都不会以<code>0</code>开头。</p>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class=\"line\">输出：7 -&gt; 0 -&gt; 8</span><br><span class=\"line\">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure>\n<h2 id=\"题目解析\"><a href=\"#题目解析\" class=\"headerlink\" title=\"题目解析\"></a>题目解析</h2><p>这个题目的意思看起来其实很简单，提供了两个链表，每个链表代表一个非负整数，它们各自的位数是按照<code>逆序</code>方式存储的，例如：<code>(2 -&gt; 4 -&gt; 3)</code>代表整数<code>342</code>，<code>(5 -&gt; 6 -&gt; 4)</code>则代表整数<code>465</code>，两数相加的结果自然是807，这就是我们要给出的答案，但是要用链表的形式返回<code>7 -&gt; 0 -&gt; 8</code>。题目中说明了是非空链表，所以就不用考虑链表为null的情况了。</p>\n<p>乍眼一看，很简单啊，不就是把两个数相加嘛，我先把它整成整数，然后相加，最后把结果整成链表，完美，哈哈哈哈，简直被自己的聪明才智给折服。</p>\n<h3 id=\"翻车尝试1：虾扯蛋法\"><a href=\"#翻车尝试1：虾扯蛋法\" class=\"headerlink\" title=\"翻车尝试1：虾扯蛋法\"></a>翻车尝试1：虾扯蛋法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        ListNode head1 = l1;</span><br><span class=\"line\">        ListNode head2 = l2;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 将链表l1转化为整数</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head1 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            i += head1.val * Math.pow(<span class=\"number\">10</span>, index);</span><br><span class=\"line\">            index++;</span><br><span class=\"line\">            head1 = head1.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 将链表l2转化为整数</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            j += head2.val * Math.pow(<span class=\"number\">10</span>, index);</span><br><span class=\"line\">            index++;</span><br><span class=\"line\">            head2 = head2.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = i + j;</span><br><span class=\"line\">        ListNode newHead = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode tmpHead = newHead;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sign = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 将结果转化为链表</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (sum &gt; <span class=\"number\">0</span> || sign == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = sum % <span class=\"number\">10</span>;</span><br><span class=\"line\">            sum = sum / <span class=\"number\">10</span>;</span><br><span class=\"line\">            tmpHead.next = <span class=\"keyword\">new</span> ListNode(tmp);</span><br><span class=\"line\">            tmpHead = tmpHead.next;</span><br><span class=\"line\">            sign++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newHead.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简直轻松加愉快，让我们来提交一下。</p>\n<img src=\"/programming/leetcode/day2-add-two-numbers/solution-1.png\" title=\"solution-1\">\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"/images/black_smile.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>怎么肥四，小老弟，翻车了啊。让我们看看错误原因：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[9]</span><br><span class=\"line\">[1,9,9,9,9,9,9,9,9,9]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[0]</span><br><span class=\"line\">预期：</span><br><span class=\"line\">[0,0,0,0,0,0,0,0,0,0,1]</span><br></pre></td></tr></table></figure>\n<p>看样子应该是整数型溢出了。。。难不倒我，改成long型不就完事了。</p>\n<h3 id=\"翻车尝试2：虾扯蛋升级法\"><a href=\"#翻车尝试2：虾扯蛋升级法\" class=\"headerlink\" title=\"翻车尝试2：虾扯蛋升级法\"></a>翻车尝试2：虾扯蛋升级法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        ListNode head1 = l1;</span><br><span class=\"line\">        ListNode head2 = l2;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head1 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            i += head1.val * Math.pow(<span class=\"number\">10</span>, index);</span><br><span class=\"line\">            index++;</span><br><span class=\"line\">            head1 = head1.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            j += head2.val * Math.pow(<span class=\"number\">10</span>, index);</span><br><span class=\"line\">            index++;</span><br><span class=\"line\">            head2 = head2.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> sum = i + j;</span><br><span class=\"line\">        ListNode newHead = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode tmpHead = newHead;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sign = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (sum &gt; <span class=\"number\">0</span> || sign == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = (<span class=\"keyword\">int</span>)(sum % <span class=\"number\">10</span>);</span><br><span class=\"line\">            sum = sum / <span class=\"number\">10</span>;</span><br><span class=\"line\">            tmpHead.next = <span class=\"keyword\">new</span> ListNode(tmp);</span><br><span class=\"line\">            tmpHead = tmpHead.next;</span><br><span class=\"line\">            sign++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newHead.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这次总没事了吧，再提交一下：</p>\n<img src=\"/programming/leetcode/day2-add-two-numbers/solution-2.png\" title=\"solution-2\">\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"/images/black_smile-2.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>这个磨人的小妖精，整出个这么大的数来折腾我，long型也溢出了。。。</p>\n<p>逼我用绝招，是时候祭出我的<code>BigInteger</code>了。</p>\n<h3 id=\"翻车尝试3：虾扯蛋终极法\"><a href=\"#翻车尝试3：虾扯蛋终极法\" class=\"headerlink\" title=\"翻车尝试3：虾扯蛋终极法\"></a>翻车尝试3：虾扯蛋终极法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        ListNode head1 = l1;</span><br><span class=\"line\">        ListNode head2 = l2;</span><br><span class=\"line\">        BigInteger i = <span class=\"keyword\">new</span> BigInteger(<span class=\"number\">0</span>);</span><br><span class=\"line\">        BigInteger j = <span class=\"keyword\">new</span> BigInteger(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head1 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            i.add(BigInteger.valueOf(head1.val * Math.pow(<span class=\"number\">10</span>, index)));</span><br><span class=\"line\">            index++;</span><br><span class=\"line\">            head1 = head1.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            j.add(BigInteger.valueOf(head2.val * Math.pow(<span class=\"number\">10</span>, index)));</span><br><span class=\"line\">            index++;</span><br><span class=\"line\">            head2 = head2.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        BigInteger sum = i.add(j);</span><br><span class=\"line\">        ListNode newHead = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode tmpHead = newHead;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sign = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (sum.compareTo(<span class=\"number\">0</span>) == <span class=\"number\">1</span> || sign == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = sum.mod(<span class=\"number\">10</span>).intValue();</span><br><span class=\"line\">            sum = sum.divide(<span class=\"number\">10</span>);</span><br><span class=\"line\">            tmpHead.next = <span class=\"keyword\">new</span> ListNode(tmp);</span><br><span class=\"line\">            tmpHead = tmpHead.next;</span><br><span class=\"line\">            sign++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newHead.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这次，连编译都不通过了，emmmm，看来不准用<code>BigInteger</code>这个类。</p>\n<img src=\"/programming/leetcode/day2-add-two-numbers/solution-3.png\" title=\"solution-3\">\n<h2 id=\"常规解法\"><a href=\"#常规解法\" class=\"headerlink\" title=\"常规解法\"></a>常规解法</h2><p>既然邪门歪道走不通，那就还是用常规操作来解决吧，仔细想想，其实也很简单，我们从两个链表的头节点开始，一起遍历，将相加得到的结果存入新的链表中即可。</p>\n<img src=\"/programming/leetcode/day2-add-two-numbers/solution-4.png\" title=\"solution-4\">\n<p>这里需要注意的就是要考虑进位的情况，比如：<code>4 + 6 = 10</code>，那么在处理后一个节点<code>3 + 4</code>的时候，需要再加1，因此需要有一个进位标志来表示是否需要进位。</p>\n<p>另外，两个链表的长度并不一定相等，需要考虑像上面那样一个很长，一个很短，而且后续一直进位的情况：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[9]</span><br><span class=\"line\">[1,9,9,9,9,9,9,9,9,9]</span><br></pre></td></tr></table></figure>\n<p>所以我们可以定义一个叫<code>carry</code>的变量来表示是否需要进位。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        ListNode head1 = l1;</span><br><span class=\"line\">        ListNode head2 = l2;</span><br><span class=\"line\">        ListNode newHead = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode head3 = newHead;</span><br><span class=\"line\">        <span class=\"comment\">// 进位标志</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> carry = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head1 != <span class=\"keyword\">null</span> || head2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取对应位置的值然后相加</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> x = (head1 != <span class=\"keyword\">null</span>) ? head1.val : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> y = (head2 != <span class=\"keyword\">null</span>) ? head2.val : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = carry ? (x + y + <span class=\"number\">1</span>) : (x + y);</span><br><span class=\"line\">            <span class=\"comment\">// 处理进位</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum &gt;= <span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">                sum -= <span class=\"number\">10</span>;</span><br><span class=\"line\">                carry = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                carry = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 新增节点</span></span><br><span class=\"line\">            head3.next = <span class=\"keyword\">new</span> ListNode(sum % <span class=\"number\">10</span>);</span><br><span class=\"line\">            head3 = head3.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (head1 != <span class=\"keyword\">null</span>) head1 = head1.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (head2 != <span class=\"keyword\">null</span>) head2 = head2.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (carry) &#123;</span><br><span class=\"line\">            head3.next = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newHead.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/programming/leetcode/day2-add-two-numbers/result-5.png\" title=\"result-5\">\n<p>嗯，这下就没什么问题了。😜</p>\n<p><a href=\"https://leetcode-cn.com/problems/add-two-numbers/\" target=\"_blank\" rel=\"noopener\">本题中文版链接</a></p>\n<p><a href=\"https://leetcode.com/problems/add-two-numbers/\" target=\"_blank\" rel=\"noopener\">本题英文版链接</a></p>\n<p>如果你有更好的解法，欢迎留言讨论~</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给出两个<code>非空</code>的链表用来表示两个非负的整数。其中，它们各自的位数是按照<code>逆序</code>的方式存储的，并且它们的每个节点只能存储<code>一位</code>数字。</p>\n<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>\n<p>您可以假设除了数字<code>0</code>之外，这两个数都不会以<code>0</code>开头。</p>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class=\"line\">输出：7 -&gt; 0 -&gt; 8</span><br><span class=\"line\">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure>\n<h2 id=\"题目解析\"><a href=\"#题目解析\" class=\"headerlink\" title=\"题目解析\"></a>题目解析</h2><p>这个题目的意思看起来其实很简单，提供了两个链表，每个链表代表一个非负整数，它们各自的位数是按照<code>逆序</code>方式存储的，例如：<code>(2 -&gt; 4 -&gt; 3)</code>代表整数<code>342</code>，<code>(5 -&gt; 6 -&gt; 4)</code>则代表整数<code>465</code>，两数相加的结果自然是807，这就是我们要给出的答案，但是要用链表的形式返回<code>7 -&gt; 0 -&gt; 8</code>。题目中说明了是非空链表，所以就不用考虑链表为null的情况了。</p>\n<p>乍眼一看，很简单啊，不就是把两个数相加嘛，我先把它整成整数，然后相加，最后把结果整成链表，完美，哈哈哈哈，简直被自己的聪明才智给折服。</p>\n<h3 id=\"翻车尝试1：虾扯蛋法\"><a href=\"#翻车尝试1：虾扯蛋法\" class=\"headerlink\" title=\"翻车尝试1：虾扯蛋法\"></a>翻车尝试1：虾扯蛋法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        ListNode head1 = l1;</span><br><span class=\"line\">        ListNode head2 = l2;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 将链表l1转化为整数</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head1 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            i += head1.val * Math.pow(<span class=\"number\">10</span>, index);</span><br><span class=\"line\">            index++;</span><br><span class=\"line\">            head1 = head1.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 将链表l2转化为整数</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            j += head2.val * Math.pow(<span class=\"number\">10</span>, index);</span><br><span class=\"line\">            index++;</span><br><span class=\"line\">            head2 = head2.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = i + j;</span><br><span class=\"line\">        ListNode newHead = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode tmpHead = newHead;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sign = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 将结果转化为链表</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (sum &gt; <span class=\"number\">0</span> || sign == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = sum % <span class=\"number\">10</span>;</span><br><span class=\"line\">            sum = sum / <span class=\"number\">10</span>;</span><br><span class=\"line\">            tmpHead.next = <span class=\"keyword\">new</span> ListNode(tmp);</span><br><span class=\"line\">            tmpHead = tmpHead.next;</span><br><span class=\"line\">            sign++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newHead.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简直轻松加愉快，让我们来提交一下。</p>\n<img src=\"/programming/leetcode/day2-add-two-numbers/solution-1.png\" title=\"solution-1\">\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"/images/black_smile.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>怎么肥四，小老弟，翻车了啊。让我们看看错误原因：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[9]</span><br><span class=\"line\">[1,9,9,9,9,9,9,9,9,9]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[0]</span><br><span class=\"line\">预期：</span><br><span class=\"line\">[0,0,0,0,0,0,0,0,0,0,1]</span><br></pre></td></tr></table></figure>\n<p>看样子应该是整数型溢出了。。。难不倒我，改成long型不就完事了。</p>\n<h3 id=\"翻车尝试2：虾扯蛋升级法\"><a href=\"#翻车尝试2：虾扯蛋升级法\" class=\"headerlink\" title=\"翻车尝试2：虾扯蛋升级法\"></a>翻车尝试2：虾扯蛋升级法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        ListNode head1 = l1;</span><br><span class=\"line\">        ListNode head2 = l2;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head1 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            i += head1.val * Math.pow(<span class=\"number\">10</span>, index);</span><br><span class=\"line\">            index++;</span><br><span class=\"line\">            head1 = head1.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            j += head2.val * Math.pow(<span class=\"number\">10</span>, index);</span><br><span class=\"line\">            index++;</span><br><span class=\"line\">            head2 = head2.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> sum = i + j;</span><br><span class=\"line\">        ListNode newHead = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode tmpHead = newHead;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sign = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (sum &gt; <span class=\"number\">0</span> || sign == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = (<span class=\"keyword\">int</span>)(sum % <span class=\"number\">10</span>);</span><br><span class=\"line\">            sum = sum / <span class=\"number\">10</span>;</span><br><span class=\"line\">            tmpHead.next = <span class=\"keyword\">new</span> ListNode(tmp);</span><br><span class=\"line\">            tmpHead = tmpHead.next;</span><br><span class=\"line\">            sign++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newHead.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这次总没事了吧，再提交一下：</p>\n<img src=\"/programming/leetcode/day2-add-two-numbers/solution-2.png\" title=\"solution-2\">\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"/images/black_smile-2.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>这个磨人的小妖精，整出个这么大的数来折腾我，long型也溢出了。。。</p>\n<p>逼我用绝招，是时候祭出我的<code>BigInteger</code>了。</p>\n<h3 id=\"翻车尝试3：虾扯蛋终极法\"><a href=\"#翻车尝试3：虾扯蛋终极法\" class=\"headerlink\" title=\"翻车尝试3：虾扯蛋终极法\"></a>翻车尝试3：虾扯蛋终极法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        ListNode head1 = l1;</span><br><span class=\"line\">        ListNode head2 = l2;</span><br><span class=\"line\">        BigInteger i = <span class=\"keyword\">new</span> BigInteger(<span class=\"number\">0</span>);</span><br><span class=\"line\">        BigInteger j = <span class=\"keyword\">new</span> BigInteger(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head1 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            i.add(BigInteger.valueOf(head1.val * Math.pow(<span class=\"number\">10</span>, index)));</span><br><span class=\"line\">            index++;</span><br><span class=\"line\">            head1 = head1.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            j.add(BigInteger.valueOf(head2.val * Math.pow(<span class=\"number\">10</span>, index)));</span><br><span class=\"line\">            index++;</span><br><span class=\"line\">            head2 = head2.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        BigInteger sum = i.add(j);</span><br><span class=\"line\">        ListNode newHead = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode tmpHead = newHead;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sign = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (sum.compareTo(<span class=\"number\">0</span>) == <span class=\"number\">1</span> || sign == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = sum.mod(<span class=\"number\">10</span>).intValue();</span><br><span class=\"line\">            sum = sum.divide(<span class=\"number\">10</span>);</span><br><span class=\"line\">            tmpHead.next = <span class=\"keyword\">new</span> ListNode(tmp);</span><br><span class=\"line\">            tmpHead = tmpHead.next;</span><br><span class=\"line\">            sign++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newHead.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这次，连编译都不通过了，emmmm，看来不准用<code>BigInteger</code>这个类。</p>\n<img src=\"/programming/leetcode/day2-add-two-numbers/solution-3.png\" title=\"solution-3\">\n<h2 id=\"常规解法\"><a href=\"#常规解法\" class=\"headerlink\" title=\"常规解法\"></a>常规解法</h2><p>既然邪门歪道走不通，那就还是用常规操作来解决吧，仔细想想，其实也很简单，我们从两个链表的头节点开始，一起遍历，将相加得到的结果存入新的链表中即可。</p>\n<img src=\"/programming/leetcode/day2-add-two-numbers/solution-4.png\" title=\"solution-4\">\n<p>这里需要注意的就是要考虑进位的情况，比如：<code>4 + 6 = 10</code>，那么在处理后一个节点<code>3 + 4</code>的时候，需要再加1，因此需要有一个进位标志来表示是否需要进位。</p>\n<p>另外，两个链表的长度并不一定相等，需要考虑像上面那样一个很长，一个很短，而且后续一直进位的情况：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[9]</span><br><span class=\"line\">[1,9,9,9,9,9,9,9,9,9]</span><br></pre></td></tr></table></figure>\n<p>所以我们可以定义一个叫<code>carry</code>的变量来表示是否需要进位。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        ListNode head1 = l1;</span><br><span class=\"line\">        ListNode head2 = l2;</span><br><span class=\"line\">        ListNode newHead = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode head3 = newHead;</span><br><span class=\"line\">        <span class=\"comment\">// 进位标志</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> carry = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head1 != <span class=\"keyword\">null</span> || head2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取对应位置的值然后相加</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> x = (head1 != <span class=\"keyword\">null</span>) ? head1.val : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> y = (head2 != <span class=\"keyword\">null</span>) ? head2.val : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = carry ? (x + y + <span class=\"number\">1</span>) : (x + y);</span><br><span class=\"line\">            <span class=\"comment\">// 处理进位</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum &gt;= <span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">                sum -= <span class=\"number\">10</span>;</span><br><span class=\"line\">                carry = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                carry = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 新增节点</span></span><br><span class=\"line\">            head3.next = <span class=\"keyword\">new</span> ListNode(sum % <span class=\"number\">10</span>);</span><br><span class=\"line\">            head3 = head3.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (head1 != <span class=\"keyword\">null</span>) head1 = head1.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (head2 != <span class=\"keyword\">null</span>) head2 = head2.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (carry) &#123;</span><br><span class=\"line\">            head3.next = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newHead.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/programming/leetcode/day2-add-two-numbers/result-5.png\" title=\"result-5\">\n<p>嗯，这下就没什么问题了。😜</p>\n<p><a href=\"https://leetcode-cn.com/problems/add-two-numbers/\" target=\"_blank\" rel=\"noopener\">本题中文版链接</a></p>\n<p><a href=\"https://leetcode.com/problems/add-two-numbers/\" target=\"_blank\" rel=\"noopener\">本题英文版链接</a></p>\n<p>如果你有更好的解法，欢迎留言讨论~</p>\n"},{"title":"【动态规划】01背包问题","date":"2019-03-10T13:23:14.000Z","_content":"\n## 说明\n\n前面用`动态规划`解决了正则表达式的问题，感觉还是不过瘾，总觉得对于`动态规划`的理解还没有到位，所以趁热打铁，继续研究几个`动态规划`的经典问题，希望能够借此加深对`动态规划`的理解。在此之前，还需要说两个跟动态规划有关的理论知识。\n\n## 最优化原理\n\n`最优化原理`指的最优策略具有这样的性质：不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简单来说就是一个最优策略的子策略也是必须是最优的，而所有子问题的局部最优解将导致整个问题的全局最优。如果一个问题能满足`最优化原理`，就称其具有`最优子结构性质`。\n\n这是判断问题能否使用动态规划解决的先决条件，如果一个问题不能满足最优化原理，那么这个问题就不适合用动态规划来求解。\n\n这样说可能比较模糊，来举个栗子吧：\n\n![](https://i.loli.net/2019/03/14/5c8a1e400a1c1.jpeg)\n\n如上图，*求从A点到E点的最短距离*，那么子问题就是*求从A点到E点之间的中间点到E点的最短距离，比如这里的B点*。\n\n那么这个问题里，怎么证明最优化原理呢？\n\n我们假设从A点到E点的最短距离为d，其最优策略的子策略假设经过B点，记该策略中B点到E点的距离为`d1`，A点到B点的距离为`d2`。我们可以使用反证法，假设存在B点到E点的最短距离`d3`，并且`d3 < d1`，那么 `d3 + d2 < d1 + d2 = d`，这与d是最短距离相矛盾，所以，`d1`是B点到E点的最短距离。\n\n为了增加理解，这里再举一个反例：\n\n![](https://i.loli.net/2019/03/14/5c8a3c4e20747.jpeg)\n\n图中有四个点，A、B、C、D，相邻两点有两条连线，代表两条通道，d1,d2,d3,d4,d5,d6代表的是道路的长度，求A到D的所有通道中，总长度除以4得到的余数最小的路径为*最优路径*，求一条*最优路径*。\n\n这里如果还是按照上面的思路去求解，就会误入歧途了。按照之前的思路，A的最优取值应该可以由B的最优取值来确定，而B的最优取值为（3+5）mod 4 = 0。所以应该选`d2`和`d6`这两条道路，而实际上，全局最优解是`d4+d5+d6`或者`d1+d5+d3`。所以这里子问题的最优解并不是原问题的最优解，即不满足最优化原理。所以就不适合使用动态规划来求解了。\n\n## 无后效性\n\n`无后效性`指的是某状态下决策的收益，只与状态和决策相关，与到达该状态的方式无关。某个阶段的状态一旦确定，则此后过程的演变不再受此前各种状态及决策的影响。换句话说，未来与过去无关，当前状态是此前历史状态的完整总结，此前历史决策只能通过影响当前的状态来影响未来的演变。再换句话说，过去做的选择不会影响现在能做的最优选择，现在能做的最优选择只与当前的状态有关，与经过如何复杂的决策到达该状态的方式无关。\n\n这也是用来验证问题是否可以使用动态规划来解答的重要方法。\n\n我们再回头看看上面的最短路径问题，如果在原来的基础上加上一个限制条件：*同一个格子只能通过一次*。那么， 这个题就不符合无后效性了，因为前一个子问题的解会对后面子问题的选择策略有影响，比如说，如果从A到B选择了一条如下图中绿色表示的路线，那么从B点出发到达E点的路线就只有一条了。也就是说从A点到B点的路径选择会影响B点到E点的路径选择。\n\n![](https://i.loli.net/2019/03/14/5c8a47085f922.jpeg)\n\n理论部分就此打住，接下来我们实战一下。\n\n## 01背包问题\n\n假设你是一名经验丰富的探险家，背着背包来到野外进行日常探险。天气晴朗而不燥热，山间的风夹杂着花香，正当你欣赏这世外桃源般的美景时，突然，你发现了一个洞穴，这个洞穴外表看起来其貌不扬，但凭借着惊为天人的直觉，这个洞穴不简单。\n\n![](https://i.loli.net/2019/03/14/5c8a47d0de9a6.png)\n\n于是，你开始往洞穴内探索，希望能发现一些有意思的东西。终于，皇天不负有心人，你在洞穴的尽头，发现了一堆不世出的珠宝，凭借你惊人的阅历，一眼便看出了它们各自的价值，心想着下下下下下下下下半辈子都有着落了。\n\n![](https://i.loli.net/2019/03/14/5c8a564a63265.png)\n\n然而，天有不测风云，正准备将它们收入囊中，却不小心触碰到一个防御机关，洞穴马上就要崩塌了。在此危机时刻，你只有一个背包，你必须尽快做出抉择，从中选择最值钱的珠宝塞到你的背包，让背包中珠宝的总价值最大。\n\n![](https://i.loli.net/2019/03/14/5c8a56572a8c0.png)\n\n好了好了，啰里啰嗦了大半天，我还是来精简一下问题吧。简而言之，你只有一个容量有限的背包，总容量为c，有n个可待选择的物品，每个物品只有一件，它们都有各自的重量和价值，你需要从中选择合适的组合来使得你背包中的物品总价值最大。\n\n## 问题分析\n\n那还不简单，不管是什么，先往背包里塞，塞满赶紧走，狗命要紧，狗命要紧。。。\n\n![20190310214935.png](https://i.loli.net/2019/03/10/5c8515f07c869.png)\n\n好了好了，开个玩笑，言归正传。\n\n简单起见，我们来将上面的问题具体化，举一个更具体的栗子：\n\n假设有5个物品，它们的价值(v)和重量(w)如下图：\n\n{% asset_img IMG_9B418BF0E7A5-1.jpeg pic %}\n\n背包总容量为10，现在要从中选择物品装入背包中，要求物品的重量不能超过背包的容量，并且最后放在背包中物品的总价值最大。\n\nemmm，等等，为什么叫做`0/1背包`呢？为什么不叫`1/2背包`，`2/3背包`？？？\n\n仔细想想，这里每个物品只有一个，对于每个物品而言，只有两种选择，盘它或者不盘，盘它记为1，不盘记为0，我们不能将物品进行分割，比如只拿半个是不允许的。这就是这个问题被称为`0/1背包`问题的原因。\n\n所以究竟选还是不选，这是个问题。\n\n![](https://i.loli.net/2019/03/14/5c8a56a150bc1.png)\n\n让我们先来体验一下将珠宝装入背包的感觉，为了方便起见，用`xi`代表第i个珠宝的选择（`xi = 1` 代表选择该珠宝，0则代表不选），`vi`代表第i个珠宝的价值，`wi`代表第i个珠宝的重量。于是我们就有了这样的限制条件：\n\n![](https://i.loli.net/2019/03/10/5c851ebfd4687.jpeg)\n\n我们的初始状态是背包容量为10，背包内物品总价值为0，接下来，我们就要开始做选择了。对于1号珠宝，当前容量为10，容纳它的重量2绰绰有余，因此有两种选择，选它或者不选。我们选择一个珠宝的时候，背包的容量会减少，但是里面的物品总价值会增加。就像下面这样：\n\n{% asset_img IMG_2ABCC82C89F7-1.jpeg exhaust-algorithm %}\n\n这样就分出了两种情况，我们继续进行选择，如果我们选择了珠宝1，那么对于珠宝2，当前剩余容量为8，大于珠宝2的容量3，因此也有两种选择，选或者不选。\n\n![](https://i.loli.net/2019/03/10/5c8524cc69459.jpeg)\n\n现在，我们得到了四个可能结果，我们每做出一个选择，就会将上面的每一种可能分裂成两种可能，后续的选择也是如此，最终，我们会得到如下的一张决策图：\n\n![](https://i.loli.net/2019/03/10/5c85286b617f4.jpeg)\n\n这里被涂上色的方框代表我们的最终待选结果，本来应该有16个待选结果，但有三个结果由于容量不足以容纳下最后一个珠宝，所以就没有继续进行裂变。\n\n然后，我们从这些结果中，找出价值最大的那个，也就是`13`，这就是我们的最优选择，根据这个选择，依次找到它的所有路径，便可以知道该选哪几个珠宝，最终结果是：珠宝4，珠宝2，珠宝1。\n\n## 分治法\n\n接下来，我们就来分析一下，如何将它扩展到一般情况。为了实现这个目的，我们需要将问题进行抽象并建模，然后将其划分为更小的子问题，找出递推关系式，这是分治思想中很重要的一步。\n\n1. 抽象问题，背包问题抽象为寻找组合（x1,x2,x3...xn，其中xi取0或1，表示第i个物品取或者不取），vi代表第i个物品的价值，wi代表第i个物品的重量，总物品数为n，背包容量为c。\n2. 建模，问题即求max(x1v1 + x2v2 + x3v3 + ... + xnvn)。\n3. 约束条件，x1w1 + x2w2 + x3w3 + ... + xnwn < c\n4. 定义函数KS(i,j)：代表当前背包剩余容量为j时，前i个物品最佳组合所对应的价值；\n\n那这里的递推关系式是怎样的呢？对于第i个物品，有两种可能：\n\n1. 背包剩余容量不足以容纳该物品，此时背包的价值与前i-1个物品的价值是一样的，KS(i,j) = KS(i-1,j)\n2. 背包剩余容量可以装下该商品，此时需要进行判断，因为装了该商品不一定能使最终组合达到最大价值，如果不装该商品，则价值为：KS(i-1,j)，如果装了该商品，则价值为KS(i-1,j-wi) + vi，从两者中选择较大的那个，所以就得出了递推关系式：\n\n![](https://i.loli.net/2019/03/12/5c87b64eb1a66.jpeg)\n\n对于这个问题的子问题，这里有必要详细说明一下。原问题是，将n件物品放入容量为c的背包，子问题则是，将前i件物品放入容量为j的背包，所得到的最优价值为KS(i,j)，如果只考虑第i件物品放还是不放，那么就可以转化为一个只涉及到前i-1个物品的问题。如果不放第i个物品，那么问题就转化为“前i-1件物品放入容量为j的背包中的最优价值组合”，对应的值为KS(i-1,j)。如果放第i个物品，那么问题就转化成了“前i-1件物品放入容量为j-wi的背包中的最优价值组合”，此时对应的值为KS(i-1,j-wi)+vi。\n\n所以，就可以很容易的写出递归解法了：\n\n```java\npublic class Solution{\n    int[] vs = {0,2,4,3,7};\n    int[] ws = {0,2,3,5,5};\n\n    @Test\n    public void testKnapsack1() {\n        int result = ks(4,10);\n        System.out.println(result);\n    }\n\n    private int ks(int i, int c){\n        int result = 0;\n        if (i == 0 || c == 0){\n            // 初始条件\n            result = 0;\n        } else if(ws[i] > c){\n            // 装不下该珠宝\n            result = ks(i-1, c);\n        } else {\n            // 可以装下\n            int tmp1 = ks(i-1, c);\n            int tmp2 = ks(i-1, c-ws[i]) + vs[i];\n            result = Math.max(tmp1, tmp2);\n        }\n        return result;\n    }\n}\n```\n\n这里为了方便处理，将数组ws和vs都增加了一个补位数0，防止数组越界，输出结果：\n\n```\n13\n```\n\n这样，我们就轻松加愉快的解决了这个问题。\n\n## 动态规划解法\n\n### 验证可行性\n\n既然开头已经说了两个验证问题是否可以使用动态规划求解的方法，那么为何不试一试呢？\n\n先来看看`最优化原理`。同样，我们使用反证法：\n\n假设(x1，x2，…，xn)是01背包问题的最优解，则有(x2，x3，…，xn)是其子问题的最优解，假设(y2，y3，…，yn)是上述问题的子问题最优解，则有(v2y2+v3y3+…+vnyn)+v1x1 > (v2x2+v3x3+…+vnxn)+v1x1。说明(X1，Y2，Y3，…，Yn)才是该01背包问题的最优解，这与最开始的假设(X1，X2，…，Xn)是01背包问题的最优解相矛盾，故01背包问题满足`最优性原理`。\n\n![](https://i.loli.net/2019/03/14/5c8a5766a30bc.png)\n\n至于`无后效性`，其实比较好理解。对于任意一个阶段，只要背包剩余容量和可选物品是一样的，那么我们能做出的现阶段的最优选择必定是一样的，是不受之前选择了什么物品所影响的。即满足`无后效性`。\n\n### 自上而下记忆法\n\n就像上一篇里的解法一样，自上而下的解法与分治法的区别就是增加了一个数组用来存储计算的中间结果来减少重复计算。这里，我们只需要多定义一个二维数组。\n\n![](https://i.loli.net/2019/03/12/5c87c27322752.jpeg)\n\n表格中，每一个格子都代表着一个子问题，我们最终的问题是求最右下角的格子的值，也就是`i=4,j=10`时的值。这里，我们的初始条件便是i=0或者j=0时对应的ks值为0，这很好理解，如果可选物品为0，或者剩余容量为0，那么最大价值自然也是0。代码如下：\n\n```java\npublic class Solution{\n    int[] vs = {0,2,4,3,7};\n    int[] ws = {0,2,3,5,5};\n    Integer[][] results = new Integer[5][11];\n\n    @Test\n    public void testKnapsack2() {\n        int result = ks2(4,10);\n        System.out.println(result);\n    }\n\n    private int ks2(int i, int c){\n        int result = 0;\n        // 如果该结果已经被计算，那么直接返回\n        if (results[i][c] != null) return results[i][c];\n        if (i == 0 || c == 0){\n            // 初始条件\n            result = 0;\n        } else if(ws[i] > c){\n            // 装不下该珠宝\n            result = ks(i-1, c);\n        } else {\n            // 可以装下\n            int tmp1 = ks(i-1, c);\n            int tmp2 = ks(i-1, c-ws[i]) + vs[i];\n            result = Math.max(tmp1, tmp2);\n            results[i][c] = result;\n        }\n        return result;\n    }\n}\n```\n\n可以看到，其实只比分治多了三行代码。\n\n### 自下而上填表法\n\n接下来，我们用自下而上的方法来解一下这道题，思路很简单，就是不断的填表，回想一下上一篇中的斐波拉契数列的自下而上解法，这里将使用同样的方式来解决。还是使用上面的表格，我们开始一行行填表。\n\n![](https://i.loli.net/2019/03/12/5c87c45b5d9bf.jpeg)\n\n当i=1时，即只有珠宝1可供选择，那么如果容量足够的话，最大价值自然就是珠宝1的价值了。\n\n![](https://i.loli.net/2019/03/12/5c87c4c11104c.jpeg)\n\n当i=2时，有两个物品可供选择，此时应用上面的递推关系式进行判断即可。这里以i=2,j=3为例进行分析：\n\n![](https://i.loli.net/2019/03/12/5c87c673e6c36.jpeg)\n\n剩下的格子使用相同的方法进行填充即可：\n\n![](https://i.loli.net/2019/03/12/5c87c75ba58ce.jpeg)\n\n这样，我们就得到了最后的结果：13。根据结果，我们可以反向找出各个物品的选择，寻找的方法很简单，就是从`i=4,j=10`开始寻找，如果`ks(i-1,j)=ks(i,j)`，说明第i个物品没有被选中，从`ks(i-1,j)`继续寻找。否则，表示第i个物品已被选中，则从`ks(i-1,j-wi)`开始寻找。\n\n{% asset_img IMG_BFE9B7063670-1.jpeg exhaust-algorithm %}\n\n转化成代码：\n\n```java\npublic class Solution{\n    int[] vs = {0,2,4,3,7};\n    int[] ws = {0,2,3,5,5};\n    Integer[][] results = new Integer[5][11];\n    \n    @Test\n    public void testKnapsack3() {\n        int result = ks3(4,10);\n        System.out.println(result);\n    }\n\n    private int ks3(int i, int j){\n        // 初始化\n        for (int m = 0; m <= i; m++){\n            results[m][0] = 0;\n        }\n        for (int m = 0; m <= j; m++){\n            results[0][m] = 0;\n        }\n        // 开始填表\n        for (int m = 1; m <= i; m++){\n            for (int n = 1; n <= j; n++){\n                if (n < ws[m]){\n                    // 装不进去\n                    results[m][n] = results[m-1][n];\n                } else {\n                    // 容量足够\n                    if (results[m-1][n] > results[m-1][n-ws[m]] + vs[m]){\n                        // 不装该珠宝，最优价值更大\n                        results[m][n] = results[m-1][n];\n                    } else {\n                        results[m][n] = results[m-1][n-ws[m]] + vs[m];\n                    }\n                }\n            }\n        }\n        return results[i][j];\n    }\n}\n```\n\n嗯，完美解决。时间复杂度即填表耗时`O(n * c)`，这里用了一个二维数组来存储子问题的解，所以空间复杂度为`O(n * c)`;\n\n## 总结\n\n回过头再看看上面的分析，会发现动态规划里最关键的问题其实是寻找原问题的子问题，并写出递推表达式，只要完成了这一步，代码部分都是水到渠成的事情了。\n\n那么问题来了，怎样把问题拆分成子问题呢？\n\nemmm，这个问题有点超纲了，说实话，我也没有掌握到诀窍，还是得具体情况具体分析，但是很多经典的问题都有其经典的套路，其它问题都可以归结到这些问题上面来，可以看做是它们的变种和延伸，把这些经典的问题吃透的话，自然能举一反三。比如采药问题，本质上就是01背包问题，而硬币问题，本质上就是我们之后要介绍的完全背包问题。\n\n个人认为，算法不在于刷多少个，而在于归纳总结，就跟做数学题一样，总有一些范式和套路，不管形式如何变化，其本质是一样的，万变不离其宗，说的就是这么回事。\n\n![](https://i.loli.net/2019/03/14/5c8a580b1789e.png)\n\n本篇到此就告一段落了，如果觉得有收获，不要吝啬你的赞哦，也欢迎关注我的公众号留言交流。\n\n![](https://i.loli.net/2019/03/14/5c8a58ba229ca.png)","source":"_posts/leetcode/dp-01-knapsack-problem.md","raw":"---\ntitle: 【动态规划】01背包问题\ndate: 2019-03-10 21:23:14\ntags: \n - Java\n - 算法\n - 动态规划\n - 背包问题\ncategories: 编程\n---\n\n## 说明\n\n前面用`动态规划`解决了正则表达式的问题，感觉还是不过瘾，总觉得对于`动态规划`的理解还没有到位，所以趁热打铁，继续研究几个`动态规划`的经典问题，希望能够借此加深对`动态规划`的理解。在此之前，还需要说两个跟动态规划有关的理论知识。\n\n## 最优化原理\n\n`最优化原理`指的最优策略具有这样的性质：不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简单来说就是一个最优策略的子策略也是必须是最优的，而所有子问题的局部最优解将导致整个问题的全局最优。如果一个问题能满足`最优化原理`，就称其具有`最优子结构性质`。\n\n这是判断问题能否使用动态规划解决的先决条件，如果一个问题不能满足最优化原理，那么这个问题就不适合用动态规划来求解。\n\n这样说可能比较模糊，来举个栗子吧：\n\n![](https://i.loli.net/2019/03/14/5c8a1e400a1c1.jpeg)\n\n如上图，*求从A点到E点的最短距离*，那么子问题就是*求从A点到E点之间的中间点到E点的最短距离，比如这里的B点*。\n\n那么这个问题里，怎么证明最优化原理呢？\n\n我们假设从A点到E点的最短距离为d，其最优策略的子策略假设经过B点，记该策略中B点到E点的距离为`d1`，A点到B点的距离为`d2`。我们可以使用反证法，假设存在B点到E点的最短距离`d3`，并且`d3 < d1`，那么 `d3 + d2 < d1 + d2 = d`，这与d是最短距离相矛盾，所以，`d1`是B点到E点的最短距离。\n\n为了增加理解，这里再举一个反例：\n\n![](https://i.loli.net/2019/03/14/5c8a3c4e20747.jpeg)\n\n图中有四个点，A、B、C、D，相邻两点有两条连线，代表两条通道，d1,d2,d3,d4,d5,d6代表的是道路的长度，求A到D的所有通道中，总长度除以4得到的余数最小的路径为*最优路径*，求一条*最优路径*。\n\n这里如果还是按照上面的思路去求解，就会误入歧途了。按照之前的思路，A的最优取值应该可以由B的最优取值来确定，而B的最优取值为（3+5）mod 4 = 0。所以应该选`d2`和`d6`这两条道路，而实际上，全局最优解是`d4+d5+d6`或者`d1+d5+d3`。所以这里子问题的最优解并不是原问题的最优解，即不满足最优化原理。所以就不适合使用动态规划来求解了。\n\n## 无后效性\n\n`无后效性`指的是某状态下决策的收益，只与状态和决策相关，与到达该状态的方式无关。某个阶段的状态一旦确定，则此后过程的演变不再受此前各种状态及决策的影响。换句话说，未来与过去无关，当前状态是此前历史状态的完整总结，此前历史决策只能通过影响当前的状态来影响未来的演变。再换句话说，过去做的选择不会影响现在能做的最优选择，现在能做的最优选择只与当前的状态有关，与经过如何复杂的决策到达该状态的方式无关。\n\n这也是用来验证问题是否可以使用动态规划来解答的重要方法。\n\n我们再回头看看上面的最短路径问题，如果在原来的基础上加上一个限制条件：*同一个格子只能通过一次*。那么， 这个题就不符合无后效性了，因为前一个子问题的解会对后面子问题的选择策略有影响，比如说，如果从A到B选择了一条如下图中绿色表示的路线，那么从B点出发到达E点的路线就只有一条了。也就是说从A点到B点的路径选择会影响B点到E点的路径选择。\n\n![](https://i.loli.net/2019/03/14/5c8a47085f922.jpeg)\n\n理论部分就此打住，接下来我们实战一下。\n\n## 01背包问题\n\n假设你是一名经验丰富的探险家，背着背包来到野外进行日常探险。天气晴朗而不燥热，山间的风夹杂着花香，正当你欣赏这世外桃源般的美景时，突然，你发现了一个洞穴，这个洞穴外表看起来其貌不扬，但凭借着惊为天人的直觉，这个洞穴不简单。\n\n![](https://i.loli.net/2019/03/14/5c8a47d0de9a6.png)\n\n于是，你开始往洞穴内探索，希望能发现一些有意思的东西。终于，皇天不负有心人，你在洞穴的尽头，发现了一堆不世出的珠宝，凭借你惊人的阅历，一眼便看出了它们各自的价值，心想着下下下下下下下下半辈子都有着落了。\n\n![](https://i.loli.net/2019/03/14/5c8a564a63265.png)\n\n然而，天有不测风云，正准备将它们收入囊中，却不小心触碰到一个防御机关，洞穴马上就要崩塌了。在此危机时刻，你只有一个背包，你必须尽快做出抉择，从中选择最值钱的珠宝塞到你的背包，让背包中珠宝的总价值最大。\n\n![](https://i.loli.net/2019/03/14/5c8a56572a8c0.png)\n\n好了好了，啰里啰嗦了大半天，我还是来精简一下问题吧。简而言之，你只有一个容量有限的背包，总容量为c，有n个可待选择的物品，每个物品只有一件，它们都有各自的重量和价值，你需要从中选择合适的组合来使得你背包中的物品总价值最大。\n\n## 问题分析\n\n那还不简单，不管是什么，先往背包里塞，塞满赶紧走，狗命要紧，狗命要紧。。。\n\n![20190310214935.png](https://i.loli.net/2019/03/10/5c8515f07c869.png)\n\n好了好了，开个玩笑，言归正传。\n\n简单起见，我们来将上面的问题具体化，举一个更具体的栗子：\n\n假设有5个物品，它们的价值(v)和重量(w)如下图：\n\n{% asset_img IMG_9B418BF0E7A5-1.jpeg pic %}\n\n背包总容量为10，现在要从中选择物品装入背包中，要求物品的重量不能超过背包的容量，并且最后放在背包中物品的总价值最大。\n\nemmm，等等，为什么叫做`0/1背包`呢？为什么不叫`1/2背包`，`2/3背包`？？？\n\n仔细想想，这里每个物品只有一个，对于每个物品而言，只有两种选择，盘它或者不盘，盘它记为1，不盘记为0，我们不能将物品进行分割，比如只拿半个是不允许的。这就是这个问题被称为`0/1背包`问题的原因。\n\n所以究竟选还是不选，这是个问题。\n\n![](https://i.loli.net/2019/03/14/5c8a56a150bc1.png)\n\n让我们先来体验一下将珠宝装入背包的感觉，为了方便起见，用`xi`代表第i个珠宝的选择（`xi = 1` 代表选择该珠宝，0则代表不选），`vi`代表第i个珠宝的价值，`wi`代表第i个珠宝的重量。于是我们就有了这样的限制条件：\n\n![](https://i.loli.net/2019/03/10/5c851ebfd4687.jpeg)\n\n我们的初始状态是背包容量为10，背包内物品总价值为0，接下来，我们就要开始做选择了。对于1号珠宝，当前容量为10，容纳它的重量2绰绰有余，因此有两种选择，选它或者不选。我们选择一个珠宝的时候，背包的容量会减少，但是里面的物品总价值会增加。就像下面这样：\n\n{% asset_img IMG_2ABCC82C89F7-1.jpeg exhaust-algorithm %}\n\n这样就分出了两种情况，我们继续进行选择，如果我们选择了珠宝1，那么对于珠宝2，当前剩余容量为8，大于珠宝2的容量3，因此也有两种选择，选或者不选。\n\n![](https://i.loli.net/2019/03/10/5c8524cc69459.jpeg)\n\n现在，我们得到了四个可能结果，我们每做出一个选择，就会将上面的每一种可能分裂成两种可能，后续的选择也是如此，最终，我们会得到如下的一张决策图：\n\n![](https://i.loli.net/2019/03/10/5c85286b617f4.jpeg)\n\n这里被涂上色的方框代表我们的最终待选结果，本来应该有16个待选结果，但有三个结果由于容量不足以容纳下最后一个珠宝，所以就没有继续进行裂变。\n\n然后，我们从这些结果中，找出价值最大的那个，也就是`13`，这就是我们的最优选择，根据这个选择，依次找到它的所有路径，便可以知道该选哪几个珠宝，最终结果是：珠宝4，珠宝2，珠宝1。\n\n## 分治法\n\n接下来，我们就来分析一下，如何将它扩展到一般情况。为了实现这个目的，我们需要将问题进行抽象并建模，然后将其划分为更小的子问题，找出递推关系式，这是分治思想中很重要的一步。\n\n1. 抽象问题，背包问题抽象为寻找组合（x1,x2,x3...xn，其中xi取0或1，表示第i个物品取或者不取），vi代表第i个物品的价值，wi代表第i个物品的重量，总物品数为n，背包容量为c。\n2. 建模，问题即求max(x1v1 + x2v2 + x3v3 + ... + xnvn)。\n3. 约束条件，x1w1 + x2w2 + x3w3 + ... + xnwn < c\n4. 定义函数KS(i,j)：代表当前背包剩余容量为j时，前i个物品最佳组合所对应的价值；\n\n那这里的递推关系式是怎样的呢？对于第i个物品，有两种可能：\n\n1. 背包剩余容量不足以容纳该物品，此时背包的价值与前i-1个物品的价值是一样的，KS(i,j) = KS(i-1,j)\n2. 背包剩余容量可以装下该商品，此时需要进行判断，因为装了该商品不一定能使最终组合达到最大价值，如果不装该商品，则价值为：KS(i-1,j)，如果装了该商品，则价值为KS(i-1,j-wi) + vi，从两者中选择较大的那个，所以就得出了递推关系式：\n\n![](https://i.loli.net/2019/03/12/5c87b64eb1a66.jpeg)\n\n对于这个问题的子问题，这里有必要详细说明一下。原问题是，将n件物品放入容量为c的背包，子问题则是，将前i件物品放入容量为j的背包，所得到的最优价值为KS(i,j)，如果只考虑第i件物品放还是不放，那么就可以转化为一个只涉及到前i-1个物品的问题。如果不放第i个物品，那么问题就转化为“前i-1件物品放入容量为j的背包中的最优价值组合”，对应的值为KS(i-1,j)。如果放第i个物品，那么问题就转化成了“前i-1件物品放入容量为j-wi的背包中的最优价值组合”，此时对应的值为KS(i-1,j-wi)+vi。\n\n所以，就可以很容易的写出递归解法了：\n\n```java\npublic class Solution{\n    int[] vs = {0,2,4,3,7};\n    int[] ws = {0,2,3,5,5};\n\n    @Test\n    public void testKnapsack1() {\n        int result = ks(4,10);\n        System.out.println(result);\n    }\n\n    private int ks(int i, int c){\n        int result = 0;\n        if (i == 0 || c == 0){\n            // 初始条件\n            result = 0;\n        } else if(ws[i] > c){\n            // 装不下该珠宝\n            result = ks(i-1, c);\n        } else {\n            // 可以装下\n            int tmp1 = ks(i-1, c);\n            int tmp2 = ks(i-1, c-ws[i]) + vs[i];\n            result = Math.max(tmp1, tmp2);\n        }\n        return result;\n    }\n}\n```\n\n这里为了方便处理，将数组ws和vs都增加了一个补位数0，防止数组越界，输出结果：\n\n```\n13\n```\n\n这样，我们就轻松加愉快的解决了这个问题。\n\n## 动态规划解法\n\n### 验证可行性\n\n既然开头已经说了两个验证问题是否可以使用动态规划求解的方法，那么为何不试一试呢？\n\n先来看看`最优化原理`。同样，我们使用反证法：\n\n假设(x1，x2，…，xn)是01背包问题的最优解，则有(x2，x3，…，xn)是其子问题的最优解，假设(y2，y3，…，yn)是上述问题的子问题最优解，则有(v2y2+v3y3+…+vnyn)+v1x1 > (v2x2+v3x3+…+vnxn)+v1x1。说明(X1，Y2，Y3，…，Yn)才是该01背包问题的最优解，这与最开始的假设(X1，X2，…，Xn)是01背包问题的最优解相矛盾，故01背包问题满足`最优性原理`。\n\n![](https://i.loli.net/2019/03/14/5c8a5766a30bc.png)\n\n至于`无后效性`，其实比较好理解。对于任意一个阶段，只要背包剩余容量和可选物品是一样的，那么我们能做出的现阶段的最优选择必定是一样的，是不受之前选择了什么物品所影响的。即满足`无后效性`。\n\n### 自上而下记忆法\n\n就像上一篇里的解法一样，自上而下的解法与分治法的区别就是增加了一个数组用来存储计算的中间结果来减少重复计算。这里，我们只需要多定义一个二维数组。\n\n![](https://i.loli.net/2019/03/12/5c87c27322752.jpeg)\n\n表格中，每一个格子都代表着一个子问题，我们最终的问题是求最右下角的格子的值，也就是`i=4,j=10`时的值。这里，我们的初始条件便是i=0或者j=0时对应的ks值为0，这很好理解，如果可选物品为0，或者剩余容量为0，那么最大价值自然也是0。代码如下：\n\n```java\npublic class Solution{\n    int[] vs = {0,2,4,3,7};\n    int[] ws = {0,2,3,5,5};\n    Integer[][] results = new Integer[5][11];\n\n    @Test\n    public void testKnapsack2() {\n        int result = ks2(4,10);\n        System.out.println(result);\n    }\n\n    private int ks2(int i, int c){\n        int result = 0;\n        // 如果该结果已经被计算，那么直接返回\n        if (results[i][c] != null) return results[i][c];\n        if (i == 0 || c == 0){\n            // 初始条件\n            result = 0;\n        } else if(ws[i] > c){\n            // 装不下该珠宝\n            result = ks(i-1, c);\n        } else {\n            // 可以装下\n            int tmp1 = ks(i-1, c);\n            int tmp2 = ks(i-1, c-ws[i]) + vs[i];\n            result = Math.max(tmp1, tmp2);\n            results[i][c] = result;\n        }\n        return result;\n    }\n}\n```\n\n可以看到，其实只比分治多了三行代码。\n\n### 自下而上填表法\n\n接下来，我们用自下而上的方法来解一下这道题，思路很简单，就是不断的填表，回想一下上一篇中的斐波拉契数列的自下而上解法，这里将使用同样的方式来解决。还是使用上面的表格，我们开始一行行填表。\n\n![](https://i.loli.net/2019/03/12/5c87c45b5d9bf.jpeg)\n\n当i=1时，即只有珠宝1可供选择，那么如果容量足够的话，最大价值自然就是珠宝1的价值了。\n\n![](https://i.loli.net/2019/03/12/5c87c4c11104c.jpeg)\n\n当i=2时，有两个物品可供选择，此时应用上面的递推关系式进行判断即可。这里以i=2,j=3为例进行分析：\n\n![](https://i.loli.net/2019/03/12/5c87c673e6c36.jpeg)\n\n剩下的格子使用相同的方法进行填充即可：\n\n![](https://i.loli.net/2019/03/12/5c87c75ba58ce.jpeg)\n\n这样，我们就得到了最后的结果：13。根据结果，我们可以反向找出各个物品的选择，寻找的方法很简单，就是从`i=4,j=10`开始寻找，如果`ks(i-1,j)=ks(i,j)`，说明第i个物品没有被选中，从`ks(i-1,j)`继续寻找。否则，表示第i个物品已被选中，则从`ks(i-1,j-wi)`开始寻找。\n\n{% asset_img IMG_BFE9B7063670-1.jpeg exhaust-algorithm %}\n\n转化成代码：\n\n```java\npublic class Solution{\n    int[] vs = {0,2,4,3,7};\n    int[] ws = {0,2,3,5,5};\n    Integer[][] results = new Integer[5][11];\n    \n    @Test\n    public void testKnapsack3() {\n        int result = ks3(4,10);\n        System.out.println(result);\n    }\n\n    private int ks3(int i, int j){\n        // 初始化\n        for (int m = 0; m <= i; m++){\n            results[m][0] = 0;\n        }\n        for (int m = 0; m <= j; m++){\n            results[0][m] = 0;\n        }\n        // 开始填表\n        for (int m = 1; m <= i; m++){\n            for (int n = 1; n <= j; n++){\n                if (n < ws[m]){\n                    // 装不进去\n                    results[m][n] = results[m-1][n];\n                } else {\n                    // 容量足够\n                    if (results[m-1][n] > results[m-1][n-ws[m]] + vs[m]){\n                        // 不装该珠宝，最优价值更大\n                        results[m][n] = results[m-1][n];\n                    } else {\n                        results[m][n] = results[m-1][n-ws[m]] + vs[m];\n                    }\n                }\n            }\n        }\n        return results[i][j];\n    }\n}\n```\n\n嗯，完美解决。时间复杂度即填表耗时`O(n * c)`，这里用了一个二维数组来存储子问题的解，所以空间复杂度为`O(n * c)`;\n\n## 总结\n\n回过头再看看上面的分析，会发现动态规划里最关键的问题其实是寻找原问题的子问题，并写出递推表达式，只要完成了这一步，代码部分都是水到渠成的事情了。\n\n那么问题来了，怎样把问题拆分成子问题呢？\n\nemmm，这个问题有点超纲了，说实话，我也没有掌握到诀窍，还是得具体情况具体分析，但是很多经典的问题都有其经典的套路，其它问题都可以归结到这些问题上面来，可以看做是它们的变种和延伸，把这些经典的问题吃透的话，自然能举一反三。比如采药问题，本质上就是01背包问题，而硬币问题，本质上就是我们之后要介绍的完全背包问题。\n\n个人认为，算法不在于刷多少个，而在于归纳总结，就跟做数学题一样，总有一些范式和套路，不管形式如何变化，其本质是一样的，万变不离其宗，说的就是这么回事。\n\n![](https://i.loli.net/2019/03/14/5c8a580b1789e.png)\n\n本篇到此就告一段落了，如果觉得有收获，不要吝啬你的赞哦，也欢迎关注我的公众号留言交流。\n\n![](https://i.loli.net/2019/03/14/5c8a58ba229ca.png)","slug":"leetcode/dp-01-knapsack-problem","published":1,"updated":"2019-06-04T01:29:57.465Z","_id":"cjxze3gno000t0cvwe73qcbbe","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>前面用<code>动态规划</code>解决了正则表达式的问题，感觉还是不过瘾，总觉得对于<code>动态规划</code>的理解还没有到位，所以趁热打铁，继续研究几个<code>动态规划</code>的经典问题，希望能够借此加深对<code>动态规划</code>的理解。在此之前，还需要说两个跟动态规划有关的理论知识。</p>\n<h2 id=\"最优化原理\"><a href=\"#最优化原理\" class=\"headerlink\" title=\"最优化原理\"></a>最优化原理</h2><p><code>最优化原理</code>指的最优策略具有这样的性质：不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简单来说就是一个最优策略的子策略也是必须是最优的，而所有子问题的局部最优解将导致整个问题的全局最优。如果一个问题能满足<code>最优化原理</code>，就称其具有<code>最优子结构性质</code>。</p>\n<p>这是判断问题能否使用动态规划解决的先决条件，如果一个问题不能满足最优化原理，那么这个问题就不适合用动态规划来求解。</p>\n<p>这样说可能比较模糊，来举个栗子吧：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a1e400a1c1.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>如上图，<em>求从A点到E点的最短距离</em>，那么子问题就是<em>求从A点到E点之间的中间点到E点的最短距离，比如这里的B点</em>。</p>\n<p>那么这个问题里，怎么证明最优化原理呢？</p>\n<p>我们假设从A点到E点的最短距离为d，其最优策略的子策略假设经过B点，记该策略中B点到E点的距离为<code>d1</code>，A点到B点的距离为<code>d2</code>。我们可以使用反证法，假设存在B点到E点的最短距离<code>d3</code>，并且<code>d3 &lt; d1</code>，那么 <code>d3 + d2 &lt; d1 + d2 = d</code>，这与d是最短距离相矛盾，所以，<code>d1</code>是B点到E点的最短距离。</p>\n<p>为了增加理解，这里再举一个反例：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a3c4e20747.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>图中有四个点，A、B、C、D，相邻两点有两条连线，代表两条通道，d1,d2,d3,d4,d5,d6代表的是道路的长度，求A到D的所有通道中，总长度除以4得到的余数最小的路径为<em>最优路径</em>，求一条<em>最优路径</em>。</p>\n<p>这里如果还是按照上面的思路去求解，就会误入歧途了。按照之前的思路，A的最优取值应该可以由B的最优取值来确定，而B的最优取值为（3+5）mod 4 = 0。所以应该选<code>d2</code>和<code>d6</code>这两条道路，而实际上，全局最优解是<code>d4+d5+d6</code>或者<code>d1+d5+d3</code>。所以这里子问题的最优解并不是原问题的最优解，即不满足最优化原理。所以就不适合使用动态规划来求解了。</p>\n<h2 id=\"无后效性\"><a href=\"#无后效性\" class=\"headerlink\" title=\"无后效性\"></a>无后效性</h2><p><code>无后效性</code>指的是某状态下决策的收益，只与状态和决策相关，与到达该状态的方式无关。某个阶段的状态一旦确定，则此后过程的演变不再受此前各种状态及决策的影响。换句话说，未来与过去无关，当前状态是此前历史状态的完整总结，此前历史决策只能通过影响当前的状态来影响未来的演变。再换句话说，过去做的选择不会影响现在能做的最优选择，现在能做的最优选择只与当前的状态有关，与经过如何复杂的决策到达该状态的方式无关。</p>\n<p>这也是用来验证问题是否可以使用动态规划来解答的重要方法。</p>\n<p>我们再回头看看上面的最短路径问题，如果在原来的基础上加上一个限制条件：<em>同一个格子只能通过一次</em>。那么， 这个题就不符合无后效性了，因为前一个子问题的解会对后面子问题的选择策略有影响，比如说，如果从A到B选择了一条如下图中绿色表示的路线，那么从B点出发到达E点的路线就只有一条了。也就是说从A点到B点的路径选择会影响B点到E点的路径选择。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a47085f922.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>理论部分就此打住，接下来我们实战一下。</p>\n<h2 id=\"01背包问题\"><a href=\"#01背包问题\" class=\"headerlink\" title=\"01背包问题\"></a>01背包问题</h2><p>假设你是一名经验丰富的探险家，背着背包来到野外进行日常探险。天气晴朗而不燥热，山间的风夹杂着花香，正当你欣赏这世外桃源般的美景时，突然，你发现了一个洞穴，这个洞穴外表看起来其貌不扬，但凭借着惊为天人的直觉，这个洞穴不简单。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a47d0de9a6.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>于是，你开始往洞穴内探索，希望能发现一些有意思的东西。终于，皇天不负有心人，你在洞穴的尽头，发现了一堆不世出的珠宝，凭借你惊人的阅历，一眼便看出了它们各自的价值，心想着下下下下下下下下半辈子都有着落了。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a564a63265.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>然而，天有不测风云，正准备将它们收入囊中，却不小心触碰到一个防御机关，洞穴马上就要崩塌了。在此危机时刻，你只有一个背包，你必须尽快做出抉择，从中选择最值钱的珠宝塞到你的背包，让背包中珠宝的总价值最大。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a56572a8c0.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>好了好了，啰里啰嗦了大半天，我还是来精简一下问题吧。简而言之，你只有一个容量有限的背包，总容量为c，有n个可待选择的物品，每个物品只有一件，它们都有各自的重量和价值，你需要从中选择合适的组合来使得你背包中的物品总价值最大。</p>\n<h2 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h2><p>那还不简单，不管是什么，先往背包里塞，塞满赶紧走，狗命要紧，狗命要紧。。。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/10/5c8515f07c869.png\" alt=\"20190310214935.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190310214935.png</div>\n            </figure>\n<p>好了好了，开个玩笑，言归正传。</p>\n<p>简单起见，我们来将上面的问题具体化，举一个更具体的栗子：</p>\n<p>假设有5个物品，它们的价值(v)和重量(w)如下图：</p>\n<img src=\"/programming/leetcode/dp-01-knapsack-problem/IMG_9B418BF0E7A5-1.jpeg\" title=\"pic\">\n<p>背包总容量为10，现在要从中选择物品装入背包中，要求物品的重量不能超过背包的容量，并且最后放在背包中物品的总价值最大。</p>\n<p>emmm，等等，为什么叫做<code>0/1背包</code>呢？为什么不叫<code>1/2背包</code>，<code>2/3背包</code>？？？</p>\n<p>仔细想想，这里每个物品只有一个，对于每个物品而言，只有两种选择，盘它或者不盘，盘它记为1，不盘记为0，我们不能将物品进行分割，比如只拿半个是不允许的。这就是这个问题被称为<code>0/1背包</code>问题的原因。</p>\n<p>所以究竟选还是不选，这是个问题。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a56a150bc1.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>让我们先来体验一下将珠宝装入背包的感觉，为了方便起见，用<code>xi</code>代表第i个珠宝的选择（<code>xi = 1</code> 代表选择该珠宝，0则代表不选），<code>vi</code>代表第i个珠宝的价值，<code>wi</code>代表第i个珠宝的重量。于是我们就有了这样的限制条件：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/10/5c851ebfd4687.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>我们的初始状态是背包容量为10，背包内物品总价值为0，接下来，我们就要开始做选择了。对于1号珠宝，当前容量为10，容纳它的重量2绰绰有余，因此有两种选择，选它或者不选。我们选择一个珠宝的时候，背包的容量会减少，但是里面的物品总价值会增加。就像下面这样：</p>\n<img src=\"/programming/leetcode/dp-01-knapsack-problem/IMG_2ABCC82C89F7-1.jpeg\" title=\"exhaust-algorithm\">\n<p>这样就分出了两种情况，我们继续进行选择，如果我们选择了珠宝1，那么对于珠宝2，当前剩余容量为8，大于珠宝2的容量3，因此也有两种选择，选或者不选。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/10/5c8524cc69459.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>现在，我们得到了四个可能结果，我们每做出一个选择，就会将上面的每一种可能分裂成两种可能，后续的选择也是如此，最终，我们会得到如下的一张决策图：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/10/5c85286b617f4.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>这里被涂上色的方框代表我们的最终待选结果，本来应该有16个待选结果，但有三个结果由于容量不足以容纳下最后一个珠宝，所以就没有继续进行裂变。</p>\n<p>然后，我们从这些结果中，找出价值最大的那个，也就是<code>13</code>，这就是我们的最优选择，根据这个选择，依次找到它的所有路径，便可以知道该选哪几个珠宝，最终结果是：珠宝4，珠宝2，珠宝1。</p>\n<h2 id=\"分治法\"><a href=\"#分治法\" class=\"headerlink\" title=\"分治法\"></a>分治法</h2><p>接下来，我们就来分析一下，如何将它扩展到一般情况。为了实现这个目的，我们需要将问题进行抽象并建模，然后将其划分为更小的子问题，找出递推关系式，这是分治思想中很重要的一步。</p>\n<ol>\n<li>抽象问题，背包问题抽象为寻找组合（x1,x2,x3…xn，其中xi取0或1，表示第i个物品取或者不取），vi代表第i个物品的价值，wi代表第i个物品的重量，总物品数为n，背包容量为c。</li>\n<li>建模，问题即求max(x1v1 + x2v2 + x3v3 + … + xnvn)。</li>\n<li>约束条件，x1w1 + x2w2 + x3w3 + … + xnwn &lt; c</li>\n<li>定义函数KS(i,j)：代表当前背包剩余容量为j时，前i个物品最佳组合所对应的价值；</li>\n</ol>\n<p>那这里的递推关系式是怎样的呢？对于第i个物品，有两种可能：</p>\n<ol>\n<li>背包剩余容量不足以容纳该物品，此时背包的价值与前i-1个物品的价值是一样的，KS(i,j) = KS(i-1,j)</li>\n<li>背包剩余容量可以装下该商品，此时需要进行判断，因为装了该商品不一定能使最终组合达到最大价值，如果不装该商品，则价值为：KS(i-1,j)，如果装了该商品，则价值为KS(i-1,j-wi) + vi，从两者中选择较大的那个，所以就得出了递推关系式：</li>\n</ol>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/12/5c87b64eb1a66.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>对于这个问题的子问题，这里有必要详细说明一下。原问题是，将n件物品放入容量为c的背包，子问题则是，将前i件物品放入容量为j的背包，所得到的最优价值为KS(i,j)，如果只考虑第i件物品放还是不放，那么就可以转化为一个只涉及到前i-1个物品的问题。如果不放第i个物品，那么问题就转化为“前i-1件物品放入容量为j的背包中的最优价值组合”，对应的值为KS(i-1,j)。如果放第i个物品，那么问题就转化成了“前i-1件物品放入容量为j-wi的背包中的最优价值组合”，此时对应的值为KS(i-1,j-wi)+vi。</p>\n<p>所以，就可以很容易的写出递归解法了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] vs = &#123;<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] ws = &#123;<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testKnapsack1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ks(<span class=\"number\">4</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">ks</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || c == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 初始条件</span></span><br><span class=\"line\">            result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(ws[i] &gt; c)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 装不下该珠宝</span></span><br><span class=\"line\">            result = ks(i-<span class=\"number\">1</span>, c);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 可以装下</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp1 = ks(i-<span class=\"number\">1</span>, c);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp2 = ks(i-<span class=\"number\">1</span>, c-ws[i]) + vs[i];</span><br><span class=\"line\">            result = Math.max(tmp1, tmp2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里为了方便处理，将数组ws和vs都增加了一个补位数0，防止数组越界，输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">13</span><br></pre></td></tr></table></figure>\n<p>这样，我们就轻松加愉快的解决了这个问题。</p>\n<h2 id=\"动态规划解法\"><a href=\"#动态规划解法\" class=\"headerlink\" title=\"动态规划解法\"></a>动态规划解法</h2><h3 id=\"验证可行性\"><a href=\"#验证可行性\" class=\"headerlink\" title=\"验证可行性\"></a>验证可行性</h3><p>既然开头已经说了两个验证问题是否可以使用动态规划求解的方法，那么为何不试一试呢？</p>\n<p>先来看看<code>最优化原理</code>。同样，我们使用反证法：</p>\n<p>假设(x1，x2，…，xn)是01背包问题的最优解，则有(x2，x3，…，xn)是其子问题的最优解，假设(y2，y3，…，yn)是上述问题的子问题最优解，则有(v2y2+v3y3+…+vnyn)+v1x1 &gt; (v2x2+v3x3+…+vnxn)+v1x1。说明(X1，Y2，Y3，…，Yn)才是该01背包问题的最优解，这与最开始的假设(X1，X2，…，Xn)是01背包问题的最优解相矛盾，故01背包问题满足<code>最优性原理</code>。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a5766a30bc.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>至于<code>无后效性</code>，其实比较好理解。对于任意一个阶段，只要背包剩余容量和可选物品是一样的，那么我们能做出的现阶段的最优选择必定是一样的，是不受之前选择了什么物品所影响的。即满足<code>无后效性</code>。</p>\n<h3 id=\"自上而下记忆法\"><a href=\"#自上而下记忆法\" class=\"headerlink\" title=\"自上而下记忆法\"></a>自上而下记忆法</h3><p>就像上一篇里的解法一样，自上而下的解法与分治法的区别就是增加了一个数组用来存储计算的中间结果来减少重复计算。这里，我们只需要多定义一个二维数组。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/12/5c87c27322752.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>表格中，每一个格子都代表着一个子问题，我们最终的问题是求最右下角的格子的值，也就是<code>i=4,j=10</code>时的值。这里，我们的初始条件便是i=0或者j=0时对应的ks值为0，这很好理解，如果可选物品为0，或者剩余容量为0，那么最大价值自然也是0。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] vs = &#123;<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] ws = &#123;<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    Integer[][] results = <span class=\"keyword\">new</span> Integer[<span class=\"number\">5</span>][<span class=\"number\">11</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testKnapsack2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ks2(<span class=\"number\">4</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">ks2</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 如果该结果已经被计算，那么直接返回</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (results[i][c] != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> results[i][c];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || c == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 初始条件</span></span><br><span class=\"line\">            result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(ws[i] &gt; c)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 装不下该珠宝</span></span><br><span class=\"line\">            result = ks(i-<span class=\"number\">1</span>, c);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 可以装下</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp1 = ks(i-<span class=\"number\">1</span>, c);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp2 = ks(i-<span class=\"number\">1</span>, c-ws[i]) + vs[i];</span><br><span class=\"line\">            result = Math.max(tmp1, tmp2);</span><br><span class=\"line\">            results[i][c] = result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，其实只比分治多了三行代码。</p>\n<h3 id=\"自下而上填表法\"><a href=\"#自下而上填表法\" class=\"headerlink\" title=\"自下而上填表法\"></a>自下而上填表法</h3><p>接下来，我们用自下而上的方法来解一下这道题，思路很简单，就是不断的填表，回想一下上一篇中的斐波拉契数列的自下而上解法，这里将使用同样的方式来解决。还是使用上面的表格，我们开始一行行填表。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/12/5c87c45b5d9bf.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>当i=1时，即只有珠宝1可供选择，那么如果容量足够的话，最大价值自然就是珠宝1的价值了。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/12/5c87c4c11104c.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>当i=2时，有两个物品可供选择，此时应用上面的递推关系式进行判断即可。这里以i=2,j=3为例进行分析：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/12/5c87c673e6c36.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>剩下的格子使用相同的方法进行填充即可：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/12/5c87c75ba58ce.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>这样，我们就得到了最后的结果：13。根据结果，我们可以反向找出各个物品的选择，寻找的方法很简单，就是从<code>i=4,j=10</code>开始寻找，如果<code>ks(i-1,j)=ks(i,j)</code>，说明第i个物品没有被选中，从<code>ks(i-1,j)</code>继续寻找。否则，表示第i个物品已被选中，则从<code>ks(i-1,j-wi)</code>开始寻找。</p>\n<img src=\"/programming/leetcode/dp-01-knapsack-problem/IMG_BFE9B7063670-1.jpeg\" title=\"exhaust-algorithm\">\n<p>转化成代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] vs = &#123;<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] ws = &#123;<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    Integer[][] results = <span class=\"keyword\">new</span> Integer[<span class=\"number\">5</span>][<span class=\"number\">11</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testKnapsack3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ks3(<span class=\"number\">4</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">ks3</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> m = <span class=\"number\">0</span>; m &lt;= i; m++)&#123;</span><br><span class=\"line\">            results[m][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> m = <span class=\"number\">0</span>; m &lt;= j; m++)&#123;</span><br><span class=\"line\">            results[<span class=\"number\">0</span>][m] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 开始填表</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> m = <span class=\"number\">1</span>; m &lt;= i; m++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> n = <span class=\"number\">1</span>; n &lt;= j; n++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (n &lt; ws[m])&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 装不进去</span></span><br><span class=\"line\">                    results[m][n] = results[m-<span class=\"number\">1</span>][n];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 容量足够</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (results[m-<span class=\"number\">1</span>][n] &gt; results[m-<span class=\"number\">1</span>][n-ws[m]] + vs[m])&#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 不装该珠宝，最优价值更大</span></span><br><span class=\"line\">                        results[m][n] = results[m-<span class=\"number\">1</span>][n];</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        results[m][n] = results[m-<span class=\"number\">1</span>][n-ws[m]] + vs[m];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> results[i][j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>嗯，完美解决。时间复杂度即填表耗时<code>O(n * c)</code>，这里用了一个二维数组来存储子问题的解，所以空间复杂度为<code>O(n * c)</code>;</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>回过头再看看上面的分析，会发现动态规划里最关键的问题其实是寻找原问题的子问题，并写出递推表达式，只要完成了这一步，代码部分都是水到渠成的事情了。</p>\n<p>那么问题来了，怎样把问题拆分成子问题呢？</p>\n<p>emmm，这个问题有点超纲了，说实话，我也没有掌握到诀窍，还是得具体情况具体分析，但是很多经典的问题都有其经典的套路，其它问题都可以归结到这些问题上面来，可以看做是它们的变种和延伸，把这些经典的问题吃透的话，自然能举一反三。比如采药问题，本质上就是01背包问题，而硬币问题，本质上就是我们之后要介绍的完全背包问题。</p>\n<p>个人认为，算法不在于刷多少个，而在于归纳总结，就跟做数学题一样，总有一些范式和套路，不管形式如何变化，其本质是一样的，万变不离其宗，说的就是这么回事。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a580b1789e.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>本篇到此就告一段落了，如果觉得有收获，不要吝啬你的赞哦，也欢迎关注我的公众号留言交流。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a58ba229ca.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>前面用<code>动态规划</code>解决了正则表达式的问题，感觉还是不过瘾，总觉得对于<code>动态规划</code>的理解还没有到位，所以趁热打铁，继续研究几个<code>动态规划</code>的经典问题，希望能够借此加深对<code>动态规划</code>的理解。在此之前，还需要说两个跟动态规划有关的理论知识。</p>\n<h2 id=\"最优化原理\"><a href=\"#最优化原理\" class=\"headerlink\" title=\"最优化原理\"></a>最优化原理</h2><p><code>最优化原理</code>指的最优策略具有这样的性质：不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简单来说就是一个最优策略的子策略也是必须是最优的，而所有子问题的局部最优解将导致整个问题的全局最优。如果一个问题能满足<code>最优化原理</code>，就称其具有<code>最优子结构性质</code>。</p>\n<p>这是判断问题能否使用动态规划解决的先决条件，如果一个问题不能满足最优化原理，那么这个问题就不适合用动态规划来求解。</p>\n<p>这样说可能比较模糊，来举个栗子吧：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a1e400a1c1.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>如上图，<em>求从A点到E点的最短距离</em>，那么子问题就是<em>求从A点到E点之间的中间点到E点的最短距离，比如这里的B点</em>。</p>\n<p>那么这个问题里，怎么证明最优化原理呢？</p>\n<p>我们假设从A点到E点的最短距离为d，其最优策略的子策略假设经过B点，记该策略中B点到E点的距离为<code>d1</code>，A点到B点的距离为<code>d2</code>。我们可以使用反证法，假设存在B点到E点的最短距离<code>d3</code>，并且<code>d3 &lt; d1</code>，那么 <code>d3 + d2 &lt; d1 + d2 = d</code>，这与d是最短距离相矛盾，所以，<code>d1</code>是B点到E点的最短距离。</p>\n<p>为了增加理解，这里再举一个反例：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a3c4e20747.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>图中有四个点，A、B、C、D，相邻两点有两条连线，代表两条通道，d1,d2,d3,d4,d5,d6代表的是道路的长度，求A到D的所有通道中，总长度除以4得到的余数最小的路径为<em>最优路径</em>，求一条<em>最优路径</em>。</p>\n<p>这里如果还是按照上面的思路去求解，就会误入歧途了。按照之前的思路，A的最优取值应该可以由B的最优取值来确定，而B的最优取值为（3+5）mod 4 = 0。所以应该选<code>d2</code>和<code>d6</code>这两条道路，而实际上，全局最优解是<code>d4+d5+d6</code>或者<code>d1+d5+d3</code>。所以这里子问题的最优解并不是原问题的最优解，即不满足最优化原理。所以就不适合使用动态规划来求解了。</p>\n<h2 id=\"无后效性\"><a href=\"#无后效性\" class=\"headerlink\" title=\"无后效性\"></a>无后效性</h2><p><code>无后效性</code>指的是某状态下决策的收益，只与状态和决策相关，与到达该状态的方式无关。某个阶段的状态一旦确定，则此后过程的演变不再受此前各种状态及决策的影响。换句话说，未来与过去无关，当前状态是此前历史状态的完整总结，此前历史决策只能通过影响当前的状态来影响未来的演变。再换句话说，过去做的选择不会影响现在能做的最优选择，现在能做的最优选择只与当前的状态有关，与经过如何复杂的决策到达该状态的方式无关。</p>\n<p>这也是用来验证问题是否可以使用动态规划来解答的重要方法。</p>\n<p>我们再回头看看上面的最短路径问题，如果在原来的基础上加上一个限制条件：<em>同一个格子只能通过一次</em>。那么， 这个题就不符合无后效性了，因为前一个子问题的解会对后面子问题的选择策略有影响，比如说，如果从A到B选择了一条如下图中绿色表示的路线，那么从B点出发到达E点的路线就只有一条了。也就是说从A点到B点的路径选择会影响B点到E点的路径选择。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a47085f922.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>理论部分就此打住，接下来我们实战一下。</p>\n<h2 id=\"01背包问题\"><a href=\"#01背包问题\" class=\"headerlink\" title=\"01背包问题\"></a>01背包问题</h2><p>假设你是一名经验丰富的探险家，背着背包来到野外进行日常探险。天气晴朗而不燥热，山间的风夹杂着花香，正当你欣赏这世外桃源般的美景时，突然，你发现了一个洞穴，这个洞穴外表看起来其貌不扬，但凭借着惊为天人的直觉，这个洞穴不简单。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a47d0de9a6.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>于是，你开始往洞穴内探索，希望能发现一些有意思的东西。终于，皇天不负有心人，你在洞穴的尽头，发现了一堆不世出的珠宝，凭借你惊人的阅历，一眼便看出了它们各自的价值，心想着下下下下下下下下半辈子都有着落了。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a564a63265.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>然而，天有不测风云，正准备将它们收入囊中，却不小心触碰到一个防御机关，洞穴马上就要崩塌了。在此危机时刻，你只有一个背包，你必须尽快做出抉择，从中选择最值钱的珠宝塞到你的背包，让背包中珠宝的总价值最大。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a56572a8c0.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>好了好了，啰里啰嗦了大半天，我还是来精简一下问题吧。简而言之，你只有一个容量有限的背包，总容量为c，有n个可待选择的物品，每个物品只有一件，它们都有各自的重量和价值，你需要从中选择合适的组合来使得你背包中的物品总价值最大。</p>\n<h2 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h2><p>那还不简单，不管是什么，先往背包里塞，塞满赶紧走，狗命要紧，狗命要紧。。。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/10/5c8515f07c869.png\" alt=\"20190310214935.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190310214935.png</div>\n            </figure>\n<p>好了好了，开个玩笑，言归正传。</p>\n<p>简单起见，我们来将上面的问题具体化，举一个更具体的栗子：</p>\n<p>假设有5个物品，它们的价值(v)和重量(w)如下图：</p>\n<img src=\"/programming/leetcode/dp-01-knapsack-problem/IMG_9B418BF0E7A5-1.jpeg\" title=\"pic\">\n<p>背包总容量为10，现在要从中选择物品装入背包中，要求物品的重量不能超过背包的容量，并且最后放在背包中物品的总价值最大。</p>\n<p>emmm，等等，为什么叫做<code>0/1背包</code>呢？为什么不叫<code>1/2背包</code>，<code>2/3背包</code>？？？</p>\n<p>仔细想想，这里每个物品只有一个，对于每个物品而言，只有两种选择，盘它或者不盘，盘它记为1，不盘记为0，我们不能将物品进行分割，比如只拿半个是不允许的。这就是这个问题被称为<code>0/1背包</code>问题的原因。</p>\n<p>所以究竟选还是不选，这是个问题。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a56a150bc1.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>让我们先来体验一下将珠宝装入背包的感觉，为了方便起见，用<code>xi</code>代表第i个珠宝的选择（<code>xi = 1</code> 代表选择该珠宝，0则代表不选），<code>vi</code>代表第i个珠宝的价值，<code>wi</code>代表第i个珠宝的重量。于是我们就有了这样的限制条件：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/10/5c851ebfd4687.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>我们的初始状态是背包容量为10，背包内物品总价值为0，接下来，我们就要开始做选择了。对于1号珠宝，当前容量为10，容纳它的重量2绰绰有余，因此有两种选择，选它或者不选。我们选择一个珠宝的时候，背包的容量会减少，但是里面的物品总价值会增加。就像下面这样：</p>\n<img src=\"/programming/leetcode/dp-01-knapsack-problem/IMG_2ABCC82C89F7-1.jpeg\" title=\"exhaust-algorithm\">\n<p>这样就分出了两种情况，我们继续进行选择，如果我们选择了珠宝1，那么对于珠宝2，当前剩余容量为8，大于珠宝2的容量3，因此也有两种选择，选或者不选。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/10/5c8524cc69459.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>现在，我们得到了四个可能结果，我们每做出一个选择，就会将上面的每一种可能分裂成两种可能，后续的选择也是如此，最终，我们会得到如下的一张决策图：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/10/5c85286b617f4.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>这里被涂上色的方框代表我们的最终待选结果，本来应该有16个待选结果，但有三个结果由于容量不足以容纳下最后一个珠宝，所以就没有继续进行裂变。</p>\n<p>然后，我们从这些结果中，找出价值最大的那个，也就是<code>13</code>，这就是我们的最优选择，根据这个选择，依次找到它的所有路径，便可以知道该选哪几个珠宝，最终结果是：珠宝4，珠宝2，珠宝1。</p>\n<h2 id=\"分治法\"><a href=\"#分治法\" class=\"headerlink\" title=\"分治法\"></a>分治法</h2><p>接下来，我们就来分析一下，如何将它扩展到一般情况。为了实现这个目的，我们需要将问题进行抽象并建模，然后将其划分为更小的子问题，找出递推关系式，这是分治思想中很重要的一步。</p>\n<ol>\n<li>抽象问题，背包问题抽象为寻找组合（x1,x2,x3…xn，其中xi取0或1，表示第i个物品取或者不取），vi代表第i个物品的价值，wi代表第i个物品的重量，总物品数为n，背包容量为c。</li>\n<li>建模，问题即求max(x1v1 + x2v2 + x3v3 + … + xnvn)。</li>\n<li>约束条件，x1w1 + x2w2 + x3w3 + … + xnwn &lt; c</li>\n<li>定义函数KS(i,j)：代表当前背包剩余容量为j时，前i个物品最佳组合所对应的价值；</li>\n</ol>\n<p>那这里的递推关系式是怎样的呢？对于第i个物品，有两种可能：</p>\n<ol>\n<li>背包剩余容量不足以容纳该物品，此时背包的价值与前i-1个物品的价值是一样的，KS(i,j) = KS(i-1,j)</li>\n<li>背包剩余容量可以装下该商品，此时需要进行判断，因为装了该商品不一定能使最终组合达到最大价值，如果不装该商品，则价值为：KS(i-1,j)，如果装了该商品，则价值为KS(i-1,j-wi) + vi，从两者中选择较大的那个，所以就得出了递推关系式：</li>\n</ol>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/12/5c87b64eb1a66.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>对于这个问题的子问题，这里有必要详细说明一下。原问题是，将n件物品放入容量为c的背包，子问题则是，将前i件物品放入容量为j的背包，所得到的最优价值为KS(i,j)，如果只考虑第i件物品放还是不放，那么就可以转化为一个只涉及到前i-1个物品的问题。如果不放第i个物品，那么问题就转化为“前i-1件物品放入容量为j的背包中的最优价值组合”，对应的值为KS(i-1,j)。如果放第i个物品，那么问题就转化成了“前i-1件物品放入容量为j-wi的背包中的最优价值组合”，此时对应的值为KS(i-1,j-wi)+vi。</p>\n<p>所以，就可以很容易的写出递归解法了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] vs = &#123;<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] ws = &#123;<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testKnapsack1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ks(<span class=\"number\">4</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">ks</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || c == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 初始条件</span></span><br><span class=\"line\">            result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(ws[i] &gt; c)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 装不下该珠宝</span></span><br><span class=\"line\">            result = ks(i-<span class=\"number\">1</span>, c);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 可以装下</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp1 = ks(i-<span class=\"number\">1</span>, c);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp2 = ks(i-<span class=\"number\">1</span>, c-ws[i]) + vs[i];</span><br><span class=\"line\">            result = Math.max(tmp1, tmp2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里为了方便处理，将数组ws和vs都增加了一个补位数0，防止数组越界，输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">13</span><br></pre></td></tr></table></figure>\n<p>这样，我们就轻松加愉快的解决了这个问题。</p>\n<h2 id=\"动态规划解法\"><a href=\"#动态规划解法\" class=\"headerlink\" title=\"动态规划解法\"></a>动态规划解法</h2><h3 id=\"验证可行性\"><a href=\"#验证可行性\" class=\"headerlink\" title=\"验证可行性\"></a>验证可行性</h3><p>既然开头已经说了两个验证问题是否可以使用动态规划求解的方法，那么为何不试一试呢？</p>\n<p>先来看看<code>最优化原理</code>。同样，我们使用反证法：</p>\n<p>假设(x1，x2，…，xn)是01背包问题的最优解，则有(x2，x3，…，xn)是其子问题的最优解，假设(y2，y3，…，yn)是上述问题的子问题最优解，则有(v2y2+v3y3+…+vnyn)+v1x1 &gt; (v2x2+v3x3+…+vnxn)+v1x1。说明(X1，Y2，Y3，…，Yn)才是该01背包问题的最优解，这与最开始的假设(X1，X2，…，Xn)是01背包问题的最优解相矛盾，故01背包问题满足<code>最优性原理</code>。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a5766a30bc.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>至于<code>无后效性</code>，其实比较好理解。对于任意一个阶段，只要背包剩余容量和可选物品是一样的，那么我们能做出的现阶段的最优选择必定是一样的，是不受之前选择了什么物品所影响的。即满足<code>无后效性</code>。</p>\n<h3 id=\"自上而下记忆法\"><a href=\"#自上而下记忆法\" class=\"headerlink\" title=\"自上而下记忆法\"></a>自上而下记忆法</h3><p>就像上一篇里的解法一样，自上而下的解法与分治法的区别就是增加了一个数组用来存储计算的中间结果来减少重复计算。这里，我们只需要多定义一个二维数组。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/12/5c87c27322752.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>表格中，每一个格子都代表着一个子问题，我们最终的问题是求最右下角的格子的值，也就是<code>i=4,j=10</code>时的值。这里，我们的初始条件便是i=0或者j=0时对应的ks值为0，这很好理解，如果可选物品为0，或者剩余容量为0，那么最大价值自然也是0。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] vs = &#123;<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] ws = &#123;<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    Integer[][] results = <span class=\"keyword\">new</span> Integer[<span class=\"number\">5</span>][<span class=\"number\">11</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testKnapsack2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ks2(<span class=\"number\">4</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">ks2</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 如果该结果已经被计算，那么直接返回</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (results[i][c] != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> results[i][c];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || c == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 初始条件</span></span><br><span class=\"line\">            result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(ws[i] &gt; c)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 装不下该珠宝</span></span><br><span class=\"line\">            result = ks(i-<span class=\"number\">1</span>, c);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 可以装下</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp1 = ks(i-<span class=\"number\">1</span>, c);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp2 = ks(i-<span class=\"number\">1</span>, c-ws[i]) + vs[i];</span><br><span class=\"line\">            result = Math.max(tmp1, tmp2);</span><br><span class=\"line\">            results[i][c] = result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，其实只比分治多了三行代码。</p>\n<h3 id=\"自下而上填表法\"><a href=\"#自下而上填表法\" class=\"headerlink\" title=\"自下而上填表法\"></a>自下而上填表法</h3><p>接下来，我们用自下而上的方法来解一下这道题，思路很简单，就是不断的填表，回想一下上一篇中的斐波拉契数列的自下而上解法，这里将使用同样的方式来解决。还是使用上面的表格，我们开始一行行填表。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/12/5c87c45b5d9bf.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>当i=1时，即只有珠宝1可供选择，那么如果容量足够的话，最大价值自然就是珠宝1的价值了。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/12/5c87c4c11104c.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>当i=2时，有两个物品可供选择，此时应用上面的递推关系式进行判断即可。这里以i=2,j=3为例进行分析：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/12/5c87c673e6c36.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>剩下的格子使用相同的方法进行填充即可：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/12/5c87c75ba58ce.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>这样，我们就得到了最后的结果：13。根据结果，我们可以反向找出各个物品的选择，寻找的方法很简单，就是从<code>i=4,j=10</code>开始寻找，如果<code>ks(i-1,j)=ks(i,j)</code>，说明第i个物品没有被选中，从<code>ks(i-1,j)</code>继续寻找。否则，表示第i个物品已被选中，则从<code>ks(i-1,j-wi)</code>开始寻找。</p>\n<img src=\"/programming/leetcode/dp-01-knapsack-problem/IMG_BFE9B7063670-1.jpeg\" title=\"exhaust-algorithm\">\n<p>转化成代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] vs = &#123;<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] ws = &#123;<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    Integer[][] results = <span class=\"keyword\">new</span> Integer[<span class=\"number\">5</span>][<span class=\"number\">11</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testKnapsack3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ks3(<span class=\"number\">4</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">ks3</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> m = <span class=\"number\">0</span>; m &lt;= i; m++)&#123;</span><br><span class=\"line\">            results[m][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> m = <span class=\"number\">0</span>; m &lt;= j; m++)&#123;</span><br><span class=\"line\">            results[<span class=\"number\">0</span>][m] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 开始填表</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> m = <span class=\"number\">1</span>; m &lt;= i; m++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> n = <span class=\"number\">1</span>; n &lt;= j; n++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (n &lt; ws[m])&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 装不进去</span></span><br><span class=\"line\">                    results[m][n] = results[m-<span class=\"number\">1</span>][n];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 容量足够</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (results[m-<span class=\"number\">1</span>][n] &gt; results[m-<span class=\"number\">1</span>][n-ws[m]] + vs[m])&#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 不装该珠宝，最优价值更大</span></span><br><span class=\"line\">                        results[m][n] = results[m-<span class=\"number\">1</span>][n];</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        results[m][n] = results[m-<span class=\"number\">1</span>][n-ws[m]] + vs[m];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> results[i][j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>嗯，完美解决。时间复杂度即填表耗时<code>O(n * c)</code>，这里用了一个二维数组来存储子问题的解，所以空间复杂度为<code>O(n * c)</code>;</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>回过头再看看上面的分析，会发现动态规划里最关键的问题其实是寻找原问题的子问题，并写出递推表达式，只要完成了这一步，代码部分都是水到渠成的事情了。</p>\n<p>那么问题来了，怎样把问题拆分成子问题呢？</p>\n<p>emmm，这个问题有点超纲了，说实话，我也没有掌握到诀窍，还是得具体情况具体分析，但是很多经典的问题都有其经典的套路，其它问题都可以归结到这些问题上面来，可以看做是它们的变种和延伸，把这些经典的问题吃透的话，自然能举一反三。比如采药问题，本质上就是01背包问题，而硬币问题，本质上就是我们之后要介绍的完全背包问题。</p>\n<p>个人认为，算法不在于刷多少个，而在于归纳总结，就跟做数学题一样，总有一些范式和套路，不管形式如何变化，其本质是一样的，万变不离其宗，说的就是这么回事。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a580b1789e.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>本篇到此就告一段落了，如果觉得有收获，不要吝啬你的赞哦，也欢迎关注我的公众号留言交流。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a58ba229ca.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>"},{"title":"LeetCode单排日记","date":"2018-12-31T16:01:00.000Z","_content":"\n## 初衷\n\n之前有研究过一段时间数据结构与算法，但平时使用的不多，就连排序都很少用（自从JDK8有了Stream，就再也没有手写排序了。），所谓用进废退，时至今日，能记住的已经不多了，还记得之前有一次面试，面试官要求写一个快速排序，结果突然记不起来该怎么写了，于是交了一个插入排序。。。\n\n为了在数据结构与算法方面不至于太辣鸡，特此开一个坑，每天刷一刷LeetCode上的算法题，也顺便把相关的数据结构和算法做一个复习。\n\n如果你也刚好有兴趣一起学习的话，那在这条路上，我能与你作伴。\n\n## 关于LeetCode\n\n`LeetCode`是目前来说做的挺不错的一个可以刷算法题的网站，官网地址是：https://leetcode.com/。 现在也有中文版的网站了，叫做力扣，地址是：https://leetcode-cn.com/。 （要不是因为在官网看到的推广，看这名字还以为是一个翻版的网站）。\n\n所以如果你是英语爱好者，建议使用英文版网站，如果对英语有些排斥，那么中文版网站将是最适合你的。两者的题目内容几乎一致，因为它们是同一家的，所以不需要太在意。\n\n对于非竞赛选手而言，刷题不需要太多，每天刷一道就很不错了，首先当然是要保证答案的正确性，如果你给的解答通过了测试，那么还可以看看其他人的解题姿势，学习一下也是很不错的。最后，别忘了还有讨论区，在里面你往往能发现一些很不错的干货。嗯，当然，做完之后最好还能有一个总结，写写自己的心路历程，解题思路以及看到很精辟的解答时的收获。\n\n不积跬步无以至千里，不积小流无以成江河。一步一个脚印的往前走，有些事情是急不来的，所以静下心来，好好努力便是了。\n\n本系列文章将会每周更新1~2篇（新年计划，尽量不打脸，哈哈），在这里，我将与你分享我的解题思路，以及心得收获，如果你有更好的想法，也欢迎提出，希望我们能在这里，一起交流，共同进步！\n","source":"_posts/leetcode/leetcode-solo-rank-begin.md","raw":"---\ntitle: LeetCode单排日记\ntags: \n - 算法\n - Java\n - LeetCode\ncategories: 编程\ndate: 2019-01-01 00:01:00\n---\n\n## 初衷\n\n之前有研究过一段时间数据结构与算法，但平时使用的不多，就连排序都很少用（自从JDK8有了Stream，就再也没有手写排序了。），所谓用进废退，时至今日，能记住的已经不多了，还记得之前有一次面试，面试官要求写一个快速排序，结果突然记不起来该怎么写了，于是交了一个插入排序。。。\n\n为了在数据结构与算法方面不至于太辣鸡，特此开一个坑，每天刷一刷LeetCode上的算法题，也顺便把相关的数据结构和算法做一个复习。\n\n如果你也刚好有兴趣一起学习的话，那在这条路上，我能与你作伴。\n\n## 关于LeetCode\n\n`LeetCode`是目前来说做的挺不错的一个可以刷算法题的网站，官网地址是：https://leetcode.com/。 现在也有中文版的网站了，叫做力扣，地址是：https://leetcode-cn.com/。 （要不是因为在官网看到的推广，看这名字还以为是一个翻版的网站）。\n\n所以如果你是英语爱好者，建议使用英文版网站，如果对英语有些排斥，那么中文版网站将是最适合你的。两者的题目内容几乎一致，因为它们是同一家的，所以不需要太在意。\n\n对于非竞赛选手而言，刷题不需要太多，每天刷一道就很不错了，首先当然是要保证答案的正确性，如果你给的解答通过了测试，那么还可以看看其他人的解题姿势，学习一下也是很不错的。最后，别忘了还有讨论区，在里面你往往能发现一些很不错的干货。嗯，当然，做完之后最好还能有一个总结，写写自己的心路历程，解题思路以及看到很精辟的解答时的收获。\n\n不积跬步无以至千里，不积小流无以成江河。一步一个脚印的往前走，有些事情是急不来的，所以静下心来，好好努力便是了。\n\n本系列文章将会每周更新1~2篇（新年计划，尽量不打脸，哈哈），在这里，我将与你分享我的解题思路，以及心得收获，如果你有更好的想法，也欢迎提出，希望我们能在这里，一起交流，共同进步！\n","slug":"leetcode/leetcode-solo-rank-begin","published":1,"updated":"2019-06-04T01:29:57.493Z","_id":"cjxze3gny000v0cvwgt26h3po","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"初衷\"><a href=\"#初衷\" class=\"headerlink\" title=\"初衷\"></a>初衷</h2><p>之前有研究过一段时间数据结构与算法，但平时使用的不多，就连排序都很少用（自从JDK8有了Stream，就再也没有手写排序了。），所谓用进废退，时至今日，能记住的已经不多了，还记得之前有一次面试，面试官要求写一个快速排序，结果突然记不起来该怎么写了，于是交了一个插入排序。。。</p>\n<p>为了在数据结构与算法方面不至于太辣鸡，特此开一个坑，每天刷一刷LeetCode上的算法题，也顺便把相关的数据结构和算法做一个复习。</p>\n<p>如果你也刚好有兴趣一起学习的话，那在这条路上，我能与你作伴。</p>\n<h2 id=\"关于LeetCode\"><a href=\"#关于LeetCode\" class=\"headerlink\" title=\"关于LeetCode\"></a>关于LeetCode</h2><p><code>LeetCode</code>是目前来说做的挺不错的一个可以刷算法题的网站，官网地址是：<a href=\"https://leetcode.com/。\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/。</a> 现在也有中文版的网站了，叫做力扣，地址是：<a href=\"https://leetcode-cn.com/。\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/。</a> （要不是因为在官网看到的推广，看这名字还以为是一个翻版的网站）。</p>\n<p>所以如果你是英语爱好者，建议使用英文版网站，如果对英语有些排斥，那么中文版网站将是最适合你的。两者的题目内容几乎一致，因为它们是同一家的，所以不需要太在意。</p>\n<p>对于非竞赛选手而言，刷题不需要太多，每天刷一道就很不错了，首先当然是要保证答案的正确性，如果你给的解答通过了测试，那么还可以看看其他人的解题姿势，学习一下也是很不错的。最后，别忘了还有讨论区，在里面你往往能发现一些很不错的干货。嗯，当然，做完之后最好还能有一个总结，写写自己的心路历程，解题思路以及看到很精辟的解答时的收获。</p>\n<p>不积跬步无以至千里，不积小流无以成江河。一步一个脚印的往前走，有些事情是急不来的，所以静下心来，好好努力便是了。</p>\n<p>本系列文章将会每周更新1~2篇（新年计划，尽量不打脸，哈哈），在这里，我将与你分享我的解题思路，以及心得收获，如果你有更好的想法，也欢迎提出，希望我们能在这里，一起交流，共同进步！</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"初衷\"><a href=\"#初衷\" class=\"headerlink\" title=\"初衷\"></a>初衷</h2><p>之前有研究过一段时间数据结构与算法，但平时使用的不多，就连排序都很少用（自从JDK8有了Stream，就再也没有手写排序了。），所谓用进废退，时至今日，能记住的已经不多了，还记得之前有一次面试，面试官要求写一个快速排序，结果突然记不起来该怎么写了，于是交了一个插入排序。。。</p>\n<p>为了在数据结构与算法方面不至于太辣鸡，特此开一个坑，每天刷一刷LeetCode上的算法题，也顺便把相关的数据结构和算法做一个复习。</p>\n<p>如果你也刚好有兴趣一起学习的话，那在这条路上，我能与你作伴。</p>\n<h2 id=\"关于LeetCode\"><a href=\"#关于LeetCode\" class=\"headerlink\" title=\"关于LeetCode\"></a>关于LeetCode</h2><p><code>LeetCode</code>是目前来说做的挺不错的一个可以刷算法题的网站，官网地址是：<a href=\"https://leetcode.com/。\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/。</a> 现在也有中文版的网站了，叫做力扣，地址是：<a href=\"https://leetcode-cn.com/。\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/。</a> （要不是因为在官网看到的推广，看这名字还以为是一个翻版的网站）。</p>\n<p>所以如果你是英语爱好者，建议使用英文版网站，如果对英语有些排斥，那么中文版网站将是最适合你的。两者的题目内容几乎一致，因为它们是同一家的，所以不需要太在意。</p>\n<p>对于非竞赛选手而言，刷题不需要太多，每天刷一道就很不错了，首先当然是要保证答案的正确性，如果你给的解答通过了测试，那么还可以看看其他人的解题姿势，学习一下也是很不错的。最后，别忘了还有讨论区，在里面你往往能发现一些很不错的干货。嗯，当然，做完之后最好还能有一个总结，写写自己的心路历程，解题思路以及看到很精辟的解答时的收获。</p>\n<p>不积跬步无以至千里，不积小流无以成江河。一步一个脚印的往前走，有些事情是急不来的，所以静下心来，好好努力便是了。</p>\n<p>本系列文章将会每周更新1~2篇（新年计划，尽量不打脸，哈哈），在这里，我将与你分享我的解题思路，以及心得收获，如果你有更好的想法，也欢迎提出，希望我们能在这里，一起交流，共同进步！</p>\n"},{"title":"【动态规划】多重背包问题","date":"2019-05-05T12:32:16.000Z","_content":"\n## 说明\n\n前面已经介绍完了01背包和完全背包，今天介绍最后一种背包问题——多重背包。\n\n这个背包，听起来就很麻烦的样子。别慌，只要你理解了前面的两种背包问题，拿下多重背包简直小菜一碟。\n\n如果没有看过前两篇01背包和完全背包的文章，强烈建议先阅读一下，因为本文跟前两篇文章关联性很强。\n\n## 多重背包\n\n有N种物品和一个容量为T的背包，第i种物品最多有M[i]件可用，价值为P[i]，体积为V[i]，求解：选哪些物品放入背包，可以使得这些物品的价值最大，并且体积总和不超过背包容量。\n\n对比一下完全背包，其实只是多了一个限制条件，完全背包问题中，物品可以选择任意多件，只要你装得下，装多少件都行。\n\n![](https://i.loli.net/2019/05/05/5cced9a232122.png)\n\n但多重背包就不一样了，每种物品都有指定的数量限制，所以不是你想装，就能一直装的。\n\n举个栗子：有A、B、C三种物品，相应的数量、价格和占用空间如下图：\n\n![](https://i.loli.net/2019/05/05/5ccee0bee771a.png)\n\n跟完全背包一样，贪心算法在这里也不适用，我就不重复说明了，大家可以回到上一篇中看看说明。\n\n## 递归法\n\n还是用之前的套路，我们先来用递归把这个问题解决一次。\n\n用ks(i,t)表示前i种物品放入一个容量为t的背包获得的最大价值，那么对于第i种物品，我们有k种选择，0 <= k  <= M[i] && 0 <= k * V[i] <= t，即可以选择0、1、2...M[i]个第i种物品，所以递推表达式为：\n\n```\nks(i,t) = max{ks(i-1, t - V[i] * k) + P[i] * k}; （0 <= k <= M[i] && 0 <= k * V[i] <= t）\n```\n\n同时，ks(0,t)=0;ks(i,0)=0;\n\n对比一下完全背包的递推关系式：\n\n```\nks(i,t) = max{ks(i-1, t - V[i] * k) + P[i] * k}; （0 <= k * V[i] <= t）\n```\n\n简直一毛一样，只是k多了一个限制条件而已。\n\n使用上面的栗子，我们可以先写出递归解法：\n\n```java\npublic static class MultiKnapsack {\n    private static int[] P={0,2,3,4};\n    private static int[] V={0,3,4,5};\n    private static int[] M={0,4,3,2};\n    private static int T = 15;\n\n    @Test\n    public void soleve1() {\n        int result = ks(P.length - 1,T);\n        System.out.println(\"最大价值为：\" + result);\n    }\n\n    private int ks(int i, int t){\n        int result = 0;\n        if (i == 0 || t == 0){\n            // 初始条件\n            result = 0;\n        } else if(V[i] > t){\n            // 装不下该珠宝\n            result = ks(i-1, t);\n        } else {\n            // 可以装下\n            // 取k个物品i，取其中使得总价值最大的k\n            for (int k = 0; k <= M[i] && k * V[i] <= t; k++){\n                int tmp2 = ks(i-1, t - V[i] * k) + P[i] * k;\n                if (tmp2 > result){\n                    result = tmp2;\n                }\n            }\n        }\n        return result;\n    }\n}\n\n```\n\n同样，这里的数组P/V/M分别添加了一个元素0，是为了减少越界判断而做的简单处理，运行如下：\n\n```\n最大价值为：11\n```\n\n对比一下完全背包中的递归解法：\n\n```java\nprivate int ks(int i, int t){\n    int result = 0;\n    if (i == 0 || t == 0){\n        // 初始条件\n        result = 0;\n    } else if(V[i] > t){\n        // 装不下该珠宝\n        result = ks(i-1, t);\n    } else {\n        // 可以装下\n        // 取k个物品i，取其中使得总价值最大的k\n        for (int k = 0; k * V[i] <= t; k++){\n            int tmp2 = ks(i-1, t - V[i] * k) + P[i] * k;\n            if (tmp2 > result){\n                result = tmp2;\n            }\n        }\n    }\n    return result;\n}\n```\n\n仅仅多了一个判断条件而已，所以只要弄懂了完全背包，多重背包就不值一提了。\n\n最优化原理和无后效性的证明跟多重背包基本一致，所以就不重复证明了。\n\n## 动态规划\n\n参考完全背包的动态规划解法，就很容易写出多重背包的动态规划解法。\n\n### 自上而下记忆法\n\n```java\nks(i,t) = max{ks(i-1, t - V[i] * k) + P[i] * k}; （0 <= k <= M[i] && 0 <= k * V[i] <= t）\n```\n\n```java\npublic static class MultiKnapsack {\n    private static int[] P={0,2,3,4};\n    private static int[] V={0,3,4,5};\n    private static int[] M={0,4,3,2};\n    private static int T = 15;\n\n    private Integer[][] results = new Integer[P.length + 1][T + 1];\n\n    @Test\n    public void solve2() {\n        int result = ks2(P.length - 1,T);\n        System.out.println(\"最大价值为：\" + result);\n    }\n\n    private int ks2(int i, int t){\n        // 如果该结果已经被计算，那么直接返回\n        if (results[i][t] != null) return results[i][t];\n        int result = 0;\n        if (i == 0 || t == 0){\n            // 初始条件\n            result = 0;\n        } else if(V[i] > t){\n            // 装不下该珠宝\n            result = ks2(i-1, t);\n        } else {\n            // 可以装下\n            // 取k个物品，取其中使得价值最大的\n            for (int k = 0; k <= M[i] && k * V[i] <= t; k++){\n                int tmp2 = ks2(i-1, t - V[i] * k) + P[i] * k;\n                if (tmp2 > result){\n                    result = tmp2;\n                }\n            }\n        }\n        results[i][t] = result;\n        return result;\n    }\n}\n```\n\n这里其实只是照葫芦画瓢。\n\n### 自下而上填表法\n\n同样也可以使用填表法来解决，此时需要将数组P、V、M额外添加的元素0去掉。\n\n除了k的限制不一样之外，其他地方跟完全背包的解法完全一致：\n\n```java\npublic static class MultiKnapsack {\n    private static int[] P={2,3,4};\n    private static int[] V={3,4,5};\n    private static int[] M={4,3,2};\n    private static int T = 15;\n\n    private int[][] dp = new int[P.length + 1][T + 1];\n\n    @Test\n    public void solve3() {\n        for (int i = 0; i < P.length; i++){\n            for (int j = 0; j <= T; j++){\n                for (int k = 0; k <= M[i] && k * V[i] <= j; k++){\n                    dp[i+1][j] = Math.max(dp[i+1][j], dp[i][j-k * V[i]] + k * P[i]);\n                }\n            }\n        }\n        System.out.println(\"最大价值为：\" + dp[P.length][T]);\n    }\n}\n```\n\n跟01背包问题一样，完全背包的空间复杂度也可以进行优化，具体思路这里就不重复介绍了，可以翻看前面的01背包问题优化篇。\n\n优化后的状态转移方程为：\n\n```\nks(t) = max{ks(t), ks(t - Vi) + Pi}\n```\n\n```java\npublic static class MultiKnapsack {\n    private static int[] P={2,3,4};\n    private static int[] V={3,4,5};\n    private static int[] M={4,3,2};\n    private static int T = 15;\n\n    private int[] newResults = new int[T + 1];\n\n    @Test\n    public void resolve4() {\n        int result = ksp(P.length,T);\n        System.out.println(result);\n    }\n\n    private int ksp(int i, int t){\n        // 开始填表\n        for (int m = 0; m < i; m++){\n            // 考虑第m个物品\n            // 分两种情况\n            // 1： M[m] * V[m] > T 则可以当做完全背包问题来处理\n            if (M[m] * V[m] >= T) {\n                for (int n = V[m]; n <= t ; n++) {\n                    newResults[n] = Math.max(newResults[n], newResults[n - V[m]] + P[m]);\n                }\n            } else {\n                // 2： M[m] * V[m] < T 则需要在 newResults[n-V[m]*k] + P[m] * k 中找到最大值，0 <= k <= M[m]\n                for (int n = V[m]; n <= t ; n++) {\n                    int k = 1;\n                    while (k < M[m] && n > V[m] * k ){\n                        newResults[n] = Math.max(newResults[n], newResults[n - V[m] * k] + P[m] * k);\n                        k++;\n                    }\n                }\n            }\n            // 可以在这里输出中间结果\n            System.out.println(JSON.toJSONString(newResults));\n        }\n        return newResults[newResults.length - 1];\n    }\n}\n```\n\n输出如下：\n\n```\n[0,0,0,0,2,2,2,4,4,4,6,6,6,8,8,8]\n[0,0,0,0,2,3,3,4,5,6,6,7,8,9,9,10]\n[0,0,0,0,2,3,4,4,5,6,7,8,8,9,10,11]\n11\n```\n\n\n这里有一个较大的不同点，在第二层循环中，需要分两种情况考虑，如果 M[m] * V[m] >= T ，那么第m个物品就可以当做完全背包问题来考虑，而如果 M[m] * V[m] < T，则每次选择时，需要从 newResults[n-V[m]*k] + P[m] * k（0 <= k <= M[m]）中找到最大值。\n\n代码很简单，但要理解却并不容易，为了加深理解，再画一张图：\n\n![](https://i.loli.net/2019/05/05/5ccef4c950a89.jpeg)\n\n多重背包问题同样也可以转化成01背包问题来求解，因为第i件物品最多选 M[i] 件，于是可以把第i种物品转化为M[i]件体积和价值相同的物品，然后再来求解这个01背包问题。\n\n## 总结\n\n多重背包问题跟完全背包简直如出一辙，仅仅是比完全背包多一个限制条件而已，如果你回过头去看看前一篇文章，就会发现这篇文章简直就是抄袭。。\n\n![](https://i.loli.net/2019/05/02/5ccaee9d39578.png)\n\n关于多重背包问题的解析到此就结束了，三个经典的背包问题到这里就告一段落了。\n\n![](https://i.loli.net/2019/03/14/5c8a580b1789e.png)\n\n如果有疑问或者有什么想法，也欢迎关注我的公众号进行留言交流：\n\n![](https://i.loli.net/2019/03/14/5c8a58ba229ca.png)","source":"_posts/leetcode/multi-knapsack-problem-md.md","raw":"---\ntitle: 【动态规划】多重背包问题\ndate: 2019-05-05 20:32:16\ntags:\n - Java\n - 算法\n - 动态规划\n - 背包问题\ncategories: 编程\n---\n\n## 说明\n\n前面已经介绍完了01背包和完全背包，今天介绍最后一种背包问题——多重背包。\n\n这个背包，听起来就很麻烦的样子。别慌，只要你理解了前面的两种背包问题，拿下多重背包简直小菜一碟。\n\n如果没有看过前两篇01背包和完全背包的文章，强烈建议先阅读一下，因为本文跟前两篇文章关联性很强。\n\n## 多重背包\n\n有N种物品和一个容量为T的背包，第i种物品最多有M[i]件可用，价值为P[i]，体积为V[i]，求解：选哪些物品放入背包，可以使得这些物品的价值最大，并且体积总和不超过背包容量。\n\n对比一下完全背包，其实只是多了一个限制条件，完全背包问题中，物品可以选择任意多件，只要你装得下，装多少件都行。\n\n![](https://i.loli.net/2019/05/05/5cced9a232122.png)\n\n但多重背包就不一样了，每种物品都有指定的数量限制，所以不是你想装，就能一直装的。\n\n举个栗子：有A、B、C三种物品，相应的数量、价格和占用空间如下图：\n\n![](https://i.loli.net/2019/05/05/5ccee0bee771a.png)\n\n跟完全背包一样，贪心算法在这里也不适用，我就不重复说明了，大家可以回到上一篇中看看说明。\n\n## 递归法\n\n还是用之前的套路，我们先来用递归把这个问题解决一次。\n\n用ks(i,t)表示前i种物品放入一个容量为t的背包获得的最大价值，那么对于第i种物品，我们有k种选择，0 <= k  <= M[i] && 0 <= k * V[i] <= t，即可以选择0、1、2...M[i]个第i种物品，所以递推表达式为：\n\n```\nks(i,t) = max{ks(i-1, t - V[i] * k) + P[i] * k}; （0 <= k <= M[i] && 0 <= k * V[i] <= t）\n```\n\n同时，ks(0,t)=0;ks(i,0)=0;\n\n对比一下完全背包的递推关系式：\n\n```\nks(i,t) = max{ks(i-1, t - V[i] * k) + P[i] * k}; （0 <= k * V[i] <= t）\n```\n\n简直一毛一样，只是k多了一个限制条件而已。\n\n使用上面的栗子，我们可以先写出递归解法：\n\n```java\npublic static class MultiKnapsack {\n    private static int[] P={0,2,3,4};\n    private static int[] V={0,3,4,5};\n    private static int[] M={0,4,3,2};\n    private static int T = 15;\n\n    @Test\n    public void soleve1() {\n        int result = ks(P.length - 1,T);\n        System.out.println(\"最大价值为：\" + result);\n    }\n\n    private int ks(int i, int t){\n        int result = 0;\n        if (i == 0 || t == 0){\n            // 初始条件\n            result = 0;\n        } else if(V[i] > t){\n            // 装不下该珠宝\n            result = ks(i-1, t);\n        } else {\n            // 可以装下\n            // 取k个物品i，取其中使得总价值最大的k\n            for (int k = 0; k <= M[i] && k * V[i] <= t; k++){\n                int tmp2 = ks(i-1, t - V[i] * k) + P[i] * k;\n                if (tmp2 > result){\n                    result = tmp2;\n                }\n            }\n        }\n        return result;\n    }\n}\n\n```\n\n同样，这里的数组P/V/M分别添加了一个元素0，是为了减少越界判断而做的简单处理，运行如下：\n\n```\n最大价值为：11\n```\n\n对比一下完全背包中的递归解法：\n\n```java\nprivate int ks(int i, int t){\n    int result = 0;\n    if (i == 0 || t == 0){\n        // 初始条件\n        result = 0;\n    } else if(V[i] > t){\n        // 装不下该珠宝\n        result = ks(i-1, t);\n    } else {\n        // 可以装下\n        // 取k个物品i，取其中使得总价值最大的k\n        for (int k = 0; k * V[i] <= t; k++){\n            int tmp2 = ks(i-1, t - V[i] * k) + P[i] * k;\n            if (tmp2 > result){\n                result = tmp2;\n            }\n        }\n    }\n    return result;\n}\n```\n\n仅仅多了一个判断条件而已，所以只要弄懂了完全背包，多重背包就不值一提了。\n\n最优化原理和无后效性的证明跟多重背包基本一致，所以就不重复证明了。\n\n## 动态规划\n\n参考完全背包的动态规划解法，就很容易写出多重背包的动态规划解法。\n\n### 自上而下记忆法\n\n```java\nks(i,t) = max{ks(i-1, t - V[i] * k) + P[i] * k}; （0 <= k <= M[i] && 0 <= k * V[i] <= t）\n```\n\n```java\npublic static class MultiKnapsack {\n    private static int[] P={0,2,3,4};\n    private static int[] V={0,3,4,5};\n    private static int[] M={0,4,3,2};\n    private static int T = 15;\n\n    private Integer[][] results = new Integer[P.length + 1][T + 1];\n\n    @Test\n    public void solve2() {\n        int result = ks2(P.length - 1,T);\n        System.out.println(\"最大价值为：\" + result);\n    }\n\n    private int ks2(int i, int t){\n        // 如果该结果已经被计算，那么直接返回\n        if (results[i][t] != null) return results[i][t];\n        int result = 0;\n        if (i == 0 || t == 0){\n            // 初始条件\n            result = 0;\n        } else if(V[i] > t){\n            // 装不下该珠宝\n            result = ks2(i-1, t);\n        } else {\n            // 可以装下\n            // 取k个物品，取其中使得价值最大的\n            for (int k = 0; k <= M[i] && k * V[i] <= t; k++){\n                int tmp2 = ks2(i-1, t - V[i] * k) + P[i] * k;\n                if (tmp2 > result){\n                    result = tmp2;\n                }\n            }\n        }\n        results[i][t] = result;\n        return result;\n    }\n}\n```\n\n这里其实只是照葫芦画瓢。\n\n### 自下而上填表法\n\n同样也可以使用填表法来解决，此时需要将数组P、V、M额外添加的元素0去掉。\n\n除了k的限制不一样之外，其他地方跟完全背包的解法完全一致：\n\n```java\npublic static class MultiKnapsack {\n    private static int[] P={2,3,4};\n    private static int[] V={3,4,5};\n    private static int[] M={4,3,2};\n    private static int T = 15;\n\n    private int[][] dp = new int[P.length + 1][T + 1];\n\n    @Test\n    public void solve3() {\n        for (int i = 0; i < P.length; i++){\n            for (int j = 0; j <= T; j++){\n                for (int k = 0; k <= M[i] && k * V[i] <= j; k++){\n                    dp[i+1][j] = Math.max(dp[i+1][j], dp[i][j-k * V[i]] + k * P[i]);\n                }\n            }\n        }\n        System.out.println(\"最大价值为：\" + dp[P.length][T]);\n    }\n}\n```\n\n跟01背包问题一样，完全背包的空间复杂度也可以进行优化，具体思路这里就不重复介绍了，可以翻看前面的01背包问题优化篇。\n\n优化后的状态转移方程为：\n\n```\nks(t) = max{ks(t), ks(t - Vi) + Pi}\n```\n\n```java\npublic static class MultiKnapsack {\n    private static int[] P={2,3,4};\n    private static int[] V={3,4,5};\n    private static int[] M={4,3,2};\n    private static int T = 15;\n\n    private int[] newResults = new int[T + 1];\n\n    @Test\n    public void resolve4() {\n        int result = ksp(P.length,T);\n        System.out.println(result);\n    }\n\n    private int ksp(int i, int t){\n        // 开始填表\n        for (int m = 0; m < i; m++){\n            // 考虑第m个物品\n            // 分两种情况\n            // 1： M[m] * V[m] > T 则可以当做完全背包问题来处理\n            if (M[m] * V[m] >= T) {\n                for (int n = V[m]; n <= t ; n++) {\n                    newResults[n] = Math.max(newResults[n], newResults[n - V[m]] + P[m]);\n                }\n            } else {\n                // 2： M[m] * V[m] < T 则需要在 newResults[n-V[m]*k] + P[m] * k 中找到最大值，0 <= k <= M[m]\n                for (int n = V[m]; n <= t ; n++) {\n                    int k = 1;\n                    while (k < M[m] && n > V[m] * k ){\n                        newResults[n] = Math.max(newResults[n], newResults[n - V[m] * k] + P[m] * k);\n                        k++;\n                    }\n                }\n            }\n            // 可以在这里输出中间结果\n            System.out.println(JSON.toJSONString(newResults));\n        }\n        return newResults[newResults.length - 1];\n    }\n}\n```\n\n输出如下：\n\n```\n[0,0,0,0,2,2,2,4,4,4,6,6,6,8,8,8]\n[0,0,0,0,2,3,3,4,5,6,6,7,8,9,9,10]\n[0,0,0,0,2,3,4,4,5,6,7,8,8,9,10,11]\n11\n```\n\n\n这里有一个较大的不同点，在第二层循环中，需要分两种情况考虑，如果 M[m] * V[m] >= T ，那么第m个物品就可以当做完全背包问题来考虑，而如果 M[m] * V[m] < T，则每次选择时，需要从 newResults[n-V[m]*k] + P[m] * k（0 <= k <= M[m]）中找到最大值。\n\n代码很简单，但要理解却并不容易，为了加深理解，再画一张图：\n\n![](https://i.loli.net/2019/05/05/5ccef4c950a89.jpeg)\n\n多重背包问题同样也可以转化成01背包问题来求解，因为第i件物品最多选 M[i] 件，于是可以把第i种物品转化为M[i]件体积和价值相同的物品，然后再来求解这个01背包问题。\n\n## 总结\n\n多重背包问题跟完全背包简直如出一辙，仅仅是比完全背包多一个限制条件而已，如果你回过头去看看前一篇文章，就会发现这篇文章简直就是抄袭。。\n\n![](https://i.loli.net/2019/05/02/5ccaee9d39578.png)\n\n关于多重背包问题的解析到此就结束了，三个经典的背包问题到这里就告一段落了。\n\n![](https://i.loli.net/2019/03/14/5c8a580b1789e.png)\n\n如果有疑问或者有什么想法，也欢迎关注我的公众号进行留言交流：\n\n![](https://i.loli.net/2019/03/14/5c8a58ba229ca.png)","slug":"leetcode/multi-knapsack-problem-md","published":1,"updated":"2019-06-04T01:29:57.493Z","_id":"cjxze3gny000y0cvwnr1uuwpf","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>前面已经介绍完了01背包和完全背包，今天介绍最后一种背包问题——多重背包。</p>\n<p>这个背包，听起来就很麻烦的样子。别慌，只要你理解了前面的两种背包问题，拿下多重背包简直小菜一碟。</p>\n<p>如果没有看过前两篇01背包和完全背包的文章，强烈建议先阅读一下，因为本文跟前两篇文章关联性很强。</p>\n<h2 id=\"多重背包\"><a href=\"#多重背包\" class=\"headerlink\" title=\"多重背包\"></a>多重背包</h2><p>有N种物品和一个容量为T的背包，第i种物品最多有M[i]件可用，价值为P[i]，体积为V[i]，求解：选哪些物品放入背包，可以使得这些物品的价值最大，并且体积总和不超过背包容量。</p>\n<p>对比一下完全背包，其实只是多了一个限制条件，完全背包问题中，物品可以选择任意多件，只要你装得下，装多少件都行。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/05/5cced9a232122.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>但多重背包就不一样了，每种物品都有指定的数量限制，所以不是你想装，就能一直装的。</p>\n<p>举个栗子：有A、B、C三种物品，相应的数量、价格和占用空间如下图：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/05/5ccee0bee771a.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>跟完全背包一样，贪心算法在这里也不适用，我就不重复说明了，大家可以回到上一篇中看看说明。</p>\n<h2 id=\"递归法\"><a href=\"#递归法\" class=\"headerlink\" title=\"递归法\"></a>递归法</h2><p>还是用之前的套路，我们先来用递归把这个问题解决一次。</p>\n<p>用ks(i,t)表示前i种物品放入一个容量为t的背包获得的最大价值，那么对于第i种物品，我们有k种选择，0 &lt;= k  &lt;= M[i] &amp;&amp; 0 &lt;= k * V[i] &lt;= t，即可以选择0、1、2…M[i]个第i种物品，所以递推表达式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ks(i,t) = max&#123;ks(i-1, t - V[i] * k) + P[i] * k&#125;; （0 &lt;= k &lt;= M[i] &amp;&amp; 0 &lt;= k * V[i] &lt;= t）</span><br></pre></td></tr></table></figure>\n<p>同时，ks(0,t)=0;ks(i,0)=0;</p>\n<p>对比一下完全背包的递推关系式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ks(i,t) = max&#123;ks(i-1, t - V[i] * k) + P[i] * k&#125;; （0 &lt;= k * V[i] &lt;= t）</span><br></pre></td></tr></table></figure>\n<p>简直一毛一样，只是k多了一个限制条件而已。</p>\n<p>使用上面的栗子，我们可以先写出递归解法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MultiKnapsack</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] P=&#123;<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] V=&#123;<span class=\"number\">0</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] M=&#123;<span class=\"number\">0</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> T = <span class=\"number\">15</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">soleve1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ks(P.length - <span class=\"number\">1</span>,T);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"最大价值为：\"</span> + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">ks</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> t)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || t == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 初始条件</span></span><br><span class=\"line\">            result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(V[i] &gt; t)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 装不下该珠宝</span></span><br><span class=\"line\">            result = ks(i-<span class=\"number\">1</span>, t);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 可以装下</span></span><br><span class=\"line\">            <span class=\"comment\">// 取k个物品i，取其中使得总价值最大的k</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt;= M[i] &amp;&amp; k * V[i] &lt;= t; k++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> tmp2 = ks(i-<span class=\"number\">1</span>, t - V[i] * k) + P[i] * k;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp2 &gt; result)&#123;</span><br><span class=\"line\">                    result = tmp2;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样，这里的数组P/V/M分别添加了一个元素0，是为了减少越界判断而做的简单处理，运行如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最大价值为：11</span><br></pre></td></tr></table></figure>\n<p>对比一下完全背包中的递归解法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">ks</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> t)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || t == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始条件</span></span><br><span class=\"line\">        result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(V[i] &gt; t)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 装不下该珠宝</span></span><br><span class=\"line\">        result = ks(i-<span class=\"number\">1</span>, t);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以装下</span></span><br><span class=\"line\">        <span class=\"comment\">// 取k个物品i，取其中使得总价值最大的k</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k * V[i] &lt;= t; k++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp2 = ks(i-<span class=\"number\">1</span>, t - V[i] * k) + P[i] * k;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tmp2 &gt; result)&#123;</span><br><span class=\"line\">                result = tmp2;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>仅仅多了一个判断条件而已，所以只要弄懂了完全背包，多重背包就不值一提了。</p>\n<p>最优化原理和无后效性的证明跟多重背包基本一致，所以就不重复证明了。</p>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><p>参考完全背包的动态规划解法，就很容易写出多重背包的动态规划解法。</p>\n<h3 id=\"自上而下记忆法\"><a href=\"#自上而下记忆法\" class=\"headerlink\" title=\"自上而下记忆法\"></a>自上而下记忆法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ks(i,t) = max&#123;ks(i-<span class=\"number\">1</span>, t - V[i] * k) + P[i] * k&#125;; （<span class=\"number\">0</span> &lt;= k &lt;= M[i] &amp;&amp; <span class=\"number\">0</span> &lt;= k * V[i] &lt;= t）</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MultiKnapsack</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] P=&#123;<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] V=&#123;<span class=\"number\">0</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] M=&#123;<span class=\"number\">0</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> T = <span class=\"number\">15</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer[][] results = <span class=\"keyword\">new</span> Integer[P.length + <span class=\"number\">1</span>][T + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">solve2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ks2(P.length - <span class=\"number\">1</span>,T);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"最大价值为：\"</span> + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">ks2</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> t)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果该结果已经被计算，那么直接返回</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (results[i][t] != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> results[i][t];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || t == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 初始条件</span></span><br><span class=\"line\">            result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(V[i] &gt; t)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 装不下该珠宝</span></span><br><span class=\"line\">            result = ks2(i-<span class=\"number\">1</span>, t);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 可以装下</span></span><br><span class=\"line\">            <span class=\"comment\">// 取k个物品，取其中使得价值最大的</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt;= M[i] &amp;&amp; k * V[i] &lt;= t; k++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> tmp2 = ks2(i-<span class=\"number\">1</span>, t - V[i] * k) + P[i] * k;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp2 &gt; result)&#123;</span><br><span class=\"line\">                    result = tmp2;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        results[i][t] = result;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里其实只是照葫芦画瓢。</p>\n<h3 id=\"自下而上填表法\"><a href=\"#自下而上填表法\" class=\"headerlink\" title=\"自下而上填表法\"></a>自下而上填表法</h3><p>同样也可以使用填表法来解决，此时需要将数组P、V、M额外添加的元素0去掉。</p>\n<p>除了k的限制不一样之外，其他地方跟完全背包的解法完全一致：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MultiKnapsack</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] P=&#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] V=&#123;<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] M=&#123;<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> T = <span class=\"number\">15</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[P.length + <span class=\"number\">1</span>][T + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">solve3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; P.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= T; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt;= M[i] &amp;&amp; k * V[i] &lt;= j; k++)&#123;</span><br><span class=\"line\">                    dp[i+<span class=\"number\">1</span>][j] = Math.max(dp[i+<span class=\"number\">1</span>][j], dp[i][j-k * V[i]] + k * P[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"最大价值为：\"</span> + dp[P.length][T]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>跟01背包问题一样，完全背包的空间复杂度也可以进行优化，具体思路这里就不重复介绍了，可以翻看前面的01背包问题优化篇。</p>\n<p>优化后的状态转移方程为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ks(t) = max&#123;ks(t), ks(t - Vi) + Pi&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MultiKnapsack</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] P=&#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] V=&#123;<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] M=&#123;<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> T = <span class=\"number\">15</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] newResults = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[T + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">resolve4</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ksp(P.length,T);</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">ksp</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> t)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 开始填表</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> m = <span class=\"number\">0</span>; m &lt; i; m++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 考虑第m个物品</span></span><br><span class=\"line\">            <span class=\"comment\">// 分两种情况</span></span><br><span class=\"line\">            <span class=\"comment\">// 1： M[m] * V[m] &gt; T 则可以当做完全背包问题来处理</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (M[m] * V[m] &gt;= T) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> n = V[m]; n &lt;= t ; n++) &#123;</span><br><span class=\"line\">                    newResults[n] = Math.max(newResults[n], newResults[n - V[m]] + P[m]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 2： M[m] * V[m] &lt; T 则需要在 newResults[n-V[m]*k] + P[m] * k 中找到最大值，0 &lt;= k &lt;= M[m]</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> n = V[m]; n &lt;= t ; n++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> k = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (k &lt; M[m] &amp;&amp; n &gt; V[m] * k )&#123;</span><br><span class=\"line\">                        newResults[n] = Math.max(newResults[n], newResults[n - V[m] * k] + P[m] * k);</span><br><span class=\"line\">                        k++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 可以在这里输出中间结果</span></span><br><span class=\"line\">            System.out.println(JSON.toJSONString(newResults));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newResults[newResults.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0,0,0,0,2,2,2,4,4,4,6,6,6,8,8,8]</span><br><span class=\"line\">[0,0,0,0,2,3,3,4,5,6,6,7,8,9,9,10]</span><br><span class=\"line\">[0,0,0,0,2,3,4,4,5,6,7,8,8,9,10,11]</span><br><span class=\"line\">11</span><br></pre></td></tr></table></figure>\n<p>这里有一个较大的不同点，在第二层循环中，需要分两种情况考虑，如果 M[m] <em> V[m] &gt;= T ，那么第m个物品就可以当做完全背包问题来考虑，而如果 M[m] </em> V[m] &lt; T，则每次选择时，需要从 newResults[n-V[m]<em>k] + P[m] </em> k（0 &lt;= k &lt;= M[m]）中找到最大值。</p>\n<p>代码很简单，但要理解却并不容易，为了加深理解，再画一张图：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/05/5ccef4c950a89.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>多重背包问题同样也可以转化成01背包问题来求解，因为第i件物品最多选 M[i] 件，于是可以把第i种物品转化为M[i]件体积和价值相同的物品，然后再来求解这个01背包问题。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>多重背包问题跟完全背包简直如出一辙，仅仅是比完全背包多一个限制条件而已，如果你回过头去看看前一篇文章，就会发现这篇文章简直就是抄袭。。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/02/5ccaee9d39578.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>关于多重背包问题的解析到此就结束了，三个经典的背包问题到这里就告一段落了。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a580b1789e.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>如果有疑问或者有什么想法，也欢迎关注我的公众号进行留言交流：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a58ba229ca.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>前面已经介绍完了01背包和完全背包，今天介绍最后一种背包问题——多重背包。</p>\n<p>这个背包，听起来就很麻烦的样子。别慌，只要你理解了前面的两种背包问题，拿下多重背包简直小菜一碟。</p>\n<p>如果没有看过前两篇01背包和完全背包的文章，强烈建议先阅读一下，因为本文跟前两篇文章关联性很强。</p>\n<h2 id=\"多重背包\"><a href=\"#多重背包\" class=\"headerlink\" title=\"多重背包\"></a>多重背包</h2><p>有N种物品和一个容量为T的背包，第i种物品最多有M[i]件可用，价值为P[i]，体积为V[i]，求解：选哪些物品放入背包，可以使得这些物品的价值最大，并且体积总和不超过背包容量。</p>\n<p>对比一下完全背包，其实只是多了一个限制条件，完全背包问题中，物品可以选择任意多件，只要你装得下，装多少件都行。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/05/5cced9a232122.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>但多重背包就不一样了，每种物品都有指定的数量限制，所以不是你想装，就能一直装的。</p>\n<p>举个栗子：有A、B、C三种物品，相应的数量、价格和占用空间如下图：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/05/5ccee0bee771a.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>跟完全背包一样，贪心算法在这里也不适用，我就不重复说明了，大家可以回到上一篇中看看说明。</p>\n<h2 id=\"递归法\"><a href=\"#递归法\" class=\"headerlink\" title=\"递归法\"></a>递归法</h2><p>还是用之前的套路，我们先来用递归把这个问题解决一次。</p>\n<p>用ks(i,t)表示前i种物品放入一个容量为t的背包获得的最大价值，那么对于第i种物品，我们有k种选择，0 &lt;= k  &lt;= M[i] &amp;&amp; 0 &lt;= k * V[i] &lt;= t，即可以选择0、1、2…M[i]个第i种物品，所以递推表达式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ks(i,t) = max&#123;ks(i-1, t - V[i] * k) + P[i] * k&#125;; （0 &lt;= k &lt;= M[i] &amp;&amp; 0 &lt;= k * V[i] &lt;= t）</span><br></pre></td></tr></table></figure>\n<p>同时，ks(0,t)=0;ks(i,0)=0;</p>\n<p>对比一下完全背包的递推关系式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ks(i,t) = max&#123;ks(i-1, t - V[i] * k) + P[i] * k&#125;; （0 &lt;= k * V[i] &lt;= t）</span><br></pre></td></tr></table></figure>\n<p>简直一毛一样，只是k多了一个限制条件而已。</p>\n<p>使用上面的栗子，我们可以先写出递归解法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MultiKnapsack</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] P=&#123;<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] V=&#123;<span class=\"number\">0</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] M=&#123;<span class=\"number\">0</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> T = <span class=\"number\">15</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">soleve1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ks(P.length - <span class=\"number\">1</span>,T);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"最大价值为：\"</span> + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">ks</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> t)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || t == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 初始条件</span></span><br><span class=\"line\">            result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(V[i] &gt; t)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 装不下该珠宝</span></span><br><span class=\"line\">            result = ks(i-<span class=\"number\">1</span>, t);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 可以装下</span></span><br><span class=\"line\">            <span class=\"comment\">// 取k个物品i，取其中使得总价值最大的k</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt;= M[i] &amp;&amp; k * V[i] &lt;= t; k++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> tmp2 = ks(i-<span class=\"number\">1</span>, t - V[i] * k) + P[i] * k;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp2 &gt; result)&#123;</span><br><span class=\"line\">                    result = tmp2;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样，这里的数组P/V/M分别添加了一个元素0，是为了减少越界判断而做的简单处理，运行如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最大价值为：11</span><br></pre></td></tr></table></figure>\n<p>对比一下完全背包中的递归解法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">ks</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> t)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || t == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始条件</span></span><br><span class=\"line\">        result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(V[i] &gt; t)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 装不下该珠宝</span></span><br><span class=\"line\">        result = ks(i-<span class=\"number\">1</span>, t);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以装下</span></span><br><span class=\"line\">        <span class=\"comment\">// 取k个物品i，取其中使得总价值最大的k</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k * V[i] &lt;= t; k++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp2 = ks(i-<span class=\"number\">1</span>, t - V[i] * k) + P[i] * k;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tmp2 &gt; result)&#123;</span><br><span class=\"line\">                result = tmp2;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>仅仅多了一个判断条件而已，所以只要弄懂了完全背包，多重背包就不值一提了。</p>\n<p>最优化原理和无后效性的证明跟多重背包基本一致，所以就不重复证明了。</p>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><p>参考完全背包的动态规划解法，就很容易写出多重背包的动态规划解法。</p>\n<h3 id=\"自上而下记忆法\"><a href=\"#自上而下记忆法\" class=\"headerlink\" title=\"自上而下记忆法\"></a>自上而下记忆法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ks(i,t) = max&#123;ks(i-<span class=\"number\">1</span>, t - V[i] * k) + P[i] * k&#125;; （<span class=\"number\">0</span> &lt;= k &lt;= M[i] &amp;&amp; <span class=\"number\">0</span> &lt;= k * V[i] &lt;= t）</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MultiKnapsack</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] P=&#123;<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] V=&#123;<span class=\"number\">0</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] M=&#123;<span class=\"number\">0</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> T = <span class=\"number\">15</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer[][] results = <span class=\"keyword\">new</span> Integer[P.length + <span class=\"number\">1</span>][T + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">solve2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ks2(P.length - <span class=\"number\">1</span>,T);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"最大价值为：\"</span> + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">ks2</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> t)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果该结果已经被计算，那么直接返回</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (results[i][t] != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> results[i][t];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || t == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 初始条件</span></span><br><span class=\"line\">            result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(V[i] &gt; t)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 装不下该珠宝</span></span><br><span class=\"line\">            result = ks2(i-<span class=\"number\">1</span>, t);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 可以装下</span></span><br><span class=\"line\">            <span class=\"comment\">// 取k个物品，取其中使得价值最大的</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt;= M[i] &amp;&amp; k * V[i] &lt;= t; k++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> tmp2 = ks2(i-<span class=\"number\">1</span>, t - V[i] * k) + P[i] * k;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tmp2 &gt; result)&#123;</span><br><span class=\"line\">                    result = tmp2;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        results[i][t] = result;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里其实只是照葫芦画瓢。</p>\n<h3 id=\"自下而上填表法\"><a href=\"#自下而上填表法\" class=\"headerlink\" title=\"自下而上填表法\"></a>自下而上填表法</h3><p>同样也可以使用填表法来解决，此时需要将数组P、V、M额外添加的元素0去掉。</p>\n<p>除了k的限制不一样之外，其他地方跟完全背包的解法完全一致：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MultiKnapsack</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] P=&#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] V=&#123;<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] M=&#123;<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> T = <span class=\"number\">15</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[P.length + <span class=\"number\">1</span>][T + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">solve3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; P.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= T; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt;= M[i] &amp;&amp; k * V[i] &lt;= j; k++)&#123;</span><br><span class=\"line\">                    dp[i+<span class=\"number\">1</span>][j] = Math.max(dp[i+<span class=\"number\">1</span>][j], dp[i][j-k * V[i]] + k * P[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"最大价值为：\"</span> + dp[P.length][T]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>跟01背包问题一样，完全背包的空间复杂度也可以进行优化，具体思路这里就不重复介绍了，可以翻看前面的01背包问题优化篇。</p>\n<p>优化后的状态转移方程为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ks(t) = max&#123;ks(t), ks(t - Vi) + Pi&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MultiKnapsack</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] P=&#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] V=&#123;<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] M=&#123;<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> T = <span class=\"number\">15</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] newResults = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[T + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">resolve4</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ksp(P.length,T);</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">ksp</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> t)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 开始填表</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> m = <span class=\"number\">0</span>; m &lt; i; m++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 考虑第m个物品</span></span><br><span class=\"line\">            <span class=\"comment\">// 分两种情况</span></span><br><span class=\"line\">            <span class=\"comment\">// 1： M[m] * V[m] &gt; T 则可以当做完全背包问题来处理</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (M[m] * V[m] &gt;= T) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> n = V[m]; n &lt;= t ; n++) &#123;</span><br><span class=\"line\">                    newResults[n] = Math.max(newResults[n], newResults[n - V[m]] + P[m]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 2： M[m] * V[m] &lt; T 则需要在 newResults[n-V[m]*k] + P[m] * k 中找到最大值，0 &lt;= k &lt;= M[m]</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> n = V[m]; n &lt;= t ; n++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> k = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (k &lt; M[m] &amp;&amp; n &gt; V[m] * k )&#123;</span><br><span class=\"line\">                        newResults[n] = Math.max(newResults[n], newResults[n - V[m] * k] + P[m] * k);</span><br><span class=\"line\">                        k++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 可以在这里输出中间结果</span></span><br><span class=\"line\">            System.out.println(JSON.toJSONString(newResults));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newResults[newResults.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0,0,0,0,2,2,2,4,4,4,6,6,6,8,8,8]</span><br><span class=\"line\">[0,0,0,0,2,3,3,4,5,6,6,7,8,9,9,10]</span><br><span class=\"line\">[0,0,0,0,2,3,4,4,5,6,7,8,8,9,10,11]</span><br><span class=\"line\">11</span><br></pre></td></tr></table></figure>\n<p>这里有一个较大的不同点，在第二层循环中，需要分两种情况考虑，如果 M[m] <em> V[m] &gt;= T ，那么第m个物品就可以当做完全背包问题来考虑，而如果 M[m] </em> V[m] &lt; T，则每次选择时，需要从 newResults[n-V[m]<em>k] + P[m] </em> k（0 &lt;= k &lt;= M[m]）中找到最大值。</p>\n<p>代码很简单，但要理解却并不容易，为了加深理解，再画一张图：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/05/5ccef4c950a89.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>多重背包问题同样也可以转化成01背包问题来求解，因为第i件物品最多选 M[i] 件，于是可以把第i种物品转化为M[i]件体积和价值相同的物品，然后再来求解这个01背包问题。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>多重背包问题跟完全背包简直如出一辙，仅仅是比完全背包多一个限制条件而已，如果你回过头去看看前一篇文章，就会发现这篇文章简直就是抄袭。。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/02/5ccaee9d39578.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>关于多重背包问题的解析到此就结束了，三个经典的背包问题到这里就告一段落了。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a580b1789e.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>如果有疑问或者有什么想法，也欢迎关注我的公众号进行留言交流：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a58ba229ca.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>"},{"title":"【动态规划】一次搞定三种背包问题","date":"2019-05-07T11:56:03.000Z","_content":"\n## 前文链接\n\n[【动态规划】01背包问题](https://www.cnblogs.com/mfrank/p/10533701.html)\n\n[【动态规划】01背包问题【续】](https://www.cnblogs.com/mfrank/p/10587463.html)\n\n[【动态规划】完全背包问题](https://www.cnblogs.com/mfrank/p/10803417.html)\n\n[【动态规划】多重背包问题](https://www.cnblogs.com/mfrank/p/10816837.html)\n\n## 说明\n\n看完前面四篇关于背包问题的文章，你会发现背包问题其实也不过如此，而且它们之间有很多相似的地方，本篇文章就来揭开它们面纱，将背包问题彻底搞定。\n\n## 三种背包问题的比较\n\n先来回顾一下三个背包问题的定义：\n\n> 01背包：\n> 有N件物品和一个容量为V的背包，第i件物品消耗的容量为Ci，价值为Wi，求解放入哪些物品可以使得背包中总价值最大。\n\n> 完全背包：\n> 有N种物品和一个容量为V的背包，每种物品都有无限件可用，第i件物品消耗的容量为Ci，价值为Wi，求解放入哪些物品可以使得背包中总价值最大。\n\n> 多重背包：\n> 有N种物品和一个容量为V的背包，第i种物品最多有Mi件可用，每件物品消耗的容量为Ci，价值为Wi，求解入哪些物品可以使得背包中总价值最大。\n\n三种背包问题都有一个共同的限制，那就是背包容量，背包的容量是有限的，这便限制了物品的选择，而三种背包问题的共同目的，便是让背包中的物品价值最大。\n\n不同的地方在于物品数量的限制，01背包问题中，每种物品只有一个，对于每种物品而言，便只有选和不选两个选择。完全背包问题中，每种物品有无限多个，所以可选的范围要大很多。在多重背包问题中，每种物品都有各自的数量限制。\n\n三种背包问题虽然对于物品数量的限制不一样，但都可以转化为01背包问题来进行思考。在完全背包问题中，虽然每种物品都可以选择无限个，但由于背包容量有限，实际上每种物品可以选择的数量也是有限的，那么将每种物品都看做是 V/Ci 种只有一件的不同物品，不就成了01背包问题吗？对于多重背包也是如此，只是每种物品的膨胀数量变成了 min{Mi, V/Ci}。\n\n所以说，01背包问题是所有背包问题的基础，弄懂了01背包问题后，完全背包和多重背包就没有什么难的地方了。\n\n下面我们来对比一下三种背包问题的状态转移方程，以便更好的理解它们之间的联系：\n\n01背包的状态转移方程：\n\n```\nF[i,v] = max{F[i-1,v], F[i-1,v-Ci] + Wi}\n```\n\n完全背包的状态转移方程：\n\n```\nF[i,v] = max{F[i-1,v-kCi] + kWi | 0 <= kCi <= v}\n```\n\n多重背包的状态转移方程：\n\n```\nF[i,v] = max{F[i-1,v-kCi] + kWi | 0 <= k <= Mi}\n```\n\n把这三个方程放到一起，便能很清晰的看到它们之间的关系了，三种背包问题都是基于子问题来选取价值最大的一个，只是选择的范围不一样。\n\n01背包考虑的是选和不选，所有只需要比较两种策略的最大值即可，而完全背包和多重背包要考虑的是选几个的问题。\n\n这样说也许还是不够形象，举个栗子就能比较好的说明了：\n\n假设背包容量为10，有两个物品可选，价值分别为：3，2，容量占用分别为，4，3。\n\n初始状态：\n\n![](https://i.loli.net/2019/05/11/5cd684433922b.jpeg)\n\n01背包的填表法：\n\n![](https://i.loli.net/2019/05/11/5cd6864f6eb81.jpeg)\n\n完全背包的填表法：\n\n![](https://i.loli.net/2019/05/11/5cd6864d1d669.jpeg)\n\n多重背包的填表法：\n\n假设两种物品的可选数量分别为：2，1.\n\n![](https://i.loli.net/2019/05/11/5cd6864e5627b.jpeg)\n\n下面再来看看三种背包问题的一维数组解决方案。\n\n01背包：\n\n```\nfor i <- 1 to N\n    for v <- V to Ci\n        F[v] = max{F[v],F[v-Ci] + Wi}\n```\n\n将其核心部分抽象出来：\n\n```\ndef ZeroOneKnapsack(F,C,W)\n    for v <- V to C\n        F[v] = max{F[v],F[v-C] + W}\n```\n\n则01背包问题可以表示为：\n\n```\nfor i <- 1 to N\n    ZeroOneKnapsack(F,Ci,Wi)\n```\n\n> N代表物品数量，Ci代表第i个物品占用的容量，V代表背包总容量，Wi代表第i个物品的价值，下同。\n\n完全背包：\n\n```\nfor i <- 1 to N\n    for v <- Ci to V\n        F[v] = max{F[v],F[v-Ci] + Wi}\n```\n\n将其核心部分抽象出来：\n\n```\ndef CompleteKnapsack(F,C,W)\n    for v <- C to V\n        F[v] = max{F[v],F[v-C] + W}\n```\n\n则完全背包问题的解可以表示为：\n\n```\nfor i <- 1 to N\n    CompleteKnapsack(F,Ci,Wi)\n```\n\n多重背包：\n\n```\nfor i <- 1 to N\n    if v < Ci * Mi\n        F[v] = max{F[v],F[v-Ci] + Wi}\n    else\n        for v <- Ci to V\n            k <- 1\n            while k < M && v > Ci * k\n                F[v] = max{F[v],F[v-Ci*k] + Wi*k}\n                k++\n```\n\n抽象出核心逻辑：\n\n```\ndef MultiKnapsack(F,C,W,M)\n    if C * M >= V\n        CompleteKnapsack(F,C,W)\n        return\n    else\n        k <- 1\n        while k < M\n            ZeroOneKnapsack(F,KC,KW)\n            k++\n        return\n```\n\n则多重背包问题的解可以表示为：\n\n```\nfor i <- 1 to N\n    MultiKnapsack(F,Ci,Wi,Mi)\n```\n\n> Mi 代表第i件物品最多可选数量\n\n## 混合背包问题\n\n现在我们来考虑一种更为复杂的情况，如果可选的物品同时具有上述三种特性，即：有的物品只能选一个，有的物品可以选择任意多个，有的物品只能选择有限多个，那么此时该如何决策呢？\n\n其实有了上面的总结和抽象，这种混合背包问题就小菜一碟了。\n\n回顾一下上面的三种背包问题的抽象解，就会发现他们每次都只会考虑一种物品，区别只在于第i个物品的可选策略。所以对于混合背包问题，同样也可以一个一个物品考虑，如果这个物品是最多选一个，那么就采用01背包的解决策略，如果是可以选择任意多个，那么就使用完全背包的解决策略，如果只能选择有限多个，那么就使用多重背包的解决策略。\n\n伪代码如下：\n\n```\nfor i <- 1 to N\n    if 第i件物品属于01背包\n        ZeroOneKnapsack(F,Ci,Wi)\n    else if 第i件物品属于完全背包\n        CompleteKnapsack(F,Ci,Wi)\n    else if 第i件物品属于多重背包\n        MultiKnapsack(F,Ci,Wi,Mi)\n```\n\n## 总结\n\n到此为止，我们就已经比较完美的解决了三种背包问题，顺便还解决了一下混合背包问题。虽然条件各不相同，但是解题思路却很相似，相信经过这一篇文章的总结，你对于背包问题也会有更好的理解，并且领会到这种抽象问题的好处。\n\n当然，更深层次的背包问题还有很多，比如二维费用问题，物品依赖问题，鉴于博主学疏才浅，暂时也没有探索的兴趣，所以就不一一进行说明了，有兴趣的话可以自行搜索相关内容。\n\n![](https://i.loli.net/2019/03/14/5c8a580b1789e.png)\n\n如果本文对你有帮助，不要吝啬你的点赞哦。也欢迎关注我的公众号进行留言交流。\n\n![](https://i.loli.net/2019/03/14/5c8a58ba229ca.png)\n\n文末再赠送一个小福利，关注公众号并回复： `python电子书大全`  即可无套路获得上百本python电子书资源。","source":"_posts/leetcode/knapsack-problem-conclusion-md.md","raw":"---\ntitle: 【动态规划】一次搞定三种背包问题\ndate: 2019-05-07 19:56:03\ntags:\n - Java\n - 算法\n - 动态规划\n - 背包问题\ncategories: 编程\n---\n\n## 前文链接\n\n[【动态规划】01背包问题](https://www.cnblogs.com/mfrank/p/10533701.html)\n\n[【动态规划】01背包问题【续】](https://www.cnblogs.com/mfrank/p/10587463.html)\n\n[【动态规划】完全背包问题](https://www.cnblogs.com/mfrank/p/10803417.html)\n\n[【动态规划】多重背包问题](https://www.cnblogs.com/mfrank/p/10816837.html)\n\n## 说明\n\n看完前面四篇关于背包问题的文章，你会发现背包问题其实也不过如此，而且它们之间有很多相似的地方，本篇文章就来揭开它们面纱，将背包问题彻底搞定。\n\n## 三种背包问题的比较\n\n先来回顾一下三个背包问题的定义：\n\n> 01背包：\n> 有N件物品和一个容量为V的背包，第i件物品消耗的容量为Ci，价值为Wi，求解放入哪些物品可以使得背包中总价值最大。\n\n> 完全背包：\n> 有N种物品和一个容量为V的背包，每种物品都有无限件可用，第i件物品消耗的容量为Ci，价值为Wi，求解放入哪些物品可以使得背包中总价值最大。\n\n> 多重背包：\n> 有N种物品和一个容量为V的背包，第i种物品最多有Mi件可用，每件物品消耗的容量为Ci，价值为Wi，求解入哪些物品可以使得背包中总价值最大。\n\n三种背包问题都有一个共同的限制，那就是背包容量，背包的容量是有限的，这便限制了物品的选择，而三种背包问题的共同目的，便是让背包中的物品价值最大。\n\n不同的地方在于物品数量的限制，01背包问题中，每种物品只有一个，对于每种物品而言，便只有选和不选两个选择。完全背包问题中，每种物品有无限多个，所以可选的范围要大很多。在多重背包问题中，每种物品都有各自的数量限制。\n\n三种背包问题虽然对于物品数量的限制不一样，但都可以转化为01背包问题来进行思考。在完全背包问题中，虽然每种物品都可以选择无限个，但由于背包容量有限，实际上每种物品可以选择的数量也是有限的，那么将每种物品都看做是 V/Ci 种只有一件的不同物品，不就成了01背包问题吗？对于多重背包也是如此，只是每种物品的膨胀数量变成了 min{Mi, V/Ci}。\n\n所以说，01背包问题是所有背包问题的基础，弄懂了01背包问题后，完全背包和多重背包就没有什么难的地方了。\n\n下面我们来对比一下三种背包问题的状态转移方程，以便更好的理解它们之间的联系：\n\n01背包的状态转移方程：\n\n```\nF[i,v] = max{F[i-1,v], F[i-1,v-Ci] + Wi}\n```\n\n完全背包的状态转移方程：\n\n```\nF[i,v] = max{F[i-1,v-kCi] + kWi | 0 <= kCi <= v}\n```\n\n多重背包的状态转移方程：\n\n```\nF[i,v] = max{F[i-1,v-kCi] + kWi | 0 <= k <= Mi}\n```\n\n把这三个方程放到一起，便能很清晰的看到它们之间的关系了，三种背包问题都是基于子问题来选取价值最大的一个，只是选择的范围不一样。\n\n01背包考虑的是选和不选，所有只需要比较两种策略的最大值即可，而完全背包和多重背包要考虑的是选几个的问题。\n\n这样说也许还是不够形象，举个栗子就能比较好的说明了：\n\n假设背包容量为10，有两个物品可选，价值分别为：3，2，容量占用分别为，4，3。\n\n初始状态：\n\n![](https://i.loli.net/2019/05/11/5cd684433922b.jpeg)\n\n01背包的填表法：\n\n![](https://i.loli.net/2019/05/11/5cd6864f6eb81.jpeg)\n\n完全背包的填表法：\n\n![](https://i.loli.net/2019/05/11/5cd6864d1d669.jpeg)\n\n多重背包的填表法：\n\n假设两种物品的可选数量分别为：2，1.\n\n![](https://i.loli.net/2019/05/11/5cd6864e5627b.jpeg)\n\n下面再来看看三种背包问题的一维数组解决方案。\n\n01背包：\n\n```\nfor i <- 1 to N\n    for v <- V to Ci\n        F[v] = max{F[v],F[v-Ci] + Wi}\n```\n\n将其核心部分抽象出来：\n\n```\ndef ZeroOneKnapsack(F,C,W)\n    for v <- V to C\n        F[v] = max{F[v],F[v-C] + W}\n```\n\n则01背包问题可以表示为：\n\n```\nfor i <- 1 to N\n    ZeroOneKnapsack(F,Ci,Wi)\n```\n\n> N代表物品数量，Ci代表第i个物品占用的容量，V代表背包总容量，Wi代表第i个物品的价值，下同。\n\n完全背包：\n\n```\nfor i <- 1 to N\n    for v <- Ci to V\n        F[v] = max{F[v],F[v-Ci] + Wi}\n```\n\n将其核心部分抽象出来：\n\n```\ndef CompleteKnapsack(F,C,W)\n    for v <- C to V\n        F[v] = max{F[v],F[v-C] + W}\n```\n\n则完全背包问题的解可以表示为：\n\n```\nfor i <- 1 to N\n    CompleteKnapsack(F,Ci,Wi)\n```\n\n多重背包：\n\n```\nfor i <- 1 to N\n    if v < Ci * Mi\n        F[v] = max{F[v],F[v-Ci] + Wi}\n    else\n        for v <- Ci to V\n            k <- 1\n            while k < M && v > Ci * k\n                F[v] = max{F[v],F[v-Ci*k] + Wi*k}\n                k++\n```\n\n抽象出核心逻辑：\n\n```\ndef MultiKnapsack(F,C,W,M)\n    if C * M >= V\n        CompleteKnapsack(F,C,W)\n        return\n    else\n        k <- 1\n        while k < M\n            ZeroOneKnapsack(F,KC,KW)\n            k++\n        return\n```\n\n则多重背包问题的解可以表示为：\n\n```\nfor i <- 1 to N\n    MultiKnapsack(F,Ci,Wi,Mi)\n```\n\n> Mi 代表第i件物品最多可选数量\n\n## 混合背包问题\n\n现在我们来考虑一种更为复杂的情况，如果可选的物品同时具有上述三种特性，即：有的物品只能选一个，有的物品可以选择任意多个，有的物品只能选择有限多个，那么此时该如何决策呢？\n\n其实有了上面的总结和抽象，这种混合背包问题就小菜一碟了。\n\n回顾一下上面的三种背包问题的抽象解，就会发现他们每次都只会考虑一种物品，区别只在于第i个物品的可选策略。所以对于混合背包问题，同样也可以一个一个物品考虑，如果这个物品是最多选一个，那么就采用01背包的解决策略，如果是可以选择任意多个，那么就使用完全背包的解决策略，如果只能选择有限多个，那么就使用多重背包的解决策略。\n\n伪代码如下：\n\n```\nfor i <- 1 to N\n    if 第i件物品属于01背包\n        ZeroOneKnapsack(F,Ci,Wi)\n    else if 第i件物品属于完全背包\n        CompleteKnapsack(F,Ci,Wi)\n    else if 第i件物品属于多重背包\n        MultiKnapsack(F,Ci,Wi,Mi)\n```\n\n## 总结\n\n到此为止，我们就已经比较完美的解决了三种背包问题，顺便还解决了一下混合背包问题。虽然条件各不相同，但是解题思路却很相似，相信经过这一篇文章的总结，你对于背包问题也会有更好的理解，并且领会到这种抽象问题的好处。\n\n当然，更深层次的背包问题还有很多，比如二维费用问题，物品依赖问题，鉴于博主学疏才浅，暂时也没有探索的兴趣，所以就不一一进行说明了，有兴趣的话可以自行搜索相关内容。\n\n![](https://i.loli.net/2019/03/14/5c8a580b1789e.png)\n\n如果本文对你有帮助，不要吝啬你的点赞哦。也欢迎关注我的公众号进行留言交流。\n\n![](https://i.loli.net/2019/03/14/5c8a58ba229ca.png)\n\n文末再赠送一个小福利，关注公众号并回复： `python电子书大全`  即可无套路获得上百本python电子书资源。","slug":"leetcode/knapsack-problem-conclusion-md","published":1,"updated":"2019-06-04T01:29:57.483Z","_id":"cjxze3gny00120cvw478hhvpu","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前文链接\"><a href=\"#前文链接\" class=\"headerlink\" title=\"前文链接\"></a>前文链接</h2><p><a href=\"https://www.cnblogs.com/mfrank/p/10533701.html\" target=\"_blank\" rel=\"noopener\">【动态规划】01背包问题</a></p>\n<p><a href=\"https://www.cnblogs.com/mfrank/p/10587463.html\" target=\"_blank\" rel=\"noopener\">【动态规划】01背包问题【续】</a></p>\n<p><a href=\"https://www.cnblogs.com/mfrank/p/10803417.html\" target=\"_blank\" rel=\"noopener\">【动态规划】完全背包问题</a></p>\n<p><a href=\"https://www.cnblogs.com/mfrank/p/10816837.html\" target=\"_blank\" rel=\"noopener\">【动态规划】多重背包问题</a></p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>看完前面四篇关于背包问题的文章，你会发现背包问题其实也不过如此，而且它们之间有很多相似的地方，本篇文章就来揭开它们面纱，将背包问题彻底搞定。</p>\n<h2 id=\"三种背包问题的比较\"><a href=\"#三种背包问题的比较\" class=\"headerlink\" title=\"三种背包问题的比较\"></a>三种背包问题的比较</h2><p>先来回顾一下三个背包问题的定义：</p>\n<blockquote>\n<p>01背包：<br>有N件物品和一个容量为V的背包，第i件物品消耗的容量为Ci，价值为Wi，求解放入哪些物品可以使得背包中总价值最大。</p>\n</blockquote>\n<blockquote>\n<p>完全背包：<br>有N种物品和一个容量为V的背包，每种物品都有无限件可用，第i件物品消耗的容量为Ci，价值为Wi，求解放入哪些物品可以使得背包中总价值最大。</p>\n</blockquote>\n<blockquote>\n<p>多重背包：<br>有N种物品和一个容量为V的背包，第i种物品最多有Mi件可用，每件物品消耗的容量为Ci，价值为Wi，求解入哪些物品可以使得背包中总价值最大。</p>\n</blockquote>\n<p>三种背包问题都有一个共同的限制，那就是背包容量，背包的容量是有限的，这便限制了物品的选择，而三种背包问题的共同目的，便是让背包中的物品价值最大。</p>\n<p>不同的地方在于物品数量的限制，01背包问题中，每种物品只有一个，对于每种物品而言，便只有选和不选两个选择。完全背包问题中，每种物品有无限多个，所以可选的范围要大很多。在多重背包问题中，每种物品都有各自的数量限制。</p>\n<p>三种背包问题虽然对于物品数量的限制不一样，但都可以转化为01背包问题来进行思考。在完全背包问题中，虽然每种物品都可以选择无限个，但由于背包容量有限，实际上每种物品可以选择的数量也是有限的，那么将每种物品都看做是 V/Ci 种只有一件的不同物品，不就成了01背包问题吗？对于多重背包也是如此，只是每种物品的膨胀数量变成了 min{Mi, V/Ci}。</p>\n<p>所以说，01背包问题是所有背包问题的基础，弄懂了01背包问题后，完全背包和多重背包就没有什么难的地方了。</p>\n<p>下面我们来对比一下三种背包问题的状态转移方程，以便更好的理解它们之间的联系：</p>\n<p>01背包的状态转移方程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">F[i,v] = max&#123;F[i-1,v], F[i-1,v-Ci] + Wi&#125;</span><br></pre></td></tr></table></figure>\n<p>完全背包的状态转移方程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">F[i,v] = max&#123;F[i-1,v-kCi] + kWi | 0 &lt;= kCi &lt;= v&#125;</span><br></pre></td></tr></table></figure>\n<p>多重背包的状态转移方程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">F[i,v] = max&#123;F[i-1,v-kCi] + kWi | 0 &lt;= k &lt;= Mi&#125;</span><br></pre></td></tr></table></figure>\n<p>把这三个方程放到一起，便能很清晰的看到它们之间的关系了，三种背包问题都是基于子问题来选取价值最大的一个，只是选择的范围不一样。</p>\n<p>01背包考虑的是选和不选，所有只需要比较两种策略的最大值即可，而完全背包和多重背包要考虑的是选几个的问题。</p>\n<p>这样说也许还是不够形象，举个栗子就能比较好的说明了：</p>\n<p>假设背包容量为10，有两个物品可选，价值分别为：3，2，容量占用分别为，4，3。</p>\n<p>初始状态：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/11/5cd684433922b.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>01背包的填表法：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/11/5cd6864f6eb81.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>完全背包的填表法：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/11/5cd6864d1d669.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>多重背包的填表法：</p>\n<p>假设两种物品的可选数量分别为：2，1.</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/11/5cd6864e5627b.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>下面再来看看三种背包问题的一维数组解决方案。</p>\n<p>01背包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i &lt;- 1 to N</span><br><span class=\"line\">    for v &lt;- V to Ci</span><br><span class=\"line\">        F[v] = max&#123;F[v],F[v-Ci] + Wi&#125;</span><br></pre></td></tr></table></figure>\n<p>将其核心部分抽象出来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def ZeroOneKnapsack(F,C,W)</span><br><span class=\"line\">    for v &lt;- V to C</span><br><span class=\"line\">        F[v] = max&#123;F[v],F[v-C] + W&#125;</span><br></pre></td></tr></table></figure>\n<p>则01背包问题可以表示为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i &lt;- 1 to N</span><br><span class=\"line\">    ZeroOneKnapsack(F,Ci,Wi)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>N代表物品数量，Ci代表第i个物品占用的容量，V代表背包总容量，Wi代表第i个物品的价值，下同。</p>\n</blockquote>\n<p>完全背包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i &lt;- 1 to N</span><br><span class=\"line\">    for v &lt;- Ci to V</span><br><span class=\"line\">        F[v] = max&#123;F[v],F[v-Ci] + Wi&#125;</span><br></pre></td></tr></table></figure>\n<p>将其核心部分抽象出来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def CompleteKnapsack(F,C,W)</span><br><span class=\"line\">    for v &lt;- C to V</span><br><span class=\"line\">        F[v] = max&#123;F[v],F[v-C] + W&#125;</span><br></pre></td></tr></table></figure>\n<p>则完全背包问题的解可以表示为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i &lt;- 1 to N</span><br><span class=\"line\">    CompleteKnapsack(F,Ci,Wi)</span><br></pre></td></tr></table></figure>\n<p>多重背包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i &lt;- 1 to N</span><br><span class=\"line\">    if v &lt; Ci * Mi</span><br><span class=\"line\">        F[v] = max&#123;F[v],F[v-Ci] + Wi&#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">        for v &lt;- Ci to V</span><br><span class=\"line\">            k &lt;- 1</span><br><span class=\"line\">            while k &lt; M &amp;&amp; v &gt; Ci * k</span><br><span class=\"line\">                F[v] = max&#123;F[v],F[v-Ci*k] + Wi*k&#125;</span><br><span class=\"line\">                k++</span><br></pre></td></tr></table></figure>\n<p>抽象出核心逻辑：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def MultiKnapsack(F,C,W,M)</span><br><span class=\"line\">    if C * M &gt;= V</span><br><span class=\"line\">        CompleteKnapsack(F,C,W)</span><br><span class=\"line\">        return</span><br><span class=\"line\">    else</span><br><span class=\"line\">        k &lt;- 1</span><br><span class=\"line\">        while k &lt; M</span><br><span class=\"line\">            ZeroOneKnapsack(F,KC,KW)</span><br><span class=\"line\">            k++</span><br><span class=\"line\">        return</span><br></pre></td></tr></table></figure>\n<p>则多重背包问题的解可以表示为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i &lt;- 1 to N</span><br><span class=\"line\">    MultiKnapsack(F,Ci,Wi,Mi)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Mi 代表第i件物品最多可选数量</p>\n</blockquote>\n<h2 id=\"混合背包问题\"><a href=\"#混合背包问题\" class=\"headerlink\" title=\"混合背包问题\"></a>混合背包问题</h2><p>现在我们来考虑一种更为复杂的情况，如果可选的物品同时具有上述三种特性，即：有的物品只能选一个，有的物品可以选择任意多个，有的物品只能选择有限多个，那么此时该如何决策呢？</p>\n<p>其实有了上面的总结和抽象，这种混合背包问题就小菜一碟了。</p>\n<p>回顾一下上面的三种背包问题的抽象解，就会发现他们每次都只会考虑一种物品，区别只在于第i个物品的可选策略。所以对于混合背包问题，同样也可以一个一个物品考虑，如果这个物品是最多选一个，那么就采用01背包的解决策略，如果是可以选择任意多个，那么就使用完全背包的解决策略，如果只能选择有限多个，那么就使用多重背包的解决策略。</p>\n<p>伪代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i &lt;- 1 to N</span><br><span class=\"line\">    if 第i件物品属于01背包</span><br><span class=\"line\">        ZeroOneKnapsack(F,Ci,Wi)</span><br><span class=\"line\">    else if 第i件物品属于完全背包</span><br><span class=\"line\">        CompleteKnapsack(F,Ci,Wi)</span><br><span class=\"line\">    else if 第i件物品属于多重背包</span><br><span class=\"line\">        MultiKnapsack(F,Ci,Wi,Mi)</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>到此为止，我们就已经比较完美的解决了三种背包问题，顺便还解决了一下混合背包问题。虽然条件各不相同，但是解题思路却很相似，相信经过这一篇文章的总结，你对于背包问题也会有更好的理解，并且领会到这种抽象问题的好处。</p>\n<p>当然，更深层次的背包问题还有很多，比如二维费用问题，物品依赖问题，鉴于博主学疏才浅，暂时也没有探索的兴趣，所以就不一一进行说明了，有兴趣的话可以自行搜索相关内容。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a580b1789e.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>如果本文对你有帮助，不要吝啬你的点赞哦。也欢迎关注我的公众号进行留言交流。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a58ba229ca.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>文末再赠送一个小福利，关注公众号并回复： <code>python电子书大全</code>  即可无套路获得上百本python电子书资源。</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"前文链接\"><a href=\"#前文链接\" class=\"headerlink\" title=\"前文链接\"></a>前文链接</h2><p><a href=\"https://www.cnblogs.com/mfrank/p/10533701.html\" target=\"_blank\" rel=\"noopener\">【动态规划】01背包问题</a></p>\n<p><a href=\"https://www.cnblogs.com/mfrank/p/10587463.html\" target=\"_blank\" rel=\"noopener\">【动态规划】01背包问题【续】</a></p>\n<p><a href=\"https://www.cnblogs.com/mfrank/p/10803417.html\" target=\"_blank\" rel=\"noopener\">【动态规划】完全背包问题</a></p>\n<p><a href=\"https://www.cnblogs.com/mfrank/p/10816837.html\" target=\"_blank\" rel=\"noopener\">【动态规划】多重背包问题</a></p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>看完前面四篇关于背包问题的文章，你会发现背包问题其实也不过如此，而且它们之间有很多相似的地方，本篇文章就来揭开它们面纱，将背包问题彻底搞定。</p>\n<h2 id=\"三种背包问题的比较\"><a href=\"#三种背包问题的比较\" class=\"headerlink\" title=\"三种背包问题的比较\"></a>三种背包问题的比较</h2><p>先来回顾一下三个背包问题的定义：</p>\n<blockquote>\n<p>01背包：<br>有N件物品和一个容量为V的背包，第i件物品消耗的容量为Ci，价值为Wi，求解放入哪些物品可以使得背包中总价值最大。</p>\n</blockquote>\n<blockquote>\n<p>完全背包：<br>有N种物品和一个容量为V的背包，每种物品都有无限件可用，第i件物品消耗的容量为Ci，价值为Wi，求解放入哪些物品可以使得背包中总价值最大。</p>\n</blockquote>\n<blockquote>\n<p>多重背包：<br>有N种物品和一个容量为V的背包，第i种物品最多有Mi件可用，每件物品消耗的容量为Ci，价值为Wi，求解入哪些物品可以使得背包中总价值最大。</p>\n</blockquote>\n<p>三种背包问题都有一个共同的限制，那就是背包容量，背包的容量是有限的，这便限制了物品的选择，而三种背包问题的共同目的，便是让背包中的物品价值最大。</p>\n<p>不同的地方在于物品数量的限制，01背包问题中，每种物品只有一个，对于每种物品而言，便只有选和不选两个选择。完全背包问题中，每种物品有无限多个，所以可选的范围要大很多。在多重背包问题中，每种物品都有各自的数量限制。</p>\n<p>三种背包问题虽然对于物品数量的限制不一样，但都可以转化为01背包问题来进行思考。在完全背包问题中，虽然每种物品都可以选择无限个，但由于背包容量有限，实际上每种物品可以选择的数量也是有限的，那么将每种物品都看做是 V/Ci 种只有一件的不同物品，不就成了01背包问题吗？对于多重背包也是如此，只是每种物品的膨胀数量变成了 min{Mi, V/Ci}。</p>\n<p>所以说，01背包问题是所有背包问题的基础，弄懂了01背包问题后，完全背包和多重背包就没有什么难的地方了。</p>\n<p>下面我们来对比一下三种背包问题的状态转移方程，以便更好的理解它们之间的联系：</p>\n<p>01背包的状态转移方程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">F[i,v] = max&#123;F[i-1,v], F[i-1,v-Ci] + Wi&#125;</span><br></pre></td></tr></table></figure>\n<p>完全背包的状态转移方程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">F[i,v] = max&#123;F[i-1,v-kCi] + kWi | 0 &lt;= kCi &lt;= v&#125;</span><br></pre></td></tr></table></figure>\n<p>多重背包的状态转移方程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">F[i,v] = max&#123;F[i-1,v-kCi] + kWi | 0 &lt;= k &lt;= Mi&#125;</span><br></pre></td></tr></table></figure>\n<p>把这三个方程放到一起，便能很清晰的看到它们之间的关系了，三种背包问题都是基于子问题来选取价值最大的一个，只是选择的范围不一样。</p>\n<p>01背包考虑的是选和不选，所有只需要比较两种策略的最大值即可，而完全背包和多重背包要考虑的是选几个的问题。</p>\n<p>这样说也许还是不够形象，举个栗子就能比较好的说明了：</p>\n<p>假设背包容量为10，有两个物品可选，价值分别为：3，2，容量占用分别为，4，3。</p>\n<p>初始状态：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/11/5cd684433922b.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>01背包的填表法：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/11/5cd6864f6eb81.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>完全背包的填表法：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/11/5cd6864d1d669.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>多重背包的填表法：</p>\n<p>假设两种物品的可选数量分别为：2，1.</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/11/5cd6864e5627b.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>下面再来看看三种背包问题的一维数组解决方案。</p>\n<p>01背包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i &lt;- 1 to N</span><br><span class=\"line\">    for v &lt;- V to Ci</span><br><span class=\"line\">        F[v] = max&#123;F[v],F[v-Ci] + Wi&#125;</span><br></pre></td></tr></table></figure>\n<p>将其核心部分抽象出来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def ZeroOneKnapsack(F,C,W)</span><br><span class=\"line\">    for v &lt;- V to C</span><br><span class=\"line\">        F[v] = max&#123;F[v],F[v-C] + W&#125;</span><br></pre></td></tr></table></figure>\n<p>则01背包问题可以表示为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i &lt;- 1 to N</span><br><span class=\"line\">    ZeroOneKnapsack(F,Ci,Wi)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>N代表物品数量，Ci代表第i个物品占用的容量，V代表背包总容量，Wi代表第i个物品的价值，下同。</p>\n</blockquote>\n<p>完全背包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i &lt;- 1 to N</span><br><span class=\"line\">    for v &lt;- Ci to V</span><br><span class=\"line\">        F[v] = max&#123;F[v],F[v-Ci] + Wi&#125;</span><br></pre></td></tr></table></figure>\n<p>将其核心部分抽象出来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def CompleteKnapsack(F,C,W)</span><br><span class=\"line\">    for v &lt;- C to V</span><br><span class=\"line\">        F[v] = max&#123;F[v],F[v-C] + W&#125;</span><br></pre></td></tr></table></figure>\n<p>则完全背包问题的解可以表示为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i &lt;- 1 to N</span><br><span class=\"line\">    CompleteKnapsack(F,Ci,Wi)</span><br></pre></td></tr></table></figure>\n<p>多重背包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i &lt;- 1 to N</span><br><span class=\"line\">    if v &lt; Ci * Mi</span><br><span class=\"line\">        F[v] = max&#123;F[v],F[v-Ci] + Wi&#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">        for v &lt;- Ci to V</span><br><span class=\"line\">            k &lt;- 1</span><br><span class=\"line\">            while k &lt; M &amp;&amp; v &gt; Ci * k</span><br><span class=\"line\">                F[v] = max&#123;F[v],F[v-Ci*k] + Wi*k&#125;</span><br><span class=\"line\">                k++</span><br></pre></td></tr></table></figure>\n<p>抽象出核心逻辑：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def MultiKnapsack(F,C,W,M)</span><br><span class=\"line\">    if C * M &gt;= V</span><br><span class=\"line\">        CompleteKnapsack(F,C,W)</span><br><span class=\"line\">        return</span><br><span class=\"line\">    else</span><br><span class=\"line\">        k &lt;- 1</span><br><span class=\"line\">        while k &lt; M</span><br><span class=\"line\">            ZeroOneKnapsack(F,KC,KW)</span><br><span class=\"line\">            k++</span><br><span class=\"line\">        return</span><br></pre></td></tr></table></figure>\n<p>则多重背包问题的解可以表示为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i &lt;- 1 to N</span><br><span class=\"line\">    MultiKnapsack(F,Ci,Wi,Mi)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Mi 代表第i件物品最多可选数量</p>\n</blockquote>\n<h2 id=\"混合背包问题\"><a href=\"#混合背包问题\" class=\"headerlink\" title=\"混合背包问题\"></a>混合背包问题</h2><p>现在我们来考虑一种更为复杂的情况，如果可选的物品同时具有上述三种特性，即：有的物品只能选一个，有的物品可以选择任意多个，有的物品只能选择有限多个，那么此时该如何决策呢？</p>\n<p>其实有了上面的总结和抽象，这种混合背包问题就小菜一碟了。</p>\n<p>回顾一下上面的三种背包问题的抽象解，就会发现他们每次都只会考虑一种物品，区别只在于第i个物品的可选策略。所以对于混合背包问题，同样也可以一个一个物品考虑，如果这个物品是最多选一个，那么就采用01背包的解决策略，如果是可以选择任意多个，那么就使用完全背包的解决策略，如果只能选择有限多个，那么就使用多重背包的解决策略。</p>\n<p>伪代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i &lt;- 1 to N</span><br><span class=\"line\">    if 第i件物品属于01背包</span><br><span class=\"line\">        ZeroOneKnapsack(F,Ci,Wi)</span><br><span class=\"line\">    else if 第i件物品属于完全背包</span><br><span class=\"line\">        CompleteKnapsack(F,Ci,Wi)</span><br><span class=\"line\">    else if 第i件物品属于多重背包</span><br><span class=\"line\">        MultiKnapsack(F,Ci,Wi,Mi)</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>到此为止，我们就已经比较完美的解决了三种背包问题，顺便还解决了一下混合背包问题。虽然条件各不相同，但是解题思路却很相似，相信经过这一篇文章的总结，你对于背包问题也会有更好的理解，并且领会到这种抽象问题的好处。</p>\n<p>当然，更深层次的背包问题还有很多，比如二维费用问题，物品依赖问题，鉴于博主学疏才浅，暂时也没有探索的兴趣，所以就不一一进行说明了，有兴趣的话可以自行搜索相关内容。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a580b1789e.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>如果本文对你有帮助，不要吝啬你的点赞哦。也欢迎关注我的公众号进行留言交流。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a58ba229ca.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>文末再赠送一个小福利，关注公众号并回复： <code>python电子书大全</code>  即可无套路获得上百本python电子书资源。</p>\n"},{"title":"【Mysql】索引简介","date":"2019-07-12T00:47:56.000Z","categorys":["编程"],"_content":"\n本文口味：番茄炒蛋，预计阅读：10分钟。\n\n博客又停更了两个月，在这期间，对人生和世界多了许多思考。在人生的不同阶段，会对生活和世界有着不一样的认知，而认知的改变也会直接反应在行为模式之中。\n\n对于生活的思考心得也会在之后的时间里，慢慢分享给大家，一方面是对自己心路历程的记录和总结，另一方面也希望能给遇到同样问题或疑惑的朋友以帮助。目前生活已经慢慢调整到我想要的样子，博客写作也该继续起航了。\n\n## 一、说明\n\nMysql是最常用的关系型数据库，而索引则是Mysql调优中最关心的部分，设计一个好的索引并写出合适的sql，就能将查询速度大大提升。从本篇开始，将会对Mysql中的索引进行深入浅出的介绍，从索引的简介、类别、使用姿势到索引的原理，最后到索引实战。希望通过本系列的文章，能让你对mysql中的索引有一个更深入的认识。\n\n以下是本文大纲：\n\n![](https://i.loli.net/2019/07/11/5d26941cb252430355.png)\n\n## 二、什么是索引\n\n索引是存储引擎用于快速查找记录的一种数据结构。\n\nemm，用人话说，如果把Mysql比作一本书的话，索引就是书的目录，根据目录便能很快找到需要的信息所在的页面，如果没有目录的话，想要查找想要的信息就只能一页一页翻了。\n比如下面这样一条简单的sql：\n\n```\nSELECT id,name,course,grade FROM t_grade WHERE name = 'Frank';\n```\n\n如果没有添加索引的话，只能从最小记录开始依次遍历mysql中的记录，然后对比每条记录是否符合搜索条件。如果表中的数据量不大（十万级别以下），耗时其实也还好，毕竟目前来说，CPU效率已经很高了。但这样其实是对CPU的一种浪费，就好比开着跑车在泥泞的乡村小路上驾驶，完全无法发挥它应有的性能。而索引便是这样一条康庄大道，有了索引，才能充分发挥mysql引擎的性能，让你的sql跑车风驰电掣。\n\n## 三、索引的优缺点\n\n对于大部分事物而言，通常存在其对立面的，有好的一面，就会有坏的一面，就像质量好的东西通常价格高，便宜的东西通常质量差，索引也是如此。\n\n使用索引的优点显而易见：\n1. 可以大大加快数据检索效率。\n2. 可以加速表与表之间的连接。\n3. 可以通过唯一索引的创建，保证数据的唯一性。\n4. 可以显著减少分组与排序的时间。\n\n总而言之，用一个字来总结，就是快。\n\n使用索引的缺点也是需要考虑的：\n1. 索引的创建和维护需要时间成本。表中的数据量越大，插入或删除数据时，调整索引所需要的时间就越长。\n2. 索引需要单独存储，占用磁盘空间，如果设置了大量的索引，占用的空间甚至比记录本身更大。\n3. 在对数据进行增、删、改时，需要同时更新索引中的数据，因此会影响增删改的速度。\n\n所以使用索引并不是百利而无一害，使用不当甚至可能造成删库跑路的惨剧【手动滑稽】。但当你了解它的原理，掌握了索引的真谛，它就会成为你的神兵利器，让你在mysql开发中所向披靡。\n\n## 四、索引的分类以及创建姿势\n\n索引可分为普通索引、唯一索引、主键索引、组合索引、全文索引。看起来好像很多很复杂，但其实并非如此，且听我慢慢道来。\n\n`普通索引`，名字中就透露出它普通的气质，也就是最常见的索引。\n\n如何创建一个普通索引呢？其实很简单，如果是在DDL中创建索引，可以这样使用：\n\n```sql\nCREATE TABLE `t_grade` (\n    id BIGINT(20) COMMENT '主键id',\n    name VARCHAR(30) COMMENT '姓名',\n    course INT COMMENT '课程，1-语文，2-数学，3-英语，4-物理',\n    grade DECIMAL(5,2) COMMENT '成绩',\n    KEY idx_name(`name`)\n)ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;\n```\n\n这样就为\"name\"列创建了一个名为\"idx_name\"的普通索引。通用的创建方式为：\n\n```sql\nKEY 索引名 (`列名`)\n```\n\n如果是为一张已经创建好的表添加一个普通索引，那么可以这样：\n\n```sql\nALTER TABLE `t_grade` ADD KEY idx_name(`name`);\n```\n\n你可能会说，“不是用index关键字来创建索引的吗”，别急别急，其实它们的效果是一样的。\n\n`主键索引`，一看就是很关键的角色，没错，每张表都会有且只有一个主键索引，即使没有显式的创建主键索引的话，也会自动创建一个隐藏的主键索引。 \n\n这么重要的索引，用的关键字肯定也得不一样才行，创建主键索引的关键字是`PRIMARY KEY`，在DDL中添加主键索引的姿势为：\n\n```sql\nCREATE TABLE `t_grade` (\n    id BIGINT(20) COMMENT '主键id',\n    name VARCHAR(30) COMMENT '姓名',\n    course INT COMMENT '课程，1-语文，2-数学，3-英语，4-物理',\n    grade DECIMAL(5,2) COMMENT '成绩',\n    PRIMARY KEY (`id`)\n)ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;\n```\n\n因为主键只能有一个，所以不需要添加主键名。通用的添加方式为：\n\n```sql\nPRIMARY KEY (`列名`)\n```\n\n如果是为已创建好的表添加主键索引，那么可以这样：\n\n```sql\nALTER TABLE `t_grade` ADD PRIMARY KEY (`id`);\n```\n\n`唯一索引`，顾名思义，就是“唯一”的索引，被添加到索引中的列的值必须是唯一的，如果向数据表中插入一条已存在的唯一索引字段记录，就会报错。\n\n定义唯一索引的关键字为 `UNIQUE KEY`。在DDL中添加唯一索引的姿势为：\n\n```sql\nCREATE TABLE `t_grade` (\n    id BIGINT(20) COMMENT '主键id',\n    name VARCHAR(30) COMMENT '姓名',\n    course INT COMMENT '课程，1-语文，2-数学，3-英语，4-物理',\n    grade DECIMAL(5,2) COMMENT '成绩',\n    UNIQUE KEY uk_name (`name`)\n)ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;\n```\n\n唯一索引的通用添加方式为：\n\n```sql\nUNIQUE KEY 索引名 (`列名`)\n```\n\n为已创建好的表添加唯一索引：\n\n```sql\nALTER TABLE `t_grade` ADD UNIQUE KEY uk_name (`name`);\n```\n\n`组合索引`，又叫联合索引，便是将两个或者多个字段组合在一起的索引，好像跟没说一样= =\n看一个栗子就知道了。\n\n```sql\nCREATE TABLE `t_grade` (\n    id BIGINT(20) COMMENT '主键id',\n    name VARCHAR(30) COMMENT '姓名',\n    course INT COMMENT '课程，1-语文，2-数学，3-英语，4-物理',\n    grade DECIMAL(5,2) COMMENT '成绩',\n    KEY idx_name_corse (`name`,`course`)\n)ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;\n```\n\n同样是使用`key`关键字，在索引名后添加多个字段名即可。这里有一点需要注意的是，字段排列是有顺序的。举例说明，下面这两个索引是不一样的：\n\n```sql\nALTER TABLE `t_grade` ADD KEY idx_name_course (`name`,`course`);\nALTER TABLE `t_grade` ADD KEY idx_name_course (`course`,`name`);\n```\n\n索引的匹配遵循“左缀匹配原则”，举个栗子说明，如果创建的组合索引是 \n\n```sql\nALTER TABLE `t_grade` ADD KEY idx_name_course (`name`,`course`);\n```\n\n那么下面语句将能命中这个组合索引。\n\n```sql\nSELECT * FROM `t_grade` WHERE name = 'Frank';  \n```\n![](https://i.loli.net/2019/07/11/5d2695c837a1478405.png)\n\n而下面这个语句将无法命中索引：\n\n```sql\nSELECT * FROM `t_grade` WHERE course = 1;\n```\n\n![](https://i.loli.net/2019/07/11/5d2695dd1113960656.png)\n\n因为在组合索引中，索引中的记录是先按照前一个字段排序，然后再根据后一个字段排序的，所以如果直接使用组合索引中的第二个字段查询时，查询索引对索引记录进行遍历，遍历完成之后还需要回溯到聚簇索引中获取完整记录，这样反而更耗时间，所以sql优化器会选择直接对记录进行遍历。\n\n如果你还不清楚索引的结构以及聚簇索引是什么，不要着急，后面的文章里会有详细的介绍。\n\n`联合唯一索引`，便是将多个字段组合起来形成一个唯一键，举个栗子：\n\n先删除所有索引，然后添加两条记录：\n\n```sql\nINSERT INTO `t_grade` (`id`, `name`, `course`, `grade`) VALUES(1, 'Frank', 1, 100);\nINSERT INTO `t_grade` (`id`, `name`, `course`, `grade`) VALUES(2, 'Frank', 1, 95);\n```\n![](https://i.loli.net/2019/07/11/5d2695fb3f84a48846.png)\n\n这样就能插入两条记录了。\n\n然后删掉这两条记录，创建一个联合唯一索引：\n\n```sql\nALTER TABLE `t_grade` ADD UNIQUE KEY idx_name_course (`name`,`course`);\n```\n\n然后再来执行一下上面的sql：\n\n![](https://i.loli.net/2019/07/11/5d26960ce9ccf62374.png)\n\n这时候，就会得到一个错误提示，因为将字段`name`和`course`创建了联合唯一索引，所以这两个字段的组合值必须是唯一的，如果要插入的记录的这两个字段组合值已经存在，那么就会抛出异常。\n\n最后一个是比较复杂的索引：`全文索引`，由于其复杂性，这里只简单的介绍它的创建姿势。\n\n```sql\nCREATE TABLE `t_article`(\n        id BIGINT COMMENT '文章id',\n        title VARCHAR(200) COMMENT '文章标题',\n        content TEXT COMMENT '文章内容',\n        FULLTEXT (title, content)\n)ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;\n```\n\n或者给现有表添加全文索引：\n\n```sql\nALTER TABLE `t_article` ADD FULLTEXT KEY fidx_title_content (title,content) WITH PARSER ngram;\n```\n\n想要使用全文索引查询，则需要使用MATCH关键字。\n\n```sql\nSELECT * FROM `t_article` WHERE MATCH(title, content) AGAINST('查询字符串');\n```\n\n当然，如果想要使用全文索引，需要确认mysql的版本号在5.7以上，否则无法在innodb引擎上使用全文索引的中文检索插件ngram。\n\n## 五、索引使用前后对比\n\n为了更直观的看出索引的优缺点，我们可以来对数据表添加索引前后执行相同sql的耗时来看出对比，这里仅进行简单的比较，没有使用性能测试。\n\n先来创建一个数据表：\n\n```sql\nCREATE TABLE `t_grade` (\n    id BIGINT(20) COMMENT '主键id',\n    name VARCHAR(30) COMMENT '姓名',\n    course INT COMMENT '课程，0-化学，1-语文，2-数学，3-英语，4-物理',\n    grade DECIMAL(5,2) COMMENT '成绩'\n)ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;\n```\n\n然后插入一百万条数据：\n\n```sql\npublic void batchInsert(){\n    long timeMillis = System.currentTimeMillis();\n    System.out.println(\"开始插入数据\");\n    for (int i = 1; i < 1000000; i++) {\n        GradeDO gradeDO = new GradeDO((long) i, randomName(), random.nextInt(5), BigDecimal.valueOf(random.nextDouble() * 100));\n        gradeMapper.insert(gradeDO);\n    }\n    System.out.println(\"插入一百万条记录耗时：\" + ( System.currentTimeMillis() - timeMillis) / 1000.0 );\n}\n```\n\n输出如下：\n\n```\n开始插入数据\n插入一百万条记录耗时：1507.102\n```\n\n现在是没有索引的状态，开始进行插入测试：\n\n```java\npublic void batchInsert(){\n    long timeMillis = System.currentTimeMillis();\n    System.out.println(\"开始插入数据\");\n    for (int i = 1000000; i < 1010000; i++) {\n        GradeDO gradeDO = new GradeDO((long) i, randomName(), random.nextInt(5), BigDecimal.valueOf(random.nextDouble() * 100));\n        gradeMapper.insert(gradeDO);\n    }\n    System.out.println(\"插入一万条记录耗时：\" + ( System.currentTimeMillis() - timeMillis) / 1000.0 );\n}\n```\n\n输出如下：\n```\n开始插入数据\n插入一万条记录耗时：15.681\n```\n\n然后进行查询测试。\n\n```java\n@Test\nvoid testQuery() {\n    long timeMillis = System.currentTimeMillis();\n    System.out.println(\"开始查询\");\n    for (int i = 0; i < 100; i++) {\n        Integer id = random.nextInt(1000000);\n        GradeDO gradeDO = gradeMapper.selectById(id);\n    }\n    System.out.println(\"一百次查询耗时：\" + ( System.currentTimeMillis() - timeMillis) / 1000.0 );\n}\n```\n\n输出如下：\n\n```\n开始查询\n一百次查询耗时：51.658\n```\n\n接下来，为id列创建一个主键，并为name字段创建一个普通索引。\n再插入一万条记录：\n\n```\n开始插入数据\n插入一万条记录耗时：17.465\n```\n\n然后进行查询测试。\n\n```\n开始查询\n一百次查询耗时：0.191\n```\n\n可以看出，在有单个索引的情况下，创建记录耗时略长于无索引的情况，当字段数量和索引数量增加时，这种差距将会增大。查询效率可以清晰的看出，这里添加了索引之后，大大的缩减了查询的耗时，当然，这里主要是聚簇索引的功劳。\n\n## 六、总结\n索引是mysql中十分重要的一个特性，使用好它就能让你的sql如虎添翼。简单来说，索引一方面可以大大提升查询性能，另一方面也会占用时间和空间成本，因此索引的选择也是一门学问。索引有很多种类型，不同类型的索引有着不同的特性，因此只有了解了它们各自的特性才能正确使用它们。\n关于索引的简介就先介绍到这里了，后面会对索引的原理进行进一步深入的介绍，让你不仅知道怎么使用索引，而且还能知道为什么要这样使用索引。","source":"_posts/mysql/mysql-index-introduction.md","raw":"---\ntitle: 【Mysql】索引简介\ndate: 2019-07-12 08:47:56\ntags:\n- mysql\n- 数据库\ncategorys:\n- 编程\n---\n\n本文口味：番茄炒蛋，预计阅读：10分钟。\n\n博客又停更了两个月，在这期间，对人生和世界多了许多思考。在人生的不同阶段，会对生活和世界有着不一样的认知，而认知的改变也会直接反应在行为模式之中。\n\n对于生活的思考心得也会在之后的时间里，慢慢分享给大家，一方面是对自己心路历程的记录和总结，另一方面也希望能给遇到同样问题或疑惑的朋友以帮助。目前生活已经慢慢调整到我想要的样子，博客写作也该继续起航了。\n\n## 一、说明\n\nMysql是最常用的关系型数据库，而索引则是Mysql调优中最关心的部分，设计一个好的索引并写出合适的sql，就能将查询速度大大提升。从本篇开始，将会对Mysql中的索引进行深入浅出的介绍，从索引的简介、类别、使用姿势到索引的原理，最后到索引实战。希望通过本系列的文章，能让你对mysql中的索引有一个更深入的认识。\n\n以下是本文大纲：\n\n![](https://i.loli.net/2019/07/11/5d26941cb252430355.png)\n\n## 二、什么是索引\n\n索引是存储引擎用于快速查找记录的一种数据结构。\n\nemm，用人话说，如果把Mysql比作一本书的话，索引就是书的目录，根据目录便能很快找到需要的信息所在的页面，如果没有目录的话，想要查找想要的信息就只能一页一页翻了。\n比如下面这样一条简单的sql：\n\n```\nSELECT id,name,course,grade FROM t_grade WHERE name = 'Frank';\n```\n\n如果没有添加索引的话，只能从最小记录开始依次遍历mysql中的记录，然后对比每条记录是否符合搜索条件。如果表中的数据量不大（十万级别以下），耗时其实也还好，毕竟目前来说，CPU效率已经很高了。但这样其实是对CPU的一种浪费，就好比开着跑车在泥泞的乡村小路上驾驶，完全无法发挥它应有的性能。而索引便是这样一条康庄大道，有了索引，才能充分发挥mysql引擎的性能，让你的sql跑车风驰电掣。\n\n## 三、索引的优缺点\n\n对于大部分事物而言，通常存在其对立面的，有好的一面，就会有坏的一面，就像质量好的东西通常价格高，便宜的东西通常质量差，索引也是如此。\n\n使用索引的优点显而易见：\n1. 可以大大加快数据检索效率。\n2. 可以加速表与表之间的连接。\n3. 可以通过唯一索引的创建，保证数据的唯一性。\n4. 可以显著减少分组与排序的时间。\n\n总而言之，用一个字来总结，就是快。\n\n使用索引的缺点也是需要考虑的：\n1. 索引的创建和维护需要时间成本。表中的数据量越大，插入或删除数据时，调整索引所需要的时间就越长。\n2. 索引需要单独存储，占用磁盘空间，如果设置了大量的索引，占用的空间甚至比记录本身更大。\n3. 在对数据进行增、删、改时，需要同时更新索引中的数据，因此会影响增删改的速度。\n\n所以使用索引并不是百利而无一害，使用不当甚至可能造成删库跑路的惨剧【手动滑稽】。但当你了解它的原理，掌握了索引的真谛，它就会成为你的神兵利器，让你在mysql开发中所向披靡。\n\n## 四、索引的分类以及创建姿势\n\n索引可分为普通索引、唯一索引、主键索引、组合索引、全文索引。看起来好像很多很复杂，但其实并非如此，且听我慢慢道来。\n\n`普通索引`，名字中就透露出它普通的气质，也就是最常见的索引。\n\n如何创建一个普通索引呢？其实很简单，如果是在DDL中创建索引，可以这样使用：\n\n```sql\nCREATE TABLE `t_grade` (\n    id BIGINT(20) COMMENT '主键id',\n    name VARCHAR(30) COMMENT '姓名',\n    course INT COMMENT '课程，1-语文，2-数学，3-英语，4-物理',\n    grade DECIMAL(5,2) COMMENT '成绩',\n    KEY idx_name(`name`)\n)ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;\n```\n\n这样就为\"name\"列创建了一个名为\"idx_name\"的普通索引。通用的创建方式为：\n\n```sql\nKEY 索引名 (`列名`)\n```\n\n如果是为一张已经创建好的表添加一个普通索引，那么可以这样：\n\n```sql\nALTER TABLE `t_grade` ADD KEY idx_name(`name`);\n```\n\n你可能会说，“不是用index关键字来创建索引的吗”，别急别急，其实它们的效果是一样的。\n\n`主键索引`，一看就是很关键的角色，没错，每张表都会有且只有一个主键索引，即使没有显式的创建主键索引的话，也会自动创建一个隐藏的主键索引。 \n\n这么重要的索引，用的关键字肯定也得不一样才行，创建主键索引的关键字是`PRIMARY KEY`，在DDL中添加主键索引的姿势为：\n\n```sql\nCREATE TABLE `t_grade` (\n    id BIGINT(20) COMMENT '主键id',\n    name VARCHAR(30) COMMENT '姓名',\n    course INT COMMENT '课程，1-语文，2-数学，3-英语，4-物理',\n    grade DECIMAL(5,2) COMMENT '成绩',\n    PRIMARY KEY (`id`)\n)ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;\n```\n\n因为主键只能有一个，所以不需要添加主键名。通用的添加方式为：\n\n```sql\nPRIMARY KEY (`列名`)\n```\n\n如果是为已创建好的表添加主键索引，那么可以这样：\n\n```sql\nALTER TABLE `t_grade` ADD PRIMARY KEY (`id`);\n```\n\n`唯一索引`，顾名思义，就是“唯一”的索引，被添加到索引中的列的值必须是唯一的，如果向数据表中插入一条已存在的唯一索引字段记录，就会报错。\n\n定义唯一索引的关键字为 `UNIQUE KEY`。在DDL中添加唯一索引的姿势为：\n\n```sql\nCREATE TABLE `t_grade` (\n    id BIGINT(20) COMMENT '主键id',\n    name VARCHAR(30) COMMENT '姓名',\n    course INT COMMENT '课程，1-语文，2-数学，3-英语，4-物理',\n    grade DECIMAL(5,2) COMMENT '成绩',\n    UNIQUE KEY uk_name (`name`)\n)ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;\n```\n\n唯一索引的通用添加方式为：\n\n```sql\nUNIQUE KEY 索引名 (`列名`)\n```\n\n为已创建好的表添加唯一索引：\n\n```sql\nALTER TABLE `t_grade` ADD UNIQUE KEY uk_name (`name`);\n```\n\n`组合索引`，又叫联合索引，便是将两个或者多个字段组合在一起的索引，好像跟没说一样= =\n看一个栗子就知道了。\n\n```sql\nCREATE TABLE `t_grade` (\n    id BIGINT(20) COMMENT '主键id',\n    name VARCHAR(30) COMMENT '姓名',\n    course INT COMMENT '课程，1-语文，2-数学，3-英语，4-物理',\n    grade DECIMAL(5,2) COMMENT '成绩',\n    KEY idx_name_corse (`name`,`course`)\n)ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;\n```\n\n同样是使用`key`关键字，在索引名后添加多个字段名即可。这里有一点需要注意的是，字段排列是有顺序的。举例说明，下面这两个索引是不一样的：\n\n```sql\nALTER TABLE `t_grade` ADD KEY idx_name_course (`name`,`course`);\nALTER TABLE `t_grade` ADD KEY idx_name_course (`course`,`name`);\n```\n\n索引的匹配遵循“左缀匹配原则”，举个栗子说明，如果创建的组合索引是 \n\n```sql\nALTER TABLE `t_grade` ADD KEY idx_name_course (`name`,`course`);\n```\n\n那么下面语句将能命中这个组合索引。\n\n```sql\nSELECT * FROM `t_grade` WHERE name = 'Frank';  \n```\n![](https://i.loli.net/2019/07/11/5d2695c837a1478405.png)\n\n而下面这个语句将无法命中索引：\n\n```sql\nSELECT * FROM `t_grade` WHERE course = 1;\n```\n\n![](https://i.loli.net/2019/07/11/5d2695dd1113960656.png)\n\n因为在组合索引中，索引中的记录是先按照前一个字段排序，然后再根据后一个字段排序的，所以如果直接使用组合索引中的第二个字段查询时，查询索引对索引记录进行遍历，遍历完成之后还需要回溯到聚簇索引中获取完整记录，这样反而更耗时间，所以sql优化器会选择直接对记录进行遍历。\n\n如果你还不清楚索引的结构以及聚簇索引是什么，不要着急，后面的文章里会有详细的介绍。\n\n`联合唯一索引`，便是将多个字段组合起来形成一个唯一键，举个栗子：\n\n先删除所有索引，然后添加两条记录：\n\n```sql\nINSERT INTO `t_grade` (`id`, `name`, `course`, `grade`) VALUES(1, 'Frank', 1, 100);\nINSERT INTO `t_grade` (`id`, `name`, `course`, `grade`) VALUES(2, 'Frank', 1, 95);\n```\n![](https://i.loli.net/2019/07/11/5d2695fb3f84a48846.png)\n\n这样就能插入两条记录了。\n\n然后删掉这两条记录，创建一个联合唯一索引：\n\n```sql\nALTER TABLE `t_grade` ADD UNIQUE KEY idx_name_course (`name`,`course`);\n```\n\n然后再来执行一下上面的sql：\n\n![](https://i.loli.net/2019/07/11/5d26960ce9ccf62374.png)\n\n这时候，就会得到一个错误提示，因为将字段`name`和`course`创建了联合唯一索引，所以这两个字段的组合值必须是唯一的，如果要插入的记录的这两个字段组合值已经存在，那么就会抛出异常。\n\n最后一个是比较复杂的索引：`全文索引`，由于其复杂性，这里只简单的介绍它的创建姿势。\n\n```sql\nCREATE TABLE `t_article`(\n        id BIGINT COMMENT '文章id',\n        title VARCHAR(200) COMMENT '文章标题',\n        content TEXT COMMENT '文章内容',\n        FULLTEXT (title, content)\n)ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;\n```\n\n或者给现有表添加全文索引：\n\n```sql\nALTER TABLE `t_article` ADD FULLTEXT KEY fidx_title_content (title,content) WITH PARSER ngram;\n```\n\n想要使用全文索引查询，则需要使用MATCH关键字。\n\n```sql\nSELECT * FROM `t_article` WHERE MATCH(title, content) AGAINST('查询字符串');\n```\n\n当然，如果想要使用全文索引，需要确认mysql的版本号在5.7以上，否则无法在innodb引擎上使用全文索引的中文检索插件ngram。\n\n## 五、索引使用前后对比\n\n为了更直观的看出索引的优缺点，我们可以来对数据表添加索引前后执行相同sql的耗时来看出对比，这里仅进行简单的比较，没有使用性能测试。\n\n先来创建一个数据表：\n\n```sql\nCREATE TABLE `t_grade` (\n    id BIGINT(20) COMMENT '主键id',\n    name VARCHAR(30) COMMENT '姓名',\n    course INT COMMENT '课程，0-化学，1-语文，2-数学，3-英语，4-物理',\n    grade DECIMAL(5,2) COMMENT '成绩'\n)ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;\n```\n\n然后插入一百万条数据：\n\n```sql\npublic void batchInsert(){\n    long timeMillis = System.currentTimeMillis();\n    System.out.println(\"开始插入数据\");\n    for (int i = 1; i < 1000000; i++) {\n        GradeDO gradeDO = new GradeDO((long) i, randomName(), random.nextInt(5), BigDecimal.valueOf(random.nextDouble() * 100));\n        gradeMapper.insert(gradeDO);\n    }\n    System.out.println(\"插入一百万条记录耗时：\" + ( System.currentTimeMillis() - timeMillis) / 1000.0 );\n}\n```\n\n输出如下：\n\n```\n开始插入数据\n插入一百万条记录耗时：1507.102\n```\n\n现在是没有索引的状态，开始进行插入测试：\n\n```java\npublic void batchInsert(){\n    long timeMillis = System.currentTimeMillis();\n    System.out.println(\"开始插入数据\");\n    for (int i = 1000000; i < 1010000; i++) {\n        GradeDO gradeDO = new GradeDO((long) i, randomName(), random.nextInt(5), BigDecimal.valueOf(random.nextDouble() * 100));\n        gradeMapper.insert(gradeDO);\n    }\n    System.out.println(\"插入一万条记录耗时：\" + ( System.currentTimeMillis() - timeMillis) / 1000.0 );\n}\n```\n\n输出如下：\n```\n开始插入数据\n插入一万条记录耗时：15.681\n```\n\n然后进行查询测试。\n\n```java\n@Test\nvoid testQuery() {\n    long timeMillis = System.currentTimeMillis();\n    System.out.println(\"开始查询\");\n    for (int i = 0; i < 100; i++) {\n        Integer id = random.nextInt(1000000);\n        GradeDO gradeDO = gradeMapper.selectById(id);\n    }\n    System.out.println(\"一百次查询耗时：\" + ( System.currentTimeMillis() - timeMillis) / 1000.0 );\n}\n```\n\n输出如下：\n\n```\n开始查询\n一百次查询耗时：51.658\n```\n\n接下来，为id列创建一个主键，并为name字段创建一个普通索引。\n再插入一万条记录：\n\n```\n开始插入数据\n插入一万条记录耗时：17.465\n```\n\n然后进行查询测试。\n\n```\n开始查询\n一百次查询耗时：0.191\n```\n\n可以看出，在有单个索引的情况下，创建记录耗时略长于无索引的情况，当字段数量和索引数量增加时，这种差距将会增大。查询效率可以清晰的看出，这里添加了索引之后，大大的缩减了查询的耗时，当然，这里主要是聚簇索引的功劳。\n\n## 六、总结\n索引是mysql中十分重要的一个特性，使用好它就能让你的sql如虎添翼。简单来说，索引一方面可以大大提升查询性能，另一方面也会占用时间和空间成本，因此索引的选择也是一门学问。索引有很多种类型，不同类型的索引有着不同的特性，因此只有了解了它们各自的特性才能正确使用它们。\n关于索引的简介就先介绍到这里了，后面会对索引的原理进行进一步深入的介绍，让你不仅知道怎么使用索引，而且还能知道为什么要这样使用索引。","slug":"mysql/mysql-index-introduction","published":1,"updated":"2019-07-12T00:51:59.674Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxze3go800150cvwdwa9ptzw","content":"<p>&#x672C;&#x6587;&#x53E3;&#x5473;&#xFF1A;&#x756A;&#x8304;&#x7092;&#x86CB;&#xFF0C;&#x9884;&#x8BA1;&#x9605;&#x8BFB;&#xFF1A;10&#x5206;&#x949F;&#x3002;</p>\n<p>&#x535A;&#x5BA2;&#x53C8;&#x505C;&#x66F4;&#x4E86;&#x4E24;&#x4E2A;&#x6708;&#xFF0C;&#x5728;&#x8FD9;&#x671F;&#x95F4;&#xFF0C;&#x5BF9;&#x4EBA;&#x751F;&#x548C;&#x4E16;&#x754C;&#x591A;&#x4E86;&#x8BB8;&#x591A;&#x601D;&#x8003;&#x3002;&#x5728;&#x4EBA;&#x751F;&#x7684;&#x4E0D;&#x540C;&#x9636;&#x6BB5;&#xFF0C;&#x4F1A;&#x5BF9;&#x751F;&#x6D3B;&#x548C;&#x4E16;&#x754C;&#x6709;&#x7740;&#x4E0D;&#x4E00;&#x6837;&#x7684;&#x8BA4;&#x77E5;&#xFF0C;&#x800C;&#x8BA4;&#x77E5;&#x7684;&#x6539;&#x53D8;&#x4E5F;&#x4F1A;&#x76F4;&#x63A5;&#x53CD;&#x5E94;&#x5728;&#x884C;&#x4E3A;&#x6A21;&#x5F0F;&#x4E4B;&#x4E2D;&#x3002;</p>\n<p>&#x5BF9;&#x4E8E;&#x751F;&#x6D3B;&#x7684;&#x601D;&#x8003;&#x5FC3;&#x5F97;&#x4E5F;&#x4F1A;&#x5728;&#x4E4B;&#x540E;&#x7684;&#x65F6;&#x95F4;&#x91CC;&#xFF0C;&#x6162;&#x6162;&#x5206;&#x4EAB;&#x7ED9;&#x5927;&#x5BB6;&#xFF0C;&#x4E00;&#x65B9;&#x9762;&#x662F;&#x5BF9;&#x81EA;&#x5DF1;&#x5FC3;&#x8DEF;&#x5386;&#x7A0B;&#x7684;&#x8BB0;&#x5F55;&#x548C;&#x603B;&#x7ED3;&#xFF0C;&#x53E6;&#x4E00;&#x65B9;&#x9762;&#x4E5F;&#x5E0C;&#x671B;&#x80FD;&#x7ED9;&#x9047;&#x5230;&#x540C;&#x6837;&#x95EE;&#x9898;&#x6216;&#x7591;&#x60D1;&#x7684;&#x670B;&#x53CB;&#x4EE5;&#x5E2E;&#x52A9;&#x3002;&#x76EE;&#x524D;&#x751F;&#x6D3B;&#x5DF2;&#x7ECF;&#x6162;&#x6162;&#x8C03;&#x6574;&#x5230;&#x6211;&#x60F3;&#x8981;&#x7684;&#x6837;&#x5B50;&#xFF0C;&#x535A;&#x5BA2;&#x5199;&#x4F5C;&#x4E5F;&#x8BE5;&#x7EE7;&#x7EED;&#x8D77;&#x822A;&#x4E86;&#x3002;</p>\n<h2 id=\"&#x4E00;&#x3001;&#x8BF4;&#x660E;\"><a href=\"#&#x4E00;&#x3001;&#x8BF4;&#x660E;\" class=\"headerlink\" title=\"&#x4E00;&#x3001;&#x8BF4;&#x660E;\"></a>&#x4E00;&#x3001;&#x8BF4;&#x660E;</h2><p>Mysql&#x662F;&#x6700;&#x5E38;&#x7528;&#x7684;&#x5173;&#x7CFB;&#x578B;&#x6570;&#x636E;&#x5E93;&#xFF0C;&#x800C;&#x7D22;&#x5F15;&#x5219;&#x662F;Mysql&#x8C03;&#x4F18;&#x4E2D;&#x6700;&#x5173;&#x5FC3;&#x7684;&#x90E8;&#x5206;&#xFF0C;&#x8BBE;&#x8BA1;&#x4E00;&#x4E2A;&#x597D;&#x7684;&#x7D22;&#x5F15;&#x5E76;&#x5199;&#x51FA;&#x5408;&#x9002;&#x7684;sql&#xFF0C;&#x5C31;&#x80FD;&#x5C06;&#x67E5;&#x8BE2;&#x901F;&#x5EA6;&#x5927;&#x5927;&#x63D0;&#x5347;&#x3002;&#x4ECE;&#x672C;&#x7BC7;&#x5F00;&#x59CB;&#xFF0C;&#x5C06;&#x4F1A;&#x5BF9;Mysql&#x4E2D;&#x7684;&#x7D22;&#x5F15;&#x8FDB;&#x884C;&#x6DF1;&#x5165;&#x6D45;&#x51FA;&#x7684;&#x4ECB;&#x7ECD;&#xFF0C;&#x4ECE;&#x7D22;&#x5F15;&#x7684;&#x7B80;&#x4ECB;&#x3001;&#x7C7B;&#x522B;&#x3001;&#x4F7F;&#x7528;&#x59FF;&#x52BF;&#x5230;&#x7D22;&#x5F15;&#x7684;&#x539F;&#x7406;&#xFF0C;&#x6700;&#x540E;&#x5230;&#x7D22;&#x5F15;&#x5B9E;&#x6218;&#x3002;&#x5E0C;&#x671B;&#x901A;&#x8FC7;&#x672C;&#x7CFB;&#x5217;&#x7684;&#x6587;&#x7AE0;&#xFF0C;&#x80FD;&#x8BA9;&#x4F60;&#x5BF9;mysql&#x4E2D;&#x7684;&#x7D22;&#x5F15;&#x6709;&#x4E00;&#x4E2A;&#x66F4;&#x6DF1;&#x5165;&#x7684;&#x8BA4;&#x8BC6;&#x3002;</p>\n<p>&#x4EE5;&#x4E0B;&#x662F;&#x672C;&#x6587;&#x5927;&#x7EB2;&#xFF1A;</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/07/11/5d26941cb252430355.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h2 id=\"&#x4E8C;&#x3001;&#x4EC0;&#x4E48;&#x662F;&#x7D22;&#x5F15;\"><a href=\"#&#x4E8C;&#x3001;&#x4EC0;&#x4E48;&#x662F;&#x7D22;&#x5F15;\" class=\"headerlink\" title=\"&#x4E8C;&#x3001;&#x4EC0;&#x4E48;&#x662F;&#x7D22;&#x5F15;\"></a>&#x4E8C;&#x3001;&#x4EC0;&#x4E48;&#x662F;&#x7D22;&#x5F15;</h2><p>&#x7D22;&#x5F15;&#x662F;&#x5B58;&#x50A8;&#x5F15;&#x64CE;&#x7528;&#x4E8E;&#x5FEB;&#x901F;&#x67E5;&#x627E;&#x8BB0;&#x5F55;&#x7684;&#x4E00;&#x79CD;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x3002;</p>\n<p>emm&#xFF0C;&#x7528;&#x4EBA;&#x8BDD;&#x8BF4;&#xFF0C;&#x5982;&#x679C;&#x628A;Mysql&#x6BD4;&#x4F5C;&#x4E00;&#x672C;&#x4E66;&#x7684;&#x8BDD;&#xFF0C;&#x7D22;&#x5F15;&#x5C31;&#x662F;&#x4E66;&#x7684;&#x76EE;&#x5F55;&#xFF0C;&#x6839;&#x636E;&#x76EE;&#x5F55;&#x4FBF;&#x80FD;&#x5F88;&#x5FEB;&#x627E;&#x5230;&#x9700;&#x8981;&#x7684;&#x4FE1;&#x606F;&#x6240;&#x5728;&#x7684;&#x9875;&#x9762;&#xFF0C;&#x5982;&#x679C;&#x6CA1;&#x6709;&#x76EE;&#x5F55;&#x7684;&#x8BDD;&#xFF0C;&#x60F3;&#x8981;&#x67E5;&#x627E;&#x60F3;&#x8981;&#x7684;&#x4FE1;&#x606F;&#x5C31;&#x53EA;&#x80FD;&#x4E00;&#x9875;&#x4E00;&#x9875;&#x7FFB;&#x4E86;&#x3002;<br>&#x6BD4;&#x5982;&#x4E0B;&#x9762;&#x8FD9;&#x6837;&#x4E00;&#x6761;&#x7B80;&#x5355;&#x7684;sql&#xFF1A;</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT id,name,course,grade FROM t_grade WHERE name = &apos;Frank&apos;;</span><br></pre></td></tr></tbody></table></figure>\n<p>&#x5982;&#x679C;&#x6CA1;&#x6709;&#x6DFB;&#x52A0;&#x7D22;&#x5F15;&#x7684;&#x8BDD;&#xFF0C;&#x53EA;&#x80FD;&#x4ECE;&#x6700;&#x5C0F;&#x8BB0;&#x5F55;&#x5F00;&#x59CB;&#x4F9D;&#x6B21;&#x904D;&#x5386;mysql&#x4E2D;&#x7684;&#x8BB0;&#x5F55;&#xFF0C;&#x7136;&#x540E;&#x5BF9;&#x6BD4;&#x6BCF;&#x6761;&#x8BB0;&#x5F55;&#x662F;&#x5426;&#x7B26;&#x5408;&#x641C;&#x7D22;&#x6761;&#x4EF6;&#x3002;&#x5982;&#x679C;&#x8868;&#x4E2D;&#x7684;&#x6570;&#x636E;&#x91CF;&#x4E0D;&#x5927;&#xFF08;&#x5341;&#x4E07;&#x7EA7;&#x522B;&#x4EE5;&#x4E0B;&#xFF09;&#xFF0C;&#x8017;&#x65F6;&#x5176;&#x5B9E;&#x4E5F;&#x8FD8;&#x597D;&#xFF0C;&#x6BD5;&#x7ADF;&#x76EE;&#x524D;&#x6765;&#x8BF4;&#xFF0C;CPU&#x6548;&#x7387;&#x5DF2;&#x7ECF;&#x5F88;&#x9AD8;&#x4E86;&#x3002;&#x4F46;&#x8FD9;&#x6837;&#x5176;&#x5B9E;&#x662F;&#x5BF9;CPU&#x7684;&#x4E00;&#x79CD;&#x6D6A;&#x8D39;&#xFF0C;&#x5C31;&#x597D;&#x6BD4;&#x5F00;&#x7740;&#x8DD1;&#x8F66;&#x5728;&#x6CE5;&#x6CDE;&#x7684;&#x4E61;&#x6751;&#x5C0F;&#x8DEF;&#x4E0A;&#x9A7E;&#x9A76;&#xFF0C;&#x5B8C;&#x5168;&#x65E0;&#x6CD5;&#x53D1;&#x6325;&#x5B83;&#x5E94;&#x6709;&#x7684;&#x6027;&#x80FD;&#x3002;&#x800C;&#x7D22;&#x5F15;&#x4FBF;&#x662F;&#x8FD9;&#x6837;&#x4E00;&#x6761;&#x5EB7;&#x5E84;&#x5927;&#x9053;&#xFF0C;&#x6709;&#x4E86;&#x7D22;&#x5F15;&#xFF0C;&#x624D;&#x80FD;&#x5145;&#x5206;&#x53D1;&#x6325;mysql&#x5F15;&#x64CE;&#x7684;&#x6027;&#x80FD;&#xFF0C;&#x8BA9;&#x4F60;&#x7684;sql&#x8DD1;&#x8F66;&#x98CE;&#x9A70;&#x7535;&#x63A3;&#x3002;</p>\n<h2 id=\"&#x4E09;&#x3001;&#x7D22;&#x5F15;&#x7684;&#x4F18;&#x7F3A;&#x70B9;\"><a href=\"#&#x4E09;&#x3001;&#x7D22;&#x5F15;&#x7684;&#x4F18;&#x7F3A;&#x70B9;\" class=\"headerlink\" title=\"&#x4E09;&#x3001;&#x7D22;&#x5F15;&#x7684;&#x4F18;&#x7F3A;&#x70B9;\"></a>&#x4E09;&#x3001;&#x7D22;&#x5F15;&#x7684;&#x4F18;&#x7F3A;&#x70B9;</h2><p>&#x5BF9;&#x4E8E;&#x5927;&#x90E8;&#x5206;&#x4E8B;&#x7269;&#x800C;&#x8A00;&#xFF0C;&#x901A;&#x5E38;&#x5B58;&#x5728;&#x5176;&#x5BF9;&#x7ACB;&#x9762;&#x7684;&#xFF0C;&#x6709;&#x597D;&#x7684;&#x4E00;&#x9762;&#xFF0C;&#x5C31;&#x4F1A;&#x6709;&#x574F;&#x7684;&#x4E00;&#x9762;&#xFF0C;&#x5C31;&#x50CF;&#x8D28;&#x91CF;&#x597D;&#x7684;&#x4E1C;&#x897F;&#x901A;&#x5E38;&#x4EF7;&#x683C;&#x9AD8;&#xFF0C;&#x4FBF;&#x5B9C;&#x7684;&#x4E1C;&#x897F;&#x901A;&#x5E38;&#x8D28;&#x91CF;&#x5DEE;&#xFF0C;&#x7D22;&#x5F15;&#x4E5F;&#x662F;&#x5982;&#x6B64;&#x3002;</p>\n<p>&#x4F7F;&#x7528;&#x7D22;&#x5F15;&#x7684;&#x4F18;&#x70B9;&#x663E;&#x800C;&#x6613;&#x89C1;&#xFF1A;</p>\n<ol>\n<li>&#x53EF;&#x4EE5;&#x5927;&#x5927;&#x52A0;&#x5FEB;&#x6570;&#x636E;&#x68C0;&#x7D22;&#x6548;&#x7387;&#x3002;</li>\n<li>&#x53EF;&#x4EE5;&#x52A0;&#x901F;&#x8868;&#x4E0E;&#x8868;&#x4E4B;&#x95F4;&#x7684;&#x8FDE;&#x63A5;&#x3002;</li>\n<li>&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x552F;&#x4E00;&#x7D22;&#x5F15;&#x7684;&#x521B;&#x5EFA;&#xFF0C;&#x4FDD;&#x8BC1;&#x6570;&#x636E;&#x7684;&#x552F;&#x4E00;&#x6027;&#x3002;</li>\n<li>&#x53EF;&#x4EE5;&#x663E;&#x8457;&#x51CF;&#x5C11;&#x5206;&#x7EC4;&#x4E0E;&#x6392;&#x5E8F;&#x7684;&#x65F6;&#x95F4;&#x3002;</li>\n</ol>\n<p>&#x603B;&#x800C;&#x8A00;&#x4E4B;&#xFF0C;&#x7528;&#x4E00;&#x4E2A;&#x5B57;&#x6765;&#x603B;&#x7ED3;&#xFF0C;&#x5C31;&#x662F;&#x5FEB;&#x3002;</p>\n<p>&#x4F7F;&#x7528;&#x7D22;&#x5F15;&#x7684;&#x7F3A;&#x70B9;&#x4E5F;&#x662F;&#x9700;&#x8981;&#x8003;&#x8651;&#x7684;&#xFF1A;</p>\n<ol>\n<li>&#x7D22;&#x5F15;&#x7684;&#x521B;&#x5EFA;&#x548C;&#x7EF4;&#x62A4;&#x9700;&#x8981;&#x65F6;&#x95F4;&#x6210;&#x672C;&#x3002;&#x8868;&#x4E2D;&#x7684;&#x6570;&#x636E;&#x91CF;&#x8D8A;&#x5927;&#xFF0C;&#x63D2;&#x5165;&#x6216;&#x5220;&#x9664;&#x6570;&#x636E;&#x65F6;&#xFF0C;&#x8C03;&#x6574;&#x7D22;&#x5F15;&#x6240;&#x9700;&#x8981;&#x7684;&#x65F6;&#x95F4;&#x5C31;&#x8D8A;&#x957F;&#x3002;</li>\n<li>&#x7D22;&#x5F15;&#x9700;&#x8981;&#x5355;&#x72EC;&#x5B58;&#x50A8;&#xFF0C;&#x5360;&#x7528;&#x78C1;&#x76D8;&#x7A7A;&#x95F4;&#xFF0C;&#x5982;&#x679C;&#x8BBE;&#x7F6E;&#x4E86;&#x5927;&#x91CF;&#x7684;&#x7D22;&#x5F15;&#xFF0C;&#x5360;&#x7528;&#x7684;&#x7A7A;&#x95F4;&#x751A;&#x81F3;&#x6BD4;&#x8BB0;&#x5F55;&#x672C;&#x8EAB;&#x66F4;&#x5927;&#x3002;</li>\n<li>&#x5728;&#x5BF9;&#x6570;&#x636E;&#x8FDB;&#x884C;&#x589E;&#x3001;&#x5220;&#x3001;&#x6539;&#x65F6;&#xFF0C;&#x9700;&#x8981;&#x540C;&#x65F6;&#x66F4;&#x65B0;&#x7D22;&#x5F15;&#x4E2D;&#x7684;&#x6570;&#x636E;&#xFF0C;&#x56E0;&#x6B64;&#x4F1A;&#x5F71;&#x54CD;&#x589E;&#x5220;&#x6539;&#x7684;&#x901F;&#x5EA6;&#x3002;</li>\n</ol>\n<p>&#x6240;&#x4EE5;&#x4F7F;&#x7528;&#x7D22;&#x5F15;&#x5E76;&#x4E0D;&#x662F;&#x767E;&#x5229;&#x800C;&#x65E0;&#x4E00;&#x5BB3;&#xFF0C;&#x4F7F;&#x7528;&#x4E0D;&#x5F53;&#x751A;&#x81F3;&#x53EF;&#x80FD;&#x9020;&#x6210;&#x5220;&#x5E93;&#x8DD1;&#x8DEF;&#x7684;&#x60E8;&#x5267;&#x3010;&#x624B;&#x52A8;&#x6ED1;&#x7A3D;&#x3011;&#x3002;&#x4F46;&#x5F53;&#x4F60;&#x4E86;&#x89E3;&#x5B83;&#x7684;&#x539F;&#x7406;&#xFF0C;&#x638C;&#x63E1;&#x4E86;&#x7D22;&#x5F15;&#x7684;&#x771F;&#x8C1B;&#xFF0C;&#x5B83;&#x5C31;&#x4F1A;&#x6210;&#x4E3A;&#x4F60;&#x7684;&#x795E;&#x5175;&#x5229;&#x5668;&#xFF0C;&#x8BA9;&#x4F60;&#x5728;mysql&#x5F00;&#x53D1;&#x4E2D;&#x6240;&#x5411;&#x62AB;&#x9761;&#x3002;</p>\n<h2 id=\"&#x56DB;&#x3001;&#x7D22;&#x5F15;&#x7684;&#x5206;&#x7C7B;&#x4EE5;&#x53CA;&#x521B;&#x5EFA;&#x59FF;&#x52BF;\"><a href=\"#&#x56DB;&#x3001;&#x7D22;&#x5F15;&#x7684;&#x5206;&#x7C7B;&#x4EE5;&#x53CA;&#x521B;&#x5EFA;&#x59FF;&#x52BF;\" class=\"headerlink\" title=\"&#x56DB;&#x3001;&#x7D22;&#x5F15;&#x7684;&#x5206;&#x7C7B;&#x4EE5;&#x53CA;&#x521B;&#x5EFA;&#x59FF;&#x52BF;\"></a>&#x56DB;&#x3001;&#x7D22;&#x5F15;&#x7684;&#x5206;&#x7C7B;&#x4EE5;&#x53CA;&#x521B;&#x5EFA;&#x59FF;&#x52BF;</h2><p>&#x7D22;&#x5F15;&#x53EF;&#x5206;&#x4E3A;&#x666E;&#x901A;&#x7D22;&#x5F15;&#x3001;&#x552F;&#x4E00;&#x7D22;&#x5F15;&#x3001;&#x4E3B;&#x952E;&#x7D22;&#x5F15;&#x3001;&#x7EC4;&#x5408;&#x7D22;&#x5F15;&#x3001;&#x5168;&#x6587;&#x7D22;&#x5F15;&#x3002;&#x770B;&#x8D77;&#x6765;&#x597D;&#x50CF;&#x5F88;&#x591A;&#x5F88;&#x590D;&#x6742;&#xFF0C;&#x4F46;&#x5176;&#x5B9E;&#x5E76;&#x975E;&#x5982;&#x6B64;&#xFF0C;&#x4E14;&#x542C;&#x6211;&#x6162;&#x6162;&#x9053;&#x6765;&#x3002;</p>\n<p><code>&#x666E;&#x901A;&#x7D22;&#x5F15;</code>&#xFF0C;&#x540D;&#x5B57;&#x4E2D;&#x5C31;&#x900F;&#x9732;&#x51FA;&#x5B83;&#x666E;&#x901A;&#x7684;&#x6C14;&#x8D28;&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x6700;&#x5E38;&#x89C1;&#x7684;&#x7D22;&#x5F15;&#x3002;</p>\n<p>&#x5982;&#x4F55;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x666E;&#x901A;&#x7D22;&#x5F15;&#x5462;&#xFF1F;&#x5176;&#x5B9E;&#x5F88;&#x7B80;&#x5355;&#xFF0C;&#x5982;&#x679C;&#x662F;&#x5728;DDL&#x4E2D;&#x521B;&#x5EFA;&#x7D22;&#x5F15;&#xFF0C;&#x53EF;&#x4EE5;&#x8FD9;&#x6837;&#x4F7F;&#x7528;&#xFF1A;</p>\n<figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_grade`</span> (</span><br><span class=\"line\">    <span class=\"keyword\">id</span> <span class=\"built_in\">BIGINT</span>(<span class=\"number\">20</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">&apos;&#x4E3B;&#x952E;id&apos;</span>,</span><br><span class=\"line\">    <span class=\"keyword\">name</span> <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">30</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">&apos;&#x59D3;&#x540D;&apos;</span>,</span><br><span class=\"line\">    course <span class=\"built_in\">INT</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">&apos;&#x8BFE;&#x7A0B;&#xFF0C;1-&#x8BED;&#x6587;&#xFF0C;2-&#x6570;&#x5B66;&#xFF0C;3-&#x82F1;&#x8BED;&#xFF0C;4-&#x7269;&#x7406;&apos;</span>,</span><br><span class=\"line\">    grade <span class=\"built_in\">DECIMAL</span>(<span class=\"number\">5</span>,<span class=\"number\">2</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">&apos;&#x6210;&#x7EE9;&apos;</span>,</span><br><span class=\"line\">    <span class=\"keyword\">KEY</span> idx_name(<span class=\"string\">`name`</span>)</span><br><span class=\"line\">)<span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">0</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8;</span><br></pre></td></tr></tbody></table></figure>\n<p>&#x8FD9;&#x6837;&#x5C31;&#x4E3A;&#x201D;name&#x201D;&#x5217;&#x521B;&#x5EFA;&#x4E86;&#x4E00;&#x4E2A;&#x540D;&#x4E3A;&#x201D;idx_name&#x201D;&#x7684;&#x666E;&#x901A;&#x7D22;&#x5F15;&#x3002;&#x901A;&#x7528;&#x7684;&#x521B;&#x5EFA;&#x65B9;&#x5F0F;&#x4E3A;&#xFF1A;</p>\n<figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KEY &#x7D22;&#x5F15;&#x540D; (`&#x5217;&#x540D;`)</span><br></pre></td></tr></tbody></table></figure>\n<p>&#x5982;&#x679C;&#x662F;&#x4E3A;&#x4E00;&#x5F20;&#x5DF2;&#x7ECF;&#x521B;&#x5EFA;&#x597D;&#x7684;&#x8868;&#x6DFB;&#x52A0;&#x4E00;&#x4E2A;&#x666E;&#x901A;&#x7D22;&#x5F15;&#xFF0C;&#x90A3;&#x4E48;&#x53EF;&#x4EE5;&#x8FD9;&#x6837;&#xFF1A;</p>\n<figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_grade`</span> <span class=\"keyword\">ADD</span> <span class=\"keyword\">KEY</span> idx_name(<span class=\"string\">`name`</span>);</span><br></pre></td></tr></tbody></table></figure>\n<p>&#x4F60;&#x53EF;&#x80FD;&#x4F1A;&#x8BF4;&#xFF0C;&#x201C;&#x4E0D;&#x662F;&#x7528;index&#x5173;&#x952E;&#x5B57;&#x6765;&#x521B;&#x5EFA;&#x7D22;&#x5F15;&#x7684;&#x5417;&#x201D;&#xFF0C;&#x522B;&#x6025;&#x522B;&#x6025;&#xFF0C;&#x5176;&#x5B9E;&#x5B83;&#x4EEC;&#x7684;&#x6548;&#x679C;&#x662F;&#x4E00;&#x6837;&#x7684;&#x3002;</p>\n<p><code>&#x4E3B;&#x952E;&#x7D22;&#x5F15;</code>&#xFF0C;&#x4E00;&#x770B;&#x5C31;&#x662F;&#x5F88;&#x5173;&#x952E;&#x7684;&#x89D2;&#x8272;&#xFF0C;&#x6CA1;&#x9519;&#xFF0C;&#x6BCF;&#x5F20;&#x8868;&#x90FD;&#x4F1A;&#x6709;&#x4E14;&#x53EA;&#x6709;&#x4E00;&#x4E2A;&#x4E3B;&#x952E;&#x7D22;&#x5F15;&#xFF0C;&#x5373;&#x4F7F;&#x6CA1;&#x6709;&#x663E;&#x5F0F;&#x7684;&#x521B;&#x5EFA;&#x4E3B;&#x952E;&#x7D22;&#x5F15;&#x7684;&#x8BDD;&#xFF0C;&#x4E5F;&#x4F1A;&#x81EA;&#x52A8;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x9690;&#x85CF;&#x7684;&#x4E3B;&#x952E;&#x7D22;&#x5F15;&#x3002; </p>\n<p>&#x8FD9;&#x4E48;&#x91CD;&#x8981;&#x7684;&#x7D22;&#x5F15;&#xFF0C;&#x7528;&#x7684;&#x5173;&#x952E;&#x5B57;&#x80AF;&#x5B9A;&#x4E5F;&#x5F97;&#x4E0D;&#x4E00;&#x6837;&#x624D;&#x884C;&#xFF0C;&#x521B;&#x5EFA;&#x4E3B;&#x952E;&#x7D22;&#x5F15;&#x7684;&#x5173;&#x952E;&#x5B57;&#x662F;<code>PRIMARY KEY</code>&#xFF0C;&#x5728;DDL&#x4E2D;&#x6DFB;&#x52A0;&#x4E3B;&#x952E;&#x7D22;&#x5F15;&#x7684;&#x59FF;&#x52BF;&#x4E3A;&#xFF1A;</p>\n<figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_grade`</span> (</span><br><span class=\"line\">    <span class=\"keyword\">id</span> <span class=\"built_in\">BIGINT</span>(<span class=\"number\">20</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">&apos;&#x4E3B;&#x952E;id&apos;</span>,</span><br><span class=\"line\">    <span class=\"keyword\">name</span> <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">30</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">&apos;&#x59D3;&#x540D;&apos;</span>,</span><br><span class=\"line\">    course <span class=\"built_in\">INT</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">&apos;&#x8BFE;&#x7A0B;&#xFF0C;1-&#x8BED;&#x6587;&#xFF0C;2-&#x6570;&#x5B66;&#xFF0C;3-&#x82F1;&#x8BED;&#xFF0C;4-&#x7269;&#x7406;&apos;</span>,</span><br><span class=\"line\">    grade <span class=\"built_in\">DECIMAL</span>(<span class=\"number\">5</span>,<span class=\"number\">2</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">&apos;&#x6210;&#x7EE9;&apos;</span>,</span><br><span class=\"line\">    PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>)</span><br><span class=\"line\">)<span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">0</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8;</span><br></pre></td></tr></tbody></table></figure>\n<p>&#x56E0;&#x4E3A;&#x4E3B;&#x952E;&#x53EA;&#x80FD;&#x6709;&#x4E00;&#x4E2A;&#xFF0C;&#x6240;&#x4EE5;&#x4E0D;&#x9700;&#x8981;&#x6DFB;&#x52A0;&#x4E3B;&#x952E;&#x540D;&#x3002;&#x901A;&#x7528;&#x7684;&#x6DFB;&#x52A0;&#x65B9;&#x5F0F;&#x4E3A;&#xFF1A;</p>\n<figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PRIMARY KEY (`&#x5217;&#x540D;`)</span><br></pre></td></tr></tbody></table></figure>\n<p>&#x5982;&#x679C;&#x662F;&#x4E3A;&#x5DF2;&#x521B;&#x5EFA;&#x597D;&#x7684;&#x8868;&#x6DFB;&#x52A0;&#x4E3B;&#x952E;&#x7D22;&#x5F15;&#xFF0C;&#x90A3;&#x4E48;&#x53EF;&#x4EE5;&#x8FD9;&#x6837;&#xFF1A;</p>\n<figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_grade`</span> <span class=\"keyword\">ADD</span> PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>);</span><br></pre></td></tr></tbody></table></figure>\n<p><code>&#x552F;&#x4E00;&#x7D22;&#x5F15;</code>&#xFF0C;&#x987E;&#x540D;&#x601D;&#x4E49;&#xFF0C;&#x5C31;&#x662F;&#x201C;&#x552F;&#x4E00;&#x201D;&#x7684;&#x7D22;&#x5F15;&#xFF0C;&#x88AB;&#x6DFB;&#x52A0;&#x5230;&#x7D22;&#x5F15;&#x4E2D;&#x7684;&#x5217;&#x7684;&#x503C;&#x5FC5;&#x987B;&#x662F;&#x552F;&#x4E00;&#x7684;&#xFF0C;&#x5982;&#x679C;&#x5411;&#x6570;&#x636E;&#x8868;&#x4E2D;&#x63D2;&#x5165;&#x4E00;&#x6761;&#x5DF2;&#x5B58;&#x5728;&#x7684;&#x552F;&#x4E00;&#x7D22;&#x5F15;&#x5B57;&#x6BB5;&#x8BB0;&#x5F55;&#xFF0C;&#x5C31;&#x4F1A;&#x62A5;&#x9519;&#x3002;</p>\n<p>&#x5B9A;&#x4E49;&#x552F;&#x4E00;&#x7D22;&#x5F15;&#x7684;&#x5173;&#x952E;&#x5B57;&#x4E3A; <code>UNIQUE KEY</code>&#x3002;&#x5728;DDL&#x4E2D;&#x6DFB;&#x52A0;&#x552F;&#x4E00;&#x7D22;&#x5F15;&#x7684;&#x59FF;&#x52BF;&#x4E3A;&#xFF1A;</p>\n<figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_grade`</span> (</span><br><span class=\"line\">    <span class=\"keyword\">id</span> <span class=\"built_in\">BIGINT</span>(<span class=\"number\">20</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">&apos;&#x4E3B;&#x952E;id&apos;</span>,</span><br><span class=\"line\">    <span class=\"keyword\">name</span> <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">30</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">&apos;&#x59D3;&#x540D;&apos;</span>,</span><br><span class=\"line\">    course <span class=\"built_in\">INT</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">&apos;&#x8BFE;&#x7A0B;&#xFF0C;1-&#x8BED;&#x6587;&#xFF0C;2-&#x6570;&#x5B66;&#xFF0C;3-&#x82F1;&#x8BED;&#xFF0C;4-&#x7269;&#x7406;&apos;</span>,</span><br><span class=\"line\">    grade <span class=\"built_in\">DECIMAL</span>(<span class=\"number\">5</span>,<span class=\"number\">2</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">&apos;&#x6210;&#x7EE9;&apos;</span>,</span><br><span class=\"line\">    <span class=\"keyword\">UNIQUE</span> <span class=\"keyword\">KEY</span> uk_name (<span class=\"string\">`name`</span>)</span><br><span class=\"line\">)<span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">0</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8;</span><br></pre></td></tr></tbody></table></figure>\n<p>&#x552F;&#x4E00;&#x7D22;&#x5F15;&#x7684;&#x901A;&#x7528;&#x6DFB;&#x52A0;&#x65B9;&#x5F0F;&#x4E3A;&#xFF1A;</p>\n<figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UNIQUE KEY &#x7D22;&#x5F15;&#x540D; (`&#x5217;&#x540D;`)</span><br></pre></td></tr></tbody></table></figure>\n<p>&#x4E3A;&#x5DF2;&#x521B;&#x5EFA;&#x597D;&#x7684;&#x8868;&#x6DFB;&#x52A0;&#x552F;&#x4E00;&#x7D22;&#x5F15;&#xFF1A;</p>\n<figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_grade`</span> <span class=\"keyword\">ADD</span> <span class=\"keyword\">UNIQUE</span> <span class=\"keyword\">KEY</span> uk_name (<span class=\"string\">`name`</span>);</span><br></pre></td></tr></tbody></table></figure>\n<p><code>&#x7EC4;&#x5408;&#x7D22;&#x5F15;</code>&#xFF0C;&#x53C8;&#x53EB;&#x8054;&#x5408;&#x7D22;&#x5F15;&#xFF0C;&#x4FBF;&#x662F;&#x5C06;&#x4E24;&#x4E2A;&#x6216;&#x8005;&#x591A;&#x4E2A;&#x5B57;&#x6BB5;&#x7EC4;&#x5408;&#x5728;&#x4E00;&#x8D77;&#x7684;&#x7D22;&#x5F15;&#xFF0C;&#x597D;&#x50CF;&#x8DDF;&#x6CA1;&#x8BF4;&#x4E00;&#x6837;= =<br>&#x770B;&#x4E00;&#x4E2A;&#x6817;&#x5B50;&#x5C31;&#x77E5;&#x9053;&#x4E86;&#x3002;</p>\n<figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_grade`</span> (</span><br><span class=\"line\">    <span class=\"keyword\">id</span> <span class=\"built_in\">BIGINT</span>(<span class=\"number\">20</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">&apos;&#x4E3B;&#x952E;id&apos;</span>,</span><br><span class=\"line\">    <span class=\"keyword\">name</span> <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">30</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">&apos;&#x59D3;&#x540D;&apos;</span>,</span><br><span class=\"line\">    course <span class=\"built_in\">INT</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">&apos;&#x8BFE;&#x7A0B;&#xFF0C;1-&#x8BED;&#x6587;&#xFF0C;2-&#x6570;&#x5B66;&#xFF0C;3-&#x82F1;&#x8BED;&#xFF0C;4-&#x7269;&#x7406;&apos;</span>,</span><br><span class=\"line\">    grade <span class=\"built_in\">DECIMAL</span>(<span class=\"number\">5</span>,<span class=\"number\">2</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">&apos;&#x6210;&#x7EE9;&apos;</span>,</span><br><span class=\"line\">    <span class=\"keyword\">KEY</span> idx_name_corse (<span class=\"string\">`name`</span>,<span class=\"string\">`course`</span>)</span><br><span class=\"line\">)<span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">0</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8;</span><br></pre></td></tr></tbody></table></figure>\n<p>&#x540C;&#x6837;&#x662F;&#x4F7F;&#x7528;<code>key</code>&#x5173;&#x952E;&#x5B57;&#xFF0C;&#x5728;&#x7D22;&#x5F15;&#x540D;&#x540E;&#x6DFB;&#x52A0;&#x591A;&#x4E2A;&#x5B57;&#x6BB5;&#x540D;&#x5373;&#x53EF;&#x3002;&#x8FD9;&#x91CC;&#x6709;&#x4E00;&#x70B9;&#x9700;&#x8981;&#x6CE8;&#x610F;&#x7684;&#x662F;&#xFF0C;&#x5B57;&#x6BB5;&#x6392;&#x5217;&#x662F;&#x6709;&#x987A;&#x5E8F;&#x7684;&#x3002;&#x4E3E;&#x4F8B;&#x8BF4;&#x660E;&#xFF0C;&#x4E0B;&#x9762;&#x8FD9;&#x4E24;&#x4E2A;&#x7D22;&#x5F15;&#x662F;&#x4E0D;&#x4E00;&#x6837;&#x7684;&#xFF1A;</p>\n<figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_grade`</span> <span class=\"keyword\">ADD</span> <span class=\"keyword\">KEY</span> idx_name_course (<span class=\"string\">`name`</span>,<span class=\"string\">`course`</span>);</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_grade`</span> <span class=\"keyword\">ADD</span> <span class=\"keyword\">KEY</span> idx_name_course (<span class=\"string\">`course`</span>,<span class=\"string\">`name`</span>);</span><br></pre></td></tr></tbody></table></figure>\n<p>&#x7D22;&#x5F15;&#x7684;&#x5339;&#x914D;&#x9075;&#x5FAA;&#x201C;&#x5DE6;&#x7F00;&#x5339;&#x914D;&#x539F;&#x5219;&#x201D;&#xFF0C;&#x4E3E;&#x4E2A;&#x6817;&#x5B50;&#x8BF4;&#x660E;&#xFF0C;&#x5982;&#x679C;&#x521B;&#x5EFA;&#x7684;&#x7EC4;&#x5408;&#x7D22;&#x5F15;&#x662F; </p>\n<figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_grade`</span> <span class=\"keyword\">ADD</span> <span class=\"keyword\">KEY</span> idx_name_course (<span class=\"string\">`name`</span>,<span class=\"string\">`course`</span>);</span><br></pre></td></tr></tbody></table></figure>\n<p>&#x90A3;&#x4E48;&#x4E0B;&#x9762;&#x8BED;&#x53E5;&#x5C06;&#x80FD;&#x547D;&#x4E2D;&#x8FD9;&#x4E2A;&#x7EC4;&#x5408;&#x7D22;&#x5F15;&#x3002;</p>\n<figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"string\">`t_grade`</span> <span class=\"keyword\">WHERE</span> <span class=\"keyword\">name</span> = <span class=\"string\">&apos;Frank&apos;</span>;</span><br></pre></td></tr></tbody></table></figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/07/11/5d2695c837a1478405.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>&#x800C;&#x4E0B;&#x9762;&#x8FD9;&#x4E2A;&#x8BED;&#x53E5;&#x5C06;&#x65E0;&#x6CD5;&#x547D;&#x4E2D;&#x7D22;&#x5F15;&#xFF1A;</p>\n<figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"string\">`t_grade`</span> <span class=\"keyword\">WHERE</span> course = <span class=\"number\">1</span>;</span><br></pre></td></tr></tbody></table></figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/07/11/5d2695dd1113960656.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>&#x56E0;&#x4E3A;&#x5728;&#x7EC4;&#x5408;&#x7D22;&#x5F15;&#x4E2D;&#xFF0C;&#x7D22;&#x5F15;&#x4E2D;&#x7684;&#x8BB0;&#x5F55;&#x662F;&#x5148;&#x6309;&#x7167;&#x524D;&#x4E00;&#x4E2A;&#x5B57;&#x6BB5;&#x6392;&#x5E8F;&#xFF0C;&#x7136;&#x540E;&#x518D;&#x6839;&#x636E;&#x540E;&#x4E00;&#x4E2A;&#x5B57;&#x6BB5;&#x6392;&#x5E8F;&#x7684;&#xFF0C;&#x6240;&#x4EE5;&#x5982;&#x679C;&#x76F4;&#x63A5;&#x4F7F;&#x7528;&#x7EC4;&#x5408;&#x7D22;&#x5F15;&#x4E2D;&#x7684;&#x7B2C;&#x4E8C;&#x4E2A;&#x5B57;&#x6BB5;&#x67E5;&#x8BE2;&#x65F6;&#xFF0C;&#x67E5;&#x8BE2;&#x7D22;&#x5F15;&#x5BF9;&#x7D22;&#x5F15;&#x8BB0;&#x5F55;&#x8FDB;&#x884C;&#x904D;&#x5386;&#xFF0C;&#x904D;&#x5386;&#x5B8C;&#x6210;&#x4E4B;&#x540E;&#x8FD8;&#x9700;&#x8981;&#x56DE;&#x6EAF;&#x5230;&#x805A;&#x7C07;&#x7D22;&#x5F15;&#x4E2D;&#x83B7;&#x53D6;&#x5B8C;&#x6574;&#x8BB0;&#x5F55;&#xFF0C;&#x8FD9;&#x6837;&#x53CD;&#x800C;&#x66F4;&#x8017;&#x65F6;&#x95F4;&#xFF0C;&#x6240;&#x4EE5;sql&#x4F18;&#x5316;&#x5668;&#x4F1A;&#x9009;&#x62E9;&#x76F4;&#x63A5;&#x5BF9;&#x8BB0;&#x5F55;&#x8FDB;&#x884C;&#x904D;&#x5386;&#x3002;</p>\n<p>&#x5982;&#x679C;&#x4F60;&#x8FD8;&#x4E0D;&#x6E05;&#x695A;&#x7D22;&#x5F15;&#x7684;&#x7ED3;&#x6784;&#x4EE5;&#x53CA;&#x805A;&#x7C07;&#x7D22;&#x5F15;&#x662F;&#x4EC0;&#x4E48;&#xFF0C;&#x4E0D;&#x8981;&#x7740;&#x6025;&#xFF0C;&#x540E;&#x9762;&#x7684;&#x6587;&#x7AE0;&#x91CC;&#x4F1A;&#x6709;&#x8BE6;&#x7EC6;&#x7684;&#x4ECB;&#x7ECD;&#x3002;</p>\n<p><code>&#x8054;&#x5408;&#x552F;&#x4E00;&#x7D22;&#x5F15;</code>&#xFF0C;&#x4FBF;&#x662F;&#x5C06;&#x591A;&#x4E2A;&#x5B57;&#x6BB5;&#x7EC4;&#x5408;&#x8D77;&#x6765;&#x5F62;&#x6210;&#x4E00;&#x4E2A;&#x552F;&#x4E00;&#x952E;&#xFF0C;&#x4E3E;&#x4E2A;&#x6817;&#x5B50;&#xFF1A;</p>\n<p>&#x5148;&#x5220;&#x9664;&#x6240;&#x6709;&#x7D22;&#x5F15;&#xFF0C;&#x7136;&#x540E;&#x6DFB;&#x52A0;&#x4E24;&#x6761;&#x8BB0;&#x5F55;&#xFF1A;</p>\n<figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`t_grade`</span> (<span class=\"string\">`id`</span>, <span class=\"string\">`name`</span>, <span class=\"string\">`course`</span>, <span class=\"string\">`grade`</span>) <span class=\"keyword\">VALUES</span>(<span class=\"number\">1</span>, <span class=\"string\">&apos;Frank&apos;</span>, <span class=\"number\">1</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`t_grade`</span> (<span class=\"string\">`id`</span>, <span class=\"string\">`name`</span>, <span class=\"string\">`course`</span>, <span class=\"string\">`grade`</span>) <span class=\"keyword\">VALUES</span>(<span class=\"number\">2</span>, <span class=\"string\">&apos;Frank&apos;</span>, <span class=\"number\">1</span>, <span class=\"number\">95</span>);</span><br></pre></td></tr></tbody></table></figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/07/11/5d2695fb3f84a48846.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>&#x8FD9;&#x6837;&#x5C31;&#x80FD;&#x63D2;&#x5165;&#x4E24;&#x6761;&#x8BB0;&#x5F55;&#x4E86;&#x3002;</p>\n<p>&#x7136;&#x540E;&#x5220;&#x6389;&#x8FD9;&#x4E24;&#x6761;&#x8BB0;&#x5F55;&#xFF0C;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x8054;&#x5408;&#x552F;&#x4E00;&#x7D22;&#x5F15;&#xFF1A;</p>\n<figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_grade`</span> <span class=\"keyword\">ADD</span> <span class=\"keyword\">UNIQUE</span> <span class=\"keyword\">KEY</span> idx_name_course (<span class=\"string\">`name`</span>,<span class=\"string\">`course`</span>);</span><br></pre></td></tr></tbody></table></figure>\n<p>&#x7136;&#x540E;&#x518D;&#x6765;&#x6267;&#x884C;&#x4E00;&#x4E0B;&#x4E0A;&#x9762;&#x7684;sql&#xFF1A;</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/07/11/5d26960ce9ccf62374.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>&#x8FD9;&#x65F6;&#x5019;&#xFF0C;&#x5C31;&#x4F1A;&#x5F97;&#x5230;&#x4E00;&#x4E2A;&#x9519;&#x8BEF;&#x63D0;&#x793A;&#xFF0C;&#x56E0;&#x4E3A;&#x5C06;&#x5B57;&#x6BB5;<code>name</code>&#x548C;<code>course</code>&#x521B;&#x5EFA;&#x4E86;&#x8054;&#x5408;&#x552F;&#x4E00;&#x7D22;&#x5F15;&#xFF0C;&#x6240;&#x4EE5;&#x8FD9;&#x4E24;&#x4E2A;&#x5B57;&#x6BB5;&#x7684;&#x7EC4;&#x5408;&#x503C;&#x5FC5;&#x987B;&#x662F;&#x552F;&#x4E00;&#x7684;&#xFF0C;&#x5982;&#x679C;&#x8981;&#x63D2;&#x5165;&#x7684;&#x8BB0;&#x5F55;&#x7684;&#x8FD9;&#x4E24;&#x4E2A;&#x5B57;&#x6BB5;&#x7EC4;&#x5408;&#x503C;&#x5DF2;&#x7ECF;&#x5B58;&#x5728;&#xFF0C;&#x90A3;&#x4E48;&#x5C31;&#x4F1A;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#x3002;</p>\n<p>&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x662F;&#x6BD4;&#x8F83;&#x590D;&#x6742;&#x7684;&#x7D22;&#x5F15;&#xFF1A;<code>&#x5168;&#x6587;&#x7D22;&#x5F15;</code>&#xFF0C;&#x7531;&#x4E8E;&#x5176;&#x590D;&#x6742;&#x6027;&#xFF0C;&#x8FD9;&#x91CC;&#x53EA;&#x7B80;&#x5355;&#x7684;&#x4ECB;&#x7ECD;&#x5B83;&#x7684;&#x521B;&#x5EFA;&#x59FF;&#x52BF;&#x3002;</p>\n<figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_article`</span>(</span><br><span class=\"line\">        <span class=\"keyword\">id</span> <span class=\"built_in\">BIGINT</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">&apos;&#x6587;&#x7AE0;id&apos;</span>,</span><br><span class=\"line\">        title <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">200</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">&apos;&#x6587;&#x7AE0;&#x6807;&#x9898;&apos;</span>,</span><br><span class=\"line\">        <span class=\"keyword\">content</span> <span class=\"built_in\">TEXT</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">&apos;&#x6587;&#x7AE0;&#x5185;&#x5BB9;&apos;</span>,</span><br><span class=\"line\">        FULLTEXT (title, <span class=\"keyword\">content</span>)</span><br><span class=\"line\">)<span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">0</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8;</span><br></pre></td></tr></tbody></table></figure>\n<p>&#x6216;&#x8005;&#x7ED9;&#x73B0;&#x6709;&#x8868;&#x6DFB;&#x52A0;&#x5168;&#x6587;&#x7D22;&#x5F15;&#xFF1A;</p>\n<figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_article`</span> <span class=\"keyword\">ADD</span> FULLTEXT <span class=\"keyword\">KEY</span> fidx_title_content (title,<span class=\"keyword\">content</span>) <span class=\"keyword\">WITH</span> PARSER ngram;</span><br></pre></td></tr></tbody></table></figure>\n<p>&#x60F3;&#x8981;&#x4F7F;&#x7528;&#x5168;&#x6587;&#x7D22;&#x5F15;&#x67E5;&#x8BE2;&#xFF0C;&#x5219;&#x9700;&#x8981;&#x4F7F;&#x7528;MATCH&#x5173;&#x952E;&#x5B57;&#x3002;</p>\n<figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"string\">`t_article`</span> <span class=\"keyword\">WHERE</span> <span class=\"keyword\">MATCH</span>(title, <span class=\"keyword\">content</span>) AGAINST(<span class=\"string\">&apos;&#x67E5;&#x8BE2;&#x5B57;&#x7B26;&#x4E32;&apos;</span>);</span><br></pre></td></tr></tbody></table></figure>\n<p>&#x5F53;&#x7136;&#xFF0C;&#x5982;&#x679C;&#x60F3;&#x8981;&#x4F7F;&#x7528;&#x5168;&#x6587;&#x7D22;&#x5F15;&#xFF0C;&#x9700;&#x8981;&#x786E;&#x8BA4;mysql&#x7684;&#x7248;&#x672C;&#x53F7;&#x5728;5.7&#x4EE5;&#x4E0A;&#xFF0C;&#x5426;&#x5219;&#x65E0;&#x6CD5;&#x5728;innodb&#x5F15;&#x64CE;&#x4E0A;&#x4F7F;&#x7528;&#x5168;&#x6587;&#x7D22;&#x5F15;&#x7684;&#x4E2D;&#x6587;&#x68C0;&#x7D22;&#x63D2;&#x4EF6;ngram&#x3002;</p>\n<h2 id=\"&#x4E94;&#x3001;&#x7D22;&#x5F15;&#x4F7F;&#x7528;&#x524D;&#x540E;&#x5BF9;&#x6BD4;\"><a href=\"#&#x4E94;&#x3001;&#x7D22;&#x5F15;&#x4F7F;&#x7528;&#x524D;&#x540E;&#x5BF9;&#x6BD4;\" class=\"headerlink\" title=\"&#x4E94;&#x3001;&#x7D22;&#x5F15;&#x4F7F;&#x7528;&#x524D;&#x540E;&#x5BF9;&#x6BD4;\"></a>&#x4E94;&#x3001;&#x7D22;&#x5F15;&#x4F7F;&#x7528;&#x524D;&#x540E;&#x5BF9;&#x6BD4;</h2><p>&#x4E3A;&#x4E86;&#x66F4;&#x76F4;&#x89C2;&#x7684;&#x770B;&#x51FA;&#x7D22;&#x5F15;&#x7684;&#x4F18;&#x7F3A;&#x70B9;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x6765;&#x5BF9;&#x6570;&#x636E;&#x8868;&#x6DFB;&#x52A0;&#x7D22;&#x5F15;&#x524D;&#x540E;&#x6267;&#x884C;&#x76F8;&#x540C;sql&#x7684;&#x8017;&#x65F6;&#x6765;&#x770B;&#x51FA;&#x5BF9;&#x6BD4;&#xFF0C;&#x8FD9;&#x91CC;&#x4EC5;&#x8FDB;&#x884C;&#x7B80;&#x5355;&#x7684;&#x6BD4;&#x8F83;&#xFF0C;&#x6CA1;&#x6709;&#x4F7F;&#x7528;&#x6027;&#x80FD;&#x6D4B;&#x8BD5;&#x3002;</p>\n<p>&#x5148;&#x6765;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x6570;&#x636E;&#x8868;&#xFF1A;</p>\n<figure class=\"highlight sql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_grade`</span> (</span><br><span class=\"line\">    <span class=\"keyword\">id</span> <span class=\"built_in\">BIGINT</span>(<span class=\"number\">20</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">&apos;&#x4E3B;&#x952E;id&apos;</span>,</span><br><span class=\"line\">    <span class=\"keyword\">name</span> <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">30</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">&apos;&#x59D3;&#x540D;&apos;</span>,</span><br><span class=\"line\">    course <span class=\"built_in\">INT</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">&apos;&#x8BFE;&#x7A0B;&#xFF0C;0-&#x5316;&#x5B66;&#xFF0C;1-&#x8BED;&#x6587;&#xFF0C;2-&#x6570;&#x5B66;&#xFF0C;3-&#x82F1;&#x8BED;&#xFF0C;4-&#x7269;&#x7406;&apos;</span>,</span><br><span class=\"line\">    grade <span class=\"built_in\">DECIMAL</span>(<span class=\"number\">5</span>,<span class=\"number\">2</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">&apos;&#x6210;&#x7EE9;&apos;</span></span><br><span class=\"line\">)<span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">0</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8;</span><br></pre></td></tr></tbody></table></figure>\n<p>&#x7136;&#x540E;&#x63D2;&#x5165;&#x4E00;&#x767E;&#x4E07;&#x6761;&#x6570;&#x636E;&#xFF1A;</p>\n<figure class=\"highlight\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void batchInsert(){</span><br><span class=\"line\">    long timeMillis = System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(&quot;&#x5F00;&#x59CB;&#x63D2;&#x5165;&#x6570;&#x636E;&quot;);</span><br><span class=\"line\">    for (int i = 1; i &lt; 1000000; i++) {</span><br><span class=\"line\">        GradeDO gradeDO = new GradeDO((long) i, randomName(), random.nextInt(5), BigDecimal.valueOf(random.nextDouble() * 100));</span><br><span class=\"line\">        gradeMapper.insert(gradeDO);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    System.out.println(&quot;&#x63D2;&#x5165;&#x4E00;&#x767E;&#x4E07;&#x6761;&#x8BB0;&#x5F55;&#x8017;&#x65F6;&#xFF1A;&quot; + ( System.currentTimeMillis() - timeMillis) / 1000.0 );</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>&#x8F93;&#x51FA;&#x5982;&#x4E0B;&#xFF1A;</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x5F00;&#x59CB;&#x63D2;&#x5165;&#x6570;&#x636E;</span><br><span class=\"line\">&#x63D2;&#x5165;&#x4E00;&#x767E;&#x4E07;&#x6761;&#x8BB0;&#x5F55;&#x8017;&#x65F6;&#xFF1A;1507.102</span><br></pre></td></tr></tbody></table></figure>\n<p>&#x73B0;&#x5728;&#x662F;&#x6CA1;&#x6709;&#x7D22;&#x5F15;&#x7684;&#x72B6;&#x6001;&#xFF0C;&#x5F00;&#x59CB;&#x8FDB;&#x884C;&#x63D2;&#x5165;&#x6D4B;&#x8BD5;&#xFF1A;</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">batchInsert</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">long</span> timeMillis = System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;&#x5F00;&#x59CB;&#x63D2;&#x5165;&#x6570;&#x636E;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1000000</span>; i &lt; <span class=\"number\">1010000</span>; i++) {</span><br><span class=\"line\">        GradeDO gradeDO = <span class=\"keyword\">new</span> GradeDO((<span class=\"keyword\">long</span>) i, randomName(), random.nextInt(<span class=\"number\">5</span>), BigDecimal.valueOf(random.nextDouble() * <span class=\"number\">100</span>));</span><br><span class=\"line\">        gradeMapper.insert(gradeDO);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;&#x63D2;&#x5165;&#x4E00;&#x4E07;&#x6761;&#x8BB0;&#x5F55;&#x8017;&#x65F6;&#xFF1A;&quot;</span> + ( System.currentTimeMillis() - timeMillis) / <span class=\"number\">1000.0</span> );</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>&#x8F93;&#x51FA;&#x5982;&#x4E0B;&#xFF1A;<br></p><figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x5F00;&#x59CB;&#x63D2;&#x5165;&#x6570;&#x636E;</span><br><span class=\"line\">&#x63D2;&#x5165;&#x4E00;&#x4E07;&#x6761;&#x8BB0;&#x5F55;&#x8017;&#x65F6;&#xFF1A;15.681</span><br></pre></td></tr></tbody></table></figure><p></p>\n<p>&#x7136;&#x540E;&#x8FDB;&#x884C;&#x67E5;&#x8BE2;&#x6D4B;&#x8BD5;&#x3002;</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testQuery</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">long</span> timeMillis = System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;&#x5F00;&#x59CB;&#x67E5;&#x8BE2;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) {</span><br><span class=\"line\">        Integer id = random.nextInt(<span class=\"number\">1000000</span>);</span><br><span class=\"line\">        GradeDO gradeDO = gradeMapper.selectById(id);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;&#x4E00;&#x767E;&#x6B21;&#x67E5;&#x8BE2;&#x8017;&#x65F6;&#xFF1A;&quot;</span> + ( System.currentTimeMillis() - timeMillis) / <span class=\"number\">1000.0</span> );</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>&#x8F93;&#x51FA;&#x5982;&#x4E0B;&#xFF1A;</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x5F00;&#x59CB;&#x67E5;&#x8BE2;</span><br><span class=\"line\">&#x4E00;&#x767E;&#x6B21;&#x67E5;&#x8BE2;&#x8017;&#x65F6;&#xFF1A;51.658</span><br></pre></td></tr></tbody></table></figure>\n<p>&#x63A5;&#x4E0B;&#x6765;&#xFF0C;&#x4E3A;id&#x5217;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x4E3B;&#x952E;&#xFF0C;&#x5E76;&#x4E3A;name&#x5B57;&#x6BB5;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x666E;&#x901A;&#x7D22;&#x5F15;&#x3002;<br>&#x518D;&#x63D2;&#x5165;&#x4E00;&#x4E07;&#x6761;&#x8BB0;&#x5F55;&#xFF1A;</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x5F00;&#x59CB;&#x63D2;&#x5165;&#x6570;&#x636E;</span><br><span class=\"line\">&#x63D2;&#x5165;&#x4E00;&#x4E07;&#x6761;&#x8BB0;&#x5F55;&#x8017;&#x65F6;&#xFF1A;17.465</span><br></pre></td></tr></tbody></table></figure>\n<p>&#x7136;&#x540E;&#x8FDB;&#x884C;&#x67E5;&#x8BE2;&#x6D4B;&#x8BD5;&#x3002;</p>\n<figure class=\"highlight plain\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x5F00;&#x59CB;&#x67E5;&#x8BE2;</span><br><span class=\"line\">&#x4E00;&#x767E;&#x6B21;&#x67E5;&#x8BE2;&#x8017;&#x65F6;&#xFF1A;0.191</span><br></pre></td></tr></tbody></table></figure>\n<p>&#x53EF;&#x4EE5;&#x770B;&#x51FA;&#xFF0C;&#x5728;&#x6709;&#x5355;&#x4E2A;&#x7D22;&#x5F15;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;&#x521B;&#x5EFA;&#x8BB0;&#x5F55;&#x8017;&#x65F6;&#x7565;&#x957F;&#x4E8E;&#x65E0;&#x7D22;&#x5F15;&#x7684;&#x60C5;&#x51B5;&#xFF0C;&#x5F53;&#x5B57;&#x6BB5;&#x6570;&#x91CF;&#x548C;&#x7D22;&#x5F15;&#x6570;&#x91CF;&#x589E;&#x52A0;&#x65F6;&#xFF0C;&#x8FD9;&#x79CD;&#x5DEE;&#x8DDD;&#x5C06;&#x4F1A;&#x589E;&#x5927;&#x3002;&#x67E5;&#x8BE2;&#x6548;&#x7387;&#x53EF;&#x4EE5;&#x6E05;&#x6670;&#x7684;&#x770B;&#x51FA;&#xFF0C;&#x8FD9;&#x91CC;&#x6DFB;&#x52A0;&#x4E86;&#x7D22;&#x5F15;&#x4E4B;&#x540E;&#xFF0C;&#x5927;&#x5927;&#x7684;&#x7F29;&#x51CF;&#x4E86;&#x67E5;&#x8BE2;&#x7684;&#x8017;&#x65F6;&#xFF0C;&#x5F53;&#x7136;&#xFF0C;&#x8FD9;&#x91CC;&#x4E3B;&#x8981;&#x662F;&#x805A;&#x7C07;&#x7D22;&#x5F15;&#x7684;&#x529F;&#x52B3;&#x3002;</p>\n<h2 id=\"&#x516D;&#x3001;&#x603B;&#x7ED3;\"><a href=\"#&#x516D;&#x3001;&#x603B;&#x7ED3;\" class=\"headerlink\" title=\"&#x516D;&#x3001;&#x603B;&#x7ED3;\"></a>&#x516D;&#x3001;&#x603B;&#x7ED3;</h2><p>&#x7D22;&#x5F15;&#x662F;mysql&#x4E2D;&#x5341;&#x5206;&#x91CD;&#x8981;&#x7684;&#x4E00;&#x4E2A;&#x7279;&#x6027;&#xFF0C;&#x4F7F;&#x7528;&#x597D;&#x5B83;&#x5C31;&#x80FD;&#x8BA9;&#x4F60;&#x7684;sql&#x5982;&#x864E;&#x6DFB;&#x7FFC;&#x3002;&#x7B80;&#x5355;&#x6765;&#x8BF4;&#xFF0C;&#x7D22;&#x5F15;&#x4E00;&#x65B9;&#x9762;&#x53EF;&#x4EE5;&#x5927;&#x5927;&#x63D0;&#x5347;&#x67E5;&#x8BE2;&#x6027;&#x80FD;&#xFF0C;&#x53E6;&#x4E00;&#x65B9;&#x9762;&#x4E5F;&#x4F1A;&#x5360;&#x7528;&#x65F6;&#x95F4;&#x548C;&#x7A7A;&#x95F4;&#x6210;&#x672C;&#xFF0C;&#x56E0;&#x6B64;&#x7D22;&#x5F15;&#x7684;&#x9009;&#x62E9;&#x4E5F;&#x662F;&#x4E00;&#x95E8;&#x5B66;&#x95EE;&#x3002;&#x7D22;&#x5F15;&#x6709;&#x5F88;&#x591A;&#x79CD;&#x7C7B;&#x578B;&#xFF0C;&#x4E0D;&#x540C;&#x7C7B;&#x578B;&#x7684;&#x7D22;&#x5F15;&#x6709;&#x7740;&#x4E0D;&#x540C;&#x7684;&#x7279;&#x6027;&#xFF0C;&#x56E0;&#x6B64;&#x53EA;&#x6709;&#x4E86;&#x89E3;&#x4E86;&#x5B83;&#x4EEC;&#x5404;&#x81EA;&#x7684;&#x7279;&#x6027;&#x624D;&#x80FD;&#x6B63;&#x786E;&#x4F7F;&#x7528;&#x5B83;&#x4EEC;&#x3002;<br>&#x5173;&#x4E8E;&#x7D22;&#x5F15;&#x7684;&#x7B80;&#x4ECB;&#x5C31;&#x5148;&#x4ECB;&#x7ECD;&#x5230;&#x8FD9;&#x91CC;&#x4E86;&#xFF0C;&#x540E;&#x9762;&#x4F1A;&#x5BF9;&#x7D22;&#x5F15;&#x7684;&#x539F;&#x7406;&#x8FDB;&#x884C;&#x8FDB;&#x4E00;&#x6B65;&#x6DF1;&#x5165;&#x7684;&#x4ECB;&#x7ECD;&#xFF0C;&#x8BA9;&#x4F60;&#x4E0D;&#x4EC5;&#x77E5;&#x9053;&#x600E;&#x4E48;&#x4F7F;&#x7528;&#x7D22;&#x5F15;&#xFF0C;&#x800C;&#x4E14;&#x8FD8;&#x80FD;&#x77E5;&#x9053;&#x4E3A;&#x4EC0;&#x4E48;&#x8981;&#x8FD9;&#x6837;&#x4F7F;&#x7528;&#x7D22;&#x5F15;&#x3002;</p>\n<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<p>本文口味：番茄炒蛋，预计阅读：10分钟。</p>\n<p>博客又停更了两个月，在这期间，对人生和世界多了许多思考。在人生的不同阶段，会对生活和世界有着不一样的认知，而认知的改变也会直接反应在行为模式之中。</p>\n<p>对于生活的思考心得也会在之后的时间里，慢慢分享给大家，一方面是对自己心路历程的记录和总结，另一方面也希望能给遇到同样问题或疑惑的朋友以帮助。目前生活已经慢慢调整到我想要的样子，博客写作也该继续起航了。</p>\n<h2 id=\"一、说明\"><a href=\"#一、说明\" class=\"headerlink\" title=\"一、说明\"></a>一、说明</h2><p>Mysql是最常用的关系型数据库，而索引则是Mysql调优中最关心的部分，设计一个好的索引并写出合适的sql，就能将查询速度大大提升。从本篇开始，将会对Mysql中的索引进行深入浅出的介绍，从索引的简介、类别、使用姿势到索引的原理，最后到索引实战。希望通过本系列的文章，能让你对mysql中的索引有一个更深入的认识。</p>\n<p>以下是本文大纲：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/07/11/5d26941cb252430355.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h2 id=\"二、什么是索引\"><a href=\"#二、什么是索引\" class=\"headerlink\" title=\"二、什么是索引\"></a>二、什么是索引</h2><p>索引是存储引擎用于快速查找记录的一种数据结构。</p>\n<p>emm，用人话说，如果把Mysql比作一本书的话，索引就是书的目录，根据目录便能很快找到需要的信息所在的页面，如果没有目录的话，想要查找想要的信息就只能一页一页翻了。<br>比如下面这样一条简单的sql：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT id,name,course,grade FROM t_grade WHERE name = &apos;Frank&apos;;</span><br></pre></td></tr></table></figure>\n<p>如果没有添加索引的话，只能从最小记录开始依次遍历mysql中的记录，然后对比每条记录是否符合搜索条件。如果表中的数据量不大（十万级别以下），耗时其实也还好，毕竟目前来说，CPU效率已经很高了。但这样其实是对CPU的一种浪费，就好比开着跑车在泥泞的乡村小路上驾驶，完全无法发挥它应有的性能。而索引便是这样一条康庄大道，有了索引，才能充分发挥mysql引擎的性能，让你的sql跑车风驰电掣。</p>\n<h2 id=\"三、索引的优缺点\"><a href=\"#三、索引的优缺点\" class=\"headerlink\" title=\"三、索引的优缺点\"></a>三、索引的优缺点</h2><p>对于大部分事物而言，通常存在其对立面的，有好的一面，就会有坏的一面，就像质量好的东西通常价格高，便宜的东西通常质量差，索引也是如此。</p>\n<p>使用索引的优点显而易见：</p>\n<ol>\n<li>可以大大加快数据检索效率。</li>\n<li>可以加速表与表之间的连接。</li>\n<li>可以通过唯一索引的创建，保证数据的唯一性。</li>\n<li>可以显著减少分组与排序的时间。</li>\n</ol>\n<p>总而言之，用一个字来总结，就是快。</p>\n<p>使用索引的缺点也是需要考虑的：</p>\n<ol>\n<li>索引的创建和维护需要时间成本。表中的数据量越大，插入或删除数据时，调整索引所需要的时间就越长。</li>\n<li>索引需要单独存储，占用磁盘空间，如果设置了大量的索引，占用的空间甚至比记录本身更大。</li>\n<li>在对数据进行增、删、改时，需要同时更新索引中的数据，因此会影响增删改的速度。</li>\n</ol>\n<p>所以使用索引并不是百利而无一害，使用不当甚至可能造成删库跑路的惨剧【手动滑稽】。但当你了解它的原理，掌握了索引的真谛，它就会成为你的神兵利器，让你在mysql开发中所向披靡。</p>\n<h2 id=\"四、索引的分类以及创建姿势\"><a href=\"#四、索引的分类以及创建姿势\" class=\"headerlink\" title=\"四、索引的分类以及创建姿势\"></a>四、索引的分类以及创建姿势</h2><p>索引可分为普通索引、唯一索引、主键索引、组合索引、全文索引。看起来好像很多很复杂，但其实并非如此，且听我慢慢道来。</p>\n<p><code>普通索引</code>，名字中就透露出它普通的气质，也就是最常见的索引。</p>\n<p>如何创建一个普通索引呢？其实很简单，如果是在DDL中创建索引，可以这样使用：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_grade`</span> (</span><br><span class=\"line\">    <span class=\"keyword\">id</span> <span class=\"built_in\">BIGINT</span>(<span class=\"number\">20</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">'主键id'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">name</span> <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">30</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">'姓名'</span>,</span><br><span class=\"line\">    course <span class=\"built_in\">INT</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'课程，1-语文，2-数学，3-英语，4-物理'</span>,</span><br><span class=\"line\">    grade <span class=\"built_in\">DECIMAL</span>(<span class=\"number\">5</span>,<span class=\"number\">2</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">'成绩'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">KEY</span> idx_name(<span class=\"string\">`name`</span>)</span><br><span class=\"line\">)<span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">0</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>\n<p>这样就为”name”列创建了一个名为”idx_name”的普通索引。通用的创建方式为：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KEY 索引名 (`列名`)</span><br></pre></td></tr></table></figure>\n<p>如果是为一张已经创建好的表添加一个普通索引，那么可以这样：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_grade`</span> <span class=\"keyword\">ADD</span> <span class=\"keyword\">KEY</span> idx_name(<span class=\"string\">`name`</span>);</span><br></pre></td></tr></table></figure>\n<p>你可能会说，“不是用index关键字来创建索引的吗”，别急别急，其实它们的效果是一样的。</p>\n<p><code>主键索引</code>，一看就是很关键的角色，没错，每张表都会有且只有一个主键索引，即使没有显式的创建主键索引的话，也会自动创建一个隐藏的主键索引。 </p>\n<p>这么重要的索引，用的关键字肯定也得不一样才行，创建主键索引的关键字是<code>PRIMARY KEY</code>，在DDL中添加主键索引的姿势为：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_grade`</span> (</span><br><span class=\"line\">    <span class=\"keyword\">id</span> <span class=\"built_in\">BIGINT</span>(<span class=\"number\">20</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">'主键id'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">name</span> <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">30</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">'姓名'</span>,</span><br><span class=\"line\">    course <span class=\"built_in\">INT</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'课程，1-语文，2-数学，3-英语，4-物理'</span>,</span><br><span class=\"line\">    grade <span class=\"built_in\">DECIMAL</span>(<span class=\"number\">5</span>,<span class=\"number\">2</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">'成绩'</span>,</span><br><span class=\"line\">    PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>)</span><br><span class=\"line\">)<span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">0</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>\n<p>因为主键只能有一个，所以不需要添加主键名。通用的添加方式为：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PRIMARY KEY (`列名`)</span><br></pre></td></tr></table></figure>\n<p>如果是为已创建好的表添加主键索引，那么可以这样：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_grade`</span> <span class=\"keyword\">ADD</span> PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>);</span><br></pre></td></tr></table></figure>\n<p><code>唯一索引</code>，顾名思义，就是“唯一”的索引，被添加到索引中的列的值必须是唯一的，如果向数据表中插入一条已存在的唯一索引字段记录，就会报错。</p>\n<p>定义唯一索引的关键字为 <code>UNIQUE KEY</code>。在DDL中添加唯一索引的姿势为：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_grade`</span> (</span><br><span class=\"line\">    <span class=\"keyword\">id</span> <span class=\"built_in\">BIGINT</span>(<span class=\"number\">20</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">'主键id'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">name</span> <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">30</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">'姓名'</span>,</span><br><span class=\"line\">    course <span class=\"built_in\">INT</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'课程，1-语文，2-数学，3-英语，4-物理'</span>,</span><br><span class=\"line\">    grade <span class=\"built_in\">DECIMAL</span>(<span class=\"number\">5</span>,<span class=\"number\">2</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">'成绩'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">UNIQUE</span> <span class=\"keyword\">KEY</span> uk_name (<span class=\"string\">`name`</span>)</span><br><span class=\"line\">)<span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">0</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>\n<p>唯一索引的通用添加方式为：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UNIQUE KEY 索引名 (`列名`)</span><br></pre></td></tr></table></figure>\n<p>为已创建好的表添加唯一索引：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_grade`</span> <span class=\"keyword\">ADD</span> <span class=\"keyword\">UNIQUE</span> <span class=\"keyword\">KEY</span> uk_name (<span class=\"string\">`name`</span>);</span><br></pre></td></tr></table></figure>\n<p><code>组合索引</code>，又叫联合索引，便是将两个或者多个字段组合在一起的索引，好像跟没说一样= =<br>看一个栗子就知道了。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_grade`</span> (</span><br><span class=\"line\">    <span class=\"keyword\">id</span> <span class=\"built_in\">BIGINT</span>(<span class=\"number\">20</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">'主键id'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">name</span> <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">30</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">'姓名'</span>,</span><br><span class=\"line\">    course <span class=\"built_in\">INT</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'课程，1-语文，2-数学，3-英语，4-物理'</span>,</span><br><span class=\"line\">    grade <span class=\"built_in\">DECIMAL</span>(<span class=\"number\">5</span>,<span class=\"number\">2</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">'成绩'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">KEY</span> idx_name_corse (<span class=\"string\">`name`</span>,<span class=\"string\">`course`</span>)</span><br><span class=\"line\">)<span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">0</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>\n<p>同样是使用<code>key</code>关键字，在索引名后添加多个字段名即可。这里有一点需要注意的是，字段排列是有顺序的。举例说明，下面这两个索引是不一样的：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_grade`</span> <span class=\"keyword\">ADD</span> <span class=\"keyword\">KEY</span> idx_name_course (<span class=\"string\">`name`</span>,<span class=\"string\">`course`</span>);</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_grade`</span> <span class=\"keyword\">ADD</span> <span class=\"keyword\">KEY</span> idx_name_course (<span class=\"string\">`course`</span>,<span class=\"string\">`name`</span>);</span><br></pre></td></tr></table></figure>\n<p>索引的匹配遵循“左缀匹配原则”，举个栗子说明，如果创建的组合索引是 </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_grade`</span> <span class=\"keyword\">ADD</span> <span class=\"keyword\">KEY</span> idx_name_course (<span class=\"string\">`name`</span>,<span class=\"string\">`course`</span>);</span><br></pre></td></tr></table></figure>\n<p>那么下面语句将能命中这个组合索引。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"string\">`t_grade`</span> <span class=\"keyword\">WHERE</span> <span class=\"keyword\">name</span> = <span class=\"string\">'Frank'</span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/07/11/5d2695c837a1478405.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>而下面这个语句将无法命中索引：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"string\">`t_grade`</span> <span class=\"keyword\">WHERE</span> course = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/07/11/5d2695dd1113960656.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>因为在组合索引中，索引中的记录是先按照前一个字段排序，然后再根据后一个字段排序的，所以如果直接使用组合索引中的第二个字段查询时，查询索引对索引记录进行遍历，遍历完成之后还需要回溯到聚簇索引中获取完整记录，这样反而更耗时间，所以sql优化器会选择直接对记录进行遍历。</p>\n<p>如果你还不清楚索引的结构以及聚簇索引是什么，不要着急，后面的文章里会有详细的介绍。</p>\n<p><code>联合唯一索引</code>，便是将多个字段组合起来形成一个唯一键，举个栗子：</p>\n<p>先删除所有索引，然后添加两条记录：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`t_grade`</span> (<span class=\"string\">`id`</span>, <span class=\"string\">`name`</span>, <span class=\"string\">`course`</span>, <span class=\"string\">`grade`</span>) <span class=\"keyword\">VALUES</span>(<span class=\"number\">1</span>, <span class=\"string\">'Frank'</span>, <span class=\"number\">1</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`t_grade`</span> (<span class=\"string\">`id`</span>, <span class=\"string\">`name`</span>, <span class=\"string\">`course`</span>, <span class=\"string\">`grade`</span>) <span class=\"keyword\">VALUES</span>(<span class=\"number\">2</span>, <span class=\"string\">'Frank'</span>, <span class=\"number\">1</span>, <span class=\"number\">95</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/07/11/5d2695fb3f84a48846.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>这样就能插入两条记录了。</p>\n<p>然后删掉这两条记录，创建一个联合唯一索引：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_grade`</span> <span class=\"keyword\">ADD</span> <span class=\"keyword\">UNIQUE</span> <span class=\"keyword\">KEY</span> idx_name_course (<span class=\"string\">`name`</span>,<span class=\"string\">`course`</span>);</span><br></pre></td></tr></table></figure>\n<p>然后再来执行一下上面的sql：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/07/11/5d26960ce9ccf62374.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>这时候，就会得到一个错误提示，因为将字段<code>name</code>和<code>course</code>创建了联合唯一索引，所以这两个字段的组合值必须是唯一的，如果要插入的记录的这两个字段组合值已经存在，那么就会抛出异常。</p>\n<p>最后一个是比较复杂的索引：<code>全文索引</code>，由于其复杂性，这里只简单的介绍它的创建姿势。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_article`</span>(</span><br><span class=\"line\">        <span class=\"keyword\">id</span> <span class=\"built_in\">BIGINT</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'文章id'</span>,</span><br><span class=\"line\">        title <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">200</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">'文章标题'</span>,</span><br><span class=\"line\">        <span class=\"keyword\">content</span> <span class=\"built_in\">TEXT</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'文章内容'</span>,</span><br><span class=\"line\">        FULLTEXT (title, <span class=\"keyword\">content</span>)</span><br><span class=\"line\">)<span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">0</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>\n<p>或者给现有表添加全文索引：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_article`</span> <span class=\"keyword\">ADD</span> FULLTEXT <span class=\"keyword\">KEY</span> fidx_title_content (title,<span class=\"keyword\">content</span>) <span class=\"keyword\">WITH</span> PARSER ngram;</span><br></pre></td></tr></table></figure>\n<p>想要使用全文索引查询，则需要使用MATCH关键字。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"string\">`t_article`</span> <span class=\"keyword\">WHERE</span> <span class=\"keyword\">MATCH</span>(title, <span class=\"keyword\">content</span>) AGAINST(<span class=\"string\">'查询字符串'</span>);</span><br></pre></td></tr></table></figure>\n<p>当然，如果想要使用全文索引，需要确认mysql的版本号在5.7以上，否则无法在innodb引擎上使用全文索引的中文检索插件ngram。</p>\n<h2 id=\"五、索引使用前后对比\"><a href=\"#五、索引使用前后对比\" class=\"headerlink\" title=\"五、索引使用前后对比\"></a>五、索引使用前后对比</h2><p>为了更直观的看出索引的优缺点，我们可以来对数据表添加索引前后执行相同sql的耗时来看出对比，这里仅进行简单的比较，没有使用性能测试。</p>\n<p>先来创建一个数据表：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`t_grade`</span> (</span><br><span class=\"line\">    <span class=\"keyword\">id</span> <span class=\"built_in\">BIGINT</span>(<span class=\"number\">20</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">'主键id'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">name</span> <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">30</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">'姓名'</span>,</span><br><span class=\"line\">    course <span class=\"built_in\">INT</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'课程，0-化学，1-语文，2-数学，3-英语，4-物理'</span>,</span><br><span class=\"line\">    grade <span class=\"built_in\">DECIMAL</span>(<span class=\"number\">5</span>,<span class=\"number\">2</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">'成绩'</span></span><br><span class=\"line\">)<span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">0</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>\n<p>然后插入一百万条数据：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void batchInsert()&#123;</span><br><span class=\"line\">    long timeMillis = System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(\"开始插入数据\");</span><br><span class=\"line\">    for (int i = 1; i &lt; 1000000; i++) &#123;</span><br><span class=\"line\">        GradeDO gradeDO = new GradeDO((long) i, randomName(), random.nextInt(5), BigDecimal.valueOf(random.nextDouble() * 100));</span><br><span class=\"line\">        gradeMapper.insert(gradeDO);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(\"插入一百万条记录耗时：\" + ( System.currentTimeMillis() - timeMillis) / 1000.0 );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">开始插入数据</span><br><span class=\"line\">插入一百万条记录耗时：1507.102</span><br></pre></td></tr></table></figure>\n<p>现在是没有索引的状态，开始进行插入测试：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">batchInsert</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> timeMillis = System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"开始插入数据\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1000000</span>; i &lt; <span class=\"number\">1010000</span>; i++) &#123;</span><br><span class=\"line\">        GradeDO gradeDO = <span class=\"keyword\">new</span> GradeDO((<span class=\"keyword\">long</span>) i, randomName(), random.nextInt(<span class=\"number\">5</span>), BigDecimal.valueOf(random.nextDouble() * <span class=\"number\">100</span>));</span><br><span class=\"line\">        gradeMapper.insert(gradeDO);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"插入一万条记录耗时：\"</span> + ( System.currentTimeMillis() - timeMillis) / <span class=\"number\">1000.0</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">开始插入数据</span><br><span class=\"line\">插入一万条记录耗时：15.681</span><br></pre></td></tr></table></figure></p>\n<p>然后进行查询测试。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testQuery</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> timeMillis = System.currentTimeMillis();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"开始查询\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">        Integer id = random.nextInt(<span class=\"number\">1000000</span>);</span><br><span class=\"line\">        GradeDO gradeDO = gradeMapper.selectById(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"一百次查询耗时：\"</span> + ( System.currentTimeMillis() - timeMillis) / <span class=\"number\">1000.0</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">开始查询</span><br><span class=\"line\">一百次查询耗时：51.658</span><br></pre></td></tr></table></figure>\n<p>接下来，为id列创建一个主键，并为name字段创建一个普通索引。<br>再插入一万条记录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">开始插入数据</span><br><span class=\"line\">插入一万条记录耗时：17.465</span><br></pre></td></tr></table></figure>\n<p>然后进行查询测试。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">开始查询</span><br><span class=\"line\">一百次查询耗时：0.191</span><br></pre></td></tr></table></figure>\n<p>可以看出，在有单个索引的情况下，创建记录耗时略长于无索引的情况，当字段数量和索引数量增加时，这种差距将会增大。查询效率可以清晰的看出，这里添加了索引之后，大大的缩减了查询的耗时，当然，这里主要是聚簇索引的功劳。</p>\n<h2 id=\"六、总结\"><a href=\"#六、总结\" class=\"headerlink\" title=\"六、总结\"></a>六、总结</h2><p>索引是mysql中十分重要的一个特性，使用好它就能让你的sql如虎添翼。简单来说，索引一方面可以大大提升查询性能，另一方面也会占用时间和空间成本，因此索引的选择也是一门学问。索引有很多种类型，不同类型的索引有着不同的特性，因此只有了解了它们各自的特性才能正确使用它们。<br>关于索引的简介就先介绍到这里了，后面会对索引的原理进行进一步深入的介绍，让你不仅知道怎么使用索引，而且还能知道为什么要这样使用索引。</p>\n"},{"title":"【RabbitMQ】一文带你搞定RabbitMQ死信队列","date":"2019-07-12T00:53:12.000Z","categorys":["编程"],"_content":"","source":"_posts/rabbitmq/rabbitmq-how-to-use-dead-letter-queue.md","raw":"---\ntitle: 【RabbitMQ】一文带你搞定RabbitMQ死信队列\ndate: 2019-07-12 08:53:12\ntags:\n- RabbitMQ\ncategorys:\n- 编程\n---\n","slug":"rabbitmq/rabbitmq-how-to-use-dead-letter-queue","published":1,"updated":"2019-07-12T00:54:50.853Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxze3go800190cvwzwkcwhnc","content":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":""},{"title":"《Java多线程编程实战指南》（核心篇）—— 总结","date":"2018-12-26T11:55:51.000Z","_content":"> 书籍作者：黄文海\n\n## 思维导图\n\n[全文思维导图](https://mubu.com/doc/lW2C-KYYy0)\n","source":"_posts/reading/java-multithread-programming-guide-in-action-notes.md","raw":"---\ntitle: 《Java多线程编程实战指南》（核心篇）—— 总结\ntags: \n - 摘要\n - Java\n - 多线程\ncategories: 阅读\ndate: 2018-12-26 19:55:51\n---\n> 书籍作者：黄文海\n\n## 思维导图\n\n[全文思维导图](https://mubu.com/doc/lW2C-KYYy0)\n","slug":"reading/java-multithread-programming-guide-in-action-notes","published":1,"updated":"2019-06-04T01:29:57.498Z","_id":"cjxze3gon001c0cvwdh9ove76","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>书籍作者：黄文海</p>\n</blockquote>\n<h2 id=\"思维导图\"><a href=\"#思维导图\" class=\"headerlink\" title=\"思维导图\"></a>思维导图</h2><p><a href=\"https://mubu.com/doc/lW2C-KYYy0\" target=\"_blank\" rel=\"noopener\">全文思维导图</a></p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<blockquote>\n<p>书籍作者：黄文海</p>\n</blockquote>\n<h2 id=\"思维导图\"><a href=\"#思维导图\" class=\"headerlink\" title=\"思维导图\"></a>思维导图</h2><p><a href=\"https://mubu.com/doc/lW2C-KYYy0\" target=\"_blank\" rel=\"noopener\">全文思维导图</a></p>\n"},{"title":"【动态规划】01背包问题【续】","date":"2019-03-23T13:31:05.000Z","categorys":"编程","_content":"\n## 说明\n\n这段时间每天加班，确实没有整块的时间来写博客了，一不小心就到周末了，要是不写篇博客，那就又要鸽了。为了不打脸，还是加班加点的把这篇博客给写了出来。\n\n![20190323214213.png](https://i.loli.net/2019/03/23/5c9637b6e2922.png)\n\n再说个题外话，最近一直在看一本关于`Mysql`的掘金小册，感觉很棒，作者用通俗易懂的语言将`Mysql`的底层原理进行了介绍，图文并茂，讲解的很深入，可以看出作者应该是花了不少心思，借阅了不少书籍的。据说作者是个95后，为了写这本小册子还特意辞了职，简直优秀！\n\n![20190323215229.png](https://i.loli.net/2019/03/23/5c963a200ae18.png)\n\n一篇文章大概需要花费40~60分钟，建议花整块的时间进行阅读。\n\n从作者的身上，也看到了一种匠心精神，反观自己，写这么水的文章，实在是惭愧。所以决定对文章质量把把关，本着宁缺毋滥的原则来写作，尽量不浪费大家的时间。\n\n好了，闲话就说到这了，言归正传。\n\n上一篇中，我们了解了`01背包问题`，并用三种方法进行了求解，但其实在最后一种解法上，我们还能再对它的空间复杂度进行优化。\n\n## 优化过程\n\n已经过去一个星期了，可能一部分人已经忘记了之前的解题思路，所以在这里把之前填表法使用到的图贴了过来：\n\n![](https://i.loli.net/2019/03/12/5c87c9244d3c9.jpeg)\n\n这是我们上一篇填表法的最终结果，在这里，聪明的你应该能发现，其实这里大部分的内容都没有用上，那么让我们来想想，如何优化一下空间复杂度呢？\n\n再回头看下之前的递推关系式：\n\n![](https://i.loli.net/2019/03/12/5c87b64eb1a66.jpeg)\n\n可以发现，每次求解 `KS(i,j)`只与`KS(i-1,m) {m:1...j}` 有关。也就是说，如果我们知道了`K(i-1,1...j)`就肯定能求出`KS(i,j)`，为了更直观的理解，再画一张图：\n\n![](https://i.loli.net/2019/03/23/5c964f94ca2a4.jpeg)\n\n下一层只需要根据上一层的结果即可推出答案，举个栗子，看`i=3，j=5`时，在求这个子问题的最优解时，根据上述推导公式，`KS(3,5) = max{KS(2,5)`,`KS(2,0) + 3} = max{6,3} = 6`;如果我们得到了`i=2`时所有子问题的解，那么就很容易求出`i=3`时所有子问题的解。\n\n因此，我们可以将求解空间进行优化，将二维数组压缩成一维数组，此时，装填转移方程变为：\n\n```java\nKS(j) = max{KS(j),KS(j - wi) + vi}\n```\n\n这里`KS(j - wi)`就相当于原来的`KS(i-1, j - wi)`。需要注意的是，由于`KS(j)`是由它前面的`KS(m){m:1..j}`推导出来的，所以在第二轮循环扫描的时候应该由后往前进行计算，因为如果由前往后推导的话，前一次循环保存下来的值可能会被修改，从而造成错误。\n\n这么说也许还是不太清楚，回头看上面的图，我们从`i=2`推算`i=3`的子问题的解时，此时一维数组中存放的是`{0,0,2,4,4,6,6,6,6,6,6}`，这是`i=2`时所有子问题的解，如果我们从前往后推算`i=3`时的解，比如，我们计算`KS(0) = 0，KS(1) = KS(1) = 0` (因为j=1时，装不下第三个珠宝，第三个珠宝的重量为5)，`KS(2) = 2,KS(3) = 4,KS(4) = 4, KS(5) = max{KS(5), KS(5-5) + 3} = 6,....,KS(8) = max{KS(8),KS(8 - 5) + 3} = 7`。在这里计算KS(8)的时候，我们就把原来KS(8)的内容修改掉了，这样，我们后续计算就无法找到这个位置的原值（这个栗子没举好。。因为后面的计算没有用到KS(8)= =），也就是上一轮循环中计算出来的值了，所以在遍历的时候，需要从后往前进行倒序遍历。\n\n```java\npublic class Solution{\n    int[] vs = {0,2,4,3,7};\n    int[] ws = {0,2,3,5,5};\n    int[] newResults = new int[11];\n\n    @Test\n    public void test() {\n        int result = ksp(4,10);\n        System.out.println(result);\n    }\n\n    private int ksp(int i, int c){\n        // 开始填表\n        for (int m = 0; m < vs.length; m++){\n            int w = ws[m];\n            int v = vs[m];\n            for (int n = c; n >= w; n--){\n                newResults[n] = Math.max(newResults[n] , newResults[n - w] + v);\n            }\n            // 可以在这里输出中间结果\n            System.out.println(JSON.toJSONString(newResults));\n        }\n        return newResults[newResults.length - 1];\n    }\n}\n```\n\n输出如下：\n\n```\n[0,0,0,0,0,0,0,0,0,0,0]\n[0,0,2,2,2,2,2,2,2,2,2]\n[0,0,2,4,4,6,6,6,6,6,6]\n[0,0,2,4,4,6,6,6,7,7,9]\n[0,0,2,4,4,7,7,9,11,11,13]\n13\n```\n\n这样，我们就顺利将空间复杂度从`O(n*c)`优化到了`O(c)`。当然，空间优化的代价是，我们只能知道最终的结果，但无法再回溯中间的选择，也就是无法根据最终结果来找到我们要选的物品组合。\n\n## 关于初始值\n\n`01背包问题`一般有两种不同的问法，一种是`“恰好装满背包”`的最优解，要求背包必须装满，那么在初始化的时候，除了`KS(0)`为`0`，其他的`KS(j)`都应该设置为`负无穷大`，这样就可以保证最终得到的`KS(c)`是恰好装满背包的最优解。另一种问法`不要求装满`，而是只希望最终得到的价值`尽可能大`，那么初始化的时候，应该将`KS(0...c)`全部设置为`0`。\n\n为什么呢？因为初始化的数组，实际上是在没有任何物品可以放入背包的情况下的`合法状态`。如果要求背包恰好装满，那么此时只有容量为0的背包可以在什么都不装且价值为0的情况下被`“恰好装满”`，其他容量的背包均没有合法的解，因此属于未定义的状态，应该设置为`负无穷大`。如果背包不需要被装满，那么任何容量的背包都有合法解，那就是“什么都不装”。这个解的价值为0，所以初始状态的值都是0。\n\n![](https://i.loli.net/2019/03/24/5c96e93168119.jpeg)\n\n## 总结\n\n`01背包问题`可以用`自上而下`的`递归记忆法`求解，也可以用`自下而上`的`填表法`求解，而后者可以将二维数组的解空间优化成一维数组的解空间，从而实现空间复杂度的优化。\n\n对于`01背包问题`的两种不同问法，实际上的区别便是`初始值`设置不一样，解题思路是一样的。\n\n关于`01背包问题`，介绍到这里就已经全部结束了，希望能对大家有所帮助。如果觉得有收获，不要吝啬你的赞哦，也欢迎关注我的公众号留言交流。\n\n![](https://i.loli.net/2019/03/14/5c8a58ba229ca.png)\n\n","source":"_posts/leetcode/dp-01-knapsack-problem-optimization.md","raw":"---\ntitle: 【动态规划】01背包问题【续】\ndate: 2019-03-23 21:31:05\ntags:\n - Java\n - 算法\n - 动态规划\n - 背包问题\ncategorys: 编程\n---\n\n## 说明\n\n这段时间每天加班，确实没有整块的时间来写博客了，一不小心就到周末了，要是不写篇博客，那就又要鸽了。为了不打脸，还是加班加点的把这篇博客给写了出来。\n\n![20190323214213.png](https://i.loli.net/2019/03/23/5c9637b6e2922.png)\n\n再说个题外话，最近一直在看一本关于`Mysql`的掘金小册，感觉很棒，作者用通俗易懂的语言将`Mysql`的底层原理进行了介绍，图文并茂，讲解的很深入，可以看出作者应该是花了不少心思，借阅了不少书籍的。据说作者是个95后，为了写这本小册子还特意辞了职，简直优秀！\n\n![20190323215229.png](https://i.loli.net/2019/03/23/5c963a200ae18.png)\n\n一篇文章大概需要花费40~60分钟，建议花整块的时间进行阅读。\n\n从作者的身上，也看到了一种匠心精神，反观自己，写这么水的文章，实在是惭愧。所以决定对文章质量把把关，本着宁缺毋滥的原则来写作，尽量不浪费大家的时间。\n\n好了，闲话就说到这了，言归正传。\n\n上一篇中，我们了解了`01背包问题`，并用三种方法进行了求解，但其实在最后一种解法上，我们还能再对它的空间复杂度进行优化。\n\n## 优化过程\n\n已经过去一个星期了，可能一部分人已经忘记了之前的解题思路，所以在这里把之前填表法使用到的图贴了过来：\n\n![](https://i.loli.net/2019/03/12/5c87c9244d3c9.jpeg)\n\n这是我们上一篇填表法的最终结果，在这里，聪明的你应该能发现，其实这里大部分的内容都没有用上，那么让我们来想想，如何优化一下空间复杂度呢？\n\n再回头看下之前的递推关系式：\n\n![](https://i.loli.net/2019/03/12/5c87b64eb1a66.jpeg)\n\n可以发现，每次求解 `KS(i,j)`只与`KS(i-1,m) {m:1...j}` 有关。也就是说，如果我们知道了`K(i-1,1...j)`就肯定能求出`KS(i,j)`，为了更直观的理解，再画一张图：\n\n![](https://i.loli.net/2019/03/23/5c964f94ca2a4.jpeg)\n\n下一层只需要根据上一层的结果即可推出答案，举个栗子，看`i=3，j=5`时，在求这个子问题的最优解时，根据上述推导公式，`KS(3,5) = max{KS(2,5)`,`KS(2,0) + 3} = max{6,3} = 6`;如果我们得到了`i=2`时所有子问题的解，那么就很容易求出`i=3`时所有子问题的解。\n\n因此，我们可以将求解空间进行优化，将二维数组压缩成一维数组，此时，装填转移方程变为：\n\n```java\nKS(j) = max{KS(j),KS(j - wi) + vi}\n```\n\n这里`KS(j - wi)`就相当于原来的`KS(i-1, j - wi)`。需要注意的是，由于`KS(j)`是由它前面的`KS(m){m:1..j}`推导出来的，所以在第二轮循环扫描的时候应该由后往前进行计算，因为如果由前往后推导的话，前一次循环保存下来的值可能会被修改，从而造成错误。\n\n这么说也许还是不太清楚，回头看上面的图，我们从`i=2`推算`i=3`的子问题的解时，此时一维数组中存放的是`{0,0,2,4,4,6,6,6,6,6,6}`，这是`i=2`时所有子问题的解，如果我们从前往后推算`i=3`时的解，比如，我们计算`KS(0) = 0，KS(1) = KS(1) = 0` (因为j=1时，装不下第三个珠宝，第三个珠宝的重量为5)，`KS(2) = 2,KS(3) = 4,KS(4) = 4, KS(5) = max{KS(5), KS(5-5) + 3} = 6,....,KS(8) = max{KS(8),KS(8 - 5) + 3} = 7`。在这里计算KS(8)的时候，我们就把原来KS(8)的内容修改掉了，这样，我们后续计算就无法找到这个位置的原值（这个栗子没举好。。因为后面的计算没有用到KS(8)= =），也就是上一轮循环中计算出来的值了，所以在遍历的时候，需要从后往前进行倒序遍历。\n\n```java\npublic class Solution{\n    int[] vs = {0,2,4,3,7};\n    int[] ws = {0,2,3,5,5};\n    int[] newResults = new int[11];\n\n    @Test\n    public void test() {\n        int result = ksp(4,10);\n        System.out.println(result);\n    }\n\n    private int ksp(int i, int c){\n        // 开始填表\n        for (int m = 0; m < vs.length; m++){\n            int w = ws[m];\n            int v = vs[m];\n            for (int n = c; n >= w; n--){\n                newResults[n] = Math.max(newResults[n] , newResults[n - w] + v);\n            }\n            // 可以在这里输出中间结果\n            System.out.println(JSON.toJSONString(newResults));\n        }\n        return newResults[newResults.length - 1];\n    }\n}\n```\n\n输出如下：\n\n```\n[0,0,0,0,0,0,0,0,0,0,0]\n[0,0,2,2,2,2,2,2,2,2,2]\n[0,0,2,4,4,6,6,6,6,6,6]\n[0,0,2,4,4,6,6,6,7,7,9]\n[0,0,2,4,4,7,7,9,11,11,13]\n13\n```\n\n这样，我们就顺利将空间复杂度从`O(n*c)`优化到了`O(c)`。当然，空间优化的代价是，我们只能知道最终的结果，但无法再回溯中间的选择，也就是无法根据最终结果来找到我们要选的物品组合。\n\n## 关于初始值\n\n`01背包问题`一般有两种不同的问法，一种是`“恰好装满背包”`的最优解，要求背包必须装满，那么在初始化的时候，除了`KS(0)`为`0`，其他的`KS(j)`都应该设置为`负无穷大`，这样就可以保证最终得到的`KS(c)`是恰好装满背包的最优解。另一种问法`不要求装满`，而是只希望最终得到的价值`尽可能大`，那么初始化的时候，应该将`KS(0...c)`全部设置为`0`。\n\n为什么呢？因为初始化的数组，实际上是在没有任何物品可以放入背包的情况下的`合法状态`。如果要求背包恰好装满，那么此时只有容量为0的背包可以在什么都不装且价值为0的情况下被`“恰好装满”`，其他容量的背包均没有合法的解，因此属于未定义的状态，应该设置为`负无穷大`。如果背包不需要被装满，那么任何容量的背包都有合法解，那就是“什么都不装”。这个解的价值为0，所以初始状态的值都是0。\n\n![](https://i.loli.net/2019/03/24/5c96e93168119.jpeg)\n\n## 总结\n\n`01背包问题`可以用`自上而下`的`递归记忆法`求解，也可以用`自下而上`的`填表法`求解，而后者可以将二维数组的解空间优化成一维数组的解空间，从而实现空间复杂度的优化。\n\n对于`01背包问题`的两种不同问法，实际上的区别便是`初始值`设置不一样，解题思路是一样的。\n\n关于`01背包问题`，介绍到这里就已经全部结束了，希望能对大家有所帮助。如果觉得有收获，不要吝啬你的赞哦，也欢迎关注我的公众号留言交流。\n\n![](https://i.loli.net/2019/03/14/5c8a58ba229ca.png)\n\n","slug":"leetcode/dp-01-knapsack-problem-optimization","published":1,"updated":"2019-06-04T01:29:57.465Z","_id":"cjxze3got001g0cvwfuw9w55m","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>这段时间每天加班，确实没有整块的时间来写博客了，一不小心就到周末了，要是不写篇博客，那就又要鸽了。为了不打脸，还是加班加点的把这篇博客给写了出来。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/23/5c9637b6e2922.png\" alt=\"20190323214213.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190323214213.png</div>\n            </figure>\n<p>再说个题外话，最近一直在看一本关于<code>Mysql</code>的掘金小册，感觉很棒，作者用通俗易懂的语言将<code>Mysql</code>的底层原理进行了介绍，图文并茂，讲解的很深入，可以看出作者应该是花了不少心思，借阅了不少书籍的。据说作者是个95后，为了写这本小册子还特意辞了职，简直优秀！</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/23/5c963a200ae18.png\" alt=\"20190323215229.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190323215229.png</div>\n            </figure>\n<p>一篇文章大概需要花费40~60分钟，建议花整块的时间进行阅读。</p>\n<p>从作者的身上，也看到了一种匠心精神，反观自己，写这么水的文章，实在是惭愧。所以决定对文章质量把把关，本着宁缺毋滥的原则来写作，尽量不浪费大家的时间。</p>\n<p>好了，闲话就说到这了，言归正传。</p>\n<p>上一篇中，我们了解了<code>01背包问题</code>，并用三种方法进行了求解，但其实在最后一种解法上，我们还能再对它的空间复杂度进行优化。</p>\n<h2 id=\"优化过程\"><a href=\"#优化过程\" class=\"headerlink\" title=\"优化过程\"></a>优化过程</h2><p>已经过去一个星期了，可能一部分人已经忘记了之前的解题思路，所以在这里把之前填表法使用到的图贴了过来：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/12/5c87c9244d3c9.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>这是我们上一篇填表法的最终结果，在这里，聪明的你应该能发现，其实这里大部分的内容都没有用上，那么让我们来想想，如何优化一下空间复杂度呢？</p>\n<p>再回头看下之前的递推关系式：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/12/5c87b64eb1a66.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>可以发现，每次求解 <code>KS(i,j)</code>只与<code>KS(i-1,m) {m:1...j}</code> 有关。也就是说，如果我们知道了<code>K(i-1,1...j)</code>就肯定能求出<code>KS(i,j)</code>，为了更直观的理解，再画一张图：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/23/5c964f94ca2a4.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>下一层只需要根据上一层的结果即可推出答案，举个栗子，看<code>i=3，j=5</code>时，在求这个子问题的最优解时，根据上述推导公式，<code>KS(3,5) = max{KS(2,5)</code>,<code>KS(2,0) + 3} = max{6,3} = 6</code>;如果我们得到了<code>i=2</code>时所有子问题的解，那么就很容易求出<code>i=3</code>时所有子问题的解。</p>\n<p>因此，我们可以将求解空间进行优化，将二维数组压缩成一维数组，此时，装填转移方程变为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KS(j) = max&#123;KS(j),KS(j - wi) + vi&#125;</span><br></pre></td></tr></table></figure>\n<p>这里<code>KS(j - wi)</code>就相当于原来的<code>KS(i-1, j - wi)</code>。需要注意的是，由于<code>KS(j)</code>是由它前面的<code>KS(m){m:1..j}</code>推导出来的，所以在第二轮循环扫描的时候应该由后往前进行计算，因为如果由前往后推导的话，前一次循环保存下来的值可能会被修改，从而造成错误。</p>\n<p>这么说也许还是不太清楚，回头看上面的图，我们从<code>i=2</code>推算<code>i=3</code>的子问题的解时，此时一维数组中存放的是<code>{0,0,2,4,4,6,6,6,6,6,6}</code>，这是<code>i=2</code>时所有子问题的解，如果我们从前往后推算<code>i=3</code>时的解，比如，我们计算<code>KS(0) = 0，KS(1) = KS(1) = 0</code> (因为j=1时，装不下第三个珠宝，第三个珠宝的重量为5)，<code>KS(2) = 2,KS(3) = 4,KS(4) = 4, KS(5) = max{KS(5), KS(5-5) + 3} = 6,....,KS(8) = max{KS(8),KS(8 - 5) + 3} = 7</code>。在这里计算KS(8)的时候，我们就把原来KS(8)的内容修改掉了，这样，我们后续计算就无法找到这个位置的原值（这个栗子没举好。。因为后面的计算没有用到KS(8)= =），也就是上一轮循环中计算出来的值了，所以在遍历的时候，需要从后往前进行倒序遍历。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] vs = &#123;<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] ws = &#123;<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] newResults = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">11</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ksp(<span class=\"number\">4</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">ksp</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 开始填表</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> m = <span class=\"number\">0</span>; m &lt; vs.length; m++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> w = ws[m];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> v = vs[m];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> n = c; n &gt;= w; n--)&#123;</span><br><span class=\"line\">                newResults[n] = Math.max(newResults[n] , newResults[n - w] + v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 可以在这里输出中间结果</span></span><br><span class=\"line\">            System.out.println(JSON.toJSONString(newResults));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newResults[newResults.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0,0,0,0,0,0,0,0,0,0,0]</span><br><span class=\"line\">[0,0,2,2,2,2,2,2,2,2,2]</span><br><span class=\"line\">[0,0,2,4,4,6,6,6,6,6,6]</span><br><span class=\"line\">[0,0,2,4,4,6,6,6,7,7,9]</span><br><span class=\"line\">[0,0,2,4,4,7,7,9,11,11,13]</span><br><span class=\"line\">13</span><br></pre></td></tr></table></figure>\n<p>这样，我们就顺利将空间复杂度从<code>O(n*c)</code>优化到了<code>O(c)</code>。当然，空间优化的代价是，我们只能知道最终的结果，但无法再回溯中间的选择，也就是无法根据最终结果来找到我们要选的物品组合。</p>\n<h2 id=\"关于初始值\"><a href=\"#关于初始值\" class=\"headerlink\" title=\"关于初始值\"></a>关于初始值</h2><p><code>01背包问题</code>一般有两种不同的问法，一种是<code>“恰好装满背包”</code>的最优解，要求背包必须装满，那么在初始化的时候，除了<code>KS(0)</code>为<code>0</code>，其他的<code>KS(j)</code>都应该设置为<code>负无穷大</code>，这样就可以保证最终得到的<code>KS(c)</code>是恰好装满背包的最优解。另一种问法<code>不要求装满</code>，而是只希望最终得到的价值<code>尽可能大</code>，那么初始化的时候，应该将<code>KS(0...c)</code>全部设置为<code>0</code>。</p>\n<p>为什么呢？因为初始化的数组，实际上是在没有任何物品可以放入背包的情况下的<code>合法状态</code>。如果要求背包恰好装满，那么此时只有容量为0的背包可以在什么都不装且价值为0的情况下被<code>“恰好装满”</code>，其他容量的背包均没有合法的解，因此属于未定义的状态，应该设置为<code>负无穷大</code>。如果背包不需要被装满，那么任何容量的背包都有合法解，那就是“什么都不装”。这个解的价值为0，所以初始状态的值都是0。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/24/5c96e93168119.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><code>01背包问题</code>可以用<code>自上而下</code>的<code>递归记忆法</code>求解，也可以用<code>自下而上</code>的<code>填表法</code>求解，而后者可以将二维数组的解空间优化成一维数组的解空间，从而实现空间复杂度的优化。</p>\n<p>对于<code>01背包问题</code>的两种不同问法，实际上的区别便是<code>初始值</code>设置不一样，解题思路是一样的。</p>\n<p>关于<code>01背包问题</code>，介绍到这里就已经全部结束了，希望能对大家有所帮助。如果觉得有收获，不要吝啬你的赞哦，也欢迎关注我的公众号留言交流。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a58ba229ca.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>这段时间每天加班，确实没有整块的时间来写博客了，一不小心就到周末了，要是不写篇博客，那就又要鸽了。为了不打脸，还是加班加点的把这篇博客给写了出来。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/23/5c9637b6e2922.png\" alt=\"20190323214213.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190323214213.png</div>\n            </figure>\n<p>再说个题外话，最近一直在看一本关于<code>Mysql</code>的掘金小册，感觉很棒，作者用通俗易懂的语言将<code>Mysql</code>的底层原理进行了介绍，图文并茂，讲解的很深入，可以看出作者应该是花了不少心思，借阅了不少书籍的。据说作者是个95后，为了写这本小册子还特意辞了职，简直优秀！</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/23/5c963a200ae18.png\" alt=\"20190323215229.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190323215229.png</div>\n            </figure>\n<p>一篇文章大概需要花费40~60分钟，建议花整块的时间进行阅读。</p>\n<p>从作者的身上，也看到了一种匠心精神，反观自己，写这么水的文章，实在是惭愧。所以决定对文章质量把把关，本着宁缺毋滥的原则来写作，尽量不浪费大家的时间。</p>\n<p>好了，闲话就说到这了，言归正传。</p>\n<p>上一篇中，我们了解了<code>01背包问题</code>，并用三种方法进行了求解，但其实在最后一种解法上，我们还能再对它的空间复杂度进行优化。</p>\n<h2 id=\"优化过程\"><a href=\"#优化过程\" class=\"headerlink\" title=\"优化过程\"></a>优化过程</h2><p>已经过去一个星期了，可能一部分人已经忘记了之前的解题思路，所以在这里把之前填表法使用到的图贴了过来：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/12/5c87c9244d3c9.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>这是我们上一篇填表法的最终结果，在这里，聪明的你应该能发现，其实这里大部分的内容都没有用上，那么让我们来想想，如何优化一下空间复杂度呢？</p>\n<p>再回头看下之前的递推关系式：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/12/5c87b64eb1a66.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>可以发现，每次求解 <code>KS(i,j)</code>只与<code>KS(i-1,m) {m:1...j}</code> 有关。也就是说，如果我们知道了<code>K(i-1,1...j)</code>就肯定能求出<code>KS(i,j)</code>，为了更直观的理解，再画一张图：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/23/5c964f94ca2a4.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>下一层只需要根据上一层的结果即可推出答案，举个栗子，看<code>i=3，j=5</code>时，在求这个子问题的最优解时，根据上述推导公式，<code>KS(3,5) = max{KS(2,5)</code>,<code>KS(2,0) + 3} = max{6,3} = 6</code>;如果我们得到了<code>i=2</code>时所有子问题的解，那么就很容易求出<code>i=3</code>时所有子问题的解。</p>\n<p>因此，我们可以将求解空间进行优化，将二维数组压缩成一维数组，此时，装填转移方程变为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KS(j) = max&#123;KS(j),KS(j - wi) + vi&#125;</span><br></pre></td></tr></table></figure>\n<p>这里<code>KS(j - wi)</code>就相当于原来的<code>KS(i-1, j - wi)</code>。需要注意的是，由于<code>KS(j)</code>是由它前面的<code>KS(m){m:1..j}</code>推导出来的，所以在第二轮循环扫描的时候应该由后往前进行计算，因为如果由前往后推导的话，前一次循环保存下来的值可能会被修改，从而造成错误。</p>\n<p>这么说也许还是不太清楚，回头看上面的图，我们从<code>i=2</code>推算<code>i=3</code>的子问题的解时，此时一维数组中存放的是<code>{0,0,2,4,4,6,6,6,6,6,6}</code>，这是<code>i=2</code>时所有子问题的解，如果我们从前往后推算<code>i=3</code>时的解，比如，我们计算<code>KS(0) = 0，KS(1) = KS(1) = 0</code> (因为j=1时，装不下第三个珠宝，第三个珠宝的重量为5)，<code>KS(2) = 2,KS(3) = 4,KS(4) = 4, KS(5) = max{KS(5), KS(5-5) + 3} = 6,....,KS(8) = max{KS(8),KS(8 - 5) + 3} = 7</code>。在这里计算KS(8)的时候，我们就把原来KS(8)的内容修改掉了，这样，我们后续计算就无法找到这个位置的原值（这个栗子没举好。。因为后面的计算没有用到KS(8)= =），也就是上一轮循环中计算出来的值了，所以在遍历的时候，需要从后往前进行倒序遍历。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] vs = &#123;<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] ws = &#123;<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] newResults = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">11</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ksp(<span class=\"number\">4</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">ksp</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 开始填表</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> m = <span class=\"number\">0</span>; m &lt; vs.length; m++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> w = ws[m];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> v = vs[m];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> n = c; n &gt;= w; n--)&#123;</span><br><span class=\"line\">                newResults[n] = Math.max(newResults[n] , newResults[n - w] + v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 可以在这里输出中间结果</span></span><br><span class=\"line\">            System.out.println(JSON.toJSONString(newResults));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newResults[newResults.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0,0,0,0,0,0,0,0,0,0,0]</span><br><span class=\"line\">[0,0,2,2,2,2,2,2,2,2,2]</span><br><span class=\"line\">[0,0,2,4,4,6,6,6,6,6,6]</span><br><span class=\"line\">[0,0,2,4,4,6,6,6,7,7,9]</span><br><span class=\"line\">[0,0,2,4,4,7,7,9,11,11,13]</span><br><span class=\"line\">13</span><br></pre></td></tr></table></figure>\n<p>这样，我们就顺利将空间复杂度从<code>O(n*c)</code>优化到了<code>O(c)</code>。当然，空间优化的代价是，我们只能知道最终的结果，但无法再回溯中间的选择，也就是无法根据最终结果来找到我们要选的物品组合。</p>\n<h2 id=\"关于初始值\"><a href=\"#关于初始值\" class=\"headerlink\" title=\"关于初始值\"></a>关于初始值</h2><p><code>01背包问题</code>一般有两种不同的问法，一种是<code>“恰好装满背包”</code>的最优解，要求背包必须装满，那么在初始化的时候，除了<code>KS(0)</code>为<code>0</code>，其他的<code>KS(j)</code>都应该设置为<code>负无穷大</code>，这样就可以保证最终得到的<code>KS(c)</code>是恰好装满背包的最优解。另一种问法<code>不要求装满</code>，而是只希望最终得到的价值<code>尽可能大</code>，那么初始化的时候，应该将<code>KS(0...c)</code>全部设置为<code>0</code>。</p>\n<p>为什么呢？因为初始化的数组，实际上是在没有任何物品可以放入背包的情况下的<code>合法状态</code>。如果要求背包恰好装满，那么此时只有容量为0的背包可以在什么都不装且价值为0的情况下被<code>“恰好装满”</code>，其他容量的背包均没有合法的解，因此属于未定义的状态，应该设置为<code>负无穷大</code>。如果背包不需要被装满，那么任何容量的背包都有合法解，那就是“什么都不装”。这个解的价值为0，所以初始状态的值都是0。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/24/5c96e93168119.jpeg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><code>01背包问题</code>可以用<code>自上而下</code>的<code>递归记忆法</code>求解，也可以用<code>自下而上</code>的<code>填表法</code>求解，而后者可以将二维数组的解空间优化成一维数组的解空间，从而实现空间复杂度的优化。</p>\n<p>对于<code>01背包问题</code>的两种不同问法，实际上的区别便是<code>初始值</code>设置不一样，解题思路是一样的。</p>\n<p>关于<code>01背包问题</code>，介绍到这里就已经全部结束了，希望能对大家有所帮助。如果觉得有收获，不要吝啬你的赞哦，也欢迎关注我的公众号留言交流。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a58ba229ca.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n"},{"title":"读书笔记系列文章","date":"2018-12-26T11:55:51.000Z","_content":"\n## 说明\n\n平时喜欢看一些书，包括技术类书籍，也包括一些文学类和方法论的书籍，曾经也是一个文学爱好者，阴差阳错的走上了开发的不归路，从此`文艺小清新`的标签就与我无缘了，大家更关注的是我的头发（手动默哀）。\n\n这里将会记录一些平时阅读书籍时的感悟和收获，阅读一本好书是一件很享受的事情，但这个过程如果不记录和回顾，那就不会有太多的知识沉淀，对自己的影响也会很有限。所以慢慢的，追求的不再是“那本书我看过”，“我今年已经看了XX本书了”，这样浮于表面的满足感，开始关注真正有意义的部分，那就是从阅读中的收获和感悟。\n\n知识或者感动，就像是一团火，我在这里添柴加薪，把我的火焰留在了这里，希望能为路过的你添加一点温暖，也希望能把这份温暖传递下去。\n\n## 非技术类书籍\n\n1. [《习惯的力量》](./The-Power-of-Habit.html)\n2. \n\n## 技术类书籍\n\n1. [《Java多线程编程实战指南》（核心篇）](./Java-Multithread-Programming-Guide-In-Action.html)\n2. 《Java并发编程实战》\n3. [《Java并发编程的艺术》](./the-art-of-java-multithread-notes.html)\n","source":"_posts/reading/reading-notes.md","raw":"---\ntitle: 读书笔记系列文章\ncategories: 阅读\ndate: 2018-12-26 19:55:51\n---\n\n## 说明\n\n平时喜欢看一些书，包括技术类书籍，也包括一些文学类和方法论的书籍，曾经也是一个文学爱好者，阴差阳错的走上了开发的不归路，从此`文艺小清新`的标签就与我无缘了，大家更关注的是我的头发（手动默哀）。\n\n这里将会记录一些平时阅读书籍时的感悟和收获，阅读一本好书是一件很享受的事情，但这个过程如果不记录和回顾，那就不会有太多的知识沉淀，对自己的影响也会很有限。所以慢慢的，追求的不再是“那本书我看过”，“我今年已经看了XX本书了”，这样浮于表面的满足感，开始关注真正有意义的部分，那就是从阅读中的收获和感悟。\n\n知识或者感动，就像是一团火，我在这里添柴加薪，把我的火焰留在了这里，希望能为路过的你添加一点温暖，也希望能把这份温暖传递下去。\n\n## 非技术类书籍\n\n1. [《习惯的力量》](./The-Power-of-Habit.html)\n2. \n\n## 技术类书籍\n\n1. [《Java多线程编程实战指南》（核心篇）](./Java-Multithread-Programming-Guide-In-Action.html)\n2. 《Java并发编程实战》\n3. [《Java并发编程的艺术》](./the-art-of-java-multithread-notes.html)\n","slug":"reading/reading-notes","published":1,"updated":"2019-06-04T01:29:57.498Z","_id":"cjxze3goy001j0cvwm6jvsgrz","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>平时喜欢看一些书，包括技术类书籍，也包括一些文学类和方法论的书籍，曾经也是一个文学爱好者，阴差阳错的走上了开发的不归路，从此<code>文艺小清新</code>的标签就与我无缘了，大家更关注的是我的头发（手动默哀）。</p>\n<p>这里将会记录一些平时阅读书籍时的感悟和收获，阅读一本好书是一件很享受的事情，但这个过程如果不记录和回顾，那就不会有太多的知识沉淀，对自己的影响也会很有限。所以慢慢的，追求的不再是“那本书我看过”，“我今年已经看了XX本书了”，这样浮于表面的满足感，开始关注真正有意义的部分，那就是从阅读中的收获和感悟。</p>\n<p>知识或者感动，就像是一团火，我在这里添柴加薪，把我的火焰留在了这里，希望能为路过的你添加一点温暖，也希望能把这份温暖传递下去。</p>\n<h2 id=\"非技术类书籍\"><a href=\"#非技术类书籍\" class=\"headerlink\" title=\"非技术类书籍\"></a>非技术类书籍</h2><ol>\n<li><a href=\"./The-Power-of-Habit.html\">《习惯的力量》</a></li>\n<li></li>\n</ol>\n<h2 id=\"技术类书籍\"><a href=\"#技术类书籍\" class=\"headerlink\" title=\"技术类书籍\"></a>技术类书籍</h2><ol>\n<li><a href=\"./Java-Multithread-Programming-Guide-In-Action.html\">《Java多线程编程实战指南》（核心篇）</a></li>\n<li>《Java并发编程实战》</li>\n<li><a href=\"./the-art-of-java-multithread-notes.html\">《Java并发编程的艺术》</a></li>\n</ol>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>平时喜欢看一些书，包括技术类书籍，也包括一些文学类和方法论的书籍，曾经也是一个文学爱好者，阴差阳错的走上了开发的不归路，从此<code>文艺小清新</code>的标签就与我无缘了，大家更关注的是我的头发（手动默哀）。</p>\n<p>这里将会记录一些平时阅读书籍时的感悟和收获，阅读一本好书是一件很享受的事情，但这个过程如果不记录和回顾，那就不会有太多的知识沉淀，对自己的影响也会很有限。所以慢慢的，追求的不再是“那本书我看过”，“我今年已经看了XX本书了”，这样浮于表面的满足感，开始关注真正有意义的部分，那就是从阅读中的收获和感悟。</p>\n<p>知识或者感动，就像是一团火，我在这里添柴加薪，把我的火焰留在了这里，希望能为路过的你添加一点温暖，也希望能把这份温暖传递下去。</p>\n<h2 id=\"非技术类书籍\"><a href=\"#非技术类书籍\" class=\"headerlink\" title=\"非技术类书籍\"></a>非技术类书籍</h2><ol>\n<li><a href=\"./The-Power-of-Habit.html\">《习惯的力量》</a></li>\n<li></li>\n</ol>\n<h2 id=\"技术类书籍\"><a href=\"#技术类书籍\" class=\"headerlink\" title=\"技术类书籍\"></a>技术类书籍</h2><ol>\n<li><a href=\"./Java-Multithread-Programming-Guide-In-Action.html\">《Java多线程编程实战指南》（核心篇）</a></li>\n<li>《Java并发编程实战》</li>\n<li><a href=\"./the-art-of-java-multithread-notes.html\">《Java并发编程的艺术》</a></li>\n</ol>\n"},{"title":"《习惯的力量》读后感","date":"2018-12-26T12:39:32.000Z","_content":"\n## 读后感\n\n翻过几页之后，我开始记起来这本书以前其实看过，但并没有留下什么印象，所以也没有太多收获，一来是当时的心境并没有对习惯产生足够的重视，二来也没有关注到里面真正重要的部分，没有对其进行总结和实践，把它遗忘在记忆的某个角落，想来真是遗憾至极。所谓亡羊补牢，为时不晚，现在把它补回来也未尝不可。\n\n作者在书中充分的说明了习惯的必要性和重要性，也说明了习惯存在的科学依据，让我开始用新的视角来审视自己的生活，为很多事情的发生找到了原因，比如为什么总是习惯在七点半左右去健身房，而一旦过了八点，去健身房的几率就会大大降低。又比如为什么不去健身房的晚上更容易选择玩游戏而不是看书。也为之后变成更好的自己找到了确实可行的方法论。\n\n习惯确实是一个有意思的东西，想想自己身上的习惯，大的习惯如健身、阅读、写博客，小习惯如转手腕等等，都是在不需要做过多决策的情况下自发进行的行为，日常生活中的种种选择大多数是由习惯决定的，而并非深思熟虑的结果，比如中午吃什么，晚上吃什么，周末怎么过，正是这些习惯在慢慢塑造着今天的我。\n\n以前看一些奇奇怪怪的鸡汤，说什么性格决定习惯，习惯决定成败之类的。现在看来，多少有些以偏概全，性格的养成大多取决于环境，跟小时候亲密接触的人关系最大，如父母或者老师。而习惯养成的目的是为了适应环境，更好的生活或者生存。两者虽然确实有较强联系，但并直接的因果关系，两者都是环境的产物。\n\n对于大脑而言，习惯本身没有好坏之分，都是一视同仁。一旦养成习惯，便会像刻入磁盘一样不可复原。习惯不会消失，但是却可以替代。习惯的三要素：暗示、惯常行为、奖赏。认识到这一点之后，对于习惯的敏感度便会提高，刻意发掘便能发现隐藏其中的暗示和奖赏，要想改变惯常行为，便需要找好替代品。比如玩游戏也许并不只是为了放松，也许更多的是为了社交，发觉这一点之后，多交朋友，与朋友定期的聚会也许可以帮助你戒除游戏。\n\n正如书中所言，我们并非要一次性调整好所有习惯，让生活直接进入自己的理想状态中，这样通常也是不现实的，所以只需要找到并养成关键习惯，便能牵一发而动全身，让其他习惯也跟着一起养成。比如说早起和健身，这两个习惯能让我更加自律，也能让我在白天有更多的精力去应付繁琐的工作，意志力也得到了锻炼，自律和意志力是养成习惯的两大重要要素，这能让其它习惯更轻松的养成。\n\n这本书让我受益匪浅，对自己有了更好的认知，对自己的生活又多了几分掌控感。未来的路上，会继续养成更多的好习惯，朝着自己的目标笃定前行。\n\n最后，推荐一款软件，habiticat，用游戏化的方式来进行习惯培养，还可以和朋友一起组队，比较有乐趣性，相信你一定会喜欢，有网页版，也有手机app，但不幸的是需要翻墙才能使用。（可以自建梯子，或者使用别人的机场）","source":"_posts/reading/the-power-of-habit.md","raw":"---\ntitle: 《习惯的力量》读后感\ntags: 读书笔记\ncategories: 阅读\ndate: 2018-12-26 20:39:32\n---\n\n## 读后感\n\n翻过几页之后，我开始记起来这本书以前其实看过，但并没有留下什么印象，所以也没有太多收获，一来是当时的心境并没有对习惯产生足够的重视，二来也没有关注到里面真正重要的部分，没有对其进行总结和实践，把它遗忘在记忆的某个角落，想来真是遗憾至极。所谓亡羊补牢，为时不晚，现在把它补回来也未尝不可。\n\n作者在书中充分的说明了习惯的必要性和重要性，也说明了习惯存在的科学依据，让我开始用新的视角来审视自己的生活，为很多事情的发生找到了原因，比如为什么总是习惯在七点半左右去健身房，而一旦过了八点，去健身房的几率就会大大降低。又比如为什么不去健身房的晚上更容易选择玩游戏而不是看书。也为之后变成更好的自己找到了确实可行的方法论。\n\n习惯确实是一个有意思的东西，想想自己身上的习惯，大的习惯如健身、阅读、写博客，小习惯如转手腕等等，都是在不需要做过多决策的情况下自发进行的行为，日常生活中的种种选择大多数是由习惯决定的，而并非深思熟虑的结果，比如中午吃什么，晚上吃什么，周末怎么过，正是这些习惯在慢慢塑造着今天的我。\n\n以前看一些奇奇怪怪的鸡汤，说什么性格决定习惯，习惯决定成败之类的。现在看来，多少有些以偏概全，性格的养成大多取决于环境，跟小时候亲密接触的人关系最大，如父母或者老师。而习惯养成的目的是为了适应环境，更好的生活或者生存。两者虽然确实有较强联系，但并直接的因果关系，两者都是环境的产物。\n\n对于大脑而言，习惯本身没有好坏之分，都是一视同仁。一旦养成习惯，便会像刻入磁盘一样不可复原。习惯不会消失，但是却可以替代。习惯的三要素：暗示、惯常行为、奖赏。认识到这一点之后，对于习惯的敏感度便会提高，刻意发掘便能发现隐藏其中的暗示和奖赏，要想改变惯常行为，便需要找好替代品。比如玩游戏也许并不只是为了放松，也许更多的是为了社交，发觉这一点之后，多交朋友，与朋友定期的聚会也许可以帮助你戒除游戏。\n\n正如书中所言，我们并非要一次性调整好所有习惯，让生活直接进入自己的理想状态中，这样通常也是不现实的，所以只需要找到并养成关键习惯，便能牵一发而动全身，让其他习惯也跟着一起养成。比如说早起和健身，这两个习惯能让我更加自律，也能让我在白天有更多的精力去应付繁琐的工作，意志力也得到了锻炼，自律和意志力是养成习惯的两大重要要素，这能让其它习惯更轻松的养成。\n\n这本书让我受益匪浅，对自己有了更好的认知，对自己的生活又多了几分掌控感。未来的路上，会继续养成更多的好习惯，朝着自己的目标笃定前行。\n\n最后，推荐一款软件，habiticat，用游戏化的方式来进行习惯培养，还可以和朋友一起组队，比较有乐趣性，相信你一定会喜欢，有网页版，也有手机app，但不幸的是需要翻墙才能使用。（可以自建梯子，或者使用别人的机场）","slug":"reading/the-power-of-habit","published":1,"updated":"2019-06-04T01:29:57.588Z","_id":"cjxze3gp1001m0cvwfjpg2c8v","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"读后感\"><a href=\"#读后感\" class=\"headerlink\" title=\"读后感\"></a>读后感</h2><p>翻过几页之后，我开始记起来这本书以前其实看过，但并没有留下什么印象，所以也没有太多收获，一来是当时的心境并没有对习惯产生足够的重视，二来也没有关注到里面真正重要的部分，没有对其进行总结和实践，把它遗忘在记忆的某个角落，想来真是遗憾至极。所谓亡羊补牢，为时不晚，现在把它补回来也未尝不可。</p>\n<p>作者在书中充分的说明了习惯的必要性和重要性，也说明了习惯存在的科学依据，让我开始用新的视角来审视自己的生活，为很多事情的发生找到了原因，比如为什么总是习惯在七点半左右去健身房，而一旦过了八点，去健身房的几率就会大大降低。又比如为什么不去健身房的晚上更容易选择玩游戏而不是看书。也为之后变成更好的自己找到了确实可行的方法论。</p>\n<p>习惯确实是一个有意思的东西，想想自己身上的习惯，大的习惯如健身、阅读、写博客，小习惯如转手腕等等，都是在不需要做过多决策的情况下自发进行的行为，日常生活中的种种选择大多数是由习惯决定的，而并非深思熟虑的结果，比如中午吃什么，晚上吃什么，周末怎么过，正是这些习惯在慢慢塑造着今天的我。</p>\n<p>以前看一些奇奇怪怪的鸡汤，说什么性格决定习惯，习惯决定成败之类的。现在看来，多少有些以偏概全，性格的养成大多取决于环境，跟小时候亲密接触的人关系最大，如父母或者老师。而习惯养成的目的是为了适应环境，更好的生活或者生存。两者虽然确实有较强联系，但并直接的因果关系，两者都是环境的产物。</p>\n<p>对于大脑而言，习惯本身没有好坏之分，都是一视同仁。一旦养成习惯，便会像刻入磁盘一样不可复原。习惯不会消失，但是却可以替代。习惯的三要素：暗示、惯常行为、奖赏。认识到这一点之后，对于习惯的敏感度便会提高，刻意发掘便能发现隐藏其中的暗示和奖赏，要想改变惯常行为，便需要找好替代品。比如玩游戏也许并不只是为了放松，也许更多的是为了社交，发觉这一点之后，多交朋友，与朋友定期的聚会也许可以帮助你戒除游戏。</p>\n<p>正如书中所言，我们并非要一次性调整好所有习惯，让生活直接进入自己的理想状态中，这样通常也是不现实的，所以只需要找到并养成关键习惯，便能牵一发而动全身，让其他习惯也跟着一起养成。比如说早起和健身，这两个习惯能让我更加自律，也能让我在白天有更多的精力去应付繁琐的工作，意志力也得到了锻炼，自律和意志力是养成习惯的两大重要要素，这能让其它习惯更轻松的养成。</p>\n<p>这本书让我受益匪浅，对自己有了更好的认知，对自己的生活又多了几分掌控感。未来的路上，会继续养成更多的好习惯，朝着自己的目标笃定前行。</p>\n<p>最后，推荐一款软件，habiticat，用游戏化的方式来进行习惯培养，还可以和朋友一起组队，比较有乐趣性，相信你一定会喜欢，有网页版，也有手机app，但不幸的是需要翻墙才能使用。（可以自建梯子，或者使用别人的机场）</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"读后感\"><a href=\"#读后感\" class=\"headerlink\" title=\"读后感\"></a>读后感</h2><p>翻过几页之后，我开始记起来这本书以前其实看过，但并没有留下什么印象，所以也没有太多收获，一来是当时的心境并没有对习惯产生足够的重视，二来也没有关注到里面真正重要的部分，没有对其进行总结和实践，把它遗忘在记忆的某个角落，想来真是遗憾至极。所谓亡羊补牢，为时不晚，现在把它补回来也未尝不可。</p>\n<p>作者在书中充分的说明了习惯的必要性和重要性，也说明了习惯存在的科学依据，让我开始用新的视角来审视自己的生活，为很多事情的发生找到了原因，比如为什么总是习惯在七点半左右去健身房，而一旦过了八点，去健身房的几率就会大大降低。又比如为什么不去健身房的晚上更容易选择玩游戏而不是看书。也为之后变成更好的自己找到了确实可行的方法论。</p>\n<p>习惯确实是一个有意思的东西，想想自己身上的习惯，大的习惯如健身、阅读、写博客，小习惯如转手腕等等，都是在不需要做过多决策的情况下自发进行的行为，日常生活中的种种选择大多数是由习惯决定的，而并非深思熟虑的结果，比如中午吃什么，晚上吃什么，周末怎么过，正是这些习惯在慢慢塑造着今天的我。</p>\n<p>以前看一些奇奇怪怪的鸡汤，说什么性格决定习惯，习惯决定成败之类的。现在看来，多少有些以偏概全，性格的养成大多取决于环境，跟小时候亲密接触的人关系最大，如父母或者老师。而习惯养成的目的是为了适应环境，更好的生活或者生存。两者虽然确实有较强联系，但并直接的因果关系，两者都是环境的产物。</p>\n<p>对于大脑而言，习惯本身没有好坏之分，都是一视同仁。一旦养成习惯，便会像刻入磁盘一样不可复原。习惯不会消失，但是却可以替代。习惯的三要素：暗示、惯常行为、奖赏。认识到这一点之后，对于习惯的敏感度便会提高，刻意发掘便能发现隐藏其中的暗示和奖赏，要想改变惯常行为，便需要找好替代品。比如玩游戏也许并不只是为了放松，也许更多的是为了社交，发觉这一点之后，多交朋友，与朋友定期的聚会也许可以帮助你戒除游戏。</p>\n<p>正如书中所言，我们并非要一次性调整好所有习惯，让生活直接进入自己的理想状态中，这样通常也是不现实的，所以只需要找到并养成关键习惯，便能牵一发而动全身，让其他习惯也跟着一起养成。比如说早起和健身，这两个习惯能让我更加自律，也能让我在白天有更多的精力去应付繁琐的工作，意志力也得到了锻炼，自律和意志力是养成习惯的两大重要要素，这能让其它习惯更轻松的养成。</p>\n<p>这本书让我受益匪浅，对自己有了更好的认知，对自己的生活又多了几分掌控感。未来的路上，会继续养成更多的好习惯，朝着自己的目标笃定前行。</p>\n<p>最后，推荐一款软件，habiticat，用游戏化的方式来进行习惯培养，还可以和朋友一起组队，比较有乐趣性，相信你一定会喜欢，有网页版，也有手机app，但不幸的是需要翻墙才能使用。（可以自建梯子，或者使用别人的机场）</p>\n"},{"title":"《习惯的力量》- 摘要","date":"2018-12-26T11:16:09.000Z","_content":"## 摘要\n\n- 科学家说，习惯之所以出现，是因为大脑一直在寻找可以省力的方式。如果让大脑自由发挥，那么大脑就会让几乎所有的惯常行为活动编程习惯，因为习惯能让大脑得到更多的休息。\n- 大脑中的这个过程是一个由三步组成的回路。第一步，存在着一个暗示，能让大脑进入某种自动行为模式，并决定使用哪种习惯。第二步，存在一个惯常行为，这可以是身体、思维或者感情方面的。第三步则是奖赏，能让你的大脑辨别出是否应该记下这个回路，以备将来之用。\n- 问题是你的大脑无法分别好习惯和坏习惯，所以，如果你有一个好习惯，那么这个习惯会一直蛰伏在你的大脑内，等待正确的暗示和奖赏的出现。\n- 建立习惯的两条基本规律：\n  - 第一，找出一种简单又明显的暗示\n  - 第二，清楚地说明有哪些奖赏\n- 习惯就是这样产生的：把暗示、惯常行为和奖赏拼在一起，然后培养一种渴求来驱动这一回路。吸烟就是这样。烟民看到暗示，比如一包万宝路，那么烟民的大脑就会开始预期尼古丁的味道。\n- 暗示加上奖赏本身并不足以让新习惯长期持续。只有当你的大脑开始预期奖赏，渴求内啡肽的分泌或成就感时，你才会自觉地在每天早上系好跑鞋鞋带。而暗示除了能够触发惯常行为，还必须能够触发人对即将到来的奖赏的渴求。\n- 要改变习惯，你必须留住旧习惯回路中的暗示，提供旧习惯回路中的奖赏，但要插入一个新的惯常行为。\n- 这就是黄金法则。如果你用同样的暗示，提供同样的奖赏，你就可以换掉惯常行为，改变自己的习惯。如果暗示和奖赏不变，几乎所有的习惯都是可以被改变的。\n- 研究人员发现，起作用的并不是上帝，而是信仰本身。一旦人们学会信仰某种东西，这种信仰就会扩展到生活的其他方面，直到他们开始相信自己能改变。信仰是将改造过的习惯回路变成永久性行为的要素。\n- 信仰很重要。你不一定要信仰上帝，但你必须相信事情会好转。\n- 可惜，并没有一套对每个人都有效的方法。我们知道，习惯是不能被消除的，而只能被代替。当使用改变习惯的黄金法则时，习惯最具可塑性：如果我们保持一样的暗示和奖赏，就能植入一种新的惯常行为。但这还不够，为了保持这个习惯，人们还得相信改变是可能的。而大多数时候，只有在团体的助力下，才能形成信仰。\n- 一些习惯比起其他习惯在重塑商业和生活方式上更有影响力，它们就是“核心习惯”，影响着人们的工作、饮食、玩乐、消费和沟通方式。核心习惯能启动一个进程，久而久之将改变一切。\n- 核心习惯说明成功并不需要做对每一件事情，而是要辨别出一些重要的优先因素，并将其变成有力的杠杆。\n- 最重要的习惯是那些自身变化后，会驱动和重塑其他行为模式的习惯。\n- 意志力不是一种技能，而是一种力量，就如同你手臂和大腿中的肌肉的力量，用力过猛会感到疲累，肌肉剩余的力量就不足以供给其他活动。\n- 当你学会强迫自己参与体育锻炼，或者开始做家庭作业，只吃沙拉不吃汉堡的时候，你的思维正在改变。当学会控制自己的冲动时，人们就在进步。他们将学会如何在诱惑面前分散注意力。而且一旦你形成了意志力锻炼的习惯，你的大脑就会驾轻就熟地帮助你专注于你的目标。\n- 当你学会强迫自己练琴一小时或者长跑15圈的时候，你就已经开始培养自我约束的能力了，一个能跟着球跑10分钟的5岁幼童长大后，一定是一个会按时做功课的六年级学生。\n- 当消费者遭遇到人生的重大事件时，他们的消费习惯更容易发生改变。例如，当一个人结婚的时候，他可能会开始购买一种新的咖啡。当他们迁居到新的住所后，可能倾向于购买不同种类的麦片。当他们离婚的时候，很可能会开始购买一种不同牌子的啤酒。\n- 那么，对于大多数人来说，生活中最大的变化是什么呢？什么样的变化会带来最强的干扰，领消费者最容易被市场营销者左右呢？答案就是生孩子。对于大多数的客户来说，没有什么事情比新生儿的到来使生活产出更大的改变了。因此，与成年人生活的其他任何阶段相比，初为父母者的购物习惯都更为灵活易变。\n- 改变习惯的方法：\n  - 找出惯常行为\n  - 用各种奖赏进行实验\n  - 将暗示隔离出来\n  - 制定计划\n- 几乎所有的习惯性暗示都可以归为以下五大类中的一类：\n  - 地点\n  - 时间\n  - 情绪状态\n  - 其他人\n  - 之前紧挨着的动作\n","source":"_posts/reading/the-power-of-habit-digest.md","raw":"---\ntitle: 《习惯的力量》- 摘要\ntags: 摘要\ncategories: 阅读\ndate: 2018-12-26 19:16:09\n---\n## 摘要\n\n- 科学家说，习惯之所以出现，是因为大脑一直在寻找可以省力的方式。如果让大脑自由发挥，那么大脑就会让几乎所有的惯常行为活动编程习惯，因为习惯能让大脑得到更多的休息。\n- 大脑中的这个过程是一个由三步组成的回路。第一步，存在着一个暗示，能让大脑进入某种自动行为模式，并决定使用哪种习惯。第二步，存在一个惯常行为，这可以是身体、思维或者感情方面的。第三步则是奖赏，能让你的大脑辨别出是否应该记下这个回路，以备将来之用。\n- 问题是你的大脑无法分别好习惯和坏习惯，所以，如果你有一个好习惯，那么这个习惯会一直蛰伏在你的大脑内，等待正确的暗示和奖赏的出现。\n- 建立习惯的两条基本规律：\n  - 第一，找出一种简单又明显的暗示\n  - 第二，清楚地说明有哪些奖赏\n- 习惯就是这样产生的：把暗示、惯常行为和奖赏拼在一起，然后培养一种渴求来驱动这一回路。吸烟就是这样。烟民看到暗示，比如一包万宝路，那么烟民的大脑就会开始预期尼古丁的味道。\n- 暗示加上奖赏本身并不足以让新习惯长期持续。只有当你的大脑开始预期奖赏，渴求内啡肽的分泌或成就感时，你才会自觉地在每天早上系好跑鞋鞋带。而暗示除了能够触发惯常行为，还必须能够触发人对即将到来的奖赏的渴求。\n- 要改变习惯，你必须留住旧习惯回路中的暗示，提供旧习惯回路中的奖赏，但要插入一个新的惯常行为。\n- 这就是黄金法则。如果你用同样的暗示，提供同样的奖赏，你就可以换掉惯常行为，改变自己的习惯。如果暗示和奖赏不变，几乎所有的习惯都是可以被改变的。\n- 研究人员发现，起作用的并不是上帝，而是信仰本身。一旦人们学会信仰某种东西，这种信仰就会扩展到生活的其他方面，直到他们开始相信自己能改变。信仰是将改造过的习惯回路变成永久性行为的要素。\n- 信仰很重要。你不一定要信仰上帝，但你必须相信事情会好转。\n- 可惜，并没有一套对每个人都有效的方法。我们知道，习惯是不能被消除的，而只能被代替。当使用改变习惯的黄金法则时，习惯最具可塑性：如果我们保持一样的暗示和奖赏，就能植入一种新的惯常行为。但这还不够，为了保持这个习惯，人们还得相信改变是可能的。而大多数时候，只有在团体的助力下，才能形成信仰。\n- 一些习惯比起其他习惯在重塑商业和生活方式上更有影响力，它们就是“核心习惯”，影响着人们的工作、饮食、玩乐、消费和沟通方式。核心习惯能启动一个进程，久而久之将改变一切。\n- 核心习惯说明成功并不需要做对每一件事情，而是要辨别出一些重要的优先因素，并将其变成有力的杠杆。\n- 最重要的习惯是那些自身变化后，会驱动和重塑其他行为模式的习惯。\n- 意志力不是一种技能，而是一种力量，就如同你手臂和大腿中的肌肉的力量，用力过猛会感到疲累，肌肉剩余的力量就不足以供给其他活动。\n- 当你学会强迫自己参与体育锻炼，或者开始做家庭作业，只吃沙拉不吃汉堡的时候，你的思维正在改变。当学会控制自己的冲动时，人们就在进步。他们将学会如何在诱惑面前分散注意力。而且一旦你形成了意志力锻炼的习惯，你的大脑就会驾轻就熟地帮助你专注于你的目标。\n- 当你学会强迫自己练琴一小时或者长跑15圈的时候，你就已经开始培养自我约束的能力了，一个能跟着球跑10分钟的5岁幼童长大后，一定是一个会按时做功课的六年级学生。\n- 当消费者遭遇到人生的重大事件时，他们的消费习惯更容易发生改变。例如，当一个人结婚的时候，他可能会开始购买一种新的咖啡。当他们迁居到新的住所后，可能倾向于购买不同种类的麦片。当他们离婚的时候，很可能会开始购买一种不同牌子的啤酒。\n- 那么，对于大多数人来说，生活中最大的变化是什么呢？什么样的变化会带来最强的干扰，领消费者最容易被市场营销者左右呢？答案就是生孩子。对于大多数的客户来说，没有什么事情比新生儿的到来使生活产出更大的改变了。因此，与成年人生活的其他任何阶段相比，初为父母者的购物习惯都更为灵活易变。\n- 改变习惯的方法：\n  - 找出惯常行为\n  - 用各种奖赏进行实验\n  - 将暗示隔离出来\n  - 制定计划\n- 几乎所有的习惯性暗示都可以归为以下五大类中的一类：\n  - 地点\n  - 时间\n  - 情绪状态\n  - 其他人\n  - 之前紧挨着的动作\n","slug":"reading/the-power-of-habit-digest","published":1,"updated":"2019-06-04T01:29:57.588Z","_id":"cjxze3gp3001o0cvwij3yvuhz","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><ul>\n<li>科学家说，习惯之所以出现，是因为大脑一直在寻找可以省力的方式。如果让大脑自由发挥，那么大脑就会让几乎所有的惯常行为活动编程习惯，因为习惯能让大脑得到更多的休息。</li>\n<li>大脑中的这个过程是一个由三步组成的回路。第一步，存在着一个暗示，能让大脑进入某种自动行为模式，并决定使用哪种习惯。第二步，存在一个惯常行为，这可以是身体、思维或者感情方面的。第三步则是奖赏，能让你的大脑辨别出是否应该记下这个回路，以备将来之用。</li>\n<li>问题是你的大脑无法分别好习惯和坏习惯，所以，如果你有一个好习惯，那么这个习惯会一直蛰伏在你的大脑内，等待正确的暗示和奖赏的出现。</li>\n<li>建立习惯的两条基本规律：<ul>\n<li>第一，找出一种简单又明显的暗示</li>\n<li>第二，清楚地说明有哪些奖赏</li>\n</ul>\n</li>\n<li>习惯就是这样产生的：把暗示、惯常行为和奖赏拼在一起，然后培养一种渴求来驱动这一回路。吸烟就是这样。烟民看到暗示，比如一包万宝路，那么烟民的大脑就会开始预期尼古丁的味道。</li>\n<li>暗示加上奖赏本身并不足以让新习惯长期持续。只有当你的大脑开始预期奖赏，渴求内啡肽的分泌或成就感时，你才会自觉地在每天早上系好跑鞋鞋带。而暗示除了能够触发惯常行为，还必须能够触发人对即将到来的奖赏的渴求。</li>\n<li>要改变习惯，你必须留住旧习惯回路中的暗示，提供旧习惯回路中的奖赏，但要插入一个新的惯常行为。</li>\n<li>这就是黄金法则。如果你用同样的暗示，提供同样的奖赏，你就可以换掉惯常行为，改变自己的习惯。如果暗示和奖赏不变，几乎所有的习惯都是可以被改变的。</li>\n<li>研究人员发现，起作用的并不是上帝，而是信仰本身。一旦人们学会信仰某种东西，这种信仰就会扩展到生活的其他方面，直到他们开始相信自己能改变。信仰是将改造过的习惯回路变成永久性行为的要素。</li>\n<li>信仰很重要。你不一定要信仰上帝，但你必须相信事情会好转。</li>\n<li>可惜，并没有一套对每个人都有效的方法。我们知道，习惯是不能被消除的，而只能被代替。当使用改变习惯的黄金法则时，习惯最具可塑性：如果我们保持一样的暗示和奖赏，就能植入一种新的惯常行为。但这还不够，为了保持这个习惯，人们还得相信改变是可能的。而大多数时候，只有在团体的助力下，才能形成信仰。</li>\n<li>一些习惯比起其他习惯在重塑商业和生活方式上更有影响力，它们就是“核心习惯”，影响着人们的工作、饮食、玩乐、消费和沟通方式。核心习惯能启动一个进程，久而久之将改变一切。</li>\n<li>核心习惯说明成功并不需要做对每一件事情，而是要辨别出一些重要的优先因素，并将其变成有力的杠杆。</li>\n<li>最重要的习惯是那些自身变化后，会驱动和重塑其他行为模式的习惯。</li>\n<li>意志力不是一种技能，而是一种力量，就如同你手臂和大腿中的肌肉的力量，用力过猛会感到疲累，肌肉剩余的力量就不足以供给其他活动。</li>\n<li>当你学会强迫自己参与体育锻炼，或者开始做家庭作业，只吃沙拉不吃汉堡的时候，你的思维正在改变。当学会控制自己的冲动时，人们就在进步。他们将学会如何在诱惑面前分散注意力。而且一旦你形成了意志力锻炼的习惯，你的大脑就会驾轻就熟地帮助你专注于你的目标。</li>\n<li>当你学会强迫自己练琴一小时或者长跑15圈的时候，你就已经开始培养自我约束的能力了，一个能跟着球跑10分钟的5岁幼童长大后，一定是一个会按时做功课的六年级学生。</li>\n<li>当消费者遭遇到人生的重大事件时，他们的消费习惯更容易发生改变。例如，当一个人结婚的时候，他可能会开始购买一种新的咖啡。当他们迁居到新的住所后，可能倾向于购买不同种类的麦片。当他们离婚的时候，很可能会开始购买一种不同牌子的啤酒。</li>\n<li>那么，对于大多数人来说，生活中最大的变化是什么呢？什么样的变化会带来最强的干扰，领消费者最容易被市场营销者左右呢？答案就是生孩子。对于大多数的客户来说，没有什么事情比新生儿的到来使生活产出更大的改变了。因此，与成年人生活的其他任何阶段相比，初为父母者的购物习惯都更为灵活易变。</li>\n<li>改变习惯的方法：<ul>\n<li>找出惯常行为</li>\n<li>用各种奖赏进行实验</li>\n<li>将暗示隔离出来</li>\n<li>制定计划</li>\n</ul>\n</li>\n<li>几乎所有的习惯性暗示都可以归为以下五大类中的一类：<ul>\n<li>地点</li>\n<li>时间</li>\n<li>情绪状态</li>\n<li>其他人</li>\n<li>之前紧挨着的动作</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><ul>\n<li>科学家说，习惯之所以出现，是因为大脑一直在寻找可以省力的方式。如果让大脑自由发挥，那么大脑就会让几乎所有的惯常行为活动编程习惯，因为习惯能让大脑得到更多的休息。</li>\n<li>大脑中的这个过程是一个由三步组成的回路。第一步，存在着一个暗示，能让大脑进入某种自动行为模式，并决定使用哪种习惯。第二步，存在一个惯常行为，这可以是身体、思维或者感情方面的。第三步则是奖赏，能让你的大脑辨别出是否应该记下这个回路，以备将来之用。</li>\n<li>问题是你的大脑无法分别好习惯和坏习惯，所以，如果你有一个好习惯，那么这个习惯会一直蛰伏在你的大脑内，等待正确的暗示和奖赏的出现。</li>\n<li>建立习惯的两条基本规律：<ul>\n<li>第一，找出一种简单又明显的暗示</li>\n<li>第二，清楚地说明有哪些奖赏</li>\n</ul>\n</li>\n<li>习惯就是这样产生的：把暗示、惯常行为和奖赏拼在一起，然后培养一种渴求来驱动这一回路。吸烟就是这样。烟民看到暗示，比如一包万宝路，那么烟民的大脑就会开始预期尼古丁的味道。</li>\n<li>暗示加上奖赏本身并不足以让新习惯长期持续。只有当你的大脑开始预期奖赏，渴求内啡肽的分泌或成就感时，你才会自觉地在每天早上系好跑鞋鞋带。而暗示除了能够触发惯常行为，还必须能够触发人对即将到来的奖赏的渴求。</li>\n<li>要改变习惯，你必须留住旧习惯回路中的暗示，提供旧习惯回路中的奖赏，但要插入一个新的惯常行为。</li>\n<li>这就是黄金法则。如果你用同样的暗示，提供同样的奖赏，你就可以换掉惯常行为，改变自己的习惯。如果暗示和奖赏不变，几乎所有的习惯都是可以被改变的。</li>\n<li>研究人员发现，起作用的并不是上帝，而是信仰本身。一旦人们学会信仰某种东西，这种信仰就会扩展到生活的其他方面，直到他们开始相信自己能改变。信仰是将改造过的习惯回路变成永久性行为的要素。</li>\n<li>信仰很重要。你不一定要信仰上帝，但你必须相信事情会好转。</li>\n<li>可惜，并没有一套对每个人都有效的方法。我们知道，习惯是不能被消除的，而只能被代替。当使用改变习惯的黄金法则时，习惯最具可塑性：如果我们保持一样的暗示和奖赏，就能植入一种新的惯常行为。但这还不够，为了保持这个习惯，人们还得相信改变是可能的。而大多数时候，只有在团体的助力下，才能形成信仰。</li>\n<li>一些习惯比起其他习惯在重塑商业和生活方式上更有影响力，它们就是“核心习惯”，影响着人们的工作、饮食、玩乐、消费和沟通方式。核心习惯能启动一个进程，久而久之将改变一切。</li>\n<li>核心习惯说明成功并不需要做对每一件事情，而是要辨别出一些重要的优先因素，并将其变成有力的杠杆。</li>\n<li>最重要的习惯是那些自身变化后，会驱动和重塑其他行为模式的习惯。</li>\n<li>意志力不是一种技能，而是一种力量，就如同你手臂和大腿中的肌肉的力量，用力过猛会感到疲累，肌肉剩余的力量就不足以供给其他活动。</li>\n<li>当你学会强迫自己参与体育锻炼，或者开始做家庭作业，只吃沙拉不吃汉堡的时候，你的思维正在改变。当学会控制自己的冲动时，人们就在进步。他们将学会如何在诱惑面前分散注意力。而且一旦你形成了意志力锻炼的习惯，你的大脑就会驾轻就熟地帮助你专注于你的目标。</li>\n<li>当你学会强迫自己练琴一小时或者长跑15圈的时候，你就已经开始培养自我约束的能力了，一个能跟着球跑10分钟的5岁幼童长大后，一定是一个会按时做功课的六年级学生。</li>\n<li>当消费者遭遇到人生的重大事件时，他们的消费习惯更容易发生改变。例如，当一个人结婚的时候，他可能会开始购买一种新的咖啡。当他们迁居到新的住所后，可能倾向于购买不同种类的麦片。当他们离婚的时候，很可能会开始购买一种不同牌子的啤酒。</li>\n<li>那么，对于大多数人来说，生活中最大的变化是什么呢？什么样的变化会带来最强的干扰，领消费者最容易被市场营销者左右呢？答案就是生孩子。对于大多数的客户来说，没有什么事情比新生儿的到来使生活产出更大的改变了。因此，与成年人生活的其他任何阶段相比，初为父母者的购物习惯都更为灵活易变。</li>\n<li>改变习惯的方法：<ul>\n<li>找出惯常行为</li>\n<li>用各种奖赏进行实验</li>\n<li>将暗示隔离出来</li>\n<li>制定计划</li>\n</ul>\n</li>\n<li>几乎所有的习惯性暗示都可以归为以下五大类中的一类：<ul>\n<li>地点</li>\n<li>时间</li>\n<li>情绪状态</li>\n<li>其他人</li>\n<li>之前紧挨着的动作</li>\n</ul>\n</li>\n</ul>\n"},{"title":"在centos7 上部署 vuepress","date":"2018-12-28T16:01:00.000Z","_content":"\n## 前言\n\n> vuepress是一款十分优秀简洁的文档生成器，可以根据目录下的md文档自动生成对应的html文件，界面简洁大方。每一个由 VuePress 生成的页面都带有预渲染好的 HTML，也因此具有非常好的加载性能和搜索引擎优化（SEO）。本文将介绍如何在CentOS7环境下部署vuepress。\n\n官方主页：https://vuepress.vuejs.org/zh/  \n\n官方文档：https://vuepress.vuejs.org/zh/guide/（官方文档就是用Vuepress搭建的，包括上面的主页）\n\n项目地址：https://github.com/vuejs/vuepress\n\n## 一、安装nodejs\n\n``` bash\ncurl -sL https://rpm.nodesource.com/setup_8.x | sudo bash -\nyum install nodejs\n```\n\n## 二、安装vuepress\n\n``` bash\nnpm install -g vuepress\n```\n\n## 三、创建工作目录\n\n``` bash\nmkdir project\ncd project\nmkdir docs\n```\n\n## 四、初始化前\n\n``` bash\nnpm init -y\nvim package.json\n```\n\n编辑成如下内容，这里其实是设置命令别名。\n\n```javascript\n{\n    \"scripts\": {\n    \t\"docs:dev\": \"vuepress dev docs\",\n    \t\"docs:build\": \"vuepress build docs\"\n    }\n}\n```\n\n创建.vuepress目录。\n\n``` bash\nmkdir .vuepress\ncd .vuepress\n```\n\n创建config.js，这是vuepress的全局配置文件，大部分属性在这里设置。\n\n``` bash\nmkdir public\nvim config.js\n```\n\n修改成如下内容，对应内容可以自行修改。\n\n``` bash\nmodule.exports = {\n\ttitle: '清风wiki',\n\tdescription: '我在等风，也在等你',\n\t// 相对于git仓库的路径 如全路径为：https://mfrank2016.github.io/wikibook/ 则设置为'/wikibook/'\n\tbase: '/wikibook/',\n\thost: '0.0.0.0',\n\t// 运行端口\n\tport: 8081,\n\n\tthemeConfig: {\n\t\t//gitc 仓库地址\n    \trepo: 'https://github.com/MFrank2016/wikibook',\n    \t// 如果你的文档不在仓库的根部\n   \t\tdocsDir: 'docs',\n    \t// 可选，默认为 master\n    \tdocsBranch: 'master',\n    \t// 默认为 true，设置为 false 来禁用\n    \teditLinks: true,\n    \t//导航栏\n    \tnav: [\n      \t\t{ text: 'Home', link: '/' },\n      \t\t{ text: 'Guide', link: '/guide/' },\n      \t\t{ text: 'External', link: 'https://google.com' },\n      \t\t{ text: 'Languages',\n      \t\titems: [\n      \t\t{ text: 'Chinese', link: '/language/chinese' },\n      \t\t{ text: 'Japanese', link: '/language/japanese' }\n      \t\t]}],\n      \tsidebar: [{\n        \ttitle: 'Group 1',\n        \tcollapsable: false,\n        \tchildren: [\n          \t\t'/'\n        \t\t]\n      \t\t},\n      \t\t{\n        \ttitle: 'Group 2',\n        \tchildren: [\n            \t'/'\n        \t\t]\n      \t\t}\n    \t]\n  \t},  \n    //搜索\n    search: true,\n    searchMaxSuggestions: 10,\n    lastUpdated: 'Last Updated', // string | boolean\n}\n```\n\n整体结构\n\n``` bash\nproject\n├─── docs\n│ ├── README.md\n│ ├── .vuepress\n│   ├── config.js\n│   └── public\n│     └── hero.png\n│ └── guide\n│   └── README.md \n└── package.json\n```\n\n## 五、初始化\n\n在docs目录下创建README.md\n\n```bash\n---\nhome: true\nheroImage: /hero.png\nactionText: 点击阅读\nactionLink: /guide/\nfooter: MIT Licensed | Copyright © 2018-present Frank\n---\n```\n\n然后回到project目录\n\n```bash\n# 开启调试模式，运行服务，此时打开 http://localhost:8081 (这里即上面设置的端口) 即能看到最简单的页面\nvuepress dev\n\n# 构建，此时会将md文档转化成html文件存储在docs/.vuepress/dist目录\nvuepress build\n```\n\n## 六、调试部署\n\n此时静态网页已经生成在了**docs/.vuepress/dist**目录下，可以先开启调试模式，然后使用ftp等软件先对服务器进行远程连接，修改docs下面的文档，每次修改上传后，会自动重新编译，当然整个过程需要一两分钟时间，这取决于服务器的性能。调整到合适的程度即可将其移动到nginx或者apache相应目录下即可。\n","source":"_posts/ops/deploy-vuepress-on-centos7.md","raw":"---\ntitle: 在centos7 上部署 vuepress\ntags: \n - 环境搭建\ncategories: 编程\ndate: 2018-12-29 00:01:00\n---\n\n## 前言\n\n> vuepress是一款十分优秀简洁的文档生成器，可以根据目录下的md文档自动生成对应的html文件，界面简洁大方。每一个由 VuePress 生成的页面都带有预渲染好的 HTML，也因此具有非常好的加载性能和搜索引擎优化（SEO）。本文将介绍如何在CentOS7环境下部署vuepress。\n\n官方主页：https://vuepress.vuejs.org/zh/  \n\n官方文档：https://vuepress.vuejs.org/zh/guide/（官方文档就是用Vuepress搭建的，包括上面的主页）\n\n项目地址：https://github.com/vuejs/vuepress\n\n## 一、安装nodejs\n\n``` bash\ncurl -sL https://rpm.nodesource.com/setup_8.x | sudo bash -\nyum install nodejs\n```\n\n## 二、安装vuepress\n\n``` bash\nnpm install -g vuepress\n```\n\n## 三、创建工作目录\n\n``` bash\nmkdir project\ncd project\nmkdir docs\n```\n\n## 四、初始化前\n\n``` bash\nnpm init -y\nvim package.json\n```\n\n编辑成如下内容，这里其实是设置命令别名。\n\n```javascript\n{\n    \"scripts\": {\n    \t\"docs:dev\": \"vuepress dev docs\",\n    \t\"docs:build\": \"vuepress build docs\"\n    }\n}\n```\n\n创建.vuepress目录。\n\n``` bash\nmkdir .vuepress\ncd .vuepress\n```\n\n创建config.js，这是vuepress的全局配置文件，大部分属性在这里设置。\n\n``` bash\nmkdir public\nvim config.js\n```\n\n修改成如下内容，对应内容可以自行修改。\n\n``` bash\nmodule.exports = {\n\ttitle: '清风wiki',\n\tdescription: '我在等风，也在等你',\n\t// 相对于git仓库的路径 如全路径为：https://mfrank2016.github.io/wikibook/ 则设置为'/wikibook/'\n\tbase: '/wikibook/',\n\thost: '0.0.0.0',\n\t// 运行端口\n\tport: 8081,\n\n\tthemeConfig: {\n\t\t//gitc 仓库地址\n    \trepo: 'https://github.com/MFrank2016/wikibook',\n    \t// 如果你的文档不在仓库的根部\n   \t\tdocsDir: 'docs',\n    \t// 可选，默认为 master\n    \tdocsBranch: 'master',\n    \t// 默认为 true，设置为 false 来禁用\n    \teditLinks: true,\n    \t//导航栏\n    \tnav: [\n      \t\t{ text: 'Home', link: '/' },\n      \t\t{ text: 'Guide', link: '/guide/' },\n      \t\t{ text: 'External', link: 'https://google.com' },\n      \t\t{ text: 'Languages',\n      \t\titems: [\n      \t\t{ text: 'Chinese', link: '/language/chinese' },\n      \t\t{ text: 'Japanese', link: '/language/japanese' }\n      \t\t]}],\n      \tsidebar: [{\n        \ttitle: 'Group 1',\n        \tcollapsable: false,\n        \tchildren: [\n          \t\t'/'\n        \t\t]\n      \t\t},\n      \t\t{\n        \ttitle: 'Group 2',\n        \tchildren: [\n            \t'/'\n        \t\t]\n      \t\t}\n    \t]\n  \t},  \n    //搜索\n    search: true,\n    searchMaxSuggestions: 10,\n    lastUpdated: 'Last Updated', // string | boolean\n}\n```\n\n整体结构\n\n``` bash\nproject\n├─── docs\n│ ├── README.md\n│ ├── .vuepress\n│   ├── config.js\n│   └── public\n│     └── hero.png\n│ └── guide\n│   └── README.md \n└── package.json\n```\n\n## 五、初始化\n\n在docs目录下创建README.md\n\n```bash\n---\nhome: true\nheroImage: /hero.png\nactionText: 点击阅读\nactionLink: /guide/\nfooter: MIT Licensed | Copyright © 2018-present Frank\n---\n```\n\n然后回到project目录\n\n```bash\n# 开启调试模式，运行服务，此时打开 http://localhost:8081 (这里即上面设置的端口) 即能看到最简单的页面\nvuepress dev\n\n# 构建，此时会将md文档转化成html文件存储在docs/.vuepress/dist目录\nvuepress build\n```\n\n## 六、调试部署\n\n此时静态网页已经生成在了**docs/.vuepress/dist**目录下，可以先开启调试模式，然后使用ftp等软件先对服务器进行远程连接，修改docs下面的文档，每次修改上传后，会自动重新编译，当然整个过程需要一两分钟时间，这取决于服务器的性能。调整到合适的程度即可将其移动到nginx或者apache相应目录下即可。\n","slug":"ops/deploy-vuepress-on-centos7","published":1,"updated":"2019-06-04T01:29:57.497Z","_id":"cjxze3gp7001s0cvwuas8bs7g","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>vuepress是一款十分优秀简洁的文档生成器，可以根据目录下的md文档自动生成对应的html文件，界面简洁大方。每一个由 VuePress 生成的页面都带有预渲染好的 HTML，也因此具有非常好的加载性能和搜索引擎优化（SEO）。本文将介绍如何在CentOS7环境下部署vuepress。</p>\n</blockquote>\n<p>官方主页：<a href=\"https://vuepress.vuejs.org/zh/\" target=\"_blank\" rel=\"noopener\">https://vuepress.vuejs.org/zh/</a>  </p>\n<p>官方文档：<a href=\"https://vuepress.vuejs.org/zh/guide/（官方文档就是用Vuepress搭建的，包括上面的主页）\" target=\"_blank\" rel=\"noopener\">https://vuepress.vuejs.org/zh/guide/（官方文档就是用Vuepress搭建的，包括上面的主页）</a></p>\n<p>项目地址：<a href=\"https://github.com/vuejs/vuepress\" target=\"_blank\" rel=\"noopener\">https://github.com/vuejs/vuepress</a></p>\n<h2 id=\"一、安装nodejs\"><a href=\"#一、安装nodejs\" class=\"headerlink\" title=\"一、安装nodejs\"></a>一、安装nodejs</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -sL https://rpm.nodesource.com/setup_8.x | sudo bash -</span><br><span class=\"line\">yum install nodejs</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、安装vuepress\"><a href=\"#二、安装vuepress\" class=\"headerlink\" title=\"二、安装vuepress\"></a>二、安装vuepress</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g vuepress</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、创建工作目录\"><a href=\"#三、创建工作目录\" class=\"headerlink\" title=\"三、创建工作目录\"></a>三、创建工作目录</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir project</span><br><span class=\"line\"><span class=\"built_in\">cd</span> project</span><br><span class=\"line\">mkdir docs</span><br></pre></td></tr></table></figure>\n<h2 id=\"四、初始化前\"><a href=\"#四、初始化前\" class=\"headerlink\" title=\"四、初始化前\"></a>四、初始化前</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm init -y</span><br><span class=\"line\">vim package.json</span><br></pre></td></tr></table></figure>\n<p>编辑成如下内容，这里其实是设置命令别名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    \t<span class=\"string\">\"docs:dev\"</span>: <span class=\"string\">\"vuepress dev docs\"</span>,</span><br><span class=\"line\">    \t<span class=\"string\">\"docs:build\"</span>: <span class=\"string\">\"vuepress build docs\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建.vuepress目录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir .vuepress</span><br><span class=\"line\"><span class=\"built_in\">cd</span> .vuepress</span><br></pre></td></tr></table></figure>\n<p>创建config.js，这是vuepress的全局配置文件，大部分属性在这里设置。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir public</span><br><span class=\"line\">vim config.js</span><br></pre></td></tr></table></figure>\n<p>修改成如下内容，对应内容可以自行修改。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">\ttitle: <span class=\"string\">'清风wiki'</span>,</span><br><span class=\"line\">\tdescription: <span class=\"string\">'我在等风，也在等你'</span>,</span><br><span class=\"line\">\t// 相对于git仓库的路径 如全路径为：https://mfrank2016.github.io/wikibook/ 则设置为<span class=\"string\">'/wikibook/'</span></span><br><span class=\"line\">\tbase: <span class=\"string\">'/wikibook/'</span>,</span><br><span class=\"line\">\thost: <span class=\"string\">'0.0.0.0'</span>,</span><br><span class=\"line\">\t// 运行端口</span><br><span class=\"line\">\tport: 8081,</span><br><span class=\"line\"></span><br><span class=\"line\">\tthemeConfig: &#123;</span><br><span class=\"line\">\t\t//gitc 仓库地址</span><br><span class=\"line\">    \trepo: <span class=\"string\">'https://github.com/MFrank2016/wikibook'</span>,</span><br><span class=\"line\">    \t// 如果你的文档不在仓库的根部</span><br><span class=\"line\">   \t\tdocsDir: <span class=\"string\">'docs'</span>,</span><br><span class=\"line\">    \t// 可选，默认为 master</span><br><span class=\"line\">    \tdocsBranch: <span class=\"string\">'master'</span>,</span><br><span class=\"line\">    \t// 默认为 <span class=\"literal\">true</span>，设置为 <span class=\"literal\">false</span> 来禁用</span><br><span class=\"line\">    \teditLinks: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    \t//导航栏</span><br><span class=\"line\">    \tnav: [</span><br><span class=\"line\">      \t\t&#123; text: <span class=\"string\">'Home'</span>, link: <span class=\"string\">'/'</span> &#125;,</span><br><span class=\"line\">      \t\t&#123; text: <span class=\"string\">'Guide'</span>, link: <span class=\"string\">'/guide/'</span> &#125;,</span><br><span class=\"line\">      \t\t&#123; text: <span class=\"string\">'External'</span>, link: <span class=\"string\">'https://google.com'</span> &#125;,</span><br><span class=\"line\">      \t\t&#123; text: <span class=\"string\">'Languages'</span>,</span><br><span class=\"line\">      \t\titems: [</span><br><span class=\"line\">      \t\t&#123; text: <span class=\"string\">'Chinese'</span>, link: <span class=\"string\">'/language/chinese'</span> &#125;,</span><br><span class=\"line\">      \t\t&#123; text: <span class=\"string\">'Japanese'</span>, link: <span class=\"string\">'/language/japanese'</span> &#125;</span><br><span class=\"line\">      \t\t]&#125;],</span><br><span class=\"line\">      \tsidebar: [&#123;</span><br><span class=\"line\">        \ttitle: <span class=\"string\">'Group 1'</span>,</span><br><span class=\"line\">        \tcollapsable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        \tchildren: [</span><br><span class=\"line\">          \t\t<span class=\"string\">'/'</span></span><br><span class=\"line\">        \t\t]</span><br><span class=\"line\">      \t\t&#125;,</span><br><span class=\"line\">      \t\t&#123;</span><br><span class=\"line\">        \ttitle: <span class=\"string\">'Group 2'</span>,</span><br><span class=\"line\">        \tchildren: [</span><br><span class=\"line\">            \t<span class=\"string\">'/'</span></span><br><span class=\"line\">        \t\t]</span><br><span class=\"line\">      \t\t&#125;</span><br><span class=\"line\">    \t]</span><br><span class=\"line\">  \t&#125;,  </span><br><span class=\"line\">    //搜索</span><br><span class=\"line\">    search: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    searchMaxSuggestions: 10,</span><br><span class=\"line\">    lastUpdated: <span class=\"string\">'Last Updated'</span>, // string | boolean</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整体结构</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">project</span><br><span class=\"line\">├─── docs</span><br><span class=\"line\">│ ├── README.md</span><br><span class=\"line\">│ ├── .vuepress</span><br><span class=\"line\">│   ├── config.js</span><br><span class=\"line\">│   └── public</span><br><span class=\"line\">│     └── hero.png</span><br><span class=\"line\">│ └── guide</span><br><span class=\"line\">│   └── README.md </span><br><span class=\"line\">└── package.json</span><br></pre></td></tr></table></figure>\n<h2 id=\"五、初始化\"><a href=\"#五、初始化\" class=\"headerlink\" title=\"五、初始化\"></a>五、初始化</h2><p>在docs目录下创建README.md</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">home: <span class=\"literal\">true</span></span><br><span class=\"line\">heroImage: /hero.png</span><br><span class=\"line\">actionText: 点击阅读</span><br><span class=\"line\">actionLink: /guide/</span><br><span class=\"line\">footer: MIT Licensed | Copyright © 2018-present Frank</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>然后回到project目录</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 开启调试模式，运行服务，此时打开 http://localhost:8081 (这里即上面设置的端口) 即能看到最简单的页面</span></span><br><span class=\"line\">vuepress dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建，此时会将md文档转化成html文件存储在docs/.vuepress/dist目录</span></span><br><span class=\"line\">vuepress build</span><br></pre></td></tr></table></figure>\n<h2 id=\"六、调试部署\"><a href=\"#六、调试部署\" class=\"headerlink\" title=\"六、调试部署\"></a>六、调试部署</h2><p>此时静态网页已经生成在了<strong>docs/.vuepress/dist</strong>目录下，可以先开启调试模式，然后使用ftp等软件先对服务器进行远程连接，修改docs下面的文档，每次修改上传后，会自动重新编译，当然整个过程需要一两分钟时间，这取决于服务器的性能。调整到合适的程度即可将其移动到nginx或者apache相应目录下即可。</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>vuepress是一款十分优秀简洁的文档生成器，可以根据目录下的md文档自动生成对应的html文件，界面简洁大方。每一个由 VuePress 生成的页面都带有预渲染好的 HTML，也因此具有非常好的加载性能和搜索引擎优化（SEO）。本文将介绍如何在CentOS7环境下部署vuepress。</p>\n</blockquote>\n<p>官方主页：<a href=\"https://vuepress.vuejs.org/zh/\" target=\"_blank\" rel=\"noopener\">https://vuepress.vuejs.org/zh/</a>  </p>\n<p>官方文档：<a href=\"https://vuepress.vuejs.org/zh/guide/（官方文档就是用Vuepress搭建的，包括上面的主页）\" target=\"_blank\" rel=\"noopener\">https://vuepress.vuejs.org/zh/guide/（官方文档就是用Vuepress搭建的，包括上面的主页）</a></p>\n<p>项目地址：<a href=\"https://github.com/vuejs/vuepress\" target=\"_blank\" rel=\"noopener\">https://github.com/vuejs/vuepress</a></p>\n<h2 id=\"一、安装nodejs\"><a href=\"#一、安装nodejs\" class=\"headerlink\" title=\"一、安装nodejs\"></a>一、安装nodejs</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -sL https://rpm.nodesource.com/setup_8.x | sudo bash -</span><br><span class=\"line\">yum install nodejs</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、安装vuepress\"><a href=\"#二、安装vuepress\" class=\"headerlink\" title=\"二、安装vuepress\"></a>二、安装vuepress</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g vuepress</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、创建工作目录\"><a href=\"#三、创建工作目录\" class=\"headerlink\" title=\"三、创建工作目录\"></a>三、创建工作目录</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir project</span><br><span class=\"line\"><span class=\"built_in\">cd</span> project</span><br><span class=\"line\">mkdir docs</span><br></pre></td></tr></table></figure>\n<h2 id=\"四、初始化前\"><a href=\"#四、初始化前\" class=\"headerlink\" title=\"四、初始化前\"></a>四、初始化前</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm init -y</span><br><span class=\"line\">vim package.json</span><br></pre></td></tr></table></figure>\n<p>编辑成如下内容，这里其实是设置命令别名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    \t<span class=\"string\">\"docs:dev\"</span>: <span class=\"string\">\"vuepress dev docs\"</span>,</span><br><span class=\"line\">    \t<span class=\"string\">\"docs:build\"</span>: <span class=\"string\">\"vuepress build docs\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建.vuepress目录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir .vuepress</span><br><span class=\"line\"><span class=\"built_in\">cd</span> .vuepress</span><br></pre></td></tr></table></figure>\n<p>创建config.js，这是vuepress的全局配置文件，大部分属性在这里设置。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir public</span><br><span class=\"line\">vim config.js</span><br></pre></td></tr></table></figure>\n<p>修改成如下内容，对应内容可以自行修改。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">\ttitle: <span class=\"string\">'清风wiki'</span>,</span><br><span class=\"line\">\tdescription: <span class=\"string\">'我在等风，也在等你'</span>,</span><br><span class=\"line\">\t// 相对于git仓库的路径 如全路径为：https://mfrank2016.github.io/wikibook/ 则设置为<span class=\"string\">'/wikibook/'</span></span><br><span class=\"line\">\tbase: <span class=\"string\">'/wikibook/'</span>,</span><br><span class=\"line\">\thost: <span class=\"string\">'0.0.0.0'</span>,</span><br><span class=\"line\">\t// 运行端口</span><br><span class=\"line\">\tport: 8081,</span><br><span class=\"line\"></span><br><span class=\"line\">\tthemeConfig: &#123;</span><br><span class=\"line\">\t\t//gitc 仓库地址</span><br><span class=\"line\">    \trepo: <span class=\"string\">'https://github.com/MFrank2016/wikibook'</span>,</span><br><span class=\"line\">    \t// 如果你的文档不在仓库的根部</span><br><span class=\"line\">   \t\tdocsDir: <span class=\"string\">'docs'</span>,</span><br><span class=\"line\">    \t// 可选，默认为 master</span><br><span class=\"line\">    \tdocsBranch: <span class=\"string\">'master'</span>,</span><br><span class=\"line\">    \t// 默认为 <span class=\"literal\">true</span>，设置为 <span class=\"literal\">false</span> 来禁用</span><br><span class=\"line\">    \teditLinks: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    \t//导航栏</span><br><span class=\"line\">    \tnav: [</span><br><span class=\"line\">      \t\t&#123; text: <span class=\"string\">'Home'</span>, link: <span class=\"string\">'/'</span> &#125;,</span><br><span class=\"line\">      \t\t&#123; text: <span class=\"string\">'Guide'</span>, link: <span class=\"string\">'/guide/'</span> &#125;,</span><br><span class=\"line\">      \t\t&#123; text: <span class=\"string\">'External'</span>, link: <span class=\"string\">'https://google.com'</span> &#125;,</span><br><span class=\"line\">      \t\t&#123; text: <span class=\"string\">'Languages'</span>,</span><br><span class=\"line\">      \t\titems: [</span><br><span class=\"line\">      \t\t&#123; text: <span class=\"string\">'Chinese'</span>, link: <span class=\"string\">'/language/chinese'</span> &#125;,</span><br><span class=\"line\">      \t\t&#123; text: <span class=\"string\">'Japanese'</span>, link: <span class=\"string\">'/language/japanese'</span> &#125;</span><br><span class=\"line\">      \t\t]&#125;],</span><br><span class=\"line\">      \tsidebar: [&#123;</span><br><span class=\"line\">        \ttitle: <span class=\"string\">'Group 1'</span>,</span><br><span class=\"line\">        \tcollapsable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        \tchildren: [</span><br><span class=\"line\">          \t\t<span class=\"string\">'/'</span></span><br><span class=\"line\">        \t\t]</span><br><span class=\"line\">      \t\t&#125;,</span><br><span class=\"line\">      \t\t&#123;</span><br><span class=\"line\">        \ttitle: <span class=\"string\">'Group 2'</span>,</span><br><span class=\"line\">        \tchildren: [</span><br><span class=\"line\">            \t<span class=\"string\">'/'</span></span><br><span class=\"line\">        \t\t]</span><br><span class=\"line\">      \t\t&#125;</span><br><span class=\"line\">    \t]</span><br><span class=\"line\">  \t&#125;,  </span><br><span class=\"line\">    //搜索</span><br><span class=\"line\">    search: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    searchMaxSuggestions: 10,</span><br><span class=\"line\">    lastUpdated: <span class=\"string\">'Last Updated'</span>, // string | boolean</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整体结构</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">project</span><br><span class=\"line\">├─── docs</span><br><span class=\"line\">│ ├── README.md</span><br><span class=\"line\">│ ├── .vuepress</span><br><span class=\"line\">│   ├── config.js</span><br><span class=\"line\">│   └── public</span><br><span class=\"line\">│     └── hero.png</span><br><span class=\"line\">│ └── guide</span><br><span class=\"line\">│   └── README.md </span><br><span class=\"line\">└── package.json</span><br></pre></td></tr></table></figure>\n<h2 id=\"五、初始化\"><a href=\"#五、初始化\" class=\"headerlink\" title=\"五、初始化\"></a>五、初始化</h2><p>在docs目录下创建README.md</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">home: <span class=\"literal\">true</span></span><br><span class=\"line\">heroImage: /hero.png</span><br><span class=\"line\">actionText: 点击阅读</span><br><span class=\"line\">actionLink: /guide/</span><br><span class=\"line\">footer: MIT Licensed | Copyright © 2018-present Frank</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>然后回到project目录</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 开启调试模式，运行服务，此时打开 http://localhost:8081 (这里即上面设置的端口) 即能看到最简单的页面</span></span><br><span class=\"line\">vuepress dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建，此时会将md文档转化成html文件存储在docs/.vuepress/dist目录</span></span><br><span class=\"line\">vuepress build</span><br></pre></td></tr></table></figure>\n<h2 id=\"六、调试部署\"><a href=\"#六、调试部署\" class=\"headerlink\" title=\"六、调试部署\"></a>六、调试部署</h2><p>此时静态网页已经生成在了<strong>docs/.vuepress/dist</strong>目录下，可以先开启调试模式，然后使用ftp等软件先对服务器进行远程连接，修改docs下面的文档，每次修改上传后，会自动重新编译，当然整个过程需要一两分钟时间，这取决于服务器的性能。调整到合适的程度即可将其移动到nginx或者apache相应目录下即可。</p>\n"},{"title":"《Java并发编程的艺术》读书笔记","date":"2019-01-03T00:06:15.000Z","_content":"> 书籍作者：方腾飞 魏鹏 程晓明\n\n## 第一章 并发编程的挑战\n\n1.1 上下文切换\n\n1. 时间片一般是几十毫秒。\n\n```bash\n疑问：时间片与CPU的哪个属性有关？\n```\n\n2. 任务从保存到再加载的过程就是一次上下文切换。\n\n```bash\n疑问：多个线程不没有产生竞争、阻塞或等待，也会发生上下文切换吗？\n```\n\n3. 使用`Lmbench3`可以测量上下文切换的时长。\n4. 使用`vmstat`可以测量上下文切换的次数。\n5. 减少上下文切换的方法：\n   1. 无锁并发编程\n   2. CAS算法\n   3. 使用最少线程\n   4. 协程\n\n1.2 死锁\n\n避免死锁的常见方法：\n\n1. 避免一个线程同时获取多个锁。\n2. 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。\n3. 尝试使用定时锁，使用`lock.tryLock(timeout)`来替代使用内部锁机制。\n4. 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。\n\n1.3 资源限制的挑战\n\n1. 资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或者软件资源。\n2. 在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变成并发执行，但是如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。\n3. 对于硬件资源限制，可以考虑使用集群并行执行程序。对于软件资源限制，可以考虑使用资源池将资源进行复用。\n   \n## 第二章 Java并发机制的底层实现原理\n\n2.1 volatile的应用\n\n1. 用volatile修饰的共享变量进行写操作的时候，虚拟机会在其代码中插入`Lock`前缀指令，该指令在多核处理器下会引发两件事情：\n   1. 将当前处理器缓存行的数据写回到系统内存。\n   2. 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。\n\n```bash\n这部分内容在《Java多线程实战指南》里说的更加详细\n```\n\n2.2 synchronized的实现原理与应用\n\n1. `JVM`基于进入和退出`Monitor`对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用`monitorenter`和`monitorexit`指令实现的，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。\n2. `synchronized`用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节。\n\n| 长度     | 内容                   | 说明                             |\n| -------- | ---------------------- | -------------------------------- |\n| 32/64bit | Mark Word              | 存储对象的hashCode或锁信息等     |\n| 32/64bit | Class Metadata Address | 存储到对象类型数据的指针         |\n| 32/64bit | Array length           | 数组的长度（如果当前对象是数组） |\n\n3. Java 对象头里的`Mark Word`里默认存储对象的`HashCode`、分代年龄和锁标记位。\n4. 锁一共有4种状态，级别从低到高分别是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。\n5. 锁可以升级但不能降级。\n6. 偏向锁：当一个线程访问同步块时并获取锁时，会在对象头和栈帧中的所记录里存储锁偏向的线程id，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的`Mark Word`里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已获得了锁。如果测试失败，则需要再测试一下`Mark Word`中偏向锁的标志位是否设置为1（表示当前为偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。\n7. 偏向锁使用的是等到发生竞争后才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。\n8. 偏向锁的撤销需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停持有偏向锁的线程，然后检测该线程是否仍处于同步代码块，如果不处于，则将对象头中的`Mark Word`信息设置为无锁状态，如果线程仍处于同步块，则会将该偏向锁升级为轻量级锁，然后唤醒暂停的线程。如下图：\n   \n![](https://ask.qcloudimg.com/http-save/yehe-1174983/cm2p35nftf.png?imageView2/2/w/1620)\n\n![](https://ask.qcloudimg.com/http-save/yehe-1174983/qeqp98u8so.png?imageView2/2/w/1620)\n\n9. \b偏向锁在Java6和Java7中是默认启用的，如果有必要可以使用JVM参数来关闭偏向锁：`-XX:-UseBiasedLocking=false`，则程序会默认进入轻量级锁状态。\n10. 轻量级锁加锁：JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的`Mark Word`复制到锁记录中，官方称为`Displaced Mark Word`。然后线程尝试使用CAS将对象头中的`Mark Word`替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。\n11. 轻量级锁解锁：使用原子的CAS操作将`Displaced Mark Word`替换回到对象头，如果\b成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。\n\n![](https://ask.qcloudimg.com/http-save/yehe-1174983/hr3330qo7g.png?imageView2/2/w/1620)\n![](https://ask.qcloudimg.com/http-save/yehe-1174983/acgacyts24.png?imageView2/2/w/1620)\n![](https://ask.qcloudimg.com/http-save/yehe-1174983/ro5yr0z6y9.png?imageView2/2/w/1620)\n\n|锁类型|优点|缺点|适用场景|\n|---|---|---|---|\n|偏向锁|加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距|如果线程间存在锁竞争，会带来额外的锁撤销的消耗|适用于只有一个线程访问同步块场景|\n|轻量级锁|竞争的线程\b不会阻塞，提高了程序的相应速度|如果始终得不到锁竞争的线程，使用自旋会消耗CPU|追求响应时间，同步块执行速度非常快|\n|重量级锁|线程竞争不使用自旋，不会消耗CPU|线程阻塞，响应时间缓慢|追求吞吐量，同步块执行时间较长|\n\n2.3 原子操作的实现原理\n\n1. 第一个机制是通过总线锁保证原子性。\n2. 第二个机制是通过缓存锁定来保证原子性。\n3. Java中可以通过锁和循环CAS的方式来实现原子操作。\n4. CAS实现原子操作的三大问题\n   1. ABA问题：如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。解决思路：在变量前面加上版本号，每次变量更新的时候把版本号加1.当前可以使用`AtomicStampedReference`来解决ABA问题。\n   2. 循环时间长开销大。\n   3. 只能保证一个共享变量的原子操作。可以使用`AtomicReference`类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS。\n5. 使用锁机制实现原子操作\n   1. 除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。\n\n## 第三章 Java内存模型\n","source":"_posts/reading/the-art-of-java-multithread-notes.md","raw":"---\ntitle: 《Java并发编程的艺术》读书笔记\ntags: \n - Java\n - 多线程\ncategories: 阅读\ndate: 2019-01-03 08:06:15\n---\n> 书籍作者：方腾飞 魏鹏 程晓明\n\n## 第一章 并发编程的挑战\n\n1.1 上下文切换\n\n1. 时间片一般是几十毫秒。\n\n```bash\n疑问：时间片与CPU的哪个属性有关？\n```\n\n2. 任务从保存到再加载的过程就是一次上下文切换。\n\n```bash\n疑问：多个线程不没有产生竞争、阻塞或等待，也会发生上下文切换吗？\n```\n\n3. 使用`Lmbench3`可以测量上下文切换的时长。\n4. 使用`vmstat`可以测量上下文切换的次数。\n5. 减少上下文切换的方法：\n   1. 无锁并发编程\n   2. CAS算法\n   3. 使用最少线程\n   4. 协程\n\n1.2 死锁\n\n避免死锁的常见方法：\n\n1. 避免一个线程同时获取多个锁。\n2. 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。\n3. 尝试使用定时锁，使用`lock.tryLock(timeout)`来替代使用内部锁机制。\n4. 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。\n\n1.3 资源限制的挑战\n\n1. 资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或者软件资源。\n2. 在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变成并发执行，但是如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。\n3. 对于硬件资源限制，可以考虑使用集群并行执行程序。对于软件资源限制，可以考虑使用资源池将资源进行复用。\n   \n## 第二章 Java并发机制的底层实现原理\n\n2.1 volatile的应用\n\n1. 用volatile修饰的共享变量进行写操作的时候，虚拟机会在其代码中插入`Lock`前缀指令，该指令在多核处理器下会引发两件事情：\n   1. 将当前处理器缓存行的数据写回到系统内存。\n   2. 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。\n\n```bash\n这部分内容在《Java多线程实战指南》里说的更加详细\n```\n\n2.2 synchronized的实现原理与应用\n\n1. `JVM`基于进入和退出`Monitor`对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用`monitorenter`和`monitorexit`指令实现的，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。\n2. `synchronized`用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节。\n\n| 长度     | 内容                   | 说明                             |\n| -------- | ---------------------- | -------------------------------- |\n| 32/64bit | Mark Word              | 存储对象的hashCode或锁信息等     |\n| 32/64bit | Class Metadata Address | 存储到对象类型数据的指针         |\n| 32/64bit | Array length           | 数组的长度（如果当前对象是数组） |\n\n3. Java 对象头里的`Mark Word`里默认存储对象的`HashCode`、分代年龄和锁标记位。\n4. 锁一共有4种状态，级别从低到高分别是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。\n5. 锁可以升级但不能降级。\n6. 偏向锁：当一个线程访问同步块时并获取锁时，会在对象头和栈帧中的所记录里存储锁偏向的线程id，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的`Mark Word`里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已获得了锁。如果测试失败，则需要再测试一下`Mark Word`中偏向锁的标志位是否设置为1（表示当前为偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。\n7. 偏向锁使用的是等到发生竞争后才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。\n8. 偏向锁的撤销需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停持有偏向锁的线程，然后检测该线程是否仍处于同步代码块，如果不处于，则将对象头中的`Mark Word`信息设置为无锁状态，如果线程仍处于同步块，则会将该偏向锁升级为轻量级锁，然后唤醒暂停的线程。如下图：\n   \n![](https://ask.qcloudimg.com/http-save/yehe-1174983/cm2p35nftf.png?imageView2/2/w/1620)\n\n![](https://ask.qcloudimg.com/http-save/yehe-1174983/qeqp98u8so.png?imageView2/2/w/1620)\n\n9. \b偏向锁在Java6和Java7中是默认启用的，如果有必要可以使用JVM参数来关闭偏向锁：`-XX:-UseBiasedLocking=false`，则程序会默认进入轻量级锁状态。\n10. 轻量级锁加锁：JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的`Mark Word`复制到锁记录中，官方称为`Displaced Mark Word`。然后线程尝试使用CAS将对象头中的`Mark Word`替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。\n11. 轻量级锁解锁：使用原子的CAS操作将`Displaced Mark Word`替换回到对象头，如果\b成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。\n\n![](https://ask.qcloudimg.com/http-save/yehe-1174983/hr3330qo7g.png?imageView2/2/w/1620)\n![](https://ask.qcloudimg.com/http-save/yehe-1174983/acgacyts24.png?imageView2/2/w/1620)\n![](https://ask.qcloudimg.com/http-save/yehe-1174983/ro5yr0z6y9.png?imageView2/2/w/1620)\n\n|锁类型|优点|缺点|适用场景|\n|---|---|---|---|\n|偏向锁|加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距|如果线程间存在锁竞争，会带来额外的锁撤销的消耗|适用于只有一个线程访问同步块场景|\n|轻量级锁|竞争的线程\b不会阻塞，提高了程序的相应速度|如果始终得不到锁竞争的线程，使用自旋会消耗CPU|追求响应时间，同步块执行速度非常快|\n|重量级锁|线程竞争不使用自旋，不会消耗CPU|线程阻塞，响应时间缓慢|追求吞吐量，同步块执行时间较长|\n\n2.3 原子操作的实现原理\n\n1. 第一个机制是通过总线锁保证原子性。\n2. 第二个机制是通过缓存锁定来保证原子性。\n3. Java中可以通过锁和循环CAS的方式来实现原子操作。\n4. CAS实现原子操作的三大问题\n   1. ABA问题：如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。解决思路：在变量前面加上版本号，每次变量更新的时候把版本号加1.当前可以使用`AtomicStampedReference`来解决ABA问题。\n   2. 循环时间长开销大。\n   3. 只能保证一个共享变量的原子操作。可以使用`AtomicReference`类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS。\n5. 使用锁机制实现原子操作\n   1. 除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。\n\n## 第三章 Java内存模型\n","slug":"reading/the-art-of-java-multithread-notes","published":1,"updated":"2019-06-04T01:29:57.499Z","_id":"cjxze3gp9001u0cvwva2wpd1b","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>书籍作者：方腾飞 魏鹏 程晓明</p>\n</blockquote>\n<h2 id=\"第一章-并发编程的挑战\"><a href=\"#第一章-并发编程的挑战\" class=\"headerlink\" title=\"第一章 并发编程的挑战\"></a>第一章 并发编程的挑战</h2><p>1.1 上下文切换</p>\n<ol>\n<li>时间片一般是几十毫秒。</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">疑问：时间片与CPU的哪个属性有关？</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>任务从保存到再加载的过程就是一次上下文切换。</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">疑问：多个线程不没有产生竞争、阻塞或等待，也会发生上下文切换吗？</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>使用<code>Lmbench3</code>可以测量上下文切换的时长。</li>\n<li>使用<code>vmstat</code>可以测量上下文切换的次数。</li>\n<li>减少上下文切换的方法：<ol>\n<li>无锁并发编程</li>\n<li>CAS算法</li>\n<li>使用最少线程</li>\n<li>协程</li>\n</ol>\n</li>\n</ol>\n<p>1.2 死锁</p>\n<p>避免死锁的常见方法：</p>\n<ol>\n<li>避免一个线程同时获取多个锁。</li>\n<li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li>\n<li>尝试使用定时锁，使用<code>lock.tryLock(timeout)</code>来替代使用内部锁机制。</li>\n<li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li>\n</ol>\n<p>1.3 资源限制的挑战</p>\n<ol>\n<li>资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或者软件资源。</li>\n<li>在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变成并发执行，但是如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。</li>\n<li>对于硬件资源限制，可以考虑使用集群并行执行程序。对于软件资源限制，可以考虑使用资源池将资源进行复用。</li>\n</ol>\n<h2 id=\"第二章-Java并发机制的底层实现原理\"><a href=\"#第二章-Java并发机制的底层实现原理\" class=\"headerlink\" title=\"第二章 Java并发机制的底层实现原理\"></a>第二章 Java并发机制的底层实现原理</h2><p>2.1 volatile的应用</p>\n<ol>\n<li>用volatile修饰的共享变量进行写操作的时候，虚拟机会在其代码中插入<code>Lock</code>前缀指令，该指令在多核处理器下会引发两件事情：<ol>\n<li>将当前处理器缓存行的数据写回到系统内存。</li>\n<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这部分内容在《Java多线程实战指南》里说的更加详细</span><br></pre></td></tr></table></figure>\n<p>2.2 synchronized的实现原理与应用</p>\n<ol>\n<li><code>JVM</code>基于进入和退出<code>Monitor</code>对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用<code>monitorenter</code>和<code>monitorexit</code>指令实现的，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。</li>\n<li><code>synchronized</code>用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>长度</th>\n<th>内容</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>32/64bit</td>\n<td>Mark Word</td>\n<td>存储对象的hashCode或锁信息等</td>\n</tr>\n<tr>\n<td>32/64bit</td>\n<td>Class Metadata Address</td>\n<td>存储到对象类型数据的指针</td>\n</tr>\n<tr>\n<td>32/64bit</td>\n<td>Array length</td>\n<td>数组的长度（如果当前对象是数组）</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"3\">\n<li>Java 对象头里的<code>Mark Word</code>里默认存储对象的<code>HashCode</code>、分代年龄和锁标记位。</li>\n<li>锁一共有4种状态，级别从低到高分别是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。</li>\n<li>锁可以升级但不能降级。</li>\n<li>偏向锁：当一个线程访问同步块时并获取锁时，会在对象头和栈帧中的所记录里存储锁偏向的线程id，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的<code>Mark Word</code>里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已获得了锁。如果测试失败，则需要再测试一下<code>Mark Word</code>中偏向锁的标志位是否设置为1（表示当前为偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</li>\n<li>偏向锁使用的是等到发生竞争后才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。</li>\n<li>偏向锁的撤销需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停持有偏向锁的线程，然后检测该线程是否仍处于同步代码块，如果不处于，则将对象头中的<code>Mark Word</code>信息设置为无锁状态，如果线程仍处于同步块，则会将该偏向锁升级为轻量级锁，然后唤醒暂停的线程。如下图：</li>\n</ol>\n<p><img src=\"https://ask.qcloudimg.com/http-save/yehe-1174983/cm2p35nftf.png?imageView2/2/w/1620\" alt=\"\"></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ask.qcloudimg.com/http-save/yehe-1174983/qeqp98u8so.png?imageView2/2/w/1620\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<ol start=\"9\">\n<li>\b偏向锁在Java6和Java7中是默认启用的，如果有必要可以使用JVM参数来关闭偏向锁：<code>-XX:-UseBiasedLocking=false</code>，则程序会默认进入轻量级锁状态。</li>\n<li>轻量级锁加锁：JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的<code>Mark Word</code>复制到锁记录中，官方称为<code>Displaced Mark Word</code>。然后线程尝试使用CAS将对象头中的<code>Mark Word</code>替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</li>\n<li>轻量级锁解锁：使用原子的CAS操作将<code>Displaced Mark Word</code>替换回到对象头，如果\b成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</li>\n</ol>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ask.qcloudimg.com/http-save/yehe-1174983/hr3330qo7g.png?imageView2/2/w/1620\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ask.qcloudimg.com/http-save/yehe-1174983/acgacyts24.png?imageView2/2/w/1620\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ask.qcloudimg.com/http-save/yehe-1174983/ro5yr0z6y9.png?imageView2/2/w/1620\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<table>\n<thead>\n<tr>\n<th>锁类型</th>\n<th>优点</th>\n<th>缺点</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>偏向锁</td>\n<td>加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距</td>\n<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>\n<td>适用于只有一个线程访问同步块场景</td>\n</tr>\n<tr>\n<td>轻量级锁</td>\n<td>竞争的线程\b不会阻塞，提高了程序的相应速度</td>\n<td>如果始终得不到锁竞争的线程，使用自旋会消耗CPU</td>\n<td>追求响应时间，同步块执行速度非常快</td>\n</tr>\n<tr>\n<td>重量级锁</td>\n<td>线程竞争不使用自旋，不会消耗CPU</td>\n<td>线程阻塞，响应时间缓慢</td>\n<td>追求吞吐量，同步块执行时间较长</td>\n</tr>\n</tbody>\n</table>\n<p>2.3 原子操作的实现原理</p>\n<ol>\n<li>第一个机制是通过总线锁保证原子性。</li>\n<li>第二个机制是通过缓存锁定来保证原子性。</li>\n<li>Java中可以通过锁和循环CAS的方式来实现原子操作。</li>\n<li>CAS实现原子操作的三大问题<ol>\n<li>ABA问题：如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。解决思路：在变量前面加上版本号，每次变量更新的时候把版本号加1.当前可以使用<code>AtomicStampedReference</code>来解决ABA问题。</li>\n<li>循环时间长开销大。</li>\n<li>只能保证一个共享变量的原子操作。可以使用<code>AtomicReference</code>类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS。</li>\n</ol>\n</li>\n<li>使用锁机制实现原子操作<ol>\n<li>除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"第三章-Java内存模型\"><a href=\"#第三章-Java内存模型\" class=\"headerlink\" title=\"第三章 Java内存模型\"></a>第三章 Java内存模型</h2>","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<blockquote>\n<p>书籍作者：方腾飞 魏鹏 程晓明</p>\n</blockquote>\n<h2 id=\"第一章-并发编程的挑战\"><a href=\"#第一章-并发编程的挑战\" class=\"headerlink\" title=\"第一章 并发编程的挑战\"></a>第一章 并发编程的挑战</h2><p>1.1 上下文切换</p>\n<ol>\n<li>时间片一般是几十毫秒。</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">疑问：时间片与CPU的哪个属性有关？</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>任务从保存到再加载的过程就是一次上下文切换。</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">疑问：多个线程不没有产生竞争、阻塞或等待，也会发生上下文切换吗？</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>使用<code>Lmbench3</code>可以测量上下文切换的时长。</li>\n<li>使用<code>vmstat</code>可以测量上下文切换的次数。</li>\n<li>减少上下文切换的方法：<ol>\n<li>无锁并发编程</li>\n<li>CAS算法</li>\n<li>使用最少线程</li>\n<li>协程</li>\n</ol>\n</li>\n</ol>\n<p>1.2 死锁</p>\n<p>避免死锁的常见方法：</p>\n<ol>\n<li>避免一个线程同时获取多个锁。</li>\n<li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li>\n<li>尝试使用定时锁，使用<code>lock.tryLock(timeout)</code>来替代使用内部锁机制。</li>\n<li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li>\n</ol>\n<p>1.3 资源限制的挑战</p>\n<ol>\n<li>资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或者软件资源。</li>\n<li>在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变成并发执行，但是如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。</li>\n<li>对于硬件资源限制，可以考虑使用集群并行执行程序。对于软件资源限制，可以考虑使用资源池将资源进行复用。</li>\n</ol>\n<h2 id=\"第二章-Java并发机制的底层实现原理\"><a href=\"#第二章-Java并发机制的底层实现原理\" class=\"headerlink\" title=\"第二章 Java并发机制的底层实现原理\"></a>第二章 Java并发机制的底层实现原理</h2><p>2.1 volatile的应用</p>\n<ol>\n<li>用volatile修饰的共享变量进行写操作的时候，虚拟机会在其代码中插入<code>Lock</code>前缀指令，该指令在多核处理器下会引发两件事情：<ol>\n<li>将当前处理器缓存行的数据写回到系统内存。</li>\n<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这部分内容在《Java多线程实战指南》里说的更加详细</span><br></pre></td></tr></table></figure>\n<p>2.2 synchronized的实现原理与应用</p>\n<ol>\n<li><code>JVM</code>基于进入和退出<code>Monitor</code>对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用<code>monitorenter</code>和<code>monitorexit</code>指令实现的，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。</li>\n<li><code>synchronized</code>用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>长度</th>\n<th>内容</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>32/64bit</td>\n<td>Mark Word</td>\n<td>存储对象的hashCode或锁信息等</td>\n</tr>\n<tr>\n<td>32/64bit</td>\n<td>Class Metadata Address</td>\n<td>存储到对象类型数据的指针</td>\n</tr>\n<tr>\n<td>32/64bit</td>\n<td>Array length</td>\n<td>数组的长度（如果当前对象是数组）</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"3\">\n<li>Java 对象头里的<code>Mark Word</code>里默认存储对象的<code>HashCode</code>、分代年龄和锁标记位。</li>\n<li>锁一共有4种状态，级别从低到高分别是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。</li>\n<li>锁可以升级但不能降级。</li>\n<li>偏向锁：当一个线程访问同步块时并获取锁时，会在对象头和栈帧中的所记录里存储锁偏向的线程id，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的<code>Mark Word</code>里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已获得了锁。如果测试失败，则需要再测试一下<code>Mark Word</code>中偏向锁的标志位是否设置为1（表示当前为偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</li>\n<li>偏向锁使用的是等到发生竞争后才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。</li>\n<li>偏向锁的撤销需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停持有偏向锁的线程，然后检测该线程是否仍处于同步代码块，如果不处于，则将对象头中的<code>Mark Word</code>信息设置为无锁状态，如果线程仍处于同步块，则会将该偏向锁升级为轻量级锁，然后唤醒暂停的线程。如下图：</li>\n</ol>\n<p><img src=\"https://ask.qcloudimg.com/http-save/yehe-1174983/cm2p35nftf.png?imageView2/2/w/1620\" alt=\"\"></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ask.qcloudimg.com/http-save/yehe-1174983/qeqp98u8so.png?imageView2/2/w/1620\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<ol start=\"9\">\n<li>\b偏向锁在Java6和Java7中是默认启用的，如果有必要可以使用JVM参数来关闭偏向锁：<code>-XX:-UseBiasedLocking=false</code>，则程序会默认进入轻量级锁状态。</li>\n<li>轻量级锁加锁：JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的<code>Mark Word</code>复制到锁记录中，官方称为<code>Displaced Mark Word</code>。然后线程尝试使用CAS将对象头中的<code>Mark Word</code>替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</li>\n<li>轻量级锁解锁：使用原子的CAS操作将<code>Displaced Mark Word</code>替换回到对象头，如果\b成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</li>\n</ol>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ask.qcloudimg.com/http-save/yehe-1174983/hr3330qo7g.png?imageView2/2/w/1620\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ask.qcloudimg.com/http-save/yehe-1174983/acgacyts24.png?imageView2/2/w/1620\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ask.qcloudimg.com/http-save/yehe-1174983/ro5yr0z6y9.png?imageView2/2/w/1620\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<table>\n<thead>\n<tr>\n<th>锁类型</th>\n<th>优点</th>\n<th>缺点</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>偏向锁</td>\n<td>加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距</td>\n<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>\n<td>适用于只有一个线程访问同步块场景</td>\n</tr>\n<tr>\n<td>轻量级锁</td>\n<td>竞争的线程\b不会阻塞，提高了程序的相应速度</td>\n<td>如果始终得不到锁竞争的线程，使用自旋会消耗CPU</td>\n<td>追求响应时间，同步块执行速度非常快</td>\n</tr>\n<tr>\n<td>重量级锁</td>\n<td>线程竞争不使用自旋，不会消耗CPU</td>\n<td>线程阻塞，响应时间缓慢</td>\n<td>追求吞吐量，同步块执行时间较长</td>\n</tr>\n</tbody>\n</table>\n<p>2.3 原子操作的实现原理</p>\n<ol>\n<li>第一个机制是通过总线锁保证原子性。</li>\n<li>第二个机制是通过缓存锁定来保证原子性。</li>\n<li>Java中可以通过锁和循环CAS的方式来实现原子操作。</li>\n<li>CAS实现原子操作的三大问题<ol>\n<li>ABA问题：如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。解决思路：在变量前面加上版本号，每次变量更新的时候把版本号加1.当前可以使用<code>AtomicStampedReference</code>来解决ABA问题。</li>\n<li>循环时间长开销大。</li>\n<li>只能保证一个共享变量的原子操作。可以使用<code>AtomicReference</code>类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS。</li>\n</ol>\n</li>\n<li>使用锁机制实现原子操作<ol>\n<li>除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"第三章-Java内存模型\"><a href=\"#第三章-Java内存模型\" class=\"headerlink\" title=\"第三章 Java内存模型\"></a>第三章 Java内存模型</h2>"},{"title":"【LeetCode】正则表达式匹配","date":"2019-03-03T07:40:30.000Z","_content":"\n## 题目描述\n\n给定一个字符串 (s) 和一个字符模式 (p)。实现支持 '.' 和 '*' 的正则表达式匹配。\n\n'.' 匹配任意单个字符。\n'*' 匹配零个或多个前面的元素。\n匹配应该覆盖整个字符串 (s) ，而不是部分字符串。\n\n说明:\n\ns 可能为空，且只包含从 a-z 的小写字母。\np 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。\n示例 1:\n\n```bash\n输入:\ns = \"aa\"\np = \"a\"\n输出: false\n解释: \"a\" 无法匹配 \"aa\" 整个字符串。\n```\n\n示例 2:\n```bash\n输入:\ns = \"aa\"\np = \"a*\"\n输出: true\n解释: '*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 \"aa\"。\n```\n\n示例 3:\n```bash\n输入:\ns = \"ab\"\np = \".*\"\n输出: true\n解释: \".*\" 表示可匹配零个或多个('*')任意字符('.')。\n```\n\n示例 4:\n```bash\n输入:\ns = \"aab\"\np = \"c*a*b\"\n输出: true\n解释: 'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 \"aab\"。\n```\n\n示例 5:\n```bash\n输入:\ns = \"mississippi\"\np = \"mis*is*p*.\"\n输出: false\n```\n\n题目难度：⭐⭐⭐\n\n## 题目解析\n\n这是一道有点难度的题，如果你看了一遍题目之后，没有什么好的想法，不用心急，深呼吸，让我们一起来探索如何解决这道题。\n\n其实题目的要求，就是实现一个最简单的正则表达式，即`.`与`*`的匹配，一提到正则表达式，你也许会想到形如 `^[A-Z]:\\\\{1,2}[^/:\\*\\?<>\\|]+\\.(jpg|gif|png|bmp)$` 之类的一大串乱七八糟的代码，觉得看着都蛋疼，还要让我来实现？？？emmmm，不要方，问题不大，不要被`正则表达式`这个名号给吓到，要相信，问题总比方法多🤣。何况这里只需要解析两个特殊字符，岂不是小菜一碟。\n\n明人不说骚话，撸起袖子就开干。\n\n先重新阅读一遍题目，对题目要求的理解和把握很关键，这决定了之后的思考会不会跑偏，后面的几个示例可以用来验证自己理解是否正确。\n\n从后面给的栗子里可以看出，题目的意思是要求字符串s与字符模式p能完全匹配才能算是通过，而不是在s中找到一个p能匹配的子字符串。\n\n脑袋一拍，那一个字符一个字符来匹配不就完事了？嗯，先试试看。把题中的栗子拿出来画成图，然后进行观察。\n\n{% asset_img example1.png example1 %}\n\n{% asset_img example2.png example2 %}\n\n{% asset_img example3.png example3 %}\n\n{% asset_img example4.png example4 %}\n\n在形成自己的思路后，一定要对这几个栗子进行验证，不然代码写完以后才发现理解错了题目的意思就很尴尬了。🌝\n\n对于一个位于字符模式p中的字符c来说，只有三种情况：\n\n1. c == '.'\n2. c == '*'\n3. c 为其他普通字符\n\n我们先来看第一种情况，当`c == '.'`的时候，因为可以匹配任意字符，那么，直接跳过即可，对于第三种情况，那么只要`s`中对应的字符字符`c`相同即可，你看，很简单吧，我们已经完成三分之二了。接下来，再来看看最后一种情况。\n\n如果`c == *`，那么代表可以匹配零个或者多个前面的字符，比如`a*`可以匹配`a`、`aaaa`、`aaaaa`也可以匹配空字符，所以它其实是个修饰符，用来修饰它前面的字符，必须要跟其他字符一起使用，所以在我们在一个个遍历模式串中的字符的时候，还需看看后面跟的字符是不是`*`，如果是的话，那么就要进行特殊处理了。\n\n`*`代表匹配0个或多个它前面的字符，所以有两种情况，一种是0个，一种是多个。\n\n梳理一下思路，每次从p中拿出一个字符来与s中的字符进行匹配，如果该字符后续的字符不是`*`，那么直接与s中对应字符进行匹配判断即可，如果匹配上了，那么就将两个游标都往后移动一位。如果匹配过程中遇到不相等的情况，则直接返回false。如果后续字符是`*`，那么就如上面所分析的，分成两种情况，一种是匹配0个，那么只需要跳过p中的这两个字符，继续与s中的字符进行比较即可，如果是匹配多个，那么将s中的游标往后移动一个，继续进行判断，这两个条件只要其中一个能满足即可。\n\n对于上面分析`*`字符的说明也许还不够清晰，继续画图：\n\n{% asset_img solution1-1.png solution1 %}\n\n{% asset_img solution1-2.png solution1 %}\n\n{% asset_img solution1-3.png solution1 %}\n\n{% asset_img solution1-4.png solution1 %}\n\n等等，你有没有闻到一丝递归的味道，既然对于每个在模式串中的字符都可以采用相同的策略进行处理，那不就是暗示这里可以使用递归吗。机智如我😝\n\n## 递归解法\n\n先来写一下伪代码来继续理清思路，毕竟这可是一道复杂度为三星级别的题，万万不可轻敌。\n\n```java\nboolean isMatch (String s, String p){\n    从p中取出字符c1，从s中取出字符d1\n    从p中再取一个字符c2\n    if (c2 == '*'){\n        跳过c1与c2或者将s的游标往后移动一位\n        return isMatch(s,p.subString(2)) || (( c1 == '.' || c1 == d1) && isMatch(s.subString(1),p)));\n    } else if(c1 == '.'){\n        直接跳过\n        return isMatch(s.subString(1),p.subString(1);\n    } else {\n        普通字符直接比较\n        return c1 == d1 && isMatch(s.subString(1), p.subString(1));\n    }\n}\n```\n\nemmm，这个伪代码好像不太合格，几乎把代码写完了，23333，接下来只需要考虑一下边界情况，把代码补全就行了，当然，还可以将代码美化一下：\n\n```java\npublic boolean isMatch(String s, String p){\n    if (p.length() <= 0) return s.length() <= 0;\n    boolean match = (s.length() > 0 && (s.charAt(0) == p.charAt(0) || p.charAt(0) == '.'));\n    if (p.length() > 1 && p.charAt(1) == '*'){\n        return isMatch(s, p.substring(2)) || (match && isMatch(s.substring(1), p));\n    } else {\n        return match && isMatch(s.substring(1), p.substring(1));\n    }\n}\n```\n\n大功告成，提交一下。\n\n{% asset_img result1.png result1 %}\n\nemmm，递归的效率一般都比较差，只击败了28%的用户。\n\n当然，一般能用递归解决的地方，都可以使用非递归的方式解决，下面，我们来使用另一种解决方案。\n\n## 动态规划解法\n\n### 动态规划简介\n\n动态规划？？？emmm，如果你不经常接触算法的话，也许对这个名词不太熟悉，所以我先简单的介绍一下。\n\n动态规划，简单来说就是，动态的去进行，规划。😂言归正传，其实动态规划也是一种分治的思想，将问题分解成一个个子问题，通过解决所有子问题，来求得原问题的解，一般用于求解最优问题。但是跟分治法不同的地方在于，动态规划的子问题往往是相互关联的，拿最简单的斐波拉契数列来说，我们使用分治的思想，对于求`fib(6)`，使用的公式是`fib(6) = fib(5) + fib(4)`，于是将原来的问题便转化为求解`fib(5)`和`fib(4)`，继续递归，`fib(5) = fib(4) + fib(3)`，然后再继续递归`fib(4) = fib(3) + fib(2) `、`fib(3) = fib(2) + fib(1) `这里`fib(1) = 1` 和 `fib(2) = 1`为初始条件，于是就能求出`fib(6)`，初看起来似乎没什么毛病，但是仔细想一想，由于每次递归都是无状态的，所以其实做了很多重复的计算，画个图来感受一下：\n\n{% asset_img fib6.png fib %}\n\n这里将fib(4)重复算了2次，fib(3)算了3次，这还只是算fib(6)，如果是fib(66)呢？那将会有大量的重复计算，这是非常浪费时间的。\n\n动态规划就可以很好的解决这个问题，动态规划的思想跟上面是一样的，但不同的是，动态规划会将每次计算的结果存起来，因此就解决了。简单一点理解，就是在分治的基础上加入了一个状态数组，来存储中间计算的结果，以减少重复计算的耗时。当然，动态规划又分为两种，一种是自顶向下，就是刚才所说的方法，另一个种是自底向上，还是拿上面的斐波拉契数列来说，要计算fib(6)，因此我们先计算`fib(3) = fib(2) + fib(1) `，再计算`fib(4) = fib(3) + fib(2) `和`fib(5) = fib(4) + fib(3)`，这样，就能算出`fib(6) = fib(5) + fib(4)`的结果了。\n\n在动态规划中有几个比较关键的概念：子问题，状态，状态空间，初始状态，状态转移方程。\n\n子问题：与原问题形式相同或者类似，只不过规模变小了，子问题都解决后，原问题即解决。\n\n状态：与子问题相关的各个变量的一组取值即为状态，状态与子问题是一对一或一对多的关系，代表着子问题的解。上面的栗子，状态就是`fib(n)`的值。\n\n状态空间：由所有状态构成的集合，上面的栗子比较简单，状态空间是一维空间。\n\n状态初始条件：即状态的初始状态，上面的栗子里`fib(1) = 1`和`fib(2) = 1`就是初始条件。\n\n状态转移方程：用来表示状态之间是如何转换的方程，即如何从一个或者多个已知的状态求出另一个状态，可以使用递推公式表示。上面栗子的公式为`fib(n) = f(n - 1) + f(n -2)  (n > 2)`\n\n### 算法过程\n\n关于动态规划的介绍就结束了，接下来我们来看如何在这道题上面使用。\n\n我们先来考虑自顶向下的算法。为方便起见，假定使用符号`s[i:]`表示字符串s中从第i个字符到最后一个字符组成的子串，p[j:]则表示模式串p中，从第j个字符到最后一个字符组成的子串，使用 `match(i,j)` 表示`s[i:]`与`p[j:]`的匹配情况，如果能匹配，则置为true，否则置为false。这就是各个子问题的状态。\n\n那么对于`match(i,j)`的值，取决于`p[j + 1]`是否为'*'。\n\ncurMatch = i < s.length() && s[i] == p[j] || p[j] == '.';\n1. p[j + 1] != '*'，match(i,j) = curMatch && match(i + 1, j + 1)\n2. p[j + 1] == '*'，match(i,j) = match(i, j + 2) || curMatch && match(i + 1, j)\n\n这样表述一下是不是就清晰了不少。\n\n以`s = \"aab\"; p = \"c*a*b\"`为例，先构建一个二维状态空间来存储中间计算得出的状态值。横向的值代表i，纵向的值代表j，match(0,0)的值即问题的解，用`f`代表`false`，`t`代表`true`。\n\n{% asset_img solution2-1.png solution2 %}\n\n接下来描述一下后续的计算过程：\n\n```java\n1. 求match(0,0): i = 0; j = 0; curMatch = false;\n2. p[1] == * -> match(0,0) = match(0,2) || false && match(1,0)\n3. 转化为求子问题match(0,2)和match(1,0)\n4. 求match(0,2): i = 0; j = 2; curMatch = true;\n5. p[1] == * -> match(0,2) = match(0,4) || true && match(1,2)\n6. 求match(0,4): i = 0; j = 4; curMatch = false;\n7. j + 1 == 5 >= p.length() -> match(0,4) = curMatch = false;\n8. match(0,4) = false;\n9. 回溯到第五步，求match(1,2): i = 1; j = 2; curMatch = true;\n10. p[3] == * -> match(1,2) = match(1,4) || true && match(2,2)\n11. 求match(1,4): i = 1; j = 4; curMatch = false;\n12. j + 1 == 5 >= p.length() -> match(1,4) = curMatch = false;\n13. match(1,4) = false;\n14. 回溯到第10步，求match(2,2): i = 2; j = 2; curMatch = false;\n15. p[3] == * -> match(2,2) = match(2,4) || false && match(3,2)\n16. 求match(2,4): i = 2; j = 4; curMatch = true;\n17.  j + 1 == 5 >= p.length() -> match(2,4) = curMatch = true;\n18. match(2,4) = true;\n19. 回溯到第15步。\n20. match(2,2) = true;\n21. 回溯到第10步。\n22. match(1,2) = true;\n23. 回溯到第5步。\n24. match(0,2) = true;\n25. 回溯到第2步。\n26. match(0,0) = true;\n27. 问题解决\n```\n\n{% asset_img solution2-2.png solution2 %}\n\n你看，其实很简单吧。😅\n\n接下来转化成代码：\n\n```java\nenum Result {\n    TRUE, FALSE\n}\n\nclass Solution {\n    // 状态空间\n    Result[][] memo;\n\n    public boolean isMatch(String text, String pattern) {\n        memo = new Result[text.length() + 1][pattern.length() + 1];\n        return match(0, 0, text, pattern);\n    }\n\n    public boolean match(int i, int j, String text, String pattern) {\n        if (memo[i][j] != null) {\n            return memo[i][j] == Result.TRUE;\n        }\n        boolean ans;\n        if (j == pattern.length()){\n            ans = i == text.length();\n        } else{\n            boolean curMatch = (i < text.length() &&\n                                   (pattern.charAt(j) == text.charAt(i) ||\n                                    pattern.charAt(j) == '.'));\n\n            if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                ans = (match(i, j+2, text, pattern) ||\n                       curMatch && match(i+1, j, text, pattern));\n            } else {\n                ans = curMatch && match(i+1, j+1, text, pattern);\n            }\n        }\n        memo[i][j] = ans ? Result.TRUE : Result.FALSE;\n        return ans;\n    }\n}\n```\n\n来跑一下结果：\n\n{% asset_img result2.png result2 %}\n\n击败了99.95%，不错不错。\n\n已经很晚了，但我还是想把另一种方法也一起写完。🙄\n\n还有一种方法，叫做自底向上方法，也是动态规划中的一种，这种方法的思路其实很简单粗暴，即从最后一个字符开始反向匹配，还是以刚才的栗子为例，从i = 3, j = 5 开始依次往左往上循环计算，match(3,5) == true，核心的逻辑并没有变。因为最边缘的值的匹配都是可以直接计算出来的，下面推算其中的一部分：\n\n```java\n1. match(3,5) = true;\n2. 求match(3,4): i = 3; j = 4; curMatch = false;\n3. j + 1 == 5 >= p.length() -> match(3,4) = curMatch = false;\n4. match(3,4) = false;\n5. 求match(3,3): i = 3; j = 3; curMatch = false;\n6. p[4] == b -> match(3,3) = curMatch = false;\n7. match(3,3) = false;\n8. 求match(3,2): i = 3; j = 2; curMatch = false;\n9. p[3] == * -> match(3,2) = match(3,4) || false && match(4,2)\n10. match(3,2) = false;\n11. 求match(3,1): i = 3; j = 1; curMatch = false;\n12. p[2] == a -> match(3,1) = curMatch = false;\n13. match(3,1) = false;\n14. 求match(3,0): i = 3; j = 0; curMatch = false;\n15. p[1] == * -> match(3,0) = match(3,2) || false && match(4,0)\n16. match(3,0) = false;\n17. ....\n```\n\n剩下的部分可以自行推导。代码如下：\n\n```java \nclass Solution {\n    public boolean isMatch(String text, String pattern) {\n        boolean[][] memo = new boolean[text.length() + 1][pattern.length() + 1];\n        memo[text.length()][pattern.length()] = true;\n\n        for (int i = text.length(); i >= 0; i--){\n            for (int j = pattern.length() - 1; j >= 0; j--){\n                boolean curMatch = (i < text.length() &&\n                                       (pattern.charAt(j) == text.charAt(i) ||\n                                        pattern.charAt(j) == '.'));\n                if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                    memo[i][j] = memo[i][j+2] || curMatch && memo[i+1][j];\n                } else {\n                    memo[i][j] = curMatch && memo[i+1][j+1];\n                }\n            }\n        }\n        return memo[0][0];\n    }\n}\n```\n\n提交一下：\n\n{% asset_img result3.png result3 %}\n\n效率也是相当高的，虽然比自顶向下方法多计算了不少值，但是减少了方法调用次数，省去了多次递归调用方法的开销，而且每次计算的过程相当简单，所以并不能说它的效率比自顶向下的方法低，要视具体情况而定。\n\n## 总结\n\n写到这，今天的题总算是完成的差不多了，长呼一口，来回顾一下今天的收获吧：\n\n首先我们用分治法，使用递归来解决，但是效率偏低。\n\n于是我们用了动态规划的思想来解决这个问题，与分治法最大的不同便在于动态规划会存储中间的计算状态，以减少重复计算。\n\n先是用了自顶向下的方法，跟分治法几乎没有差异，只是多使用了一个二维数组。\n\n接着用自底向上的方法来解决，从最后的字符开始匹配，将多次递归调用转为在一个循环体中完成。\n\n总结一下动态规划的步骤：\n\n1. 抽象问题。将问题分解为多个子问题，子问题的解一旦求出就会被保存。\n2. 确定状态。确认我们要求解的子问题的状态空间，并设置初始状态。\n3. 确定状态转移方程。这一步是最难也是最重要的一步。\n","source":"_posts/leetcode/day4-regular-expression-matching.md","raw":"---\ntitle: 【LeetCode】正则表达式匹配\ndate: 2019-03-03 15:40:30\ntags: \n - Java\n - 算法\n - LeetCode\n - 动态规划\ncategories: 编程\n---\n\n## 题目描述\n\n给定一个字符串 (s) 和一个字符模式 (p)。实现支持 '.' 和 '*' 的正则表达式匹配。\n\n'.' 匹配任意单个字符。\n'*' 匹配零个或多个前面的元素。\n匹配应该覆盖整个字符串 (s) ，而不是部分字符串。\n\n说明:\n\ns 可能为空，且只包含从 a-z 的小写字母。\np 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。\n示例 1:\n\n```bash\n输入:\ns = \"aa\"\np = \"a\"\n输出: false\n解释: \"a\" 无法匹配 \"aa\" 整个字符串。\n```\n\n示例 2:\n```bash\n输入:\ns = \"aa\"\np = \"a*\"\n输出: true\n解释: '*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 \"aa\"。\n```\n\n示例 3:\n```bash\n输入:\ns = \"ab\"\np = \".*\"\n输出: true\n解释: \".*\" 表示可匹配零个或多个('*')任意字符('.')。\n```\n\n示例 4:\n```bash\n输入:\ns = \"aab\"\np = \"c*a*b\"\n输出: true\n解释: 'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 \"aab\"。\n```\n\n示例 5:\n```bash\n输入:\ns = \"mississippi\"\np = \"mis*is*p*.\"\n输出: false\n```\n\n题目难度：⭐⭐⭐\n\n## 题目解析\n\n这是一道有点难度的题，如果你看了一遍题目之后，没有什么好的想法，不用心急，深呼吸，让我们一起来探索如何解决这道题。\n\n其实题目的要求，就是实现一个最简单的正则表达式，即`.`与`*`的匹配，一提到正则表达式，你也许会想到形如 `^[A-Z]:\\\\{1,2}[^/:\\*\\?<>\\|]+\\.(jpg|gif|png|bmp)$` 之类的一大串乱七八糟的代码，觉得看着都蛋疼，还要让我来实现？？？emmmm，不要方，问题不大，不要被`正则表达式`这个名号给吓到，要相信，问题总比方法多🤣。何况这里只需要解析两个特殊字符，岂不是小菜一碟。\n\n明人不说骚话，撸起袖子就开干。\n\n先重新阅读一遍题目，对题目要求的理解和把握很关键，这决定了之后的思考会不会跑偏，后面的几个示例可以用来验证自己理解是否正确。\n\n从后面给的栗子里可以看出，题目的意思是要求字符串s与字符模式p能完全匹配才能算是通过，而不是在s中找到一个p能匹配的子字符串。\n\n脑袋一拍，那一个字符一个字符来匹配不就完事了？嗯，先试试看。把题中的栗子拿出来画成图，然后进行观察。\n\n{% asset_img example1.png example1 %}\n\n{% asset_img example2.png example2 %}\n\n{% asset_img example3.png example3 %}\n\n{% asset_img example4.png example4 %}\n\n在形成自己的思路后，一定要对这几个栗子进行验证，不然代码写完以后才发现理解错了题目的意思就很尴尬了。🌝\n\n对于一个位于字符模式p中的字符c来说，只有三种情况：\n\n1. c == '.'\n2. c == '*'\n3. c 为其他普通字符\n\n我们先来看第一种情况，当`c == '.'`的时候，因为可以匹配任意字符，那么，直接跳过即可，对于第三种情况，那么只要`s`中对应的字符字符`c`相同即可，你看，很简单吧，我们已经完成三分之二了。接下来，再来看看最后一种情况。\n\n如果`c == *`，那么代表可以匹配零个或者多个前面的字符，比如`a*`可以匹配`a`、`aaaa`、`aaaaa`也可以匹配空字符，所以它其实是个修饰符，用来修饰它前面的字符，必须要跟其他字符一起使用，所以在我们在一个个遍历模式串中的字符的时候，还需看看后面跟的字符是不是`*`，如果是的话，那么就要进行特殊处理了。\n\n`*`代表匹配0个或多个它前面的字符，所以有两种情况，一种是0个，一种是多个。\n\n梳理一下思路，每次从p中拿出一个字符来与s中的字符进行匹配，如果该字符后续的字符不是`*`，那么直接与s中对应字符进行匹配判断即可，如果匹配上了，那么就将两个游标都往后移动一位。如果匹配过程中遇到不相等的情况，则直接返回false。如果后续字符是`*`，那么就如上面所分析的，分成两种情况，一种是匹配0个，那么只需要跳过p中的这两个字符，继续与s中的字符进行比较即可，如果是匹配多个，那么将s中的游标往后移动一个，继续进行判断，这两个条件只要其中一个能满足即可。\n\n对于上面分析`*`字符的说明也许还不够清晰，继续画图：\n\n{% asset_img solution1-1.png solution1 %}\n\n{% asset_img solution1-2.png solution1 %}\n\n{% asset_img solution1-3.png solution1 %}\n\n{% asset_img solution1-4.png solution1 %}\n\n等等，你有没有闻到一丝递归的味道，既然对于每个在模式串中的字符都可以采用相同的策略进行处理，那不就是暗示这里可以使用递归吗。机智如我😝\n\n## 递归解法\n\n先来写一下伪代码来继续理清思路，毕竟这可是一道复杂度为三星级别的题，万万不可轻敌。\n\n```java\nboolean isMatch (String s, String p){\n    从p中取出字符c1，从s中取出字符d1\n    从p中再取一个字符c2\n    if (c2 == '*'){\n        跳过c1与c2或者将s的游标往后移动一位\n        return isMatch(s,p.subString(2)) || (( c1 == '.' || c1 == d1) && isMatch(s.subString(1),p)));\n    } else if(c1 == '.'){\n        直接跳过\n        return isMatch(s.subString(1),p.subString(1);\n    } else {\n        普通字符直接比较\n        return c1 == d1 && isMatch(s.subString(1), p.subString(1));\n    }\n}\n```\n\nemmm，这个伪代码好像不太合格，几乎把代码写完了，23333，接下来只需要考虑一下边界情况，把代码补全就行了，当然，还可以将代码美化一下：\n\n```java\npublic boolean isMatch(String s, String p){\n    if (p.length() <= 0) return s.length() <= 0;\n    boolean match = (s.length() > 0 && (s.charAt(0) == p.charAt(0) || p.charAt(0) == '.'));\n    if (p.length() > 1 && p.charAt(1) == '*'){\n        return isMatch(s, p.substring(2)) || (match && isMatch(s.substring(1), p));\n    } else {\n        return match && isMatch(s.substring(1), p.substring(1));\n    }\n}\n```\n\n大功告成，提交一下。\n\n{% asset_img result1.png result1 %}\n\nemmm，递归的效率一般都比较差，只击败了28%的用户。\n\n当然，一般能用递归解决的地方，都可以使用非递归的方式解决，下面，我们来使用另一种解决方案。\n\n## 动态规划解法\n\n### 动态规划简介\n\n动态规划？？？emmm，如果你不经常接触算法的话，也许对这个名词不太熟悉，所以我先简单的介绍一下。\n\n动态规划，简单来说就是，动态的去进行，规划。😂言归正传，其实动态规划也是一种分治的思想，将问题分解成一个个子问题，通过解决所有子问题，来求得原问题的解，一般用于求解最优问题。但是跟分治法不同的地方在于，动态规划的子问题往往是相互关联的，拿最简单的斐波拉契数列来说，我们使用分治的思想，对于求`fib(6)`，使用的公式是`fib(6) = fib(5) + fib(4)`，于是将原来的问题便转化为求解`fib(5)`和`fib(4)`，继续递归，`fib(5) = fib(4) + fib(3)`，然后再继续递归`fib(4) = fib(3) + fib(2) `、`fib(3) = fib(2) + fib(1) `这里`fib(1) = 1` 和 `fib(2) = 1`为初始条件，于是就能求出`fib(6)`，初看起来似乎没什么毛病，但是仔细想一想，由于每次递归都是无状态的，所以其实做了很多重复的计算，画个图来感受一下：\n\n{% asset_img fib6.png fib %}\n\n这里将fib(4)重复算了2次，fib(3)算了3次，这还只是算fib(6)，如果是fib(66)呢？那将会有大量的重复计算，这是非常浪费时间的。\n\n动态规划就可以很好的解决这个问题，动态规划的思想跟上面是一样的，但不同的是，动态规划会将每次计算的结果存起来，因此就解决了。简单一点理解，就是在分治的基础上加入了一个状态数组，来存储中间计算的结果，以减少重复计算的耗时。当然，动态规划又分为两种，一种是自顶向下，就是刚才所说的方法，另一个种是自底向上，还是拿上面的斐波拉契数列来说，要计算fib(6)，因此我们先计算`fib(3) = fib(2) + fib(1) `，再计算`fib(4) = fib(3) + fib(2) `和`fib(5) = fib(4) + fib(3)`，这样，就能算出`fib(6) = fib(5) + fib(4)`的结果了。\n\n在动态规划中有几个比较关键的概念：子问题，状态，状态空间，初始状态，状态转移方程。\n\n子问题：与原问题形式相同或者类似，只不过规模变小了，子问题都解决后，原问题即解决。\n\n状态：与子问题相关的各个变量的一组取值即为状态，状态与子问题是一对一或一对多的关系，代表着子问题的解。上面的栗子，状态就是`fib(n)`的值。\n\n状态空间：由所有状态构成的集合，上面的栗子比较简单，状态空间是一维空间。\n\n状态初始条件：即状态的初始状态，上面的栗子里`fib(1) = 1`和`fib(2) = 1`就是初始条件。\n\n状态转移方程：用来表示状态之间是如何转换的方程，即如何从一个或者多个已知的状态求出另一个状态，可以使用递推公式表示。上面栗子的公式为`fib(n) = f(n - 1) + f(n -2)  (n > 2)`\n\n### 算法过程\n\n关于动态规划的介绍就结束了，接下来我们来看如何在这道题上面使用。\n\n我们先来考虑自顶向下的算法。为方便起见，假定使用符号`s[i:]`表示字符串s中从第i个字符到最后一个字符组成的子串，p[j:]则表示模式串p中，从第j个字符到最后一个字符组成的子串，使用 `match(i,j)` 表示`s[i:]`与`p[j:]`的匹配情况，如果能匹配，则置为true，否则置为false。这就是各个子问题的状态。\n\n那么对于`match(i,j)`的值，取决于`p[j + 1]`是否为'*'。\n\ncurMatch = i < s.length() && s[i] == p[j] || p[j] == '.';\n1. p[j + 1] != '*'，match(i,j) = curMatch && match(i + 1, j + 1)\n2. p[j + 1] == '*'，match(i,j) = match(i, j + 2) || curMatch && match(i + 1, j)\n\n这样表述一下是不是就清晰了不少。\n\n以`s = \"aab\"; p = \"c*a*b\"`为例，先构建一个二维状态空间来存储中间计算得出的状态值。横向的值代表i，纵向的值代表j，match(0,0)的值即问题的解，用`f`代表`false`，`t`代表`true`。\n\n{% asset_img solution2-1.png solution2 %}\n\n接下来描述一下后续的计算过程：\n\n```java\n1. 求match(0,0): i = 0; j = 0; curMatch = false;\n2. p[1] == * -> match(0,0) = match(0,2) || false && match(1,0)\n3. 转化为求子问题match(0,2)和match(1,0)\n4. 求match(0,2): i = 0; j = 2; curMatch = true;\n5. p[1] == * -> match(0,2) = match(0,4) || true && match(1,2)\n6. 求match(0,4): i = 0; j = 4; curMatch = false;\n7. j + 1 == 5 >= p.length() -> match(0,4) = curMatch = false;\n8. match(0,4) = false;\n9. 回溯到第五步，求match(1,2): i = 1; j = 2; curMatch = true;\n10. p[3] == * -> match(1,2) = match(1,4) || true && match(2,2)\n11. 求match(1,4): i = 1; j = 4; curMatch = false;\n12. j + 1 == 5 >= p.length() -> match(1,4) = curMatch = false;\n13. match(1,4) = false;\n14. 回溯到第10步，求match(2,2): i = 2; j = 2; curMatch = false;\n15. p[3] == * -> match(2,2) = match(2,4) || false && match(3,2)\n16. 求match(2,4): i = 2; j = 4; curMatch = true;\n17.  j + 1 == 5 >= p.length() -> match(2,4) = curMatch = true;\n18. match(2,4) = true;\n19. 回溯到第15步。\n20. match(2,2) = true;\n21. 回溯到第10步。\n22. match(1,2) = true;\n23. 回溯到第5步。\n24. match(0,2) = true;\n25. 回溯到第2步。\n26. match(0,0) = true;\n27. 问题解决\n```\n\n{% asset_img solution2-2.png solution2 %}\n\n你看，其实很简单吧。😅\n\n接下来转化成代码：\n\n```java\nenum Result {\n    TRUE, FALSE\n}\n\nclass Solution {\n    // 状态空间\n    Result[][] memo;\n\n    public boolean isMatch(String text, String pattern) {\n        memo = new Result[text.length() + 1][pattern.length() + 1];\n        return match(0, 0, text, pattern);\n    }\n\n    public boolean match(int i, int j, String text, String pattern) {\n        if (memo[i][j] != null) {\n            return memo[i][j] == Result.TRUE;\n        }\n        boolean ans;\n        if (j == pattern.length()){\n            ans = i == text.length();\n        } else{\n            boolean curMatch = (i < text.length() &&\n                                   (pattern.charAt(j) == text.charAt(i) ||\n                                    pattern.charAt(j) == '.'));\n\n            if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                ans = (match(i, j+2, text, pattern) ||\n                       curMatch && match(i+1, j, text, pattern));\n            } else {\n                ans = curMatch && match(i+1, j+1, text, pattern);\n            }\n        }\n        memo[i][j] = ans ? Result.TRUE : Result.FALSE;\n        return ans;\n    }\n}\n```\n\n来跑一下结果：\n\n{% asset_img result2.png result2 %}\n\n击败了99.95%，不错不错。\n\n已经很晚了，但我还是想把另一种方法也一起写完。🙄\n\n还有一种方法，叫做自底向上方法，也是动态规划中的一种，这种方法的思路其实很简单粗暴，即从最后一个字符开始反向匹配，还是以刚才的栗子为例，从i = 3, j = 5 开始依次往左往上循环计算，match(3,5) == true，核心的逻辑并没有变。因为最边缘的值的匹配都是可以直接计算出来的，下面推算其中的一部分：\n\n```java\n1. match(3,5) = true;\n2. 求match(3,4): i = 3; j = 4; curMatch = false;\n3. j + 1 == 5 >= p.length() -> match(3,4) = curMatch = false;\n4. match(3,4) = false;\n5. 求match(3,3): i = 3; j = 3; curMatch = false;\n6. p[4] == b -> match(3,3) = curMatch = false;\n7. match(3,3) = false;\n8. 求match(3,2): i = 3; j = 2; curMatch = false;\n9. p[3] == * -> match(3,2) = match(3,4) || false && match(4,2)\n10. match(3,2) = false;\n11. 求match(3,1): i = 3; j = 1; curMatch = false;\n12. p[2] == a -> match(3,1) = curMatch = false;\n13. match(3,1) = false;\n14. 求match(3,0): i = 3; j = 0; curMatch = false;\n15. p[1] == * -> match(3,0) = match(3,2) || false && match(4,0)\n16. match(3,0) = false;\n17. ....\n```\n\n剩下的部分可以自行推导。代码如下：\n\n```java \nclass Solution {\n    public boolean isMatch(String text, String pattern) {\n        boolean[][] memo = new boolean[text.length() + 1][pattern.length() + 1];\n        memo[text.length()][pattern.length()] = true;\n\n        for (int i = text.length(); i >= 0; i--){\n            for (int j = pattern.length() - 1; j >= 0; j--){\n                boolean curMatch = (i < text.length() &&\n                                       (pattern.charAt(j) == text.charAt(i) ||\n                                        pattern.charAt(j) == '.'));\n                if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                    memo[i][j] = memo[i][j+2] || curMatch && memo[i+1][j];\n                } else {\n                    memo[i][j] = curMatch && memo[i+1][j+1];\n                }\n            }\n        }\n        return memo[0][0];\n    }\n}\n```\n\n提交一下：\n\n{% asset_img result3.png result3 %}\n\n效率也是相当高的，虽然比自顶向下方法多计算了不少值，但是减少了方法调用次数，省去了多次递归调用方法的开销，而且每次计算的过程相当简单，所以并不能说它的效率比自顶向下的方法低，要视具体情况而定。\n\n## 总结\n\n写到这，今天的题总算是完成的差不多了，长呼一口，来回顾一下今天的收获吧：\n\n首先我们用分治法，使用递归来解决，但是效率偏低。\n\n于是我们用了动态规划的思想来解决这个问题，与分治法最大的不同便在于动态规划会存储中间的计算状态，以减少重复计算。\n\n先是用了自顶向下的方法，跟分治法几乎没有差异，只是多使用了一个二维数组。\n\n接着用自底向上的方法来解决，从最后的字符开始匹配，将多次递归调用转为在一个循环体中完成。\n\n总结一下动态规划的步骤：\n\n1. 抽象问题。将问题分解为多个子问题，子问题的解一旦求出就会被保存。\n2. 确定状态。确认我们要求解的子问题的状态空间，并设置初始状态。\n3. 确定状态转移方程。这一步是最难也是最重要的一步。\n","slug":"leetcode/day4-regular-expression-matching","published":1,"updated":"2019-06-04T01:29:57.438Z","_id":"cjxze3gpc001y0cvw806qtrv7","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个字符串 (s) 和一个字符模式 (p)。实现支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>\n<p>‘.’ 匹配任意单个字符。<br>‘*’ 匹配零个或多个前面的元素。<br>匹配应该覆盖整个字符串 (s) ，而不是部分字符串。</p>\n<p>说明:</p>\n<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。<br>示例 1:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">s = <span class=\"string\">\"aa\"</span></span><br><span class=\"line\">p = <span class=\"string\">\"a\"</span></span><br><span class=\"line\">输出: <span class=\"literal\">false</span></span><br><span class=\"line\">解释: <span class=\"string\">\"a\"</span> 无法匹配 <span class=\"string\">\"aa\"</span> 整个字符串。</span><br></pre></td></tr></table></figure>\n<p>示例 2:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">s = <span class=\"string\">\"aa\"</span></span><br><span class=\"line\">p = <span class=\"string\">\"a*\"</span></span><br><span class=\"line\">输出: <span class=\"literal\">true</span></span><br><span class=\"line\">解释: <span class=\"string\">'*'</span> 代表可匹配零个或多个前面的元素, 即可以匹配 <span class=\"string\">'a'</span> 。因此, 重复 <span class=\"string\">'a'</span> 一次, 字符串可变为 <span class=\"string\">\"aa\"</span>。</span><br></pre></td></tr></table></figure></p>\n<p>示例 3:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">s = <span class=\"string\">\"ab\"</span></span><br><span class=\"line\">p = <span class=\"string\">\".*\"</span></span><br><span class=\"line\">输出: <span class=\"literal\">true</span></span><br><span class=\"line\">解释: <span class=\"string\">\".*\"</span> 表示可匹配零个或多个(<span class=\"string\">'*'</span>)任意字符(<span class=\"string\">'.'</span>)。</span><br></pre></td></tr></table></figure></p>\n<p>示例 4:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">s = <span class=\"string\">\"aab\"</span></span><br><span class=\"line\">p = <span class=\"string\">\"c*a*b\"</span></span><br><span class=\"line\">输出: <span class=\"literal\">true</span></span><br><span class=\"line\">解释: <span class=\"string\">'c'</span> 可以不被重复, <span class=\"string\">'a'</span> 可以被重复一次。因此可以匹配字符串 <span class=\"string\">\"aab\"</span>。</span><br></pre></td></tr></table></figure></p>\n<p>示例 5:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">s = <span class=\"string\">\"mississippi\"</span></span><br><span class=\"line\">p = <span class=\"string\">\"mis*is*p*.\"</span></span><br><span class=\"line\">输出: <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure></p>\n<p>题目难度：⭐⭐⭐</p>\n<h2 id=\"题目解析\"><a href=\"#题目解析\" class=\"headerlink\" title=\"题目解析\"></a>题目解析</h2><p>这是一道有点难度的题，如果你看了一遍题目之后，没有什么好的想法，不用心急，深呼吸，让我们一起来探索如何解决这道题。</p>\n<p>其实题目的要求，就是实现一个最简单的正则表达式，即<code>.</code>与<code>*</code>的匹配，一提到正则表达式，你也许会想到形如 <code>^[A-Z]:\\\\{1,2}[^/:\\*\\?&lt;&gt;\\|]+\\.(jpg|gif|png|bmp)$</code> 之类的一大串乱七八糟的代码，觉得看着都蛋疼，还要让我来实现？？？emmmm，不要方，问题不大，不要被<code>正则表达式</code>这个名号给吓到，要相信，问题总比方法多🤣。何况这里只需要解析两个特殊字符，岂不是小菜一碟。</p>\n<p>明人不说骚话，撸起袖子就开干。</p>\n<p>先重新阅读一遍题目，对题目要求的理解和把握很关键，这决定了之后的思考会不会跑偏，后面的几个示例可以用来验证自己理解是否正确。</p>\n<p>从后面给的栗子里可以看出，题目的意思是要求字符串s与字符模式p能完全匹配才能算是通过，而不是在s中找到一个p能匹配的子字符串。</p>\n<p>脑袋一拍，那一个字符一个字符来匹配不就完事了？嗯，先试试看。把题中的栗子拿出来画成图，然后进行观察。</p>\n<img src=\"/programming/leetcode/day4-regular-expression-matching/example1.png\" title=\"example1\">\n<img src=\"/programming/leetcode/day4-regular-expression-matching/example2.png\" title=\"example2\">\n<img src=\"/programming/leetcode/day4-regular-expression-matching/example3.png\" title=\"example3\">\n<img src=\"/programming/leetcode/day4-regular-expression-matching/example4.png\" title=\"example4\">\n<p>在形成自己的思路后，一定要对这几个栗子进行验证，不然代码写完以后才发现理解错了题目的意思就很尴尬了。🌝</p>\n<p>对于一个位于字符模式p中的字符c来说，只有三种情况：</p>\n<ol>\n<li>c == ‘.’</li>\n<li>c == ‘*’</li>\n<li>c 为其他普通字符</li>\n</ol>\n<p>我们先来看第一种情况，当<code>c == &#39;.&#39;</code>的时候，因为可以匹配任意字符，那么，直接跳过即可，对于第三种情况，那么只要<code>s</code>中对应的字符字符<code>c</code>相同即可，你看，很简单吧，我们已经完成三分之二了。接下来，再来看看最后一种情况。</p>\n<p>如果<code>c == *</code>，那么代表可以匹配零个或者多个前面的字符，比如<code>a*</code>可以匹配<code>a</code>、<code>aaaa</code>、<code>aaaaa</code>也可以匹配空字符，所以它其实是个修饰符，用来修饰它前面的字符，必须要跟其他字符一起使用，所以在我们在一个个遍历模式串中的字符的时候，还需看看后面跟的字符是不是<code>*</code>，如果是的话，那么就要进行特殊处理了。</p>\n<p><code>*</code>代表匹配0个或多个它前面的字符，所以有两种情况，一种是0个，一种是多个。</p>\n<p>梳理一下思路，每次从p中拿出一个字符来与s中的字符进行匹配，如果该字符后续的字符不是<code>*</code>，那么直接与s中对应字符进行匹配判断即可，如果匹配上了，那么就将两个游标都往后移动一位。如果匹配过程中遇到不相等的情况，则直接返回false。如果后续字符是<code>*</code>，那么就如上面所分析的，分成两种情况，一种是匹配0个，那么只需要跳过p中的这两个字符，继续与s中的字符进行比较即可，如果是匹配多个，那么将s中的游标往后移动一个，继续进行判断，这两个条件只要其中一个能满足即可。</p>\n<p>对于上面分析<code>*</code>字符的说明也许还不够清晰，继续画图：</p>\n<img src=\"/programming/leetcode/day4-regular-expression-matching/solution1-1.png\" title=\"solution1\">\n<img src=\"/programming/leetcode/day4-regular-expression-matching/solution1-2.png\" title=\"solution1\">\n<img src=\"/programming/leetcode/day4-regular-expression-matching/solution1-3.png\" title=\"solution1\">\n<img src=\"/programming/leetcode/day4-regular-expression-matching/solution1-4.png\" title=\"solution1\">\n<p>等等，你有没有闻到一丝递归的味道，既然对于每个在模式串中的字符都可以采用相同的策略进行处理，那不就是暗示这里可以使用递归吗。机智如我😝</p>\n<h2 id=\"递归解法\"><a href=\"#递归解法\" class=\"headerlink\" title=\"递归解法\"></a>递归解法</h2><p>先来写一下伪代码来继续理清思路，毕竟这可是一道复杂度为三星级别的题，万万不可轻敌。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isMatch</span> <span class=\"params\">(String s, String p)</span></span>&#123;</span><br><span class=\"line\">    从p中取出字符c1，从s中取出字符d1</span><br><span class=\"line\">    从p中再取一个字符c2</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c2 == <span class=\"string\">'*'</span>)&#123;</span><br><span class=\"line\">        跳过c1与c2或者将s的游标往后移动一位</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isMatch(s,p.subString(<span class=\"number\">2</span>)) || (( c1 == <span class=\"string\">'.'</span> || c1 == d1) &amp;&amp; isMatch(s.subString(<span class=\"number\">1</span>),p)));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(c1 == <span class=\"string\">'.'</span>)&#123;</span><br><span class=\"line\">        直接跳过</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isMatch(s.subString(<span class=\"number\">1</span>),p.subString(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        普通字符直接比较</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c1 == d1 &amp;&amp; isMatch(s.subString(<span class=\"number\">1</span>), p.subString(<span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>emmm，这个伪代码好像不太合格，几乎把代码写完了，23333，接下来只需要考虑一下边界情况，把代码补全就行了，当然，还可以将代码美化一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMatch</span><span class=\"params\">(String s, String p)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p.length() &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> s.length() &lt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> match = (s.length() &gt; <span class=\"number\">0</span> &amp;&amp; (s.charAt(<span class=\"number\">0</span>) == p.charAt(<span class=\"number\">0</span>) || p.charAt(<span class=\"number\">0</span>) == <span class=\"string\">'.'</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p.length() &gt; <span class=\"number\">1</span> &amp;&amp; p.charAt(<span class=\"number\">1</span>) == <span class=\"string\">'*'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isMatch(s, p.substring(<span class=\"number\">2</span>)) || (match &amp;&amp; isMatch(s.substring(<span class=\"number\">1</span>), p));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> match &amp;&amp; isMatch(s.substring(<span class=\"number\">1</span>), p.substring(<span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大功告成，提交一下。</p>\n<img src=\"/programming/leetcode/day4-regular-expression-matching/result1.png\" title=\"result1\">\n<p>emmm，递归的效率一般都比较差，只击败了28%的用户。</p>\n<p>当然，一般能用递归解决的地方，都可以使用非递归的方式解决，下面，我们来使用另一种解决方案。</p>\n<h2 id=\"动态规划解法\"><a href=\"#动态规划解法\" class=\"headerlink\" title=\"动态规划解法\"></a>动态规划解法</h2><h3 id=\"动态规划简介\"><a href=\"#动态规划简介\" class=\"headerlink\" title=\"动态规划简介\"></a>动态规划简介</h3><p>动态规划？？？emmm，如果你不经常接触算法的话，也许对这个名词不太熟悉，所以我先简单的介绍一下。</p>\n<p>动态规划，简单来说就是，动态的去进行，规划。😂言归正传，其实动态规划也是一种分治的思想，将问题分解成一个个子问题，通过解决所有子问题，来求得原问题的解，一般用于求解最优问题。但是跟分治法不同的地方在于，动态规划的子问题往往是相互关联的，拿最简单的斐波拉契数列来说，我们使用分治的思想，对于求<code>fib(6)</code>，使用的公式是<code>fib(6) = fib(5) + fib(4)</code>，于是将原来的问题便转化为求解<code>fib(5)</code>和<code>fib(4)</code>，继续递归，<code>fib(5) = fib(4) + fib(3)</code>，然后再继续递归<code>fib(4) = fib(3) + fib(2)</code>、<code>fib(3) = fib(2) + fib(1)</code>这里<code>fib(1) = 1</code> 和 <code>fib(2) = 1</code>为初始条件，于是就能求出<code>fib(6)</code>，初看起来似乎没什么毛病，但是仔细想一想，由于每次递归都是无状态的，所以其实做了很多重复的计算，画个图来感受一下：</p>\n\n<p>这里将fib(4)重复算了2次，fib(3)算了3次，这还只是算fib(6)，如果是fib(66)呢？那将会有大量的重复计算，这是非常浪费时间的。</p>\n<p>动态规划就可以很好的解决这个问题，动态规划的思想跟上面是一样的，但不同的是，动态规划会将每次计算的结果存起来，因此就解决了。简单一点理解，就是在分治的基础上加入了一个状态数组，来存储中间计算的结果，以减少重复计算的耗时。当然，动态规划又分为两种，一种是自顶向下，就是刚才所说的方法，另一个种是自底向上，还是拿上面的斐波拉契数列来说，要计算fib(6)，因此我们先计算<code>fib(3) = fib(2) + fib(1)</code>，再计算<code>fib(4) = fib(3) + fib(2)</code>和<code>fib(5) = fib(4) + fib(3)</code>，这样，就能算出<code>fib(6) = fib(5) + fib(4)</code>的结果了。</p>\n<p>在动态规划中有几个比较关键的概念：子问题，状态，状态空间，初始状态，状态转移方程。</p>\n<p>子问题：与原问题形式相同或者类似，只不过规模变小了，子问题都解决后，原问题即解决。</p>\n<p>状态：与子问题相关的各个变量的一组取值即为状态，状态与子问题是一对一或一对多的关系，代表着子问题的解。上面的栗子，状态就是<code>fib(n)</code>的值。</p>\n<p>状态空间：由所有状态构成的集合，上面的栗子比较简单，状态空间是一维空间。</p>\n<p>状态初始条件：即状态的初始状态，上面的栗子里<code>fib(1) = 1</code>和<code>fib(2) = 1</code>就是初始条件。</p>\n<p>状态转移方程：用来表示状态之间是如何转换的方程，即如何从一个或者多个已知的状态求出另一个状态，可以使用递推公式表示。上面栗子的公式为<code>fib(n) = f(n - 1) + f(n -2)  (n &gt; 2)</code></p>\n<h3 id=\"算法过程\"><a href=\"#算法过程\" class=\"headerlink\" title=\"算法过程\"></a>算法过程</h3><p>关于动态规划的介绍就结束了，接下来我们来看如何在这道题上面使用。</p>\n<p>我们先来考虑自顶向下的算法。为方便起见，假定使用符号<code>s[i:]</code>表示字符串s中从第i个字符到最后一个字符组成的子串，p[j:]则表示模式串p中，从第j个字符到最后一个字符组成的子串，使用 <code>match(i,j)</code> 表示<code>s[i:]</code>与<code>p[j:]</code>的匹配情况，如果能匹配，则置为true，否则置为false。这就是各个子问题的状态。</p>\n<p>那么对于<code>match(i,j)</code>的值，取决于<code>p[j + 1]</code>是否为’*’。</p>\n<p>curMatch = i &lt; s.length() &amp;&amp; s[i] == p[j] || p[j] == ‘.’;</p>\n<ol>\n<li>p[j + 1] != ‘*’，match(i,j) = curMatch &amp;&amp; match(i + 1, j + 1)</li>\n<li>p[j + 1] == ‘*’，match(i,j) = match(i, j + 2) || curMatch &amp;&amp; match(i + 1, j)</li>\n</ol>\n<p>这样表述一下是不是就清晰了不少。</p>\n<p>以<code>s = &quot;aab&quot;; p = &quot;c*a*b&quot;</code>为例，先构建一个二维状态空间来存储中间计算得出的状态值。横向的值代表i，纵向的值代表j，match(0,0)的值即问题的解，用<code>f</code>代表<code>false</code>，<code>t</code>代表<code>true</code>。</p>\n<img src=\"/programming/leetcode/day4-regular-expression-matching/solution2-1.png\" title=\"solution2\">\n<p>接下来描述一下后续的计算过程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>. 求match(<span class=\"number\">0</span>,<span class=\"number\">0</span>): i = <span class=\"number\">0</span>; j = <span class=\"number\">0</span>; curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">2</span>. p[<span class=\"number\">1</span>] == * -&gt; match(<span class=\"number\">0</span>,<span class=\"number\">0</span>) = match(<span class=\"number\">0</span>,<span class=\"number\">2</span>) || <span class=\"keyword\">false</span> &amp;&amp; match(<span class=\"number\">1</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"number\">3</span>. 转化为求子问题match(<span class=\"number\">0</span>,<span class=\"number\">2</span>)和match(<span class=\"number\">1</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"number\">4</span>. 求match(<span class=\"number\">0</span>,<span class=\"number\">2</span>): i = <span class=\"number\">0</span>; j = <span class=\"number\">2</span>; curMatch = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"number\">5</span>. p[<span class=\"number\">1</span>] == * -&gt; match(<span class=\"number\">0</span>,<span class=\"number\">2</span>) = match(<span class=\"number\">0</span>,<span class=\"number\">4</span>) || <span class=\"keyword\">true</span> &amp;&amp; match(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"number\">6</span>. 求match(<span class=\"number\">0</span>,<span class=\"number\">4</span>): i = <span class=\"number\">0</span>; j = <span class=\"number\">4</span>; curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">7</span>. j + <span class=\"number\">1</span> == <span class=\"number\">5</span> &gt;= p.length() -&gt; match(<span class=\"number\">0</span>,<span class=\"number\">4</span>) = curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">8</span>. match(<span class=\"number\">0</span>,<span class=\"number\">4</span>) = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">9</span>. 回溯到第五步，求match(<span class=\"number\">1</span>,<span class=\"number\">2</span>): i = <span class=\"number\">1</span>; j = <span class=\"number\">2</span>; curMatch = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"number\">10</span>. p[<span class=\"number\">3</span>] == * -&gt; match(<span class=\"number\">1</span>,<span class=\"number\">2</span>) = match(<span class=\"number\">1</span>,<span class=\"number\">4</span>) || <span class=\"keyword\">true</span> &amp;&amp; match(<span class=\"number\">2</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"number\">11</span>. 求match(<span class=\"number\">1</span>,<span class=\"number\">4</span>): i = <span class=\"number\">1</span>; j = <span class=\"number\">4</span>; curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">12</span>. j + <span class=\"number\">1</span> == <span class=\"number\">5</span> &gt;= p.length() -&gt; match(<span class=\"number\">1</span>,<span class=\"number\">4</span>) = curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">13</span>. match(<span class=\"number\">1</span>,<span class=\"number\">4</span>) = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">14</span>. 回溯到第<span class=\"number\">10</span>步，求match(<span class=\"number\">2</span>,<span class=\"number\">2</span>): i = <span class=\"number\">2</span>; j = <span class=\"number\">2</span>; curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">15</span>. p[<span class=\"number\">3</span>] == * -&gt; match(<span class=\"number\">2</span>,<span class=\"number\">2</span>) = match(<span class=\"number\">2</span>,<span class=\"number\">4</span>) || <span class=\"keyword\">false</span> &amp;&amp; match(<span class=\"number\">3</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"number\">16</span>. 求match(<span class=\"number\">2</span>,<span class=\"number\">4</span>): i = <span class=\"number\">2</span>; j = <span class=\"number\">4</span>; curMatch = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"number\">17</span>.  j + <span class=\"number\">1</span> == <span class=\"number\">5</span> &gt;= p.length() -&gt; match(<span class=\"number\">2</span>,<span class=\"number\">4</span>) = curMatch = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"number\">18</span>. match(<span class=\"number\">2</span>,<span class=\"number\">4</span>) = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"number\">19</span>. 回溯到第<span class=\"number\">15</span>步。</span><br><span class=\"line\"><span class=\"number\">20</span>. match(<span class=\"number\">2</span>,<span class=\"number\">2</span>) = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"number\">21</span>. 回溯到第<span class=\"number\">10</span>步。</span><br><span class=\"line\"><span class=\"number\">22</span>. match(<span class=\"number\">1</span>,<span class=\"number\">2</span>) = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"number\">23</span>. 回溯到第<span class=\"number\">5</span>步。</span><br><span class=\"line\"><span class=\"number\">24</span>. match(<span class=\"number\">0</span>,<span class=\"number\">2</span>) = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"number\">25</span>. 回溯到第<span class=\"number\">2</span>步。</span><br><span class=\"line\"><span class=\"number\">26</span>. match(<span class=\"number\">0</span>,<span class=\"number\">0</span>) = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"number\">27</span>. 问题解决</span><br></pre></td></tr></table></figure>\n<img src=\"/programming/leetcode/day4-regular-expression-matching/solution2-2.png\" title=\"solution2\">\n<p>你看，其实很简单吧。😅</p>\n<p>接下来转化成代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Result &#123;</span><br><span class=\"line\">    TRUE, FALSE</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 状态空间</span></span><br><span class=\"line\">    Result[][] memo;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMatch</span><span class=\"params\">(String text, String pattern)</span> </span>&#123;</span><br><span class=\"line\">        memo = <span class=\"keyword\">new</span> Result[text.length() + <span class=\"number\">1</span>][pattern.length() + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> match(<span class=\"number\">0</span>, <span class=\"number\">0</span>, text, pattern);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">match</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j, String text, String pattern)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (memo[i][j] != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> memo[i][j] == Result.TRUE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> ans;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j == pattern.length())&#123;</span><br><span class=\"line\">            ans = i == text.length();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> curMatch = (i &lt; text.length() &amp;&amp;</span><br><span class=\"line\">                                   (pattern.charAt(j) == text.charAt(i) ||</span><br><span class=\"line\">                                    pattern.charAt(j) == <span class=\"string\">'.'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; pattern.length() &amp;&amp; pattern.charAt(j+<span class=\"number\">1</span>) == <span class=\"string\">'*'</span>)&#123;</span><br><span class=\"line\">                ans = (match(i, j+<span class=\"number\">2</span>, text, pattern) ||</span><br><span class=\"line\">                       curMatch &amp;&amp; match(i+<span class=\"number\">1</span>, j, text, pattern));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans = curMatch &amp;&amp; match(i+<span class=\"number\">1</span>, j+<span class=\"number\">1</span>, text, pattern);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        memo[i][j] = ans ? Result.TRUE : Result.FALSE;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>来跑一下结果：</p>\n<img src=\"/programming/leetcode/day4-regular-expression-matching/result2.png\" title=\"result2\">\n<p>击败了99.95%，不错不错。</p>\n<p>已经很晚了，但我还是想把另一种方法也一起写完。🙄</p>\n<p>还有一种方法，叫做自底向上方法，也是动态规划中的一种，这种方法的思路其实很简单粗暴，即从最后一个字符开始反向匹配，还是以刚才的栗子为例，从i = 3, j = 5 开始依次往左往上循环计算，match(3,5) == true，核心的逻辑并没有变。因为最边缘的值的匹配都是可以直接计算出来的，下面推算其中的一部分：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>. match(<span class=\"number\">3</span>,<span class=\"number\">5</span>) = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"number\">2</span>. 求match(<span class=\"number\">3</span>,<span class=\"number\">4</span>): i = <span class=\"number\">3</span>; j = <span class=\"number\">4</span>; curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">3</span>. j + <span class=\"number\">1</span> == <span class=\"number\">5</span> &gt;= p.length() -&gt; match(<span class=\"number\">3</span>,<span class=\"number\">4</span>) = curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">4</span>. match(<span class=\"number\">3</span>,<span class=\"number\">4</span>) = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">5</span>. 求match(<span class=\"number\">3</span>,<span class=\"number\">3</span>): i = <span class=\"number\">3</span>; j = <span class=\"number\">3</span>; curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">6</span>. p[<span class=\"number\">4</span>] == b -&gt; match(<span class=\"number\">3</span>,<span class=\"number\">3</span>) = curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">7</span>. match(<span class=\"number\">3</span>,<span class=\"number\">3</span>) = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">8</span>. 求match(<span class=\"number\">3</span>,<span class=\"number\">2</span>): i = <span class=\"number\">3</span>; j = <span class=\"number\">2</span>; curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">9</span>. p[<span class=\"number\">3</span>] == * -&gt; match(<span class=\"number\">3</span>,<span class=\"number\">2</span>) = match(<span class=\"number\">3</span>,<span class=\"number\">4</span>) || <span class=\"keyword\">false</span> &amp;&amp; match(<span class=\"number\">4</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"number\">10</span>. match(<span class=\"number\">3</span>,<span class=\"number\">2</span>) = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">11</span>. 求match(<span class=\"number\">3</span>,<span class=\"number\">1</span>): i = <span class=\"number\">3</span>; j = <span class=\"number\">1</span>; curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">12</span>. p[<span class=\"number\">2</span>] == a -&gt; match(<span class=\"number\">3</span>,<span class=\"number\">1</span>) = curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">13</span>. match(<span class=\"number\">3</span>,<span class=\"number\">1</span>) = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">14</span>. 求match(<span class=\"number\">3</span>,<span class=\"number\">0</span>): i = <span class=\"number\">3</span>; j = <span class=\"number\">0</span>; curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">15</span>. p[<span class=\"number\">1</span>] == * -&gt; match(<span class=\"number\">3</span>,<span class=\"number\">0</span>) = match(<span class=\"number\">3</span>,<span class=\"number\">2</span>) || <span class=\"keyword\">false</span> &amp;&amp; match(<span class=\"number\">4</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"number\">16</span>. match(<span class=\"number\">3</span>,<span class=\"number\">0</span>) = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">17</span>. ....</span><br></pre></td></tr></table></figure>\n<p>剩下的部分可以自行推导。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMatch</span><span class=\"params\">(String text, String pattern)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span>[][] memo = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[text.length() + <span class=\"number\">1</span>][pattern.length() + <span class=\"number\">1</span>];</span><br><span class=\"line\">        memo[text.length()][pattern.length()] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = text.length(); i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = pattern.length() - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> curMatch = (i &lt; text.length() &amp;&amp;</span><br><span class=\"line\">                                       (pattern.charAt(j) == text.charAt(i) ||</span><br><span class=\"line\">                                        pattern.charAt(j) == <span class=\"string\">'.'</span>));</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; pattern.length() &amp;&amp; pattern.charAt(j+<span class=\"number\">1</span>) == <span class=\"string\">'*'</span>)&#123;</span><br><span class=\"line\">                    memo[i][j] = memo[i][j+<span class=\"number\">2</span>] || curMatch &amp;&amp; memo[i+<span class=\"number\">1</span>][j];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    memo[i][j] = curMatch &amp;&amp; memo[i+<span class=\"number\">1</span>][j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> memo[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>提交一下：</p>\n<img src=\"/programming/leetcode/day4-regular-expression-matching/result3.png\" title=\"result3\">\n<p>效率也是相当高的，虽然比自顶向下方法多计算了不少值，但是减少了方法调用次数，省去了多次递归调用方法的开销，而且每次计算的过程相当简单，所以并不能说它的效率比自顶向下的方法低，要视具体情况而定。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>写到这，今天的题总算是完成的差不多了，长呼一口，来回顾一下今天的收获吧：</p>\n<p>首先我们用分治法，使用递归来解决，但是效率偏低。</p>\n<p>于是我们用了动态规划的思想来解决这个问题，与分治法最大的不同便在于动态规划会存储中间的计算状态，以减少重复计算。</p>\n<p>先是用了自顶向下的方法，跟分治法几乎没有差异，只是多使用了一个二维数组。</p>\n<p>接着用自底向上的方法来解决，从最后的字符开始匹配，将多次递归调用转为在一个循环体中完成。</p>\n<p>总结一下动态规划的步骤：</p>\n<ol>\n<li>抽象问题。将问题分解为多个子问题，子问题的解一旦求出就会被保存。</li>\n<li>确定状态。确认我们要求解的子问题的状态空间，并设置初始状态。</li>\n<li>确定状态转移方程。这一步是最难也是最重要的一步。</li>\n</ol>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个字符串 (s) 和一个字符模式 (p)。实现支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>\n<p>‘.’ 匹配任意单个字符。<br>‘*’ 匹配零个或多个前面的元素。<br>匹配应该覆盖整个字符串 (s) ，而不是部分字符串。</p>\n<p>说明:</p>\n<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。<br>示例 1:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">s = <span class=\"string\">\"aa\"</span></span><br><span class=\"line\">p = <span class=\"string\">\"a\"</span></span><br><span class=\"line\">输出: <span class=\"literal\">false</span></span><br><span class=\"line\">解释: <span class=\"string\">\"a\"</span> 无法匹配 <span class=\"string\">\"aa\"</span> 整个字符串。</span><br></pre></td></tr></table></figure>\n<p>示例 2:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">s = <span class=\"string\">\"aa\"</span></span><br><span class=\"line\">p = <span class=\"string\">\"a*\"</span></span><br><span class=\"line\">输出: <span class=\"literal\">true</span></span><br><span class=\"line\">解释: <span class=\"string\">'*'</span> 代表可匹配零个或多个前面的元素, 即可以匹配 <span class=\"string\">'a'</span> 。因此, 重复 <span class=\"string\">'a'</span> 一次, 字符串可变为 <span class=\"string\">\"aa\"</span>。</span><br></pre></td></tr></table></figure></p>\n<p>示例 3:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">s = <span class=\"string\">\"ab\"</span></span><br><span class=\"line\">p = <span class=\"string\">\".*\"</span></span><br><span class=\"line\">输出: <span class=\"literal\">true</span></span><br><span class=\"line\">解释: <span class=\"string\">\".*\"</span> 表示可匹配零个或多个(<span class=\"string\">'*'</span>)任意字符(<span class=\"string\">'.'</span>)。</span><br></pre></td></tr></table></figure></p>\n<p>示例 4:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">s = <span class=\"string\">\"aab\"</span></span><br><span class=\"line\">p = <span class=\"string\">\"c*a*b\"</span></span><br><span class=\"line\">输出: <span class=\"literal\">true</span></span><br><span class=\"line\">解释: <span class=\"string\">'c'</span> 可以不被重复, <span class=\"string\">'a'</span> 可以被重复一次。因此可以匹配字符串 <span class=\"string\">\"aab\"</span>。</span><br></pre></td></tr></table></figure></p>\n<p>示例 5:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">s = <span class=\"string\">\"mississippi\"</span></span><br><span class=\"line\">p = <span class=\"string\">\"mis*is*p*.\"</span></span><br><span class=\"line\">输出: <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure></p>\n<p>题目难度：⭐⭐⭐</p>\n<h2 id=\"题目解析\"><a href=\"#题目解析\" class=\"headerlink\" title=\"题目解析\"></a>题目解析</h2><p>这是一道有点难度的题，如果你看了一遍题目之后，没有什么好的想法，不用心急，深呼吸，让我们一起来探索如何解决这道题。</p>\n<p>其实题目的要求，就是实现一个最简单的正则表达式，即<code>.</code>与<code>*</code>的匹配，一提到正则表达式，你也许会想到形如 <code>^[A-Z]:\\\\{1,2}[^/:\\*\\?&lt;&gt;\\|]+\\.(jpg|gif|png|bmp)$</code> 之类的一大串乱七八糟的代码，觉得看着都蛋疼，还要让我来实现？？？emmmm，不要方，问题不大，不要被<code>正则表达式</code>这个名号给吓到，要相信，问题总比方法多🤣。何况这里只需要解析两个特殊字符，岂不是小菜一碟。</p>\n<p>明人不说骚话，撸起袖子就开干。</p>\n<p>先重新阅读一遍题目，对题目要求的理解和把握很关键，这决定了之后的思考会不会跑偏，后面的几个示例可以用来验证自己理解是否正确。</p>\n<p>从后面给的栗子里可以看出，题目的意思是要求字符串s与字符模式p能完全匹配才能算是通过，而不是在s中找到一个p能匹配的子字符串。</p>\n<p>脑袋一拍，那一个字符一个字符来匹配不就完事了？嗯，先试试看。把题中的栗子拿出来画成图，然后进行观察。</p>\n<img src=\"/programming/leetcode/day4-regular-expression-matching/example1.png\" title=\"example1\">\n<img src=\"/programming/leetcode/day4-regular-expression-matching/example2.png\" title=\"example2\">\n<img src=\"/programming/leetcode/day4-regular-expression-matching/example3.png\" title=\"example3\">\n<img src=\"/programming/leetcode/day4-regular-expression-matching/example4.png\" title=\"example4\">\n<p>在形成自己的思路后，一定要对这几个栗子进行验证，不然代码写完以后才发现理解错了题目的意思就很尴尬了。🌝</p>\n<p>对于一个位于字符模式p中的字符c来说，只有三种情况：</p>\n<ol>\n<li>c == ‘.’</li>\n<li>c == ‘*’</li>\n<li>c 为其他普通字符</li>\n</ol>\n<p>我们先来看第一种情况，当<code>c == &#39;.&#39;</code>的时候，因为可以匹配任意字符，那么，直接跳过即可，对于第三种情况，那么只要<code>s</code>中对应的字符字符<code>c</code>相同即可，你看，很简单吧，我们已经完成三分之二了。接下来，再来看看最后一种情况。</p>\n<p>如果<code>c == *</code>，那么代表可以匹配零个或者多个前面的字符，比如<code>a*</code>可以匹配<code>a</code>、<code>aaaa</code>、<code>aaaaa</code>也可以匹配空字符，所以它其实是个修饰符，用来修饰它前面的字符，必须要跟其他字符一起使用，所以在我们在一个个遍历模式串中的字符的时候，还需看看后面跟的字符是不是<code>*</code>，如果是的话，那么就要进行特殊处理了。</p>\n<p><code>*</code>代表匹配0个或多个它前面的字符，所以有两种情况，一种是0个，一种是多个。</p>\n<p>梳理一下思路，每次从p中拿出一个字符来与s中的字符进行匹配，如果该字符后续的字符不是<code>*</code>，那么直接与s中对应字符进行匹配判断即可，如果匹配上了，那么就将两个游标都往后移动一位。如果匹配过程中遇到不相等的情况，则直接返回false。如果后续字符是<code>*</code>，那么就如上面所分析的，分成两种情况，一种是匹配0个，那么只需要跳过p中的这两个字符，继续与s中的字符进行比较即可，如果是匹配多个，那么将s中的游标往后移动一个，继续进行判断，这两个条件只要其中一个能满足即可。</p>\n<p>对于上面分析<code>*</code>字符的说明也许还不够清晰，继续画图：</p>\n<img src=\"/programming/leetcode/day4-regular-expression-matching/solution1-1.png\" title=\"solution1\">\n<img src=\"/programming/leetcode/day4-regular-expression-matching/solution1-2.png\" title=\"solution1\">\n<img src=\"/programming/leetcode/day4-regular-expression-matching/solution1-3.png\" title=\"solution1\">\n<img src=\"/programming/leetcode/day4-regular-expression-matching/solution1-4.png\" title=\"solution1\">\n<p>等等，你有没有闻到一丝递归的味道，既然对于每个在模式串中的字符都可以采用相同的策略进行处理，那不就是暗示这里可以使用递归吗。机智如我😝</p>\n<h2 id=\"递归解法\"><a href=\"#递归解法\" class=\"headerlink\" title=\"递归解法\"></a>递归解法</h2><p>先来写一下伪代码来继续理清思路，毕竟这可是一道复杂度为三星级别的题，万万不可轻敌。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isMatch</span> <span class=\"params\">(String s, String p)</span></span>&#123;</span><br><span class=\"line\">    从p中取出字符c1，从s中取出字符d1</span><br><span class=\"line\">    从p中再取一个字符c2</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c2 == <span class=\"string\">'*'</span>)&#123;</span><br><span class=\"line\">        跳过c1与c2或者将s的游标往后移动一位</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isMatch(s,p.subString(<span class=\"number\">2</span>)) || (( c1 == <span class=\"string\">'.'</span> || c1 == d1) &amp;&amp; isMatch(s.subString(<span class=\"number\">1</span>),p)));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(c1 == <span class=\"string\">'.'</span>)&#123;</span><br><span class=\"line\">        直接跳过</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isMatch(s.subString(<span class=\"number\">1</span>),p.subString(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        普通字符直接比较</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c1 == d1 &amp;&amp; isMatch(s.subString(<span class=\"number\">1</span>), p.subString(<span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>emmm，这个伪代码好像不太合格，几乎把代码写完了，23333，接下来只需要考虑一下边界情况，把代码补全就行了，当然，还可以将代码美化一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMatch</span><span class=\"params\">(String s, String p)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p.length() &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> s.length() &lt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> match = (s.length() &gt; <span class=\"number\">0</span> &amp;&amp; (s.charAt(<span class=\"number\">0</span>) == p.charAt(<span class=\"number\">0</span>) || p.charAt(<span class=\"number\">0</span>) == <span class=\"string\">'.'</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p.length() &gt; <span class=\"number\">1</span> &amp;&amp; p.charAt(<span class=\"number\">1</span>) == <span class=\"string\">'*'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isMatch(s, p.substring(<span class=\"number\">2</span>)) || (match &amp;&amp; isMatch(s.substring(<span class=\"number\">1</span>), p));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> match &amp;&amp; isMatch(s.substring(<span class=\"number\">1</span>), p.substring(<span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大功告成，提交一下。</p>\n<img src=\"/programming/leetcode/day4-regular-expression-matching/result1.png\" title=\"result1\">\n<p>emmm，递归的效率一般都比较差，只击败了28%的用户。</p>\n<p>当然，一般能用递归解决的地方，都可以使用非递归的方式解决，下面，我们来使用另一种解决方案。</p>\n<h2 id=\"动态规划解法\"><a href=\"#动态规划解法\" class=\"headerlink\" title=\"动态规划解法\"></a>动态规划解法</h2><h3 id=\"动态规划简介\"><a href=\"#动态规划简介\" class=\"headerlink\" title=\"动态规划简介\"></a>动态规划简介</h3><p>动态规划？？？emmm，如果你不经常接触算法的话，也许对这个名词不太熟悉，所以我先简单的介绍一下。</p>\n<p>动态规划，简单来说就是，动态的去进行，规划。😂言归正传，其实动态规划也是一种分治的思想，将问题分解成一个个子问题，通过解决所有子问题，来求得原问题的解，一般用于求解最优问题。但是跟分治法不同的地方在于，动态规划的子问题往往是相互关联的，拿最简单的斐波拉契数列来说，我们使用分治的思想，对于求<code>fib(6)</code>，使用的公式是<code>fib(6) = fib(5) + fib(4)</code>，于是将原来的问题便转化为求解<code>fib(5)</code>和<code>fib(4)</code>，继续递归，<code>fib(5) = fib(4) + fib(3)</code>，然后再继续递归<code>fib(4) = fib(3) + fib(2)</code>、<code>fib(3) = fib(2) + fib(1)</code>这里<code>fib(1) = 1</code> 和 <code>fib(2) = 1</code>为初始条件，于是就能求出<code>fib(6)</code>，初看起来似乎没什么毛病，但是仔细想一想，由于每次递归都是无状态的，所以其实做了很多重复的计算，画个图来感受一下：</p>\n\n<p>这里将fib(4)重复算了2次，fib(3)算了3次，这还只是算fib(6)，如果是fib(66)呢？那将会有大量的重复计算，这是非常浪费时间的。</p>\n<p>动态规划就可以很好的解决这个问题，动态规划的思想跟上面是一样的，但不同的是，动态规划会将每次计算的结果存起来，因此就解决了。简单一点理解，就是在分治的基础上加入了一个状态数组，来存储中间计算的结果，以减少重复计算的耗时。当然，动态规划又分为两种，一种是自顶向下，就是刚才所说的方法，另一个种是自底向上，还是拿上面的斐波拉契数列来说，要计算fib(6)，因此我们先计算<code>fib(3) = fib(2) + fib(1)</code>，再计算<code>fib(4) = fib(3) + fib(2)</code>和<code>fib(5) = fib(4) + fib(3)</code>，这样，就能算出<code>fib(6) = fib(5) + fib(4)</code>的结果了。</p>\n<p>在动态规划中有几个比较关键的概念：子问题，状态，状态空间，初始状态，状态转移方程。</p>\n<p>子问题：与原问题形式相同或者类似，只不过规模变小了，子问题都解决后，原问题即解决。</p>\n<p>状态：与子问题相关的各个变量的一组取值即为状态，状态与子问题是一对一或一对多的关系，代表着子问题的解。上面的栗子，状态就是<code>fib(n)</code>的值。</p>\n<p>状态空间：由所有状态构成的集合，上面的栗子比较简单，状态空间是一维空间。</p>\n<p>状态初始条件：即状态的初始状态，上面的栗子里<code>fib(1) = 1</code>和<code>fib(2) = 1</code>就是初始条件。</p>\n<p>状态转移方程：用来表示状态之间是如何转换的方程，即如何从一个或者多个已知的状态求出另一个状态，可以使用递推公式表示。上面栗子的公式为<code>fib(n) = f(n - 1) + f(n -2)  (n &gt; 2)</code></p>\n<h3 id=\"算法过程\"><a href=\"#算法过程\" class=\"headerlink\" title=\"算法过程\"></a>算法过程</h3><p>关于动态规划的介绍就结束了，接下来我们来看如何在这道题上面使用。</p>\n<p>我们先来考虑自顶向下的算法。为方便起见，假定使用符号<code>s[i:]</code>表示字符串s中从第i个字符到最后一个字符组成的子串，p[j:]则表示模式串p中，从第j个字符到最后一个字符组成的子串，使用 <code>match(i,j)</code> 表示<code>s[i:]</code>与<code>p[j:]</code>的匹配情况，如果能匹配，则置为true，否则置为false。这就是各个子问题的状态。</p>\n<p>那么对于<code>match(i,j)</code>的值，取决于<code>p[j + 1]</code>是否为’*’。</p>\n<p>curMatch = i &lt; s.length() &amp;&amp; s[i] == p[j] || p[j] == ‘.’;</p>\n<ol>\n<li>p[j + 1] != ‘*’，match(i,j) = curMatch &amp;&amp; match(i + 1, j + 1)</li>\n<li>p[j + 1] == ‘*’，match(i,j) = match(i, j + 2) || curMatch &amp;&amp; match(i + 1, j)</li>\n</ol>\n<p>这样表述一下是不是就清晰了不少。</p>\n<p>以<code>s = &quot;aab&quot;; p = &quot;c*a*b&quot;</code>为例，先构建一个二维状态空间来存储中间计算得出的状态值。横向的值代表i，纵向的值代表j，match(0,0)的值即问题的解，用<code>f</code>代表<code>false</code>，<code>t</code>代表<code>true</code>。</p>\n<img src=\"/programming/leetcode/day4-regular-expression-matching/solution2-1.png\" title=\"solution2\">\n<p>接下来描述一下后续的计算过程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>. 求match(<span class=\"number\">0</span>,<span class=\"number\">0</span>): i = <span class=\"number\">0</span>; j = <span class=\"number\">0</span>; curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">2</span>. p[<span class=\"number\">1</span>] == * -&gt; match(<span class=\"number\">0</span>,<span class=\"number\">0</span>) = match(<span class=\"number\">0</span>,<span class=\"number\">2</span>) || <span class=\"keyword\">false</span> &amp;&amp; match(<span class=\"number\">1</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"number\">3</span>. 转化为求子问题match(<span class=\"number\">0</span>,<span class=\"number\">2</span>)和match(<span class=\"number\">1</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"number\">4</span>. 求match(<span class=\"number\">0</span>,<span class=\"number\">2</span>): i = <span class=\"number\">0</span>; j = <span class=\"number\">2</span>; curMatch = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"number\">5</span>. p[<span class=\"number\">1</span>] == * -&gt; match(<span class=\"number\">0</span>,<span class=\"number\">2</span>) = match(<span class=\"number\">0</span>,<span class=\"number\">4</span>) || <span class=\"keyword\">true</span> &amp;&amp; match(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"number\">6</span>. 求match(<span class=\"number\">0</span>,<span class=\"number\">4</span>): i = <span class=\"number\">0</span>; j = <span class=\"number\">4</span>; curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">7</span>. j + <span class=\"number\">1</span> == <span class=\"number\">5</span> &gt;= p.length() -&gt; match(<span class=\"number\">0</span>,<span class=\"number\">4</span>) = curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">8</span>. match(<span class=\"number\">0</span>,<span class=\"number\">4</span>) = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">9</span>. 回溯到第五步，求match(<span class=\"number\">1</span>,<span class=\"number\">2</span>): i = <span class=\"number\">1</span>; j = <span class=\"number\">2</span>; curMatch = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"number\">10</span>. p[<span class=\"number\">3</span>] == * -&gt; match(<span class=\"number\">1</span>,<span class=\"number\">2</span>) = match(<span class=\"number\">1</span>,<span class=\"number\">4</span>) || <span class=\"keyword\">true</span> &amp;&amp; match(<span class=\"number\">2</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"number\">11</span>. 求match(<span class=\"number\">1</span>,<span class=\"number\">4</span>): i = <span class=\"number\">1</span>; j = <span class=\"number\">4</span>; curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">12</span>. j + <span class=\"number\">1</span> == <span class=\"number\">5</span> &gt;= p.length() -&gt; match(<span class=\"number\">1</span>,<span class=\"number\">4</span>) = curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">13</span>. match(<span class=\"number\">1</span>,<span class=\"number\">4</span>) = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">14</span>. 回溯到第<span class=\"number\">10</span>步，求match(<span class=\"number\">2</span>,<span class=\"number\">2</span>): i = <span class=\"number\">2</span>; j = <span class=\"number\">2</span>; curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">15</span>. p[<span class=\"number\">3</span>] == * -&gt; match(<span class=\"number\">2</span>,<span class=\"number\">2</span>) = match(<span class=\"number\">2</span>,<span class=\"number\">4</span>) || <span class=\"keyword\">false</span> &amp;&amp; match(<span class=\"number\">3</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"number\">16</span>. 求match(<span class=\"number\">2</span>,<span class=\"number\">4</span>): i = <span class=\"number\">2</span>; j = <span class=\"number\">4</span>; curMatch = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"number\">17</span>.  j + <span class=\"number\">1</span> == <span class=\"number\">5</span> &gt;= p.length() -&gt; match(<span class=\"number\">2</span>,<span class=\"number\">4</span>) = curMatch = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"number\">18</span>. match(<span class=\"number\">2</span>,<span class=\"number\">4</span>) = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"number\">19</span>. 回溯到第<span class=\"number\">15</span>步。</span><br><span class=\"line\"><span class=\"number\">20</span>. match(<span class=\"number\">2</span>,<span class=\"number\">2</span>) = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"number\">21</span>. 回溯到第<span class=\"number\">10</span>步。</span><br><span class=\"line\"><span class=\"number\">22</span>. match(<span class=\"number\">1</span>,<span class=\"number\">2</span>) = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"number\">23</span>. 回溯到第<span class=\"number\">5</span>步。</span><br><span class=\"line\"><span class=\"number\">24</span>. match(<span class=\"number\">0</span>,<span class=\"number\">2</span>) = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"number\">25</span>. 回溯到第<span class=\"number\">2</span>步。</span><br><span class=\"line\"><span class=\"number\">26</span>. match(<span class=\"number\">0</span>,<span class=\"number\">0</span>) = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"number\">27</span>. 问题解决</span><br></pre></td></tr></table></figure>\n<img src=\"/programming/leetcode/day4-regular-expression-matching/solution2-2.png\" title=\"solution2\">\n<p>你看，其实很简单吧。😅</p>\n<p>接下来转化成代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Result &#123;</span><br><span class=\"line\">    TRUE, FALSE</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 状态空间</span></span><br><span class=\"line\">    Result[][] memo;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMatch</span><span class=\"params\">(String text, String pattern)</span> </span>&#123;</span><br><span class=\"line\">        memo = <span class=\"keyword\">new</span> Result[text.length() + <span class=\"number\">1</span>][pattern.length() + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> match(<span class=\"number\">0</span>, <span class=\"number\">0</span>, text, pattern);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">match</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j, String text, String pattern)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (memo[i][j] != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> memo[i][j] == Result.TRUE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> ans;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j == pattern.length())&#123;</span><br><span class=\"line\">            ans = i == text.length();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> curMatch = (i &lt; text.length() &amp;&amp;</span><br><span class=\"line\">                                   (pattern.charAt(j) == text.charAt(i) ||</span><br><span class=\"line\">                                    pattern.charAt(j) == <span class=\"string\">'.'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; pattern.length() &amp;&amp; pattern.charAt(j+<span class=\"number\">1</span>) == <span class=\"string\">'*'</span>)&#123;</span><br><span class=\"line\">                ans = (match(i, j+<span class=\"number\">2</span>, text, pattern) ||</span><br><span class=\"line\">                       curMatch &amp;&amp; match(i+<span class=\"number\">1</span>, j, text, pattern));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans = curMatch &amp;&amp; match(i+<span class=\"number\">1</span>, j+<span class=\"number\">1</span>, text, pattern);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        memo[i][j] = ans ? Result.TRUE : Result.FALSE;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>来跑一下结果：</p>\n<img src=\"/programming/leetcode/day4-regular-expression-matching/result2.png\" title=\"result2\">\n<p>击败了99.95%，不错不错。</p>\n<p>已经很晚了，但我还是想把另一种方法也一起写完。🙄</p>\n<p>还有一种方法，叫做自底向上方法，也是动态规划中的一种，这种方法的思路其实很简单粗暴，即从最后一个字符开始反向匹配，还是以刚才的栗子为例，从i = 3, j = 5 开始依次往左往上循环计算，match(3,5) == true，核心的逻辑并没有变。因为最边缘的值的匹配都是可以直接计算出来的，下面推算其中的一部分：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>. match(<span class=\"number\">3</span>,<span class=\"number\">5</span>) = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"><span class=\"number\">2</span>. 求match(<span class=\"number\">3</span>,<span class=\"number\">4</span>): i = <span class=\"number\">3</span>; j = <span class=\"number\">4</span>; curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">3</span>. j + <span class=\"number\">1</span> == <span class=\"number\">5</span> &gt;= p.length() -&gt; match(<span class=\"number\">3</span>,<span class=\"number\">4</span>) = curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">4</span>. match(<span class=\"number\">3</span>,<span class=\"number\">4</span>) = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">5</span>. 求match(<span class=\"number\">3</span>,<span class=\"number\">3</span>): i = <span class=\"number\">3</span>; j = <span class=\"number\">3</span>; curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">6</span>. p[<span class=\"number\">4</span>] == b -&gt; match(<span class=\"number\">3</span>,<span class=\"number\">3</span>) = curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">7</span>. match(<span class=\"number\">3</span>,<span class=\"number\">3</span>) = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">8</span>. 求match(<span class=\"number\">3</span>,<span class=\"number\">2</span>): i = <span class=\"number\">3</span>; j = <span class=\"number\">2</span>; curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">9</span>. p[<span class=\"number\">3</span>] == * -&gt; match(<span class=\"number\">3</span>,<span class=\"number\">2</span>) = match(<span class=\"number\">3</span>,<span class=\"number\">4</span>) || <span class=\"keyword\">false</span> &amp;&amp; match(<span class=\"number\">4</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"number\">10</span>. match(<span class=\"number\">3</span>,<span class=\"number\">2</span>) = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">11</span>. 求match(<span class=\"number\">3</span>,<span class=\"number\">1</span>): i = <span class=\"number\">3</span>; j = <span class=\"number\">1</span>; curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">12</span>. p[<span class=\"number\">2</span>] == a -&gt; match(<span class=\"number\">3</span>,<span class=\"number\">1</span>) = curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">13</span>. match(<span class=\"number\">3</span>,<span class=\"number\">1</span>) = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">14</span>. 求match(<span class=\"number\">3</span>,<span class=\"number\">0</span>): i = <span class=\"number\">3</span>; j = <span class=\"number\">0</span>; curMatch = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">15</span>. p[<span class=\"number\">1</span>] == * -&gt; match(<span class=\"number\">3</span>,<span class=\"number\">0</span>) = match(<span class=\"number\">3</span>,<span class=\"number\">2</span>) || <span class=\"keyword\">false</span> &amp;&amp; match(<span class=\"number\">4</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"number\">16</span>. match(<span class=\"number\">3</span>,<span class=\"number\">0</span>) = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"number\">17</span>. ....</span><br></pre></td></tr></table></figure>\n<p>剩下的部分可以自行推导。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMatch</span><span class=\"params\">(String text, String pattern)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span>[][] memo = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[text.length() + <span class=\"number\">1</span>][pattern.length() + <span class=\"number\">1</span>];</span><br><span class=\"line\">        memo[text.length()][pattern.length()] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = text.length(); i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = pattern.length() - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> curMatch = (i &lt; text.length() &amp;&amp;</span><br><span class=\"line\">                                       (pattern.charAt(j) == text.charAt(i) ||</span><br><span class=\"line\">                                        pattern.charAt(j) == <span class=\"string\">'.'</span>));</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; pattern.length() &amp;&amp; pattern.charAt(j+<span class=\"number\">1</span>) == <span class=\"string\">'*'</span>)&#123;</span><br><span class=\"line\">                    memo[i][j] = memo[i][j+<span class=\"number\">2</span>] || curMatch &amp;&amp; memo[i+<span class=\"number\">1</span>][j];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    memo[i][j] = curMatch &amp;&amp; memo[i+<span class=\"number\">1</span>][j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> memo[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>提交一下：</p>\n<img src=\"/programming/leetcode/day4-regular-expression-matching/result3.png\" title=\"result3\">\n<p>效率也是相当高的，虽然比自顶向下方法多计算了不少值，但是减少了方法调用次数，省去了多次递归调用方法的开销，而且每次计算的过程相当简单，所以并不能说它的效率比自顶向下的方法低，要视具体情况而定。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>写到这，今天的题总算是完成的差不多了，长呼一口，来回顾一下今天的收获吧：</p>\n<p>首先我们用分治法，使用递归来解决，但是效率偏低。</p>\n<p>于是我们用了动态规划的思想来解决这个问题，与分治法最大的不同便在于动态规划会存储中间的计算状态，以减少重复计算。</p>\n<p>先是用了自顶向下的方法，跟分治法几乎没有差异，只是多使用了一个二维数组。</p>\n<p>接着用自底向上的方法来解决，从最后的字符开始匹配，将多次递归调用转为在一个循环体中完成。</p>\n<p>总结一下动态规划的步骤：</p>\n<ol>\n<li>抽象问题。将问题分解为多个子问题，子问题的解一旦求出就会被保存。</li>\n<li>确定状态。确认我们要求解的子问题的状态空间，并设置初始状态。</li>\n<li>确定状态转移方程。这一步是最难也是最重要的一步。</li>\n</ol>\n"},{"title":"【效率工具】SSH一键登录脚本（可一键从跳板机登录线上服务器）","date":"2019-03-27T15:00:23.000Z","categorys":null,"_content":"\n## 说明\n\n前阵子上线，一次性上了十个服务，一直上到凌晨才完事，期间每个服务都要先输入跳板机的登录信息来登录跳板机，然后再输入线上服务器的信息来登录线上服务器，实在是太过于麻烦，而且有些服务还有好几台服务器，检查问题的时候，服务器跳来跳去的，简直苦不堪言。\n\n![20190327230716.png](https://i.loli.net/2019/03/27/5c9b91a70e5ca.png)\n\n于是，便萌发了用shell脚本的方式来一键跳转的想法，先上github上搜了搜现成的轮子，发现都不太好用，要不就是没说明，要不就是只能登一台服务器，不能满足从跳板机A跳转到线上服务器B的需求。\n\n所以，还是自己动手，丰衣足食。\n\n## Shell脚本\n\nShell脚本已经发布到了`github`上，链接在此：https://github.com/MFrank2016/GotoSSH\n\n这个脚本借鉴了`AutoSSH`的脚本，并将其进行了修改，使得能够支持从跳板机直接跳转登录服务器。\n\n## 使用说明\n\n`GotoSSH`是一个一键登录SSH的脚本，可直接从跳板机登录到线上服务器，致力于帮助你提高工作效率。\n\n## 安装依赖\n\nCentOS :\n\n```shell\n$ sudo yum install -y expect\n```\n\nUbuntu :\n\n```shell\n$ sudo apt-get install tcl tk expect\n```\n\nMac :\n\n```shell\n$ sudo brew install expect\n```\n\n## 安装 GotoSSH\n\n```shell\n$ git clone https://github.com/MFrank2016/GotoSSH.git\n$ cd GotoSSH\n$ chmod a+x gotossh\n$ sudo cp gotossh /usr/local/bin/\n```\n\n## 配置\n\n```shell\n$ vim ~/.gotossh_config\nserver_name|ip|username|password|port|rely_server_no\n```\n\n最后一列是代表该服务器依赖于哪个服务器，如果该列的值设置为0，代表不依赖于其他服务器，否则代表需要先登录其他服务器后才能登录该服务器，目前暂时只能从A跳转到B，不支持多跳转，感觉没有必要，如果有需要，把脚本稍微改改就行了。\n\n## 举个栗子\n\n```shell\n$ vim ~/.gotossh_config\ntest_server|192.168.0.1|root|password|22|0\nonline_server|192.168.2.2|root|password|22|1\n```\n\n## 使用说明\n\n```shell\n$ gotossh\n######################################################################################\n#                                  [GOTO SSH]                                        #\n#                                                                                    #\n#                                                                                    #\n# [1] test_server - 192.168.0.1:root                                                 #\n# [2] online_server - 192.168.2.2:root                                               #\n#                                                                                    #\n#                                                                                    #\n######################################################################################\nServer Number:(Input Server Number Here)\n```\n\nOR\n\n```shell\ngotossh 1\n```\n\nOR\n\n```shell\ngotossh 2\n```\n\n因为配置文件里设置了服务器2依赖于服务器1，所以会先登录服务器1，然后再登录服务器2。\n\n这样，只需要小手一点，就能直接登录线上服务器，岂不是美滋滋。\n\n![20190327231606.png](https://i.loli.net/2019/03/27/5c9b93b7d1c8a.png)\n\n## 小结\n\n虽然只是一个简单的脚本，奈何道法太浅，硬生生折腾了大半天才调试完成，但也算是了却了一桩心愿。\n\n独乐了不如众乐乐，特此分享给大家，希望能对大家有所帮助。\n\n如果觉得还不错，别忘了加个star✨也欢迎关注我的公众号留言交流。\n\n![](https://i.loli.net/2019/03/14/5c8a58ba229ca.png)","source":"_posts/shell/shell-gotossh.md","raw":"---\ntitle: 【效率工具】SSH一键登录脚本（可一键从跳板机登录线上服务器）\ndate: 2019-03-27 23:00:23\ntags:\ncategorys:\n---\n\n## 说明\n\n前阵子上线，一次性上了十个服务，一直上到凌晨才完事，期间每个服务都要先输入跳板机的登录信息来登录跳板机，然后再输入线上服务器的信息来登录线上服务器，实在是太过于麻烦，而且有些服务还有好几台服务器，检查问题的时候，服务器跳来跳去的，简直苦不堪言。\n\n![20190327230716.png](https://i.loli.net/2019/03/27/5c9b91a70e5ca.png)\n\n于是，便萌发了用shell脚本的方式来一键跳转的想法，先上github上搜了搜现成的轮子，发现都不太好用，要不就是没说明，要不就是只能登一台服务器，不能满足从跳板机A跳转到线上服务器B的需求。\n\n所以，还是自己动手，丰衣足食。\n\n## Shell脚本\n\nShell脚本已经发布到了`github`上，链接在此：https://github.com/MFrank2016/GotoSSH\n\n这个脚本借鉴了`AutoSSH`的脚本，并将其进行了修改，使得能够支持从跳板机直接跳转登录服务器。\n\n## 使用说明\n\n`GotoSSH`是一个一键登录SSH的脚本，可直接从跳板机登录到线上服务器，致力于帮助你提高工作效率。\n\n## 安装依赖\n\nCentOS :\n\n```shell\n$ sudo yum install -y expect\n```\n\nUbuntu :\n\n```shell\n$ sudo apt-get install tcl tk expect\n```\n\nMac :\n\n```shell\n$ sudo brew install expect\n```\n\n## 安装 GotoSSH\n\n```shell\n$ git clone https://github.com/MFrank2016/GotoSSH.git\n$ cd GotoSSH\n$ chmod a+x gotossh\n$ sudo cp gotossh /usr/local/bin/\n```\n\n## 配置\n\n```shell\n$ vim ~/.gotossh_config\nserver_name|ip|username|password|port|rely_server_no\n```\n\n最后一列是代表该服务器依赖于哪个服务器，如果该列的值设置为0，代表不依赖于其他服务器，否则代表需要先登录其他服务器后才能登录该服务器，目前暂时只能从A跳转到B，不支持多跳转，感觉没有必要，如果有需要，把脚本稍微改改就行了。\n\n## 举个栗子\n\n```shell\n$ vim ~/.gotossh_config\ntest_server|192.168.0.1|root|password|22|0\nonline_server|192.168.2.2|root|password|22|1\n```\n\n## 使用说明\n\n```shell\n$ gotossh\n######################################################################################\n#                                  [GOTO SSH]                                        #\n#                                                                                    #\n#                                                                                    #\n# [1] test_server - 192.168.0.1:root                                                 #\n# [2] online_server - 192.168.2.2:root                                               #\n#                                                                                    #\n#                                                                                    #\n######################################################################################\nServer Number:(Input Server Number Here)\n```\n\nOR\n\n```shell\ngotossh 1\n```\n\nOR\n\n```shell\ngotossh 2\n```\n\n因为配置文件里设置了服务器2依赖于服务器1，所以会先登录服务器1，然后再登录服务器2。\n\n这样，只需要小手一点，就能直接登录线上服务器，岂不是美滋滋。\n\n![20190327231606.png](https://i.loli.net/2019/03/27/5c9b93b7d1c8a.png)\n\n## 小结\n\n虽然只是一个简单的脚本，奈何道法太浅，硬生生折腾了大半天才调试完成，但也算是了却了一桩心愿。\n\n独乐了不如众乐乐，特此分享给大家，希望能对大家有所帮助。\n\n如果觉得还不错，别忘了加个star✨也欢迎关注我的公众号留言交流。\n\n![](https://i.loli.net/2019/03/14/5c8a58ba229ca.png)","slug":"shell/shell-gotossh","published":1,"updated":"2019-06-04T01:29:57.638Z","_id":"cjxze3gpc00210cvwbb5v8glj","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>前阵子上线，一次性上了十个服务，一直上到凌晨才完事，期间每个服务都要先输入跳板机的登录信息来登录跳板机，然后再输入线上服务器的信息来登录线上服务器，实在是太过于麻烦，而且有些服务还有好几台服务器，检查问题的时候，服务器跳来跳去的，简直苦不堪言。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/27/5c9b91a70e5ca.png\" alt=\"20190327230716.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190327230716.png</div>\n            </figure>\n<p>于是，便萌发了用shell脚本的方式来一键跳转的想法，先上github上搜了搜现成的轮子，发现都不太好用，要不就是没说明，要不就是只能登一台服务器，不能满足从跳板机A跳转到线上服务器B的需求。</p>\n<p>所以，还是自己动手，丰衣足食。</p>\n<h2 id=\"Shell脚本\"><a href=\"#Shell脚本\" class=\"headerlink\" title=\"Shell脚本\"></a>Shell脚本</h2><p>Shell脚本已经发布到了<code>github</code>上，链接在此：<a href=\"https://github.com/MFrank2016/GotoSSH\" target=\"_blank\" rel=\"noopener\">https://github.com/MFrank2016/GotoSSH</a></p>\n<p>这个脚本借鉴了<code>AutoSSH</code>的脚本，并将其进行了修改，使得能够支持从跳板机直接跳转登录服务器。</p>\n<h2 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h2><p><code>GotoSSH</code>是一个一键登录SSH的脚本，可直接从跳板机登录到线上服务器，致力于帮助你提高工作效率。</p>\n<h2 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h2><p>CentOS :</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo yum install -y expect</span></span><br></pre></td></tr></table></figure>\n<p>Ubuntu :</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo apt-get install tcl tk expect</span></span><br></pre></td></tr></table></figure>\n<p>Mac :</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo brew install expect</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"安装-GotoSSH\"><a href=\"#安装-GotoSSH\" class=\"headerlink\" title=\"安装 GotoSSH\"></a>安装 GotoSSH</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git <span class=\"built_in\">clone</span> https://github.com/MFrank2016/GotoSSH.git</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> GotoSSH</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> chmod a+x gotossh</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo cp gotossh /usr/<span class=\"built_in\">local</span>/bin/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> vim ~/.gotossh_config</span></span><br><span class=\"line\">server_name|ip|username|password|port|rely_server_no</span><br></pre></td></tr></table></figure>\n<p>最后一列是代表该服务器依赖于哪个服务器，如果该列的值设置为0，代表不依赖于其他服务器，否则代表需要先登录其他服务器后才能登录该服务器，目前暂时只能从A跳转到B，不支持多跳转，感觉没有必要，如果有需要，把脚本稍微改改就行了。</p>\n<h2 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> vim ~/.gotossh_config</span></span><br><span class=\"line\">test_server|192.168.0.1|root|password|22|0</span><br><span class=\"line\">online_server|192.168.2.2|root|password|22|1</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用说明-1\"><a href=\"#使用说明-1\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> gotossh</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">#####################################################################################</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">                                  [GOTO SSH]                                        <span class=\"comment\">#</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">                                                                                    <span class=\"comment\">#</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">                                                                                    <span class=\"comment\">#</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> [1] test_server - 192.168.0.1:root                                                 <span class=\"comment\">#</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> [2] online_server - 192.168.2.2:root                                               <span class=\"comment\">#</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">                                                                                    <span class=\"comment\">#</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">                                                                                    <span class=\"comment\">#</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">#####################################################################################</span></span></span><br><span class=\"line\">Server Number:(Input Server Number Here)</span><br></pre></td></tr></table></figure>\n<p>OR</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gotossh 1</span><br></pre></td></tr></table></figure>\n<p>OR</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gotossh 2</span><br></pre></td></tr></table></figure>\n<p>因为配置文件里设置了服务器2依赖于服务器1，所以会先登录服务器1，然后再登录服务器2。</p>\n<p>这样，只需要小手一点，就能直接登录线上服务器，岂不是美滋滋。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/27/5c9b93b7d1c8a.png\" alt=\"20190327231606.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190327231606.png</div>\n            </figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>虽然只是一个简单的脚本，奈何道法太浅，硬生生折腾了大半天才调试完成，但也算是了却了一桩心愿。</p>\n<p>独乐了不如众乐乐，特此分享给大家，希望能对大家有所帮助。</p>\n<p>如果觉得还不错，别忘了加个star✨也欢迎关注我的公众号留言交流。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a58ba229ca.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>前阵子上线，一次性上了十个服务，一直上到凌晨才完事，期间每个服务都要先输入跳板机的登录信息来登录跳板机，然后再输入线上服务器的信息来登录线上服务器，实在是太过于麻烦，而且有些服务还有好几台服务器，检查问题的时候，服务器跳来跳去的，简直苦不堪言。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/27/5c9b91a70e5ca.png\" alt=\"20190327230716.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190327230716.png</div>\n            </figure>\n<p>于是，便萌发了用shell脚本的方式来一键跳转的想法，先上github上搜了搜现成的轮子，发现都不太好用，要不就是没说明，要不就是只能登一台服务器，不能满足从跳板机A跳转到线上服务器B的需求。</p>\n<p>所以，还是自己动手，丰衣足食。</p>\n<h2 id=\"Shell脚本\"><a href=\"#Shell脚本\" class=\"headerlink\" title=\"Shell脚本\"></a>Shell脚本</h2><p>Shell脚本已经发布到了<code>github</code>上，链接在此：<a href=\"https://github.com/MFrank2016/GotoSSH\" target=\"_blank\" rel=\"noopener\">https://github.com/MFrank2016/GotoSSH</a></p>\n<p>这个脚本借鉴了<code>AutoSSH</code>的脚本，并将其进行了修改，使得能够支持从跳板机直接跳转登录服务器。</p>\n<h2 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h2><p><code>GotoSSH</code>是一个一键登录SSH的脚本，可直接从跳板机登录到线上服务器，致力于帮助你提高工作效率。</p>\n<h2 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h2><p>CentOS :</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo yum install -y expect</span></span><br></pre></td></tr></table></figure>\n<p>Ubuntu :</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo apt-get install tcl tk expect</span></span><br></pre></td></tr></table></figure>\n<p>Mac :</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo brew install expect</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"安装-GotoSSH\"><a href=\"#安装-GotoSSH\" class=\"headerlink\" title=\"安装 GotoSSH\"></a>安装 GotoSSH</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git <span class=\"built_in\">clone</span> https://github.com/MFrank2016/GotoSSH.git</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> GotoSSH</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> chmod a+x gotossh</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo cp gotossh /usr/<span class=\"built_in\">local</span>/bin/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> vim ~/.gotossh_config</span></span><br><span class=\"line\">server_name|ip|username|password|port|rely_server_no</span><br></pre></td></tr></table></figure>\n<p>最后一列是代表该服务器依赖于哪个服务器，如果该列的值设置为0，代表不依赖于其他服务器，否则代表需要先登录其他服务器后才能登录该服务器，目前暂时只能从A跳转到B，不支持多跳转，感觉没有必要，如果有需要，把脚本稍微改改就行了。</p>\n<h2 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> vim ~/.gotossh_config</span></span><br><span class=\"line\">test_server|192.168.0.1|root|password|22|0</span><br><span class=\"line\">online_server|192.168.2.2|root|password|22|1</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用说明-1\"><a href=\"#使用说明-1\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> gotossh</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">#####################################################################################</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">                                  [GOTO SSH]                                        <span class=\"comment\">#</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">                                                                                    <span class=\"comment\">#</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">                                                                                    <span class=\"comment\">#</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> [1] test_server - 192.168.0.1:root                                                 <span class=\"comment\">#</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> [2] online_server - 192.168.2.2:root                                               <span class=\"comment\">#</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">                                                                                    <span class=\"comment\">#</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">                                                                                    <span class=\"comment\">#</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">#####################################################################################</span></span></span><br><span class=\"line\">Server Number:(Input Server Number Here)</span><br></pre></td></tr></table></figure>\n<p>OR</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gotossh 1</span><br></pre></td></tr></table></figure>\n<p>OR</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gotossh 2</span><br></pre></td></tr></table></figure>\n<p>因为配置文件里设置了服务器2依赖于服务器1，所以会先登录服务器1，然后再登录服务器2。</p>\n<p>这样，只需要小手一点，就能直接登录线上服务器，岂不是美滋滋。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/27/5c9b93b7d1c8a.png\" alt=\"20190327231606.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190327231606.png</div>\n            </figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>虽然只是一个简单的脚本，奈何道法太浅，硬生生折腾了大半天才调试完成，但也算是了却了一桩心愿。</p>\n<p>独乐了不如众乐乐，特此分享给大家，希望能对大家有所帮助。</p>\n<p>如果觉得还不错，别忘了加个star✨也欢迎关注我的公众号留言交流。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a58ba229ca.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>"},{"title":"【效率工具】史上最好用的SSH一键登录脚本，超强更新！","date":"2019-03-28T16:26:30.000Z","categorys":null,"_content":"\n## 说明\n\n虽然已经是凌晨，但丝毫不能掩盖我激动的心情，今天完成了对GotoSSH的一次大更新，新增了两个肥肠实用的功能，是真的好用，话不多说，先来看效果图：\n\n普通的一键登录：\n\n![](https://i.loli.net/2019/03/29/5c9cf654b339b.gif)\n\n一键登录跳板机，然后跳转登录线上服务器：\n\n![](https://i.loli.net/2019/03/29/5c9cf6c81ad1f.gif)\n\n![](https://i.loli.net/2019/03/29/5c9cf6ee38d18.gif)\n\n一键登录跳板机查看指定日志：\n\n![](https://i.loli.net/2019/03/29/5c9cf72b7b707.gif)\n\n一键登录跳板机后跳转线上服务器查看指定日志：\n\n![](https://i.loli.net/2019/03/29/5c9cf76aad6ac.gif)\n\n然后是更加劲爆内容，一键从跳板机复制指定文件到本地：\n\n![](https://i.loli.net/2019/03/29/5c9cf782c0db4.gif)\n\n一键从生产环境复制指定文件到本地：\n\n![](https://i.loli.net/2019/03/29/5c9cf7b506db0.gif)\n\n![20190329003615.png](https://i.loli.net/2019/03/29/5c9cf80147c31.png)\n\n我只能说，是真的强。\n\n## Shell脚本\n\nShell脚本已经发布到了`github`上，链接在此：https://github.com/MFrank2016/GotoSSH\n\n可自行前往下载，好用的话别忘了给个star。\n\n## 安装依赖\n\nCentOS :\n```\n$ sudo yum install -y expect\n```\n\nUbuntu :\n```\n$ sudo apt-get install tcl tk expect\n```\n\nMac :\n```\n$ sudo brew install expect\n```\n\n## 安装 GotoSSH\n\n```\n$ git clone https://github.com/MFrank2016/GotoSSH.git\n$ cd GotoSSH\n$ chmod a+x gotossh\n$ sudo cp gotossh /usr/local/bin/\n```\n\n## 配置\n\n```\n$ vim ~/.gotossh_config\nserver_name|ip|username|password|port|rely_server_no\n\n[Server1]\ncommend=tail -f -n 10 testlog.log\n\n[scp]\nlog1=~/testlog.log\n```\n\n配置文件由三部分组成。\n\n第一部分是服务器的基本信息。\n\n```\nserver_name|ip|username|password|port|rely_server_no\n```\n\n举个栗子：\n\n```\nJumpServer1|118.24.163.31|root|testpassword|22|0\nOnlineServerB|111.231.59.85|root|testpassword2|22|1\n```\n\n最后一列是代表该服务器依赖于哪个服务器，如果该列的值设置为0，代表不依赖于其他服务器，否则代表需要先登录其他服务器后才能登录该服务器，目前暂时只支持二连跳，不支持多跳转。\n\n第二部分是自定义命令，你可以在这里为每台服务器单独设置一些自定义命令。\n\n```\n[Server1]\ncommend=tail -f -n 10 testlog.log\n```\n\nServer1 表示以下是为第一台服务器设置的命令，同理Server2则表示为第二台设置的命令。对于顺序没有要求，只要为需要设置自定义命令的服务器添加该选项即可。\n\ncommend 是命令的名字，可以随意取名，最好简单一点，方便输入，等号后面是实际执行的命令。\n\n举个栗子：\n\n```\ngotossh 1 commend\n```\n\n只要你小手一点回车，脚本便会自动帮你登录到第一台服务器，然后执行上面的命令`tail -f -n 10 testlog.log`。\n\n注意，如果你输入的命令需要密码的话，需要在命令后面把密码也带上，并且用|分隔。\n\n举个栗子：\n\n```\n[Server1]\ncommend=scp root@111.231.59.85:/var/log/test-service/test-service.log ./test-server.log|testpassword2\n```\n\n当然，强烈建议不要将类似`rm -rf xxx`等敏感操作放到这里，因为如果配置不当，容易引发事故。\n\n配置文件的最后一部分是对于scp命令的支持。\n\n```\n[scp]\nlog1=~/testlog.log\nlog2=/var/log/test-service/test-service.log\n```\n\nlog1 和 log2 都是随意起的名字，后面是服务器上你想要复制的文件路径，配置好之后，你就可以这样使用：\n\n```\ngotossh 1 scp log1\n```\n\n它就会自动把第一台服务器上的`~/testlog.log`文件复制到你的本地。\n\n```\ngotossh 2 scp log2\n```\n\n这个操作就更厉害了，因为第二台服务器设置了对第一台服务器的依赖，所以它会先登录第一台服务器，然后再复制第二台服务器上的文件到第一台服务器上，最后，退出服务器到本地，将第一台服务器上的复制品再拷贝到本地。\n\n## 配置文件举例\n```\n$ vim ~/.gotossh_config\nJumpServer1|118.24.163.31|root|testpassword|22|0\nOnlineServerB|111.231.59.85|root|testpassword2|22|1\n\n[Server1]\nlog=tail -f -n 20 testlog.log\n\n[Server2]\nlog=tail -f -n 20 /var/log/test-service/test-service.log\ncd=cd /var/log/test-service/\n\n[scp]\nlog3=~/testlog.log\nlog4=/var/log/test-service/test-service.log\n```\n\n## 用法\n```\n$ gotossh\n######################################################################################\n#                                  [GOTO SSH]                                        #\n#                                                                                    #\n#                                                                                    #\n# [1] test_server - 192.168.0.1:root                                                 #\n# [2] online_server - 192.168.2.2:root                                               #\n#                                                                                    #\n#                                                                                    #\n######################################################################################\nServer Number:(Input Server Number Here)\n```\n\n```\ngotossh 1\ngotossh 2\ngotossh 1 log\ngotossh 2 log\ngotossh 2 cd\ngotossh 1 scp log3\ngotossh 2 scp log4\n```\n\n## 解决了什么问题\n\n1. 查询线上服务器日志的时候，需要先登录跳板机，然后再登录服务器，过程比较麻烦。需要多次查看服务器信息，如，ip，用户名，密码等，查看后还需要来回进行复制。利用GotoSSH，配置好服务器信息之后，可以直接一键跳转。\n2. 增加了登录服务器后执行自定义命令，这一点主要是在查看日志的时候，还需要先去查看一下服务的日志路径，然后再切回来看日志，既然每次都是模板式操作，为何不简化一下呢？\n3. 服务器上有时候操作很不方便，因为对权限做了严格的限制，很多命令无法使用，所以增加了对`scp`命令的支持，可以将线上服务器日志一键拷贝到本地，岂不是美滋滋。\n\n最后再贴一下项目地址：https://github.com/MFrank2016/GotoSSH\n\n如果觉得还不错，别忘了加个star✨也欢迎关注我的公众号留言交流。\n\n![](https://i.loli.net/2019/03/14/5c8a58ba229ca.png)\n","source":"_posts/shell/gotossh-update.md","raw":"---\ntitle: 【效率工具】史上最好用的SSH一键登录脚本，超强更新！\ndate: 2019-03-29 00:26:30\ntags:\ncategorys:\n---\n\n## 说明\n\n虽然已经是凌晨，但丝毫不能掩盖我激动的心情，今天完成了对GotoSSH的一次大更新，新增了两个肥肠实用的功能，是真的好用，话不多说，先来看效果图：\n\n普通的一键登录：\n\n![](https://i.loli.net/2019/03/29/5c9cf654b339b.gif)\n\n一键登录跳板机，然后跳转登录线上服务器：\n\n![](https://i.loli.net/2019/03/29/5c9cf6c81ad1f.gif)\n\n![](https://i.loli.net/2019/03/29/5c9cf6ee38d18.gif)\n\n一键登录跳板机查看指定日志：\n\n![](https://i.loli.net/2019/03/29/5c9cf72b7b707.gif)\n\n一键登录跳板机后跳转线上服务器查看指定日志：\n\n![](https://i.loli.net/2019/03/29/5c9cf76aad6ac.gif)\n\n然后是更加劲爆内容，一键从跳板机复制指定文件到本地：\n\n![](https://i.loli.net/2019/03/29/5c9cf782c0db4.gif)\n\n一键从生产环境复制指定文件到本地：\n\n![](https://i.loli.net/2019/03/29/5c9cf7b506db0.gif)\n\n![20190329003615.png](https://i.loli.net/2019/03/29/5c9cf80147c31.png)\n\n我只能说，是真的强。\n\n## Shell脚本\n\nShell脚本已经发布到了`github`上，链接在此：https://github.com/MFrank2016/GotoSSH\n\n可自行前往下载，好用的话别忘了给个star。\n\n## 安装依赖\n\nCentOS :\n```\n$ sudo yum install -y expect\n```\n\nUbuntu :\n```\n$ sudo apt-get install tcl tk expect\n```\n\nMac :\n```\n$ sudo brew install expect\n```\n\n## 安装 GotoSSH\n\n```\n$ git clone https://github.com/MFrank2016/GotoSSH.git\n$ cd GotoSSH\n$ chmod a+x gotossh\n$ sudo cp gotossh /usr/local/bin/\n```\n\n## 配置\n\n```\n$ vim ~/.gotossh_config\nserver_name|ip|username|password|port|rely_server_no\n\n[Server1]\ncommend=tail -f -n 10 testlog.log\n\n[scp]\nlog1=~/testlog.log\n```\n\n配置文件由三部分组成。\n\n第一部分是服务器的基本信息。\n\n```\nserver_name|ip|username|password|port|rely_server_no\n```\n\n举个栗子：\n\n```\nJumpServer1|118.24.163.31|root|testpassword|22|0\nOnlineServerB|111.231.59.85|root|testpassword2|22|1\n```\n\n最后一列是代表该服务器依赖于哪个服务器，如果该列的值设置为0，代表不依赖于其他服务器，否则代表需要先登录其他服务器后才能登录该服务器，目前暂时只支持二连跳，不支持多跳转。\n\n第二部分是自定义命令，你可以在这里为每台服务器单独设置一些自定义命令。\n\n```\n[Server1]\ncommend=tail -f -n 10 testlog.log\n```\n\nServer1 表示以下是为第一台服务器设置的命令，同理Server2则表示为第二台设置的命令。对于顺序没有要求，只要为需要设置自定义命令的服务器添加该选项即可。\n\ncommend 是命令的名字，可以随意取名，最好简单一点，方便输入，等号后面是实际执行的命令。\n\n举个栗子：\n\n```\ngotossh 1 commend\n```\n\n只要你小手一点回车，脚本便会自动帮你登录到第一台服务器，然后执行上面的命令`tail -f -n 10 testlog.log`。\n\n注意，如果你输入的命令需要密码的话，需要在命令后面把密码也带上，并且用|分隔。\n\n举个栗子：\n\n```\n[Server1]\ncommend=scp root@111.231.59.85:/var/log/test-service/test-service.log ./test-server.log|testpassword2\n```\n\n当然，强烈建议不要将类似`rm -rf xxx`等敏感操作放到这里，因为如果配置不当，容易引发事故。\n\n配置文件的最后一部分是对于scp命令的支持。\n\n```\n[scp]\nlog1=~/testlog.log\nlog2=/var/log/test-service/test-service.log\n```\n\nlog1 和 log2 都是随意起的名字，后面是服务器上你想要复制的文件路径，配置好之后，你就可以这样使用：\n\n```\ngotossh 1 scp log1\n```\n\n它就会自动把第一台服务器上的`~/testlog.log`文件复制到你的本地。\n\n```\ngotossh 2 scp log2\n```\n\n这个操作就更厉害了，因为第二台服务器设置了对第一台服务器的依赖，所以它会先登录第一台服务器，然后再复制第二台服务器上的文件到第一台服务器上，最后，退出服务器到本地，将第一台服务器上的复制品再拷贝到本地。\n\n## 配置文件举例\n```\n$ vim ~/.gotossh_config\nJumpServer1|118.24.163.31|root|testpassword|22|0\nOnlineServerB|111.231.59.85|root|testpassword2|22|1\n\n[Server1]\nlog=tail -f -n 20 testlog.log\n\n[Server2]\nlog=tail -f -n 20 /var/log/test-service/test-service.log\ncd=cd /var/log/test-service/\n\n[scp]\nlog3=~/testlog.log\nlog4=/var/log/test-service/test-service.log\n```\n\n## 用法\n```\n$ gotossh\n######################################################################################\n#                                  [GOTO SSH]                                        #\n#                                                                                    #\n#                                                                                    #\n# [1] test_server - 192.168.0.1:root                                                 #\n# [2] online_server - 192.168.2.2:root                                               #\n#                                                                                    #\n#                                                                                    #\n######################################################################################\nServer Number:(Input Server Number Here)\n```\n\n```\ngotossh 1\ngotossh 2\ngotossh 1 log\ngotossh 2 log\ngotossh 2 cd\ngotossh 1 scp log3\ngotossh 2 scp log4\n```\n\n## 解决了什么问题\n\n1. 查询线上服务器日志的时候，需要先登录跳板机，然后再登录服务器，过程比较麻烦。需要多次查看服务器信息，如，ip，用户名，密码等，查看后还需要来回进行复制。利用GotoSSH，配置好服务器信息之后，可以直接一键跳转。\n2. 增加了登录服务器后执行自定义命令，这一点主要是在查看日志的时候，还需要先去查看一下服务的日志路径，然后再切回来看日志，既然每次都是模板式操作，为何不简化一下呢？\n3. 服务器上有时候操作很不方便，因为对权限做了严格的限制，很多命令无法使用，所以增加了对`scp`命令的支持，可以将线上服务器日志一键拷贝到本地，岂不是美滋滋。\n\n最后再贴一下项目地址：https://github.com/MFrank2016/GotoSSH\n\n如果觉得还不错，别忘了加个star✨也欢迎关注我的公众号留言交流。\n\n![](https://i.loli.net/2019/03/14/5c8a58ba229ca.png)\n","slug":"shell/gotossh-update","published":1,"updated":"2019-06-04T01:29:57.588Z","_id":"cjxze3gpc00250cvwda23pozc","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>虽然已经是凌晨，但丝毫不能掩盖我激动的心情，今天完成了对GotoSSH的一次大更新，新增了两个肥肠实用的功能，是真的好用，话不多说，先来看效果图：</p>\n<p>普通的一键登录：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/29/5c9cf654b339b.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>一键登录跳板机，然后跳转登录线上服务器：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/29/5c9cf6c81ad1f.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/29/5c9cf6ee38d18.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>一键登录跳板机查看指定日志：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/29/5c9cf72b7b707.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>一键登录跳板机后跳转线上服务器查看指定日志：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/29/5c9cf76aad6ac.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>然后是更加劲爆内容，一键从跳板机复制指定文件到本地：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/29/5c9cf782c0db4.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>一键从生产环境复制指定文件到本地：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/29/5c9cf7b506db0.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/29/5c9cf80147c31.png\" alt=\"20190329003615.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190329003615.png</div>\n            </figure>\n<p>我只能说，是真的强。</p>\n<h2 id=\"Shell脚本\"><a href=\"#Shell脚本\" class=\"headerlink\" title=\"Shell脚本\"></a>Shell脚本</h2><p>Shell脚本已经发布到了<code>github</code>上，链接在此：<a href=\"https://github.com/MFrank2016/GotoSSH\" target=\"_blank\" rel=\"noopener\">https://github.com/MFrank2016/GotoSSH</a></p>\n<p>可自行前往下载，好用的话别忘了给个star。</p>\n<h2 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h2><p>CentOS :<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo yum install -y expect</span><br></pre></td></tr></table></figure></p>\n<p>Ubuntu :<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install tcl tk expect</span><br></pre></td></tr></table></figure></p>\n<p>Mac :<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo brew install expect</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"安装-GotoSSH\"><a href=\"#安装-GotoSSH\" class=\"headerlink\" title=\"安装 GotoSSH\"></a>安装 GotoSSH</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone https://github.com/MFrank2016/GotoSSH.git</span><br><span class=\"line\">$ cd GotoSSH</span><br><span class=\"line\">$ chmod a+x gotossh</span><br><span class=\"line\">$ sudo cp gotossh /usr/local/bin/</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vim ~/.gotossh_config</span><br><span class=\"line\">server_name|ip|username|password|port|rely_server_no</span><br><span class=\"line\"></span><br><span class=\"line\">[Server1]</span><br><span class=\"line\">commend=tail -f -n 10 testlog.log</span><br><span class=\"line\"></span><br><span class=\"line\">[scp]</span><br><span class=\"line\">log1=~/testlog.log</span><br></pre></td></tr></table></figure>\n<p>配置文件由三部分组成。</p>\n<p>第一部分是服务器的基本信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server_name|ip|username|password|port|rely_server_no</span><br></pre></td></tr></table></figure>\n<p>举个栗子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JumpServer1|118.24.163.31|root|testpassword|22|0</span><br><span class=\"line\">OnlineServerB|111.231.59.85|root|testpassword2|22|1</span><br></pre></td></tr></table></figure>\n<p>最后一列是代表该服务器依赖于哪个服务器，如果该列的值设置为0，代表不依赖于其他服务器，否则代表需要先登录其他服务器后才能登录该服务器，目前暂时只支持二连跳，不支持多跳转。</p>\n<p>第二部分是自定义命令，你可以在这里为每台服务器单独设置一些自定义命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Server1]</span><br><span class=\"line\">commend=tail -f -n 10 testlog.log</span><br></pre></td></tr></table></figure>\n<p>Server1 表示以下是为第一台服务器设置的命令，同理Server2则表示为第二台设置的命令。对于顺序没有要求，只要为需要设置自定义命令的服务器添加该选项即可。</p>\n<p>commend 是命令的名字，可以随意取名，最好简单一点，方便输入，等号后面是实际执行的命令。</p>\n<p>举个栗子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gotossh 1 commend</span><br></pre></td></tr></table></figure>\n<p>只要你小手一点回车，脚本便会自动帮你登录到第一台服务器，然后执行上面的命令<code>tail -f -n 10 testlog.log</code>。</p>\n<p>注意，如果你输入的命令需要密码的话，需要在命令后面把密码也带上，并且用|分隔。</p>\n<p>举个栗子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Server1]</span><br><span class=\"line\">commend=scp root@111.231.59.85:/var/log/test-service/test-service.log ./test-server.log|testpassword2</span><br></pre></td></tr></table></figure>\n<p>当然，强烈建议不要将类似<code>rm -rf xxx</code>等敏感操作放到这里，因为如果配置不当，容易引发事故。</p>\n<p>配置文件的最后一部分是对于scp命令的支持。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[scp]</span><br><span class=\"line\">log1=~/testlog.log</span><br><span class=\"line\">log2=/var/log/test-service/test-service.log</span><br></pre></td></tr></table></figure>\n<p>log1 和 log2 都是随意起的名字，后面是服务器上你想要复制的文件路径，配置好之后，你就可以这样使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gotossh 1 scp log1</span><br></pre></td></tr></table></figure>\n<p>它就会自动把第一台服务器上的<code>~/testlog.log</code>文件复制到你的本地。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gotossh 2 scp log2</span><br></pre></td></tr></table></figure>\n<p>这个操作就更厉害了，因为第二台服务器设置了对第一台服务器的依赖，所以它会先登录第一台服务器，然后再复制第二台服务器上的文件到第一台服务器上，最后，退出服务器到本地，将第一台服务器上的复制品再拷贝到本地。</p>\n<h2 id=\"配置文件举例\"><a href=\"#配置文件举例\" class=\"headerlink\" title=\"配置文件举例\"></a>配置文件举例</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vim ~/.gotossh_config</span><br><span class=\"line\">JumpServer1|118.24.163.31|root|testpassword|22|0</span><br><span class=\"line\">OnlineServerB|111.231.59.85|root|testpassword2|22|1</span><br><span class=\"line\"></span><br><span class=\"line\">[Server1]</span><br><span class=\"line\">log=tail -f -n 20 testlog.log</span><br><span class=\"line\"></span><br><span class=\"line\">[Server2]</span><br><span class=\"line\">log=tail -f -n 20 /var/log/test-service/test-service.log</span><br><span class=\"line\">cd=cd /var/log/test-service/</span><br><span class=\"line\"></span><br><span class=\"line\">[scp]</span><br><span class=\"line\">log3=~/testlog.log</span><br><span class=\"line\">log4=/var/log/test-service/test-service.log</span><br></pre></td></tr></table></figure>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gotossh</span><br><span class=\"line\">######################################################################################</span><br><span class=\"line\">#                                  [GOTO SSH]                                        #</span><br><span class=\"line\">#                                                                                    #</span><br><span class=\"line\">#                                                                                    #</span><br><span class=\"line\"># [1] test_server - 192.168.0.1:root                                                 #</span><br><span class=\"line\"># [2] online_server - 192.168.2.2:root                                               #</span><br><span class=\"line\">#                                                                                    #</span><br><span class=\"line\">#                                                                                    #</span><br><span class=\"line\">######################################################################################</span><br><span class=\"line\">Server Number:(Input Server Number Here)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gotossh 1</span><br><span class=\"line\">gotossh 2</span><br><span class=\"line\">gotossh 1 log</span><br><span class=\"line\">gotossh 2 log</span><br><span class=\"line\">gotossh 2 cd</span><br><span class=\"line\">gotossh 1 scp log3</span><br><span class=\"line\">gotossh 2 scp log4</span><br></pre></td></tr></table></figure>\n<h2 id=\"解决了什么问题\"><a href=\"#解决了什么问题\" class=\"headerlink\" title=\"解决了什么问题\"></a>解决了什么问题</h2><ol>\n<li>查询线上服务器日志的时候，需要先登录跳板机，然后再登录服务器，过程比较麻烦。需要多次查看服务器信息，如，ip，用户名，密码等，查看后还需要来回进行复制。利用GotoSSH，配置好服务器信息之后，可以直接一键跳转。</li>\n<li>增加了登录服务器后执行自定义命令，这一点主要是在查看日志的时候，还需要先去查看一下服务的日志路径，然后再切回来看日志，既然每次都是模板式操作，为何不简化一下呢？</li>\n<li>服务器上有时候操作很不方便，因为对权限做了严格的限制，很多命令无法使用，所以增加了对<code>scp</code>命令的支持，可以将线上服务器日志一键拷贝到本地，岂不是美滋滋。</li>\n</ol>\n<p>最后再贴一下项目地址：<a href=\"https://github.com/MFrank2016/GotoSSH\" target=\"_blank\" rel=\"noopener\">https://github.com/MFrank2016/GotoSSH</a></p>\n<p>如果觉得还不错，别忘了加个star✨也欢迎关注我的公众号留言交流。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a58ba229ca.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>虽然已经是凌晨，但丝毫不能掩盖我激动的心情，今天完成了对GotoSSH的一次大更新，新增了两个肥肠实用的功能，是真的好用，话不多说，先来看效果图：</p>\n<p>普通的一键登录：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/29/5c9cf654b339b.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>一键登录跳板机，然后跳转登录线上服务器：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/29/5c9cf6c81ad1f.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/29/5c9cf6ee38d18.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>一键登录跳板机查看指定日志：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/29/5c9cf72b7b707.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>一键登录跳板机后跳转线上服务器查看指定日志：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/29/5c9cf76aad6ac.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>然后是更加劲爆内容，一键从跳板机复制指定文件到本地：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/29/5c9cf782c0db4.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>一键从生产环境复制指定文件到本地：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/29/5c9cf7b506db0.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/29/5c9cf80147c31.png\" alt=\"20190329003615.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190329003615.png</div>\n            </figure>\n<p>我只能说，是真的强。</p>\n<h2 id=\"Shell脚本\"><a href=\"#Shell脚本\" class=\"headerlink\" title=\"Shell脚本\"></a>Shell脚本</h2><p>Shell脚本已经发布到了<code>github</code>上，链接在此：<a href=\"https://github.com/MFrank2016/GotoSSH\" target=\"_blank\" rel=\"noopener\">https://github.com/MFrank2016/GotoSSH</a></p>\n<p>可自行前往下载，好用的话别忘了给个star。</p>\n<h2 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h2><p>CentOS :<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo yum install -y expect</span><br></pre></td></tr></table></figure></p>\n<p>Ubuntu :<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install tcl tk expect</span><br></pre></td></tr></table></figure></p>\n<p>Mac :<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo brew install expect</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"安装-GotoSSH\"><a href=\"#安装-GotoSSH\" class=\"headerlink\" title=\"安装 GotoSSH\"></a>安装 GotoSSH</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone https://github.com/MFrank2016/GotoSSH.git</span><br><span class=\"line\">$ cd GotoSSH</span><br><span class=\"line\">$ chmod a+x gotossh</span><br><span class=\"line\">$ sudo cp gotossh /usr/local/bin/</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vim ~/.gotossh_config</span><br><span class=\"line\">server_name|ip|username|password|port|rely_server_no</span><br><span class=\"line\"></span><br><span class=\"line\">[Server1]</span><br><span class=\"line\">commend=tail -f -n 10 testlog.log</span><br><span class=\"line\"></span><br><span class=\"line\">[scp]</span><br><span class=\"line\">log1=~/testlog.log</span><br></pre></td></tr></table></figure>\n<p>配置文件由三部分组成。</p>\n<p>第一部分是服务器的基本信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server_name|ip|username|password|port|rely_server_no</span><br></pre></td></tr></table></figure>\n<p>举个栗子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JumpServer1|118.24.163.31|root|testpassword|22|0</span><br><span class=\"line\">OnlineServerB|111.231.59.85|root|testpassword2|22|1</span><br></pre></td></tr></table></figure>\n<p>最后一列是代表该服务器依赖于哪个服务器，如果该列的值设置为0，代表不依赖于其他服务器，否则代表需要先登录其他服务器后才能登录该服务器，目前暂时只支持二连跳，不支持多跳转。</p>\n<p>第二部分是自定义命令，你可以在这里为每台服务器单独设置一些自定义命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Server1]</span><br><span class=\"line\">commend=tail -f -n 10 testlog.log</span><br></pre></td></tr></table></figure>\n<p>Server1 表示以下是为第一台服务器设置的命令，同理Server2则表示为第二台设置的命令。对于顺序没有要求，只要为需要设置自定义命令的服务器添加该选项即可。</p>\n<p>commend 是命令的名字，可以随意取名，最好简单一点，方便输入，等号后面是实际执行的命令。</p>\n<p>举个栗子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gotossh 1 commend</span><br></pre></td></tr></table></figure>\n<p>只要你小手一点回车，脚本便会自动帮你登录到第一台服务器，然后执行上面的命令<code>tail -f -n 10 testlog.log</code>。</p>\n<p>注意，如果你输入的命令需要密码的话，需要在命令后面把密码也带上，并且用|分隔。</p>\n<p>举个栗子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Server1]</span><br><span class=\"line\">commend=scp root@111.231.59.85:/var/log/test-service/test-service.log ./test-server.log|testpassword2</span><br></pre></td></tr></table></figure>\n<p>当然，强烈建议不要将类似<code>rm -rf xxx</code>等敏感操作放到这里，因为如果配置不当，容易引发事故。</p>\n<p>配置文件的最后一部分是对于scp命令的支持。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[scp]</span><br><span class=\"line\">log1=~/testlog.log</span><br><span class=\"line\">log2=/var/log/test-service/test-service.log</span><br></pre></td></tr></table></figure>\n<p>log1 和 log2 都是随意起的名字，后面是服务器上你想要复制的文件路径，配置好之后，你就可以这样使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gotossh 1 scp log1</span><br></pre></td></tr></table></figure>\n<p>它就会自动把第一台服务器上的<code>~/testlog.log</code>文件复制到你的本地。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gotossh 2 scp log2</span><br></pre></td></tr></table></figure>\n<p>这个操作就更厉害了，因为第二台服务器设置了对第一台服务器的依赖，所以它会先登录第一台服务器，然后再复制第二台服务器上的文件到第一台服务器上，最后，退出服务器到本地，将第一台服务器上的复制品再拷贝到本地。</p>\n<h2 id=\"配置文件举例\"><a href=\"#配置文件举例\" class=\"headerlink\" title=\"配置文件举例\"></a>配置文件举例</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vim ~/.gotossh_config</span><br><span class=\"line\">JumpServer1|118.24.163.31|root|testpassword|22|0</span><br><span class=\"line\">OnlineServerB|111.231.59.85|root|testpassword2|22|1</span><br><span class=\"line\"></span><br><span class=\"line\">[Server1]</span><br><span class=\"line\">log=tail -f -n 20 testlog.log</span><br><span class=\"line\"></span><br><span class=\"line\">[Server2]</span><br><span class=\"line\">log=tail -f -n 20 /var/log/test-service/test-service.log</span><br><span class=\"line\">cd=cd /var/log/test-service/</span><br><span class=\"line\"></span><br><span class=\"line\">[scp]</span><br><span class=\"line\">log3=~/testlog.log</span><br><span class=\"line\">log4=/var/log/test-service/test-service.log</span><br></pre></td></tr></table></figure>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gotossh</span><br><span class=\"line\">######################################################################################</span><br><span class=\"line\">#                                  [GOTO SSH]                                        #</span><br><span class=\"line\">#                                                                                    #</span><br><span class=\"line\">#                                                                                    #</span><br><span class=\"line\"># [1] test_server - 192.168.0.1:root                                                 #</span><br><span class=\"line\"># [2] online_server - 192.168.2.2:root                                               #</span><br><span class=\"line\">#                                                                                    #</span><br><span class=\"line\">#                                                                                    #</span><br><span class=\"line\">######################################################################################</span><br><span class=\"line\">Server Number:(Input Server Number Here)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gotossh 1</span><br><span class=\"line\">gotossh 2</span><br><span class=\"line\">gotossh 1 log</span><br><span class=\"line\">gotossh 2 log</span><br><span class=\"line\">gotossh 2 cd</span><br><span class=\"line\">gotossh 1 scp log3</span><br><span class=\"line\">gotossh 2 scp log4</span><br></pre></td></tr></table></figure>\n<h2 id=\"解决了什么问题\"><a href=\"#解决了什么问题\" class=\"headerlink\" title=\"解决了什么问题\"></a>解决了什么问题</h2><ol>\n<li>查询线上服务器日志的时候，需要先登录跳板机，然后再登录服务器，过程比较麻烦。需要多次查看服务器信息，如，ip，用户名，密码等，查看后还需要来回进行复制。利用GotoSSH，配置好服务器信息之后，可以直接一键跳转。</li>\n<li>增加了登录服务器后执行自定义命令，这一点主要是在查看日志的时候，还需要先去查看一下服务的日志路径，然后再切回来看日志，既然每次都是模板式操作，为何不简化一下呢？</li>\n<li>服务器上有时候操作很不方便，因为对权限做了严格的限制，很多命令无法使用，所以增加了对<code>scp</code>命令的支持，可以将线上服务器日志一键拷贝到本地，岂不是美滋滋。</li>\n</ol>\n<p>最后再贴一下项目地址：<a href=\"https://github.com/MFrank2016/GotoSSH\" target=\"_blank\" rel=\"noopener\">https://github.com/MFrank2016/GotoSSH</a></p>\n<p>如果觉得还不错，别忘了加个star✨也欢迎关注我的公众号留言交流。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a58ba229ca.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n"},{"title":"【效率工具】史上最好用的SSH一键登录脚本，第三版更新！","date":"2019-04-04T11:10:39.000Z","categorys":null,"_content":"\n## 说明\n\n时隔一周，GotoSSH又迎来了一次重大更新，让这个史诗级的shell工具变得更加丝般顺滑了~\n\n这次的主要更新是对自定义全局命令以及自定义属性的支持，让设置更加灵活，此外，对各个细节进行了调整，并修复了一些极少数情况下可能会发生的bug。\n\n另外，最重要的一点是，对代码进行了大量优化和注释，让小白也能很轻松的看懂各个地方是在做什么事情，毕竟对于服务器信息这么隐私的信息，交给一个第三方shell来管理，大家难免会有些不放心嘛，这个可以理解，所以特意做了这个更新，让大家能放心食用。\n\n有能力的小伙伴也可以把这个shell脚本自行改进，让它变得更加好用，如果有其他想法，欢迎提出，会考虑在后续更新中进行添加。\n\n## 更新后样式\n\n普通的一键登录到服务器:\n\n![](https://i.loli.net/2019/04/08/5caa300e3e11c.gif)\n\n先登录跳板机，然后自动跳转到线上服务器：\n\n![](https://i.loli.net/2019/04/08/5caa305847211.gif)\n\n![](https://i.loli.net/2019/04/08/5caa30d31db3a.gif)\n\n登录服务并查看日志：\n\n![](https://i.loli.net/2019/04/08/5caa36045135c.gif)\n\n![](https://i.loli.net/2019/04/08/5caa3603366a4.gif)\n\n登录跳板机，然后跳转线上服务器并查看指定日志：\n\n![](https://i.loli.net/2019/04/08/5caa3ac235cf7.gif)\n\n从服务器复制文件到本地：\n\n![](https://i.loli.net/2019/04/08/5caab56a6e3c3.gif)\n\n从线上服务器复制文件到跳板机，然后再复制到本地：\n\n![](https://i.loli.net/2019/04/08/5caab6078e829.gif)\n\n列举所有服务器:\n\n![](https://i.loli.net/2019/04/08/5caab7530dc2c.gif)\n\n列举服务器支持的所有命令:\n\n![list-all-the-commands.gif](https://i.loli.net/2019/04/08/5caab7d733ef1.gif)\n\n## v3版本更新功能\n\n1. 新增了两个命令，一个是查看服务器列表，一个是查看支持的命令列表。\n   \n因为有小伙伴反映说，记不住哪个服务器是几号，每次需要先输入`gotossh`来查看，然后再`ctrl + c`退出，之后再进行长命令操作，感觉不太优雅。emmmm，于是就有了这么个功能：\n\n![](https://i.loli.net/2019/04/08/5caab7530dc2c.gif)\n\n现在可以使用`gotossh -l`查看所有的服务器列表了。\n\n此外，顺便增加了对自定义命令的更友好支持，一是在选择完服务器后，会显示该服务器支持的命令列表，包括该服务器的自定义命令，以及全局命令。\n\n![list-all-the-commands.gif](https://i.loli.net/2019/04/08/5caab7d733ef1.gif)\n\n2. 配置文件中，新增了`setting`节点和`common-command`节点。\n   \n前者是用于设置全局配置信息，目前仅有version信息，用于之后的升级迭代。后续会考虑加入如颜色，显示方案等自定义配置。\n\n后者即全局公用命令，可以看做是模板命令，为什么要做这个功能呢？\n\n很多服务的日志地址其实是类似的，比如A服务的日志地址也许是：`/var/log/server-a/service-a.log`，B服务的日志地址也许是：`/var/log/server-b/server-b.log`，它们的大致路径其实是差不多的，所以如果有了模板命令，我们便不需要给每个服务器来单独设置一个自定义命令了，只需要在该自定义属性中配置相应属性即可。\n\n比如设置一条模板命令：\n\n```\n[common-command]\nlog=/var/log/[service-name]/[service-name].log\n```\n\n再为服务a和服务b设置相应的属性：\n\n```\n[Server-Attribute-service-a]\nservice-name=service-a\n\n[Server-Attribute-service-b]\nservice-name=service-b\n```\n\n这样一来，使用就更加优雅了，管理起来也更加方便。\n\n3. 配置文件中，服务器信息的分割符由原来的“|”改成了“||”\n   \n因为考虑到密码中可能含有“|”，所以进行了上述调整，不过仍旧没法解决密码中存在“||”的情况，emmm，这种情况应该不多，暂时先不考虑了。\n\n4. 配置文件中，改用`link_name`作为服务器标识\n\n之前配置自定义命令时，使用的是`Server-ServerNo`的形式，但如果服务器数量比较多，删除前面的服务器配置后，会导致后面的服务器编号改变，这样就需要对自定义节点进行调整，比较麻烦，所以使用`Server-link_name`来作为节点名称就是来解决这个问题的。\n\n5. 配置文件中，新增了自定义属性\n\n上面其实已经看到过了，可以新增`Server-Attribute-link_name`节点来设置服务器的自定义属性，这个自定义属性可以用在自定义命令或者全局公用命令中进行替换。\n\n另外，还新增了两个特殊的自定义属性`[P1][P2]`，分别代表传入脚本的第三个和第四个参数，举个栗子：\n\n```\n[Server-service-a]\ncd=cd [P1]\n```\n\n使用如上配置后，当输入`gotossh 1 cd /var/log/service-a`（假设service-a是第一台服务器）后，将会先登录该服务器，然后执行`cd /var/log/service-a`命令，这里`[P1]`将会被传入脚本的第三个参数`/var/log/service-a`所替代，同理，还可以在命令中使用`[P2]`，它将被第四个参数替代。\n\n6. 新增了大量注释，让代码看起来更加清晰\n\n目的在前面已经说过了，这里就不再赘述了，希望大家多提建议，一起来让这个shell脚本变得更好好用。\n\n## 旧版本升级\n\n如果你已经使用了之前的版本，那么使用新版本的话，你需要进行以下操作：\n\n1. 进入`/usr/local/bin/`删除原来的shell。\n2. 安装依赖\n\n```shell\n$ brew install gnu-sed --with-default-names\n$ export PATH=\"$(brew --prefix coreutils)/libexec/gnubin:/usr/local/bin:$PATH\"\n$ export MANPATH=\"/usr/local/opt/coreutils/libexec/gnuman:$MANPATH\"\n```\n3. 拉取最新代码并安装\n\n```shell\n$ git clone https://github.com/MFrank2016/GotoSSH.git\n$ cd GotoSSH\n$ chmod a+x gotossh\n$ sudo cp gotossh /usr/local/bin/\n```\n\nshell里已经写好了配置升级的函数，所以不用太担心旧配置的调整。如果想要使用新功能的话，参照上面的说明，添加相应的节点，如`common-command`即可。\n\n## 小结\n\n`GotoSSH`虽然只是一个小的脚本，但是说实话，这个几百行的脚本调试起来可真的不容易，没法打断点就只能用输出的方式一点点的排查问题，比较蛋疼，清明节花了一整天的时间才调试好，希望大家能多多支持一下，给项目加个star的话就非常感谢啦。\n\n","source":"_posts/shell/gotossh-v3-md.md","raw":"---\ntitle: 【效率工具】史上最好用的SSH一键登录脚本，第三版更新！\ndate: 2019-04-04 19:10:39\ntags:\ncategorys:\n---\n\n## 说明\n\n时隔一周，GotoSSH又迎来了一次重大更新，让这个史诗级的shell工具变得更加丝般顺滑了~\n\n这次的主要更新是对自定义全局命令以及自定义属性的支持，让设置更加灵活，此外，对各个细节进行了调整，并修复了一些极少数情况下可能会发生的bug。\n\n另外，最重要的一点是，对代码进行了大量优化和注释，让小白也能很轻松的看懂各个地方是在做什么事情，毕竟对于服务器信息这么隐私的信息，交给一个第三方shell来管理，大家难免会有些不放心嘛，这个可以理解，所以特意做了这个更新，让大家能放心食用。\n\n有能力的小伙伴也可以把这个shell脚本自行改进，让它变得更加好用，如果有其他想法，欢迎提出，会考虑在后续更新中进行添加。\n\n## 更新后样式\n\n普通的一键登录到服务器:\n\n![](https://i.loli.net/2019/04/08/5caa300e3e11c.gif)\n\n先登录跳板机，然后自动跳转到线上服务器：\n\n![](https://i.loli.net/2019/04/08/5caa305847211.gif)\n\n![](https://i.loli.net/2019/04/08/5caa30d31db3a.gif)\n\n登录服务并查看日志：\n\n![](https://i.loli.net/2019/04/08/5caa36045135c.gif)\n\n![](https://i.loli.net/2019/04/08/5caa3603366a4.gif)\n\n登录跳板机，然后跳转线上服务器并查看指定日志：\n\n![](https://i.loli.net/2019/04/08/5caa3ac235cf7.gif)\n\n从服务器复制文件到本地：\n\n![](https://i.loli.net/2019/04/08/5caab56a6e3c3.gif)\n\n从线上服务器复制文件到跳板机，然后再复制到本地：\n\n![](https://i.loli.net/2019/04/08/5caab6078e829.gif)\n\n列举所有服务器:\n\n![](https://i.loli.net/2019/04/08/5caab7530dc2c.gif)\n\n列举服务器支持的所有命令:\n\n![list-all-the-commands.gif](https://i.loli.net/2019/04/08/5caab7d733ef1.gif)\n\n## v3版本更新功能\n\n1. 新增了两个命令，一个是查看服务器列表，一个是查看支持的命令列表。\n   \n因为有小伙伴反映说，记不住哪个服务器是几号，每次需要先输入`gotossh`来查看，然后再`ctrl + c`退出，之后再进行长命令操作，感觉不太优雅。emmmm，于是就有了这么个功能：\n\n![](https://i.loli.net/2019/04/08/5caab7530dc2c.gif)\n\n现在可以使用`gotossh -l`查看所有的服务器列表了。\n\n此外，顺便增加了对自定义命令的更友好支持，一是在选择完服务器后，会显示该服务器支持的命令列表，包括该服务器的自定义命令，以及全局命令。\n\n![list-all-the-commands.gif](https://i.loli.net/2019/04/08/5caab7d733ef1.gif)\n\n2. 配置文件中，新增了`setting`节点和`common-command`节点。\n   \n前者是用于设置全局配置信息，目前仅有version信息，用于之后的升级迭代。后续会考虑加入如颜色，显示方案等自定义配置。\n\n后者即全局公用命令，可以看做是模板命令，为什么要做这个功能呢？\n\n很多服务的日志地址其实是类似的，比如A服务的日志地址也许是：`/var/log/server-a/service-a.log`，B服务的日志地址也许是：`/var/log/server-b/server-b.log`，它们的大致路径其实是差不多的，所以如果有了模板命令，我们便不需要给每个服务器来单独设置一个自定义命令了，只需要在该自定义属性中配置相应属性即可。\n\n比如设置一条模板命令：\n\n```\n[common-command]\nlog=/var/log/[service-name]/[service-name].log\n```\n\n再为服务a和服务b设置相应的属性：\n\n```\n[Server-Attribute-service-a]\nservice-name=service-a\n\n[Server-Attribute-service-b]\nservice-name=service-b\n```\n\n这样一来，使用就更加优雅了，管理起来也更加方便。\n\n3. 配置文件中，服务器信息的分割符由原来的“|”改成了“||”\n   \n因为考虑到密码中可能含有“|”，所以进行了上述调整，不过仍旧没法解决密码中存在“||”的情况，emmm，这种情况应该不多，暂时先不考虑了。\n\n4. 配置文件中，改用`link_name`作为服务器标识\n\n之前配置自定义命令时，使用的是`Server-ServerNo`的形式，但如果服务器数量比较多，删除前面的服务器配置后，会导致后面的服务器编号改变，这样就需要对自定义节点进行调整，比较麻烦，所以使用`Server-link_name`来作为节点名称就是来解决这个问题的。\n\n5. 配置文件中，新增了自定义属性\n\n上面其实已经看到过了，可以新增`Server-Attribute-link_name`节点来设置服务器的自定义属性，这个自定义属性可以用在自定义命令或者全局公用命令中进行替换。\n\n另外，还新增了两个特殊的自定义属性`[P1][P2]`，分别代表传入脚本的第三个和第四个参数，举个栗子：\n\n```\n[Server-service-a]\ncd=cd [P1]\n```\n\n使用如上配置后，当输入`gotossh 1 cd /var/log/service-a`（假设service-a是第一台服务器）后，将会先登录该服务器，然后执行`cd /var/log/service-a`命令，这里`[P1]`将会被传入脚本的第三个参数`/var/log/service-a`所替代，同理，还可以在命令中使用`[P2]`，它将被第四个参数替代。\n\n6. 新增了大量注释，让代码看起来更加清晰\n\n目的在前面已经说过了，这里就不再赘述了，希望大家多提建议，一起来让这个shell脚本变得更好好用。\n\n## 旧版本升级\n\n如果你已经使用了之前的版本，那么使用新版本的话，你需要进行以下操作：\n\n1. 进入`/usr/local/bin/`删除原来的shell。\n2. 安装依赖\n\n```shell\n$ brew install gnu-sed --with-default-names\n$ export PATH=\"$(brew --prefix coreutils)/libexec/gnubin:/usr/local/bin:$PATH\"\n$ export MANPATH=\"/usr/local/opt/coreutils/libexec/gnuman:$MANPATH\"\n```\n3. 拉取最新代码并安装\n\n```shell\n$ git clone https://github.com/MFrank2016/GotoSSH.git\n$ cd GotoSSH\n$ chmod a+x gotossh\n$ sudo cp gotossh /usr/local/bin/\n```\n\nshell里已经写好了配置升级的函数，所以不用太担心旧配置的调整。如果想要使用新功能的话，参照上面的说明，添加相应的节点，如`common-command`即可。\n\n## 小结\n\n`GotoSSH`虽然只是一个小的脚本，但是说实话，这个几百行的脚本调试起来可真的不容易，没法打断点就只能用输出的方式一点点的排查问题，比较蛋疼，清明节花了一整天的时间才调试好，希望大家能多多支持一下，给项目加个star的话就非常感谢啦。\n\n","slug":"shell/gotossh-v3-md","published":1,"updated":"2019-06-04T01:29:57.612Z","_id":"cjxze3gq600340cvwa3a902j4","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>时隔一周，GotoSSH又迎来了一次重大更新，让这个史诗级的shell工具变得更加丝般顺滑了~</p>\n<p>这次的主要更新是对自定义全局命令以及自定义属性的支持，让设置更加灵活，此外，对各个细节进行了调整，并修复了一些极少数情况下可能会发生的bug。</p>\n<p>另外，最重要的一点是，对代码进行了大量优化和注释，让小白也能很轻松的看懂各个地方是在做什么事情，毕竟对于服务器信息这么隐私的信息，交给一个第三方shell来管理，大家难免会有些不放心嘛，这个可以理解，所以特意做了这个更新，让大家能放心食用。</p>\n<p>有能力的小伙伴也可以把这个shell脚本自行改进，让它变得更加好用，如果有其他想法，欢迎提出，会考虑在后续更新中进行添加。</p>\n<h2 id=\"更新后样式\"><a href=\"#更新后样式\" class=\"headerlink\" title=\"更新后样式\"></a>更新后样式</h2><p>普通的一键登录到服务器:</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/08/5caa300e3e11c.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>先登录跳板机，然后自动跳转到线上服务器：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/08/5caa305847211.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/08/5caa30d31db3a.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>登录服务并查看日志：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/08/5caa36045135c.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/08/5caa3603366a4.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>登录跳板机，然后跳转线上服务器并查看指定日志：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/08/5caa3ac235cf7.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>从服务器复制文件到本地：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/08/5caab56a6e3c3.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>从线上服务器复制文件到跳板机，然后再复制到本地：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/08/5caab6078e829.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>列举所有服务器:</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/08/5caab7530dc2c.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>列举服务器支持的所有命令:</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/08/5caab7d733ef1.gif\" alt=\"list-all-the-commands.gif\" title=\"\">\n                </div>\n                <div class=\"image-caption\">list-all-the-commands.gif</div>\n            </figure>\n<h2 id=\"v3版本更新功能\"><a href=\"#v3版本更新功能\" class=\"headerlink\" title=\"v3版本更新功能\"></a>v3版本更新功能</h2><ol>\n<li>新增了两个命令，一个是查看服务器列表，一个是查看支持的命令列表。</li>\n</ol>\n<p>因为有小伙伴反映说，记不住哪个服务器是几号，每次需要先输入<code>gotossh</code>来查看，然后再<code>ctrl + c</code>退出，之后再进行长命令操作，感觉不太优雅。emmmm，于是就有了这么个功能：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/08/5caab7530dc2c.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>现在可以使用<code>gotossh -l</code>查看所有的服务器列表了。</p>\n<p>此外，顺便增加了对自定义命令的更友好支持，一是在选择完服务器后，会显示该服务器支持的命令列表，包括该服务器的自定义命令，以及全局命令。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/08/5caab7d733ef1.gif\" alt=\"list-all-the-commands.gif\" title=\"\">\n                </div>\n                <div class=\"image-caption\">list-all-the-commands.gif</div>\n            </figure>\n<ol start=\"2\">\n<li>配置文件中，新增了<code>setting</code>节点和<code>common-command</code>节点。</li>\n</ol>\n<p>前者是用于设置全局配置信息，目前仅有version信息，用于之后的升级迭代。后续会考虑加入如颜色，显示方案等自定义配置。</p>\n<p>后者即全局公用命令，可以看做是模板命令，为什么要做这个功能呢？</p>\n<p>很多服务的日志地址其实是类似的，比如A服务的日志地址也许是：<code>/var/log/server-a/service-a.log</code>，B服务的日志地址也许是：<code>/var/log/server-b/server-b.log</code>，它们的大致路径其实是差不多的，所以如果有了模板命令，我们便不需要给每个服务器来单独设置一个自定义命令了，只需要在该自定义属性中配置相应属性即可。</p>\n<p>比如设置一条模板命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common-command]</span><br><span class=\"line\">log=/var/log/[service-name]/[service-name].log</span><br></pre></td></tr></table></figure>\n<p>再为服务a和服务b设置相应的属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Server-Attribute-service-a]</span><br><span class=\"line\">service-name=service-a</span><br><span class=\"line\"></span><br><span class=\"line\">[Server-Attribute-service-b]</span><br><span class=\"line\">service-name=service-b</span><br></pre></td></tr></table></figure>\n<p>这样一来，使用就更加优雅了，管理起来也更加方便。</p>\n<ol start=\"3\">\n<li>配置文件中，服务器信息的分割符由原来的“|”改成了“||”</li>\n</ol>\n<p>因为考虑到密码中可能含有“|”，所以进行了上述调整，不过仍旧没法解决密码中存在“||”的情况，emmm，这种情况应该不多，暂时先不考虑了。</p>\n<ol start=\"4\">\n<li>配置文件中，改用<code>link_name</code>作为服务器标识</li>\n</ol>\n<p>之前配置自定义命令时，使用的是<code>Server-ServerNo</code>的形式，但如果服务器数量比较多，删除前面的服务器配置后，会导致后面的服务器编号改变，这样就需要对自定义节点进行调整，比较麻烦，所以使用<code>Server-link_name</code>来作为节点名称就是来解决这个问题的。</p>\n<ol start=\"5\">\n<li>配置文件中，新增了自定义属性</li>\n</ol>\n<p>上面其实已经看到过了，可以新增<code>Server-Attribute-link_name</code>节点来设置服务器的自定义属性，这个自定义属性可以用在自定义命令或者全局公用命令中进行替换。</p>\n<p>另外，还新增了两个特殊的自定义属性<code>[P1][P2]</code>，分别代表传入脚本的第三个和第四个参数，举个栗子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Server-service-a]</span><br><span class=\"line\">cd=cd [P1]</span><br></pre></td></tr></table></figure>\n<p>使用如上配置后，当输入<code>gotossh 1 cd /var/log/service-a</code>（假设service-a是第一台服务器）后，将会先登录该服务器，然后执行<code>cd /var/log/service-a</code>命令，这里<code>[P1]</code>将会被传入脚本的第三个参数<code>/var/log/service-a</code>所替代，同理，还可以在命令中使用<code>[P2]</code>，它将被第四个参数替代。</p>\n<ol start=\"6\">\n<li>新增了大量注释，让代码看起来更加清晰</li>\n</ol>\n<p>目的在前面已经说过了，这里就不再赘述了，希望大家多提建议，一起来让这个shell脚本变得更好好用。</p>\n<h2 id=\"旧版本升级\"><a href=\"#旧版本升级\" class=\"headerlink\" title=\"旧版本升级\"></a>旧版本升级</h2><p>如果你已经使用了之前的版本，那么使用新版本的话，你需要进行以下操作：</p>\n<ol>\n<li>进入<code>/usr/local/bin/</code>删除原来的shell。</li>\n<li>安装依赖</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> brew install gnu-sed --with-default-names</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">export</span> PATH=<span class=\"string\">\"<span class=\"variable\">$(brew --prefix coreutils)</span>/libexec/gnubin:/usr/local/bin:<span class=\"variable\">$PATH</span>\"</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">export</span> MANPATH=<span class=\"string\">\"/usr/local/opt/coreutils/libexec/gnuman:<span class=\"variable\">$MANPATH</span>\"</span></span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>拉取最新代码并安装</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git <span class=\"built_in\">clone</span> https://github.com/MFrank2016/GotoSSH.git</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> GotoSSH</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> chmod a+x gotossh</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo cp gotossh /usr/<span class=\"built_in\">local</span>/bin/</span></span><br></pre></td></tr></table></figure>\n<p>shell里已经写好了配置升级的函数，所以不用太担心旧配置的调整。如果想要使用新功能的话，参照上面的说明，添加相应的节点，如<code>common-command</code>即可。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p><code>GotoSSH</code>虽然只是一个小的脚本，但是说实话，这个几百行的脚本调试起来可真的不容易，没法打断点就只能用输出的方式一点点的排查问题，比较蛋疼，清明节花了一整天的时间才调试好，希望大家能多多支持一下，给项目加个star的话就非常感谢啦。</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>时隔一周，GotoSSH又迎来了一次重大更新，让这个史诗级的shell工具变得更加丝般顺滑了~</p>\n<p>这次的主要更新是对自定义全局命令以及自定义属性的支持，让设置更加灵活，此外，对各个细节进行了调整，并修复了一些极少数情况下可能会发生的bug。</p>\n<p>另外，最重要的一点是，对代码进行了大量优化和注释，让小白也能很轻松的看懂各个地方是在做什么事情，毕竟对于服务器信息这么隐私的信息，交给一个第三方shell来管理，大家难免会有些不放心嘛，这个可以理解，所以特意做了这个更新，让大家能放心食用。</p>\n<p>有能力的小伙伴也可以把这个shell脚本自行改进，让它变得更加好用，如果有其他想法，欢迎提出，会考虑在后续更新中进行添加。</p>\n<h2 id=\"更新后样式\"><a href=\"#更新后样式\" class=\"headerlink\" title=\"更新后样式\"></a>更新后样式</h2><p>普通的一键登录到服务器:</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/08/5caa300e3e11c.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>先登录跳板机，然后自动跳转到线上服务器：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/08/5caa305847211.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/08/5caa30d31db3a.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>登录服务并查看日志：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/08/5caa36045135c.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/08/5caa3603366a4.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>登录跳板机，然后跳转线上服务器并查看指定日志：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/08/5caa3ac235cf7.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>从服务器复制文件到本地：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/08/5caab56a6e3c3.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>从线上服务器复制文件到跳板机，然后再复制到本地：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/08/5caab6078e829.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>列举所有服务器:</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/08/5caab7530dc2c.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>列举服务器支持的所有命令:</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/08/5caab7d733ef1.gif\" alt=\"list-all-the-commands.gif\" title=\"\">\n                </div>\n                <div class=\"image-caption\">list-all-the-commands.gif</div>\n            </figure>\n<h2 id=\"v3版本更新功能\"><a href=\"#v3版本更新功能\" class=\"headerlink\" title=\"v3版本更新功能\"></a>v3版本更新功能</h2><ol>\n<li>新增了两个命令，一个是查看服务器列表，一个是查看支持的命令列表。</li>\n</ol>\n<p>因为有小伙伴反映说，记不住哪个服务器是几号，每次需要先输入<code>gotossh</code>来查看，然后再<code>ctrl + c</code>退出，之后再进行长命令操作，感觉不太优雅。emmmm，于是就有了这么个功能：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/08/5caab7530dc2c.gif\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>现在可以使用<code>gotossh -l</code>查看所有的服务器列表了。</p>\n<p>此外，顺便增加了对自定义命令的更友好支持，一是在选择完服务器后，会显示该服务器支持的命令列表，包括该服务器的自定义命令，以及全局命令。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/08/5caab7d733ef1.gif\" alt=\"list-all-the-commands.gif\" title=\"\">\n                </div>\n                <div class=\"image-caption\">list-all-the-commands.gif</div>\n            </figure>\n<ol start=\"2\">\n<li>配置文件中，新增了<code>setting</code>节点和<code>common-command</code>节点。</li>\n</ol>\n<p>前者是用于设置全局配置信息，目前仅有version信息，用于之后的升级迭代。后续会考虑加入如颜色，显示方案等自定义配置。</p>\n<p>后者即全局公用命令，可以看做是模板命令，为什么要做这个功能呢？</p>\n<p>很多服务的日志地址其实是类似的，比如A服务的日志地址也许是：<code>/var/log/server-a/service-a.log</code>，B服务的日志地址也许是：<code>/var/log/server-b/server-b.log</code>，它们的大致路径其实是差不多的，所以如果有了模板命令，我们便不需要给每个服务器来单独设置一个自定义命令了，只需要在该自定义属性中配置相应属性即可。</p>\n<p>比如设置一条模板命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common-command]</span><br><span class=\"line\">log=/var/log/[service-name]/[service-name].log</span><br></pre></td></tr></table></figure>\n<p>再为服务a和服务b设置相应的属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Server-Attribute-service-a]</span><br><span class=\"line\">service-name=service-a</span><br><span class=\"line\"></span><br><span class=\"line\">[Server-Attribute-service-b]</span><br><span class=\"line\">service-name=service-b</span><br></pre></td></tr></table></figure>\n<p>这样一来，使用就更加优雅了，管理起来也更加方便。</p>\n<ol start=\"3\">\n<li>配置文件中，服务器信息的分割符由原来的“|”改成了“||”</li>\n</ol>\n<p>因为考虑到密码中可能含有“|”，所以进行了上述调整，不过仍旧没法解决密码中存在“||”的情况，emmm，这种情况应该不多，暂时先不考虑了。</p>\n<ol start=\"4\">\n<li>配置文件中，改用<code>link_name</code>作为服务器标识</li>\n</ol>\n<p>之前配置自定义命令时，使用的是<code>Server-ServerNo</code>的形式，但如果服务器数量比较多，删除前面的服务器配置后，会导致后面的服务器编号改变，这样就需要对自定义节点进行调整，比较麻烦，所以使用<code>Server-link_name</code>来作为节点名称就是来解决这个问题的。</p>\n<ol start=\"5\">\n<li>配置文件中，新增了自定义属性</li>\n</ol>\n<p>上面其实已经看到过了，可以新增<code>Server-Attribute-link_name</code>节点来设置服务器的自定义属性，这个自定义属性可以用在自定义命令或者全局公用命令中进行替换。</p>\n<p>另外，还新增了两个特殊的自定义属性<code>[P1][P2]</code>，分别代表传入脚本的第三个和第四个参数，举个栗子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Server-service-a]</span><br><span class=\"line\">cd=cd [P1]</span><br></pre></td></tr></table></figure>\n<p>使用如上配置后，当输入<code>gotossh 1 cd /var/log/service-a</code>（假设service-a是第一台服务器）后，将会先登录该服务器，然后执行<code>cd /var/log/service-a</code>命令，这里<code>[P1]</code>将会被传入脚本的第三个参数<code>/var/log/service-a</code>所替代，同理，还可以在命令中使用<code>[P2]</code>，它将被第四个参数替代。</p>\n<ol start=\"6\">\n<li>新增了大量注释，让代码看起来更加清晰</li>\n</ol>\n<p>目的在前面已经说过了，这里就不再赘述了，希望大家多提建议，一起来让这个shell脚本变得更好好用。</p>\n<h2 id=\"旧版本升级\"><a href=\"#旧版本升级\" class=\"headerlink\" title=\"旧版本升级\"></a>旧版本升级</h2><p>如果你已经使用了之前的版本，那么使用新版本的话，你需要进行以下操作：</p>\n<ol>\n<li>进入<code>/usr/local/bin/</code>删除原来的shell。</li>\n<li>安装依赖</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> brew install gnu-sed --with-default-names</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">export</span> PATH=<span class=\"string\">\"<span class=\"variable\">$(brew --prefix coreutils)</span>/libexec/gnubin:/usr/local/bin:<span class=\"variable\">$PATH</span>\"</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">export</span> MANPATH=<span class=\"string\">\"/usr/local/opt/coreutils/libexec/gnuman:<span class=\"variable\">$MANPATH</span>\"</span></span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>拉取最新代码并安装</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git <span class=\"built_in\">clone</span> https://github.com/MFrank2016/GotoSSH.git</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> GotoSSH</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> chmod a+x gotossh</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo cp gotossh /usr/<span class=\"built_in\">local</span>/bin/</span></span><br></pre></td></tr></table></figure>\n<p>shell里已经写好了配置升级的函数，所以不用太担心旧配置的调整。如果想要使用新功能的话，参照上面的说明，添加相应的节点，如<code>common-command</code>即可。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p><code>GotoSSH</code>虽然只是一个小的脚本，但是说实话，这个几百行的脚本调试起来可真的不容易，没法打断点就只能用输出的方式一点点的排查问题，比较蛋疼，清明节花了一整天的时间才调试好，希望大家能多多支持一下，给项目加个star的话就非常感谢啦。</p>\n"},{"title":"《Java多线程编程实战指南》（核心篇）—— 摘要","date":"2018-12-26T11:55:51.000Z","_content":"> 书籍作者：黄文海\n> 出版社：电子工业出版社\n\n## 思维导图\n\n[全文思维导图](https://mubu.com/doc/lW2C-KYYy0)\n\n## 第一章 走进Java世界中的线程\n\n1. `进程`是程序向操作系统申请资源的基本单位，`线程`是进程中可独立执行的最小单位。\n2. 一个进程可以包含多个线程。\n3. 线程所要完成的计算被称为`任务`。\n4. 启动一个线程的实质是请求Java虚拟机运行相应的线程，而这个线程具体何时能够运行是由线程调度器决定的。\n5. Java虚拟机会为每个线程分配调用栈所需的内存空间。\n6. Java平台中的任意一段代码总是由确定的线程负责执行的，这个线程就相应的被称为这段代码的`执行线程`。可以通过调用Thread.currentThread()来获取这段代码的执行线程。\n7. 线程的属性：\n\n| 属性               | 类型及用途                                                   | 注意事项                                                     |\n| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 编号（ID）         | Long。用于标识不同的线程。                                   | 不同线程虽然拥有的编号不同，但是某个编号的线程运行结束后，该编号可能被后续创建的线程使用，这种编号的唯一性只在Java虚拟机的一次运行中有效。 |\n| 名称（name）       | String。用于区分不同线程。（面向人）默认值与线程编号有关，默认值格式为：“Thread-线程编号” | 为每一个线程设置一个简短而含义明确的名称有助于多线程程序的调试和问题定位。 |\n| 线程类别（Daemon） | boolean。true表示相应的线程为守护线程，否则表示相应的线程为用户线程。 | 该属性必须在线程启动之前设置，否则setDaemon方法会抛出异常。负责一些关键任务的线程不适合设置为守护线程。 |\n| 优先级（Priority） | int。该属性本质上是给线程调度器的提示，用于表示应用程序希望线程能够优先得以运行。Java定义了1~10的10个优先级，默认值为5。 | 一般使用默认优先级即可。   |\n\n8. `用户线程`会阻止Java虚拟机的正常停止，即一个Java虚拟机只有在其所有用户线程都运行结束的情况下才能正常停止。而`守护线程`则不会影响Java虚拟机的正常停止，守护线程通常用于执行一些重要性不是很高的任务，例如用于监视其他线程的运行情况。\n9. Thread的`join`方法的作用相当于执行该方法的线程和线程调度器说：“我得先暂停一下，等到另外一个线程运行结束后我才能继续干活。”\n10. `yield`静态方法的作用相当于执行该方法的线程对线程调度器说：“我现在不急，如果别人需要处理器资源极度话先给他用吧。当然，如果没有其他人要用，我也不介意继续占用。”\n11. `sleep`静态方法的作用相当于执行该方法的线程对线程调度器说：“我想小憩一会儿，过段时间再叫醒我继续干活吧。”\n12. 假设线程A所执行的代码创建了线程B，那么，习惯上我们称线程B为线程A的`子线程`，相应地线程A就被称为线程B的`父线程`。\n13. 在Java平台中，一个线程是否是守护线程默认取决于其父线程。\n14. 一个线程的优先级默认值为该线程的父线程的优先级。\n15. `Thread.State`是一个枚举类型，用来表示线程的当前状态。\n    1. `NEW`：一个已创建而未启动的线程处于该状态。 \n    2. `RUNNABLE`：该状态可以被看成一个复合状态。它包括两个子状态：READY和RUNNING。\n    3. `BLOCKED`：线程进行阻塞式操作或申请由其他线程正在独占的资源时，相应的线程会处于该状态。\n    4. `WAITING`：执行某些特定方法之后就会处于这种等待状态，包括：Object.wait(),Thread.join(),LockSupport.park(),Condition.await()。能够使相应线程从WAITING变更为RUNNABLE的相应方法包括：Objeck.notify()/notifyAll()、LockSupport.unpark()、Condition.signal()。\n    5. `TIMED WAITING`：限时等待状态。\n    6. `TERMINATED`：已执行结束的线程处于该状态。\n16. Java程序的线程转储包含的线程具体信息包括线程的属性、生命周期状态、线程的调用栈以及锁相关的信息。\n17. 多线程编程具有以下优势：\n    1. 提高系统的**吞吐率**。\n    2. 提高**响应性**。\n    3. 充分利用多核优势。\n    4. 最小化对系统资源的使用。\n    5. 简化程序的结构\n18. 多线程编程的风险：\n    1. 线程安全问题。\n    2. 线程活性问题。\n    3. 上下文切换。\n    4. 可靠性。\n\n## 第二章 多线程编程的目标与挑战\n\n1. 多线程编程的实质就是将任务的处理方式由串行改为`并发`，即实现并发化，以发挥并发的优势。\n2. `状态变量`：即类的实例变量、静态变量。\n3. `共享变量`：即可以被多个线程共同访问的变量。\n4. `竞态`是指计算的正确性依赖于相对时间顺序或者线程的交错。\n5. 竞态往往伴随着读取`脏数据`问题。\n6. 竞态的两种模式：`read-modify-write`（读-改-写）和`check-then-act`（检测后行动）。\n7. 如果一个类在单线程环境下能够运行正常，并且在多线程环境下，在其使用方不必为其做任何改变的情况下也能运作正常，那么我们就称其是`线程安全`的，相应地，我们称这个类具有线程安全性。\n8. 对于涉及共享变量访问的操作，若该操作从其执行线程以外的任意线程来看是不可分割的，那么该操作就是原子操作，相应地我们称该操作具有`原子性`。\n9. Java中有两种方式来实现原子性。一种是使用`锁`，另一种是利用处理器提供的专门`CAS`指令。\n10. 在多线程环境下，一个线程对某个变量进行更新之后，后续访问该变量的线程可能无法立刻读取到这个更新的结果，甚至永远也无法读取到这个更新的结果，这就是线程安全的另一个表现形式：`可见性`。\n11. 可见性问题可能来源于JIT编译器的优化，也可能来源于`寄存器`和`高速缓存`。\n12. 虽然一个处理器的高速缓存中的内容不能被另一个处理器直接读取，但是一个处理器可以通过`缓存一致性协议`来读取其他处理器的高速缓存的数据，并将读到的数据更新到该处理器的高速缓存中。\n13. `volatile`关键字所起到的一个作用就是，提示JIT编译器被修饰的变量可能被多个线程共享，以阻止JIT编译器做出可能导致程序运行不正常的优化。另外一个作用是读取一个volatile关键字修饰的变量会使相应的处理器执行刷新处理器缓存的动作，写一个volatile关键字修饰的变量会使相应的处理器执行冲刷处理器缓存的动作，从而保障可见性。\n14. 对于同一个共享变量而言，一个线程更新了该变量的值之后，其他线程能够读取到这个更新后的值，那么这个值就被称为该变量的相对新值。\n15. 父线程在启动子线程之前对共享变量的更新对于子线程来说是可见的。\n16. 一个线程终止后该线程对共享变量的更新对于调用该线程的`join`方法的线程而言是可见的。\n17. `有序性`指在什么情况下一个处理器上运行的一个线程所执行的内存访问操作在另一个处理器上运行的其他线程看起来是乱序的。\n18. `重排序`是对内存访问有关的操作所做的一种优化，它可以在不影响单线程程序正确性的情况下提升程序的性能。重排序主要包括：`指令重排序`和`存储子系统重排序`。\n19. 重排序可能导致线程安全问题。\n20. 重排序不是必然出现的。\n21. 处理器也可能执行指令重排序，这使得执行顺序和程序顺序不一致，处理器对指令进行重排序也被称为处理器的乱序执行。处理器乱序执行并不会对单线程程序的正确性产生影响。\n22. 主内存相对于处理器是一个慢速设备。为了避免其拖后腿，处理器并不是直接访问主内存，而是通过高速缓存访问主内存的。\n23. 内存重排序包括：LoadLoad重排序、StoreStore重排序、LoadStore重排序、StoreLoad重排序。\n24. 存在数据依赖关系的语句不会被重排序，只有不存在数据依赖关系的语句才可能会被重排序。\n25. 可见性是有序性的基础，有序性影响可见性。\n26. 一个线程由于其时间片用完或者其自身原因被迫或者主动暂停其运行时，另外一个线程可以被操作系统选中占用处理器开始或者继续其运行。这种一个线程暂停，另一个线程被选中开始或者继续运行的过程就叫做`上下文切换`。\n27. 进度信息就被称为上下文，它一般包括通用寄存器的内容和程序计数器的内容。\n28. 自发性上下文切换指线程由于其自身因素导致的切出。如执行以下指令：Thread.sleep()、Object.wait()、Thread.join()、LockSupport.park()。\n29. 非自发性上下文切换指线程由于线程调度器的原因被迫切出。\n30. 上下文切换的开销包括**直接开销**和**间接开销**。\n    1. 操作系统保存和恢复上下文所需的开销，这主要是处理器时间开销。\n    2. 线程调度器进行线程调度的开销。\n    3. 处理器高速缓存重新加载的开销。\n    4. 上下文切换也可能导致整个一级高速缓存中的内容被冲刷。\n31. 这些由于资源稀缺性或者程序自身的问题和缺陷导致线程一直处于非RUNNABLE状态，或者线程虽然处于RUNNABLE状态但是其要执行的任务却一直无法进展的现象就被称为`线程活性故障`。常见的活性故障包括：\n    1. 死锁\n    2. 锁死\n    3. 活锁\n    4. 饥饿\n32. 一次只能够被一个线程占用的资源被称为`排他性`资源。在一个线程占用一个排他性资源进行访问时，其他线程视图访问该资源的现象就被称为`资源争用`。\n33. 同一时间内，处于运行状态的线程数量越多，我们就称并发程度越高，简称`高并发`。\n34. 在多个线程申请同一个排他性资源的情况下，决定哪个线程会被授予该资源的独占权，即选择哪个申请者占用该资源的过程就是`资源的调度`。\n35. 如果资源的任何一个先申请者总是能够比任何一个后申请者先获得该资源的独占权，那么相应的资源调度策略就被称为是`公平`的，如果资源的后申请者可能比先申请者先获得资源的独占权，那么相应的资源调度策略就被称为`非公平`的。\n36. 在极端的情况下，非公平调度策略可能导致等待队列中的线程永远无法获得其所需的资源，即出现`饥饿`。\n37. 一般来说，非公平调度策略的**吞吐率高**，即单位时间内它可以为更多的申请者调配资源。其缺点是，从申请者个体的角度来看这些申请者获得相应资源的独占权所需要的**时间偏差**可能比较大。\n38. 非公平调度策略可能带来一个好处——减少上下文切换的次数。\n39. 多数线程占用资源的时间相当长的情况下不适合使用**非公平调度策略**。\n40. 非公平调度策略是我们多数情况下的**首选**调度策略。其优点是吞吐率较大；缺点是资源申请者申请资源所需的时间偏差可能较大，并可能导致饥饿。公平调度策略适合在资源的时间相对长或资源的平均申请时间间隔相对长的情况下，或者对资源申请所需的时间偏差有所要求的情况下使用。其优点是线程申请资源所需的时间偏差较小，并且不会导致线程饥饿现象；其缺点是吞吐率较小。\n\n## 第三章 Java线程同步机制\n\n1. `线程同步机制`是一套用于协调线程间的数据访问及活动的机制，该机制用用户保障线程安全以及实现这些线程的共同目标。\n\n2. 线程安全问题的产生前提是多个线程并发访问共享变量、共享资源。\n\n3. 锁的持有线程在其获得锁之后和释放锁之前这段时间内所执行的代码被称为`临界区`。\n\n4. Java平台中的锁包括`内部锁`和`显示锁`。\n\n5. 锁是通过`互斥`保障原子性的。\n\n6. 一个锁实例锁保护的共享数据的数量大小就被称为锁的`粒度`。\n\n7. 锁的开销包括锁的申请和释放锁产生的开销，以及锁可能导致的上下文切换的开销，这些开销主要是处理器时间。\n\n8. `锁泄漏`是指一个线程获得某个锁之后，由于程序的错误缺陷致使该锁一直无法被释放而导致其他线程一直无法获得该锁的现象。\n\n9. Java平台中的任何一个对象都有唯一的一个与之关联的锁。这种锁被称为`监视器`或者`内部锁`。内部锁是一种`排他锁`，它能保障原子性、可见性和有序性。\n\n10. Java虚拟机会为每个内部锁分配一个`入口集`，用于记录等待获得相应内部锁的线程。多个线程申请同一个锁的时候，只有一个申请者能够成为该锁的持有线程，而其他申请者的申请操作会失败。\n\n11. 公平锁保障锁调度的公平性往往是以增加了线程的暂停和唤醒的可能性，即增加了上下文切换为代价的。因此公平锁适合于锁被持有的时间相对长或者线程申请锁的平均间隔时间相对长的情形。总得来说使用公平锁的开销比使用非公平锁的开销要大，因此显式锁默认使用的是非公平调度策略。\n\n12. `读写锁`是一种改进型的排它锁，也被称为共享/排它锁。读锁是`共享`的，写锁是`排他`的。\n\n13. 读写锁适合于在以下条件同时得以满足的场景中使用：\n\n    1. 只读操作比写操作要频繁得多。\n    2. 读线程持有锁的时间比较长。\n\n14. `ReetrantReadWriteLock`所实现的读写锁是`个可重入锁`。ReetrantReadWriteLock支持写锁的`降级`，即一个线程持有读写锁的写锁的情况下可以继续获得相应的读锁。\n\n15. `ReetrantReadWriteLock`并不支持锁的升级。读线程如果要转而申请写锁，需要先释放读锁，然后申请相应的写锁。\n\n16. `内存屏障`是对一类仅针对内存读、写操作指令的跨处理器架构的比较底层的抽象。内存屏障是被插入到两个指令之间进行使用的，其作用是**禁止编译器、处理器重排序从而保障有序性**。\n\n17. 按照可见性保障来划分，`内存屏障`可分为`加载屏障`和`存储屏障`。加载屏障的作用是**刷新处理器缓存**，存储屏障的作用是**冲刷处理器缓存**。Java虚拟机会在MonitorExit对应的机器码指令之后插入一个`存储屏障`，这就保障了写线程在释放锁之前在临界区中对共享变量所做的更新对读线程是可同步的。相应的，Java虚拟机会在MonitorEnter对应的机器码指令之后临界区开始之前的地方插入一个`加载屏障`，这使得读线程的执行处理器能够将写线程对相应共享变量所做的更新从其他处理器同步到该处理器的高速缓存中。\n\n18. 按照有序性保障来划分，`内存屏障`可以分为`获取屏障`和`释放屏障`。获取屏障的使用方式是在一个读操作之后插入该内存屏障，其作用是**禁止该读操作与其后的任何读写操作之间进行重排序**，这相当于在进行后续操作之前先要获得相应共享数据的所有权。释放屏障的使用方式是在一个写操作之前插入该内存屏障，其作用是**禁止该写操作与其前面的任何读写操作之间进行重排序**。Java虚拟机会在MonitorEnter对应的机器码指令之后临界区开始之前的地方插入一个获取屏障，并在临界区结束之后MonitorExit对应的机器码指令之前的地方插入一个释放屏障。\n\n19. 临界区之外的语句可以被重排序到临界区之内，而临界区内的操作无法被重排序到临界区之外。\n\n    1. 临界区内的操作不允许被重排序到临界区之外。\n\n    2. 临界区内的操作之间允许被重排序。\n\n    3. 临界区外的操作之间可以被重排序。\n\n    4. 锁申请与锁释放操作不能被重排序。\n\n    5. 两个锁申请操作不能被重排序。\n\n    6. 两个锁释放操作不能被重排序。\n\n    7. 临界区外的操作可以被重排到临界区之内。\n\n20. `volatile`变量不会被编译器分配到寄存器进行存储，对volatile变量的读写操作都是内存访问操作。\n\n21. `volatile`关键字常被称为`轻量级锁`，其作用与锁的作用有相同的地方：保证可见性和有序性。原子性方面它仅能保证写volatile变量操作的原子性，但没有锁的排他性。其次，volatile关键字的使用不会引起上下文切换。\n\n22. 一个赋值操作：\n\n    ```java\n    volatile Map aMap = new HashMap();\n    ```\n\n    可以分解为如下伪代码所示的几个子操作：\n\n    ```java\n    objRef = allocate(HashMap.class); // 子操作1：分配对象所需的存储空间\n    invokeConstructor(objRef); // 子操作2：初始化objRef引用的对象\n    aMap = objRef; // 子操作3：将对象引用写入变量aMap\n    ```\n\n    虽然volatile关键字仅保障其中的子操作3是一个原子操作，但是由于子操作1与子操作2仅涉及局部变量而未涉及共享变量，因此对变量aMap的赋值操作仍然是一个原子操作。\n\n23. 对于volatile变量的写操作，Java虚拟机会在操作之前插入一个`释放屏障`，并在该操作之后插入一个`存储屏障`。\n\n24. 对于volatile变量的读操作，Java虚拟机会在操作之前插入一个`加载屏障`，并在该操作之后插入一个`获取屏障`。\n\n25. 写volatile变量操作与该操作之前的任何读、写操作**不会被重排序**。\n\n26. 读volatile变量操作与该操作之后的任何读、写操作**不会被重排序**。\n\n27. volatile关键字在可见性方面仅仅是保证读线程能够读取到共享变量的相对新值。对于引用型变量和数组变量，volatile关键字并不能保证读线程能够读取到对象相应的字段、元素的相对新值。\n\n28. volatile变量的读、写操作都不会导致上下文切换，因此volatile的开销比锁要小。\n\n29. volatile使用的典型场景：\n\n    1. 使用volatile变量作为`状态标志`。\n\n    2. 使用volatile保障`可见性`。\n\n    3. 使用volatile变量代替锁。\n\n    4. 使用volatile实现简易版的读写锁。\n\n30. volatile关键字并非锁的代替品，volatile关键字和锁各有其适用条件。前者更适合于多个线程共享一个状态变量，而后者更适合于多个线程共享一组状态变量。某些情形下，我们可以将多个线程共享的一组状态变量合并成一个对象，用一个volatile变量来引用该对象，从而使我们不必要使用锁。\n\n31. `原子变量类`是基于CAS实现的能够保障对共享变量进行`read-modify-write`更新操作的原子性和可见性的一组工具类。\n\n32. `对象发布`是指使对象能够被其作用域之外的线程访问。\n\n33. 常见的对象发布形式包括：\n\n    1. 将对象引用存储到public变量中。\n\n    2. 在非private方法中返回一个对象。\n\n    3. 创建内部类，使得当前对象能够被这个内部类使用。\n\n    4. 通过方法调用将对象传递给外部方法。\n\n34. `static`关键字在多线程环境下有其特殊的含义，它能够保证一个线程即使在未使用其他同步机制的情况下也总是可以读取到一个类的静态变量的初始值。\n\n35. 对于引用型静态变量，`static`关键字还能够保障一个线程读取到该变量的初始值时，这个值所指向的对象已经初始化完毕。\n\n36. `static` 关键字仅仅保障读线程能够读取到相应字段的初始值，而不是相对新值。\n\n37. 当一个对象被发布到其他线程的时候，该对象的所有`final`字段都是初始化完毕的。\n\n38. 对于引用型`final`字段，`final`关键字还进一步确保该字段所引用的对象已经初始化完毕，即这些线程读取该字段所引用的对象的各个字段时所读取到的值都是相应字段的初始值。\n\n39. 当一个对象的引用对其他线程可见的时候，这些线程所看到的该对象的final字段必然是初始化完毕的。final关键字的作用仅是这种有序性的保障，它并不能保障包含final字段的对象的引用自身对其他线程的可见性。\n\n40. `安全发布`就是指对象以一种线程安全的方式被发布。\n\n41. 当一个对象的发布出现我们不期望的结果或者对象发布本身不是我们所期望的时候，我们就称该对象`逸出`。\n\n42. 对象逸出包括：\n\n    1. 在构造函器中将this赋值给一个共享变量。\n\n    2. 在构造器中将this作为方法参数传递给其他方法。\n\n    3. 在构造器中启动基于匿名类的线程。\n\n43. 一个对象在其初始化过程中没有出现this逸出，我们就称该对象为正确创建的对象。\n\n44. 实现对象的安全发布，通常可以依照以下顺序选择适用且开销最小的线程同步机制。\n\n    1. 使用staic关键字引用该对象的变量。\n\n    2. 使用final关键字修饰引用该对象的变量。\n\n    3. 使用volatile关键字修饰引用该对象的变量。\n\n    4. 使用AtomicReference来引用该对象。\n\n    5. 对访问该对象的代码进行加锁。\n\n## 第四章 牛刀小试：玩转线程\n\n1. 多线程编程中分而治之的使用主要有两种方式：**基于数据的分割**和**基于任务的分割**。\n\n2. 基于数据的分割的结果是产生多个`同质工作者线程`，即任务处理逻辑相同的线程。需要考虑如下因素：\n\n   1. 工作者线程数量的合理设置问题。\n\n   2. 工作者线程的异常处理问题。\n\n   3. 原始输入规模未知问题。\n\n   4. 程序的复杂性增加的问题。\n\n3. 为了提高任务的执行效率，我们可能使用多个线程去共同完成一个任务的执行。这就是基于任务的分割，其基本思想就是将任务按照一定的规则分解成若干子任务，并使用专门的工作者线程去执行这些子任务，从而实现任务的并发执行。\n\n4. 线程所执行的任务按照 其消耗的主要资源可划分为`CPU密集型`任务和`IO密集型`任务。\n\n5. CPU密集型任务执行过程中消耗的主要资源是CPU时间，CPU密集型任务的一个典型例子是加密和解密；IO密集型任务执行过程中消耗的主要资源是IO资源，典型的IO密集型任务就包括文件读写、网络读写等。\n\n6. 基于任务的分割结果是产生多个相互协作的`异质工作者线程`。\n\n7. `Amdahl’s 定律`描述了线程数与多线程程序相对于单线程程序的提速之间的关系。\n   $$\n   S_{max} = \\frac{1}{P + \\frac{1 - P}{N}}\n   $$\n   其中，N为处理器数量，程序中必须串行化的部分耗时占程序全部耗时的比率为P。\n\n8. 为使多线程程序能够获得较大的提速，我们**应该从算法入手，减少程序中必须串行的部分，而不是寄希望于增加线程数**。\n\n9. 线程数设置得过少可能导致无法充分利用处理器资源；而线程数设置得过大则又可能导致过多的上下文切换，从而反倒降低了系统的性能。\n\n10. 线程数的合理值可以根据以下规则设置：\n\n    1. 对于CPU密集型线程，考虑到这类线程执行任务时消耗的主要是处理器资源，我们可以将这类线程的线程数设置为$N_{cpu} $个。因为CPU密集型线程也可能由于某些原因（比如缺页中断）而被切出，此时为了避免处理器资源的浪费，我们也可以为这类线程设置一个额外的线程，即将线程数设置为$N_{cpu}  + 1$\n\n    2. 对于IO密集型线程，考虑到IO操作可能导致上下文切换，为这样的线程设置过多的线程会导致过多的额外系统开销。因此如果一个这样的工作者线程就可以满足我们的要求，那么就不要设置更多的线程数。如果一个工作者线程仍然不够用，那么我们可以考虑将这类线程的数量设置为$2 * N_{cpu} $\n\n11. **挖掘出程序中可并发点**是实现多线程编程的目标——并发计算的前提。\n\n12. 实现并发化的策略包括基于数据的分割策略和基于任务的分割策略。\n\n## 第五章 线程间协作\n\n1. 一个线程因其执行目标动作所需的保护条件未满足而被暂停的过程被称为`等待`。\n\n2. 一个线程更新了系统的状态，使得其他线程所需的保护条件得以满足的时候唤醒那些被暂停的线程的过程就被称为`通知`。\n\n3. 由于一个线程只有在持有一个对象的内部所的情况下才能够调用该对象的wait方法，因此Object.wait()调用总是放在相应对象所引导的临界区之中。\n\n4. 等待线程对保护条件的判断、Object.wait()的执行以及目标动作的执行必须放在同一个对象所引导的临界区之中。\n\n5. `Object.wait()`暂停当前线程时释放的锁只是与该wait方法所属对象的内部锁。当前线程所持有的其他内部锁、显示锁并不会因此而被释放。\n\n6. `Object.notify()`的执行线程持有的相应对象的内部锁只有在Object.notify()调用所在的临界区代码执行结束后才会被释放，而Object.notify()本身并不会将这个内部锁释放。因此，为了 使等待线程在其被唤醒之后能够尽快再次获得相应的内部锁，我们要尽可能地将Object.notify()调用放在靠近临界区结束的地方。\n\n7. `等待线程`和`通知线程`是同步在同一对象之上的两种线程。\n\n8. Java虚拟机会为每个对象维护一个`入口集`用于存储申请该对象内部锁的线程。Java虚拟机还会为每个对象维护一个被称为`等待集`的队列，该队列用于存储该对象上的等待线程。Object.wait()将当前线程暂停并释放相应的内部锁的同时会将当前线程存入该方法所属对象的等待集中。\n\n9. wait/notify的开销及问题\n\n   1. 过早唤醒问题\n\n   2. 信号丢失问题\n\n   3. 欺骗性唤醒问题\n\n   4. 上下文切换问题\n\n10. 只有在有证据表明使用`Object.notify()`足够的情况下才使用`Object.notify()`，只有在下列条件全部满足的情况下才能够用于替代`notifyAll`方法：\n\n    1. 一次通知仅需要唤醒至多一个线程。\n\n    2. 相应对象的等待集中仅包含同质等待线程。\n\n11. `join(long)`允许我们指定一个超时时间。如果目标线程没有在指定的时间内终止，那么当前线程也会继续运行。`join(long)`实际上就是使用了`wait/notify`来实现的。\n\n12. Java虚拟机会在目标线程的run方法运行结束后执行该线程的`notifyAll`方法来通知所有的等待线程。\n\n13. `Condition`接口可作为`wait/notify`的替代品来实现等待/通知，它为解决过早唤醒问题提供了支持，并解决了`Object.wait(long)`不能区分其返回是否是由等待超时而导致的问题。\n\n14. `Condition.await()/signal()`也要求其执行线程持有创建该Condition实例的显示锁。Condition实例也被称为条件变量或者条件队列。每个Condition实例内部都维护了一个用于存储等待线程的队列。\n\n15. `Condition`接口本身只是对解决过早唤醒问题提供了支持。要真正解决过早唤醒问题，我们需要通过应用代码维护保护条件与条件变量的await方法来实现其等待，并使通知线程在更新了相关共享变量之后，仅调用与这些共享变量有关的保护条件所对应的条件变量的`signal/signalAll`方法来实现通知。\n\n16. `Condition.awaitUntil(Date deadline)`可以用于实现带超时时间限制的等待，并且该方法的返回值能够区分该方法调用是由于等待超时而返回还是由于其他线程执行了相应条件变量的`signal/signalAll`方法而返回。\n\n17. 等待线程因执行`Condition.await()/awaitUntil(Date)`而被暂停的同时，其持有的相应显示锁也会被释放，等待线程被唤醒之后得以继续运行时需要再次申请相应的显示锁，然后等待线程对`Condition.await()/awaitUntil(Date)`的调用才能返回。\n\n18. `CountDownLatch`可以用来实现一个线程等待其他线程完成一组特定的操作之后才继续运行。这组操作被称为`先决操作`。\n\n19. `CountDownLatch`内部计数器值达到0后其值就恒定不变，后续执行该CountDownLatch实例的await方法的任何一个线程都不会被暂停。为了避免等待线程永远被暂停，`CountDownLatch.countDown()`调用必须放在代码中总是可以被执行到的地方，例如`finally`块中。\n\n20. 使用`CyclicBarrier`实现等待的线程被称为`参与方`，参与方只需要执行`CyclicBarrier.await()`就可以实现等待。\n\n21. 最后一个线程执行`CyclicBarrier.await()`会使得使用相应`CyclicBarrier`实例的其他所有参与方被唤醒，而最后一个线程自身并不会被暂停。\n\n22. 由于`CyclicBarrier`内部实现是基于条件变量的，因此`CyclicBarrier`的开销与条件变量的开销相似，其主要开销在可能产生的上下文切换。\n\n23. CyclicBarrier内部使用了一个条件变量trip来实现等待/通知。CyclicBarrier内部实现使用了分代的概念用于表示CyclicBarrier实例是可以重复使用的。\n\n24. 最后一个线程相当于通知线程，它执行费CyclicBarrier.await()会使得相应实例的parties值变为0，此时该线程会先执行barrierAction.run()，然后再执行 trip.signalAll()来唤醒所有等待线程。接着，开始下一个分代，即使得CyclicBarrier的parties指又重新恢复为其初始值。\n\n25. CyclicBarrier的典型应用场景包括以下几个:\n\n    1. 使得迭代算法并发化。\n\n    2. 在测试代码中模拟高并发。\n\n26. 将产品存入传输通道的线程就被称为生产者线程，从传输通道中取出产品进行消费的线程就被称为消费者线程。\n\n27. 一个方法或者操作如果能够导致其执行线程被暂停，那么我们就称相应的方法/操作为阻塞方法。阻塞方法能够导致上下文切换。\n\n28. 阻塞队列按照其存储空间的容量是否受限制来划分，可分为有界队列和无界队列。有界队列的存储容量限制是由应用程序制定的，无界队列的最大存储容量为Interger.MAX_VALUE($2^{31} - 1$)个元素。\n\n29. ArrayBlockingQueue的缺点是其内部在实现put、take操作的时候使用的是同一个锁，从而可能导致锁的高争用，进而导致较多的上下文切换。\n\n30. LinkedBlockingQueue既能实现无界队列，也能实现有界队列。\n\n31. LinkedBlockingQueue的优点是其内部在实现\bput、take操作的时候分别使用了两个显示锁（putLock和takeLock），这\b降低了锁争用的可能性。LinkedBlockingQueue的内部存储空间是一个链表，而链表节点所需的存储空间是动态分配的，put操作、take操作都会导致链表节点的动态创建和移除，因此LinkedBlockingQueue的缺点是它可能增加垃圾回收的负担。\n\n32. SynchronousQueue可以被看做一种特殊的有界队列。\n\n33. SynchronousQueue适合于在消费者处理能力和生产者处理能力相差不大的情况下使用。\n34. ArrayBlockingQueue和SynchronousQueue都既支持非公平调度也支持公平调度，而LinkedBlockingQueue仅支持非公平调度。\n35. 如果生产者线程和消费者线程之间的并发程度比较大，那么这些线程对传输通道内部所使用的锁的争用可能性也随之增加。这时，有界队列的实现适合选用LinkedBlockingQueue，否则我们可以考虑ArrayBlockingQueue。\n36. 使用无界队列作为传输通道的一个好处是put操作并不会导致生产者线程被阻塞。一般我们在使用无界队列作为传输通道的时候会同时限制生产者的生产速率。\n37. Semaphore.acquire() 和 Semaphore.release()总是配对使用。\n38. Semaphore.release()调用总是应该放在一个finally块中。\n39. 创建Semaphore时如果构造函数中的参数permits值为1，那么所创建的Semaphore实例相当于一个互斥锁。与其他互斥锁不同的是，由于一个线程可以在未执行过Semaphore.acquire()的情况下执行Semaphore.release()，因此这种互斥锁允许一个线程释放另一个线程所持有的锁。\n40. PipedOutputStream和PipedInputStream适合在两个线程间使用，即适用于单生产者-单消费者的情形。\n41. 输出异常的处理。如果生产者线程在其执行过程中出现了不可恢复的异常，那么消费者线程就会永远也无法读取到新的数据。\n42. 当消费者线程消费一个已填充的缓冲区时，另外一个缓冲区可以由生产者线程进行填充，从而实现了数据生成与消费的并发。这种缓冲技术就被称为双缓冲。\n43. Exchanger.exchange(V)的返回值是对方线程执行该方法时所指定的参数x的值。因此，Exchanger.exchange(V)的返回值就造成一种生产者线程和消费者线程之间交换缓冲区的效果。\n44. 中断可以被看做由一个线程发送给另一个线程的一种指示，该指示用于表示发起线程希望目标线程停止其正在执行的操作。中断仅仅代表发起线程的一个诉求，目标线程可能会满足发起线程的诉求，也可能根本不会理会发起线程的诉求。Java平台会为每个线程维护一个被称为中断标记的布尔型状态变量用于表示相应线程释放接收到了中断。\n45. 目标线程检查中断标记后所执行的操作，被称为目标线程对中断的响应，简称中断响应。\n46. 能够响应中断的方法通常是在执行阻塞操作之前判断中断标志，若中断标志值为true则抛出InterruptedException。\n47. 如果发起线程给目标线程发送中断的那一刻，目标线程已经由于执行了一些阻塞方法操作而被暂停，那么此时Java虚拟机可能会设置目标线程的线程中断标记并将该线程唤醒，从而使目标线程被唤醒后继续执行的代码再次得到相应中断的机会。所以，给目标线程发送中断还能够产生唤醒目标线程的效果。\n48. 在单生产者-单消费者模式中，停止生产者、消费者线程有一种简单的方法：生产者线程在其终止前往传’输通道中存入一个特殊产品作为消费者线程的线程停止标记，消费者线程取出这个产品之后就可以退出run方法而终止了。\n\n## 第六章 保障线程安全的设计技术\n","source":"_posts/reading/java-multithread-programming-guide-in-action-digest.md","raw":"---\ntitle: 《Java多线程编程实战指南》（核心篇）—— 摘要\ntags: \n - 摘要\n - Java\n - 多线程\ncategories: 阅读\ndate: 2018-12-26 19:55:51\n---\n> 书籍作者：黄文海\n> 出版社：电子工业出版社\n\n## 思维导图\n\n[全文思维导图](https://mubu.com/doc/lW2C-KYYy0)\n\n## 第一章 走进Java世界中的线程\n\n1. `进程`是程序向操作系统申请资源的基本单位，`线程`是进程中可独立执行的最小单位。\n2. 一个进程可以包含多个线程。\n3. 线程所要完成的计算被称为`任务`。\n4. 启动一个线程的实质是请求Java虚拟机运行相应的线程，而这个线程具体何时能够运行是由线程调度器决定的。\n5. Java虚拟机会为每个线程分配调用栈所需的内存空间。\n6. Java平台中的任意一段代码总是由确定的线程负责执行的，这个线程就相应的被称为这段代码的`执行线程`。可以通过调用Thread.currentThread()来获取这段代码的执行线程。\n7. 线程的属性：\n\n| 属性               | 类型及用途                                                   | 注意事项                                                     |\n| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 编号（ID）         | Long。用于标识不同的线程。                                   | 不同线程虽然拥有的编号不同，但是某个编号的线程运行结束后，该编号可能被后续创建的线程使用，这种编号的唯一性只在Java虚拟机的一次运行中有效。 |\n| 名称（name）       | String。用于区分不同线程。（面向人）默认值与线程编号有关，默认值格式为：“Thread-线程编号” | 为每一个线程设置一个简短而含义明确的名称有助于多线程程序的调试和问题定位。 |\n| 线程类别（Daemon） | boolean。true表示相应的线程为守护线程，否则表示相应的线程为用户线程。 | 该属性必须在线程启动之前设置，否则setDaemon方法会抛出异常。负责一些关键任务的线程不适合设置为守护线程。 |\n| 优先级（Priority） | int。该属性本质上是给线程调度器的提示，用于表示应用程序希望线程能够优先得以运行。Java定义了1~10的10个优先级，默认值为5。 | 一般使用默认优先级即可。   |\n\n8. `用户线程`会阻止Java虚拟机的正常停止，即一个Java虚拟机只有在其所有用户线程都运行结束的情况下才能正常停止。而`守护线程`则不会影响Java虚拟机的正常停止，守护线程通常用于执行一些重要性不是很高的任务，例如用于监视其他线程的运行情况。\n9. Thread的`join`方法的作用相当于执行该方法的线程和线程调度器说：“我得先暂停一下，等到另外一个线程运行结束后我才能继续干活。”\n10. `yield`静态方法的作用相当于执行该方法的线程对线程调度器说：“我现在不急，如果别人需要处理器资源极度话先给他用吧。当然，如果没有其他人要用，我也不介意继续占用。”\n11. `sleep`静态方法的作用相当于执行该方法的线程对线程调度器说：“我想小憩一会儿，过段时间再叫醒我继续干活吧。”\n12. 假设线程A所执行的代码创建了线程B，那么，习惯上我们称线程B为线程A的`子线程`，相应地线程A就被称为线程B的`父线程`。\n13. 在Java平台中，一个线程是否是守护线程默认取决于其父线程。\n14. 一个线程的优先级默认值为该线程的父线程的优先级。\n15. `Thread.State`是一个枚举类型，用来表示线程的当前状态。\n    1. `NEW`：一个已创建而未启动的线程处于该状态。 \n    2. `RUNNABLE`：该状态可以被看成一个复合状态。它包括两个子状态：READY和RUNNING。\n    3. `BLOCKED`：线程进行阻塞式操作或申请由其他线程正在独占的资源时，相应的线程会处于该状态。\n    4. `WAITING`：执行某些特定方法之后就会处于这种等待状态，包括：Object.wait(),Thread.join(),LockSupport.park(),Condition.await()。能够使相应线程从WAITING变更为RUNNABLE的相应方法包括：Objeck.notify()/notifyAll()、LockSupport.unpark()、Condition.signal()。\n    5. `TIMED WAITING`：限时等待状态。\n    6. `TERMINATED`：已执行结束的线程处于该状态。\n16. Java程序的线程转储包含的线程具体信息包括线程的属性、生命周期状态、线程的调用栈以及锁相关的信息。\n17. 多线程编程具有以下优势：\n    1. 提高系统的**吞吐率**。\n    2. 提高**响应性**。\n    3. 充分利用多核优势。\n    4. 最小化对系统资源的使用。\n    5. 简化程序的结构\n18. 多线程编程的风险：\n    1. 线程安全问题。\n    2. 线程活性问题。\n    3. 上下文切换。\n    4. 可靠性。\n\n## 第二章 多线程编程的目标与挑战\n\n1. 多线程编程的实质就是将任务的处理方式由串行改为`并发`，即实现并发化，以发挥并发的优势。\n2. `状态变量`：即类的实例变量、静态变量。\n3. `共享变量`：即可以被多个线程共同访问的变量。\n4. `竞态`是指计算的正确性依赖于相对时间顺序或者线程的交错。\n5. 竞态往往伴随着读取`脏数据`问题。\n6. 竞态的两种模式：`read-modify-write`（读-改-写）和`check-then-act`（检测后行动）。\n7. 如果一个类在单线程环境下能够运行正常，并且在多线程环境下，在其使用方不必为其做任何改变的情况下也能运作正常，那么我们就称其是`线程安全`的，相应地，我们称这个类具有线程安全性。\n8. 对于涉及共享变量访问的操作，若该操作从其执行线程以外的任意线程来看是不可分割的，那么该操作就是原子操作，相应地我们称该操作具有`原子性`。\n9. Java中有两种方式来实现原子性。一种是使用`锁`，另一种是利用处理器提供的专门`CAS`指令。\n10. 在多线程环境下，一个线程对某个变量进行更新之后，后续访问该变量的线程可能无法立刻读取到这个更新的结果，甚至永远也无法读取到这个更新的结果，这就是线程安全的另一个表现形式：`可见性`。\n11. 可见性问题可能来源于JIT编译器的优化，也可能来源于`寄存器`和`高速缓存`。\n12. 虽然一个处理器的高速缓存中的内容不能被另一个处理器直接读取，但是一个处理器可以通过`缓存一致性协议`来读取其他处理器的高速缓存的数据，并将读到的数据更新到该处理器的高速缓存中。\n13. `volatile`关键字所起到的一个作用就是，提示JIT编译器被修饰的变量可能被多个线程共享，以阻止JIT编译器做出可能导致程序运行不正常的优化。另外一个作用是读取一个volatile关键字修饰的变量会使相应的处理器执行刷新处理器缓存的动作，写一个volatile关键字修饰的变量会使相应的处理器执行冲刷处理器缓存的动作，从而保障可见性。\n14. 对于同一个共享变量而言，一个线程更新了该变量的值之后，其他线程能够读取到这个更新后的值，那么这个值就被称为该变量的相对新值。\n15. 父线程在启动子线程之前对共享变量的更新对于子线程来说是可见的。\n16. 一个线程终止后该线程对共享变量的更新对于调用该线程的`join`方法的线程而言是可见的。\n17. `有序性`指在什么情况下一个处理器上运行的一个线程所执行的内存访问操作在另一个处理器上运行的其他线程看起来是乱序的。\n18. `重排序`是对内存访问有关的操作所做的一种优化，它可以在不影响单线程程序正确性的情况下提升程序的性能。重排序主要包括：`指令重排序`和`存储子系统重排序`。\n19. 重排序可能导致线程安全问题。\n20. 重排序不是必然出现的。\n21. 处理器也可能执行指令重排序，这使得执行顺序和程序顺序不一致，处理器对指令进行重排序也被称为处理器的乱序执行。处理器乱序执行并不会对单线程程序的正确性产生影响。\n22. 主内存相对于处理器是一个慢速设备。为了避免其拖后腿，处理器并不是直接访问主内存，而是通过高速缓存访问主内存的。\n23. 内存重排序包括：LoadLoad重排序、StoreStore重排序、LoadStore重排序、StoreLoad重排序。\n24. 存在数据依赖关系的语句不会被重排序，只有不存在数据依赖关系的语句才可能会被重排序。\n25. 可见性是有序性的基础，有序性影响可见性。\n26. 一个线程由于其时间片用完或者其自身原因被迫或者主动暂停其运行时，另外一个线程可以被操作系统选中占用处理器开始或者继续其运行。这种一个线程暂停，另一个线程被选中开始或者继续运行的过程就叫做`上下文切换`。\n27. 进度信息就被称为上下文，它一般包括通用寄存器的内容和程序计数器的内容。\n28. 自发性上下文切换指线程由于其自身因素导致的切出。如执行以下指令：Thread.sleep()、Object.wait()、Thread.join()、LockSupport.park()。\n29. 非自发性上下文切换指线程由于线程调度器的原因被迫切出。\n30. 上下文切换的开销包括**直接开销**和**间接开销**。\n    1. 操作系统保存和恢复上下文所需的开销，这主要是处理器时间开销。\n    2. 线程调度器进行线程调度的开销。\n    3. 处理器高速缓存重新加载的开销。\n    4. 上下文切换也可能导致整个一级高速缓存中的内容被冲刷。\n31. 这些由于资源稀缺性或者程序自身的问题和缺陷导致线程一直处于非RUNNABLE状态，或者线程虽然处于RUNNABLE状态但是其要执行的任务却一直无法进展的现象就被称为`线程活性故障`。常见的活性故障包括：\n    1. 死锁\n    2. 锁死\n    3. 活锁\n    4. 饥饿\n32. 一次只能够被一个线程占用的资源被称为`排他性`资源。在一个线程占用一个排他性资源进行访问时，其他线程视图访问该资源的现象就被称为`资源争用`。\n33. 同一时间内，处于运行状态的线程数量越多，我们就称并发程度越高，简称`高并发`。\n34. 在多个线程申请同一个排他性资源的情况下，决定哪个线程会被授予该资源的独占权，即选择哪个申请者占用该资源的过程就是`资源的调度`。\n35. 如果资源的任何一个先申请者总是能够比任何一个后申请者先获得该资源的独占权，那么相应的资源调度策略就被称为是`公平`的，如果资源的后申请者可能比先申请者先获得资源的独占权，那么相应的资源调度策略就被称为`非公平`的。\n36. 在极端的情况下，非公平调度策略可能导致等待队列中的线程永远无法获得其所需的资源，即出现`饥饿`。\n37. 一般来说，非公平调度策略的**吞吐率高**，即单位时间内它可以为更多的申请者调配资源。其缺点是，从申请者个体的角度来看这些申请者获得相应资源的独占权所需要的**时间偏差**可能比较大。\n38. 非公平调度策略可能带来一个好处——减少上下文切换的次数。\n39. 多数线程占用资源的时间相当长的情况下不适合使用**非公平调度策略**。\n40. 非公平调度策略是我们多数情况下的**首选**调度策略。其优点是吞吐率较大；缺点是资源申请者申请资源所需的时间偏差可能较大，并可能导致饥饿。公平调度策略适合在资源的时间相对长或资源的平均申请时间间隔相对长的情况下，或者对资源申请所需的时间偏差有所要求的情况下使用。其优点是线程申请资源所需的时间偏差较小，并且不会导致线程饥饿现象；其缺点是吞吐率较小。\n\n## 第三章 Java线程同步机制\n\n1. `线程同步机制`是一套用于协调线程间的数据访问及活动的机制，该机制用用户保障线程安全以及实现这些线程的共同目标。\n\n2. 线程安全问题的产生前提是多个线程并发访问共享变量、共享资源。\n\n3. 锁的持有线程在其获得锁之后和释放锁之前这段时间内所执行的代码被称为`临界区`。\n\n4. Java平台中的锁包括`内部锁`和`显示锁`。\n\n5. 锁是通过`互斥`保障原子性的。\n\n6. 一个锁实例锁保护的共享数据的数量大小就被称为锁的`粒度`。\n\n7. 锁的开销包括锁的申请和释放锁产生的开销，以及锁可能导致的上下文切换的开销，这些开销主要是处理器时间。\n\n8. `锁泄漏`是指一个线程获得某个锁之后，由于程序的错误缺陷致使该锁一直无法被释放而导致其他线程一直无法获得该锁的现象。\n\n9. Java平台中的任何一个对象都有唯一的一个与之关联的锁。这种锁被称为`监视器`或者`内部锁`。内部锁是一种`排他锁`，它能保障原子性、可见性和有序性。\n\n10. Java虚拟机会为每个内部锁分配一个`入口集`，用于记录等待获得相应内部锁的线程。多个线程申请同一个锁的时候，只有一个申请者能够成为该锁的持有线程，而其他申请者的申请操作会失败。\n\n11. 公平锁保障锁调度的公平性往往是以增加了线程的暂停和唤醒的可能性，即增加了上下文切换为代价的。因此公平锁适合于锁被持有的时间相对长或者线程申请锁的平均间隔时间相对长的情形。总得来说使用公平锁的开销比使用非公平锁的开销要大，因此显式锁默认使用的是非公平调度策略。\n\n12. `读写锁`是一种改进型的排它锁，也被称为共享/排它锁。读锁是`共享`的，写锁是`排他`的。\n\n13. 读写锁适合于在以下条件同时得以满足的场景中使用：\n\n    1. 只读操作比写操作要频繁得多。\n    2. 读线程持有锁的时间比较长。\n\n14. `ReetrantReadWriteLock`所实现的读写锁是`个可重入锁`。ReetrantReadWriteLock支持写锁的`降级`，即一个线程持有读写锁的写锁的情况下可以继续获得相应的读锁。\n\n15. `ReetrantReadWriteLock`并不支持锁的升级。读线程如果要转而申请写锁，需要先释放读锁，然后申请相应的写锁。\n\n16. `内存屏障`是对一类仅针对内存读、写操作指令的跨处理器架构的比较底层的抽象。内存屏障是被插入到两个指令之间进行使用的，其作用是**禁止编译器、处理器重排序从而保障有序性**。\n\n17. 按照可见性保障来划分，`内存屏障`可分为`加载屏障`和`存储屏障`。加载屏障的作用是**刷新处理器缓存**，存储屏障的作用是**冲刷处理器缓存**。Java虚拟机会在MonitorExit对应的机器码指令之后插入一个`存储屏障`，这就保障了写线程在释放锁之前在临界区中对共享变量所做的更新对读线程是可同步的。相应的，Java虚拟机会在MonitorEnter对应的机器码指令之后临界区开始之前的地方插入一个`加载屏障`，这使得读线程的执行处理器能够将写线程对相应共享变量所做的更新从其他处理器同步到该处理器的高速缓存中。\n\n18. 按照有序性保障来划分，`内存屏障`可以分为`获取屏障`和`释放屏障`。获取屏障的使用方式是在一个读操作之后插入该内存屏障，其作用是**禁止该读操作与其后的任何读写操作之间进行重排序**，这相当于在进行后续操作之前先要获得相应共享数据的所有权。释放屏障的使用方式是在一个写操作之前插入该内存屏障，其作用是**禁止该写操作与其前面的任何读写操作之间进行重排序**。Java虚拟机会在MonitorEnter对应的机器码指令之后临界区开始之前的地方插入一个获取屏障，并在临界区结束之后MonitorExit对应的机器码指令之前的地方插入一个释放屏障。\n\n19. 临界区之外的语句可以被重排序到临界区之内，而临界区内的操作无法被重排序到临界区之外。\n\n    1. 临界区内的操作不允许被重排序到临界区之外。\n\n    2. 临界区内的操作之间允许被重排序。\n\n    3. 临界区外的操作之间可以被重排序。\n\n    4. 锁申请与锁释放操作不能被重排序。\n\n    5. 两个锁申请操作不能被重排序。\n\n    6. 两个锁释放操作不能被重排序。\n\n    7. 临界区外的操作可以被重排到临界区之内。\n\n20. `volatile`变量不会被编译器分配到寄存器进行存储，对volatile变量的读写操作都是内存访问操作。\n\n21. `volatile`关键字常被称为`轻量级锁`，其作用与锁的作用有相同的地方：保证可见性和有序性。原子性方面它仅能保证写volatile变量操作的原子性，但没有锁的排他性。其次，volatile关键字的使用不会引起上下文切换。\n\n22. 一个赋值操作：\n\n    ```java\n    volatile Map aMap = new HashMap();\n    ```\n\n    可以分解为如下伪代码所示的几个子操作：\n\n    ```java\n    objRef = allocate(HashMap.class); // 子操作1：分配对象所需的存储空间\n    invokeConstructor(objRef); // 子操作2：初始化objRef引用的对象\n    aMap = objRef; // 子操作3：将对象引用写入变量aMap\n    ```\n\n    虽然volatile关键字仅保障其中的子操作3是一个原子操作，但是由于子操作1与子操作2仅涉及局部变量而未涉及共享变量，因此对变量aMap的赋值操作仍然是一个原子操作。\n\n23. 对于volatile变量的写操作，Java虚拟机会在操作之前插入一个`释放屏障`，并在该操作之后插入一个`存储屏障`。\n\n24. 对于volatile变量的读操作，Java虚拟机会在操作之前插入一个`加载屏障`，并在该操作之后插入一个`获取屏障`。\n\n25. 写volatile变量操作与该操作之前的任何读、写操作**不会被重排序**。\n\n26. 读volatile变量操作与该操作之后的任何读、写操作**不会被重排序**。\n\n27. volatile关键字在可见性方面仅仅是保证读线程能够读取到共享变量的相对新值。对于引用型变量和数组变量，volatile关键字并不能保证读线程能够读取到对象相应的字段、元素的相对新值。\n\n28. volatile变量的读、写操作都不会导致上下文切换，因此volatile的开销比锁要小。\n\n29. volatile使用的典型场景：\n\n    1. 使用volatile变量作为`状态标志`。\n\n    2. 使用volatile保障`可见性`。\n\n    3. 使用volatile变量代替锁。\n\n    4. 使用volatile实现简易版的读写锁。\n\n30. volatile关键字并非锁的代替品，volatile关键字和锁各有其适用条件。前者更适合于多个线程共享一个状态变量，而后者更适合于多个线程共享一组状态变量。某些情形下，我们可以将多个线程共享的一组状态变量合并成一个对象，用一个volatile变量来引用该对象，从而使我们不必要使用锁。\n\n31. `原子变量类`是基于CAS实现的能够保障对共享变量进行`read-modify-write`更新操作的原子性和可见性的一组工具类。\n\n32. `对象发布`是指使对象能够被其作用域之外的线程访问。\n\n33. 常见的对象发布形式包括：\n\n    1. 将对象引用存储到public变量中。\n\n    2. 在非private方法中返回一个对象。\n\n    3. 创建内部类，使得当前对象能够被这个内部类使用。\n\n    4. 通过方法调用将对象传递给外部方法。\n\n34. `static`关键字在多线程环境下有其特殊的含义，它能够保证一个线程即使在未使用其他同步机制的情况下也总是可以读取到一个类的静态变量的初始值。\n\n35. 对于引用型静态变量，`static`关键字还能够保障一个线程读取到该变量的初始值时，这个值所指向的对象已经初始化完毕。\n\n36. `static` 关键字仅仅保障读线程能够读取到相应字段的初始值，而不是相对新值。\n\n37. 当一个对象被发布到其他线程的时候，该对象的所有`final`字段都是初始化完毕的。\n\n38. 对于引用型`final`字段，`final`关键字还进一步确保该字段所引用的对象已经初始化完毕，即这些线程读取该字段所引用的对象的各个字段时所读取到的值都是相应字段的初始值。\n\n39. 当一个对象的引用对其他线程可见的时候，这些线程所看到的该对象的final字段必然是初始化完毕的。final关键字的作用仅是这种有序性的保障，它并不能保障包含final字段的对象的引用自身对其他线程的可见性。\n\n40. `安全发布`就是指对象以一种线程安全的方式被发布。\n\n41. 当一个对象的发布出现我们不期望的结果或者对象发布本身不是我们所期望的时候，我们就称该对象`逸出`。\n\n42. 对象逸出包括：\n\n    1. 在构造函器中将this赋值给一个共享变量。\n\n    2. 在构造器中将this作为方法参数传递给其他方法。\n\n    3. 在构造器中启动基于匿名类的线程。\n\n43. 一个对象在其初始化过程中没有出现this逸出，我们就称该对象为正确创建的对象。\n\n44. 实现对象的安全发布，通常可以依照以下顺序选择适用且开销最小的线程同步机制。\n\n    1. 使用staic关键字引用该对象的变量。\n\n    2. 使用final关键字修饰引用该对象的变量。\n\n    3. 使用volatile关键字修饰引用该对象的变量。\n\n    4. 使用AtomicReference来引用该对象。\n\n    5. 对访问该对象的代码进行加锁。\n\n## 第四章 牛刀小试：玩转线程\n\n1. 多线程编程中分而治之的使用主要有两种方式：**基于数据的分割**和**基于任务的分割**。\n\n2. 基于数据的分割的结果是产生多个`同质工作者线程`，即任务处理逻辑相同的线程。需要考虑如下因素：\n\n   1. 工作者线程数量的合理设置问题。\n\n   2. 工作者线程的异常处理问题。\n\n   3. 原始输入规模未知问题。\n\n   4. 程序的复杂性增加的问题。\n\n3. 为了提高任务的执行效率，我们可能使用多个线程去共同完成一个任务的执行。这就是基于任务的分割，其基本思想就是将任务按照一定的规则分解成若干子任务，并使用专门的工作者线程去执行这些子任务，从而实现任务的并发执行。\n\n4. 线程所执行的任务按照 其消耗的主要资源可划分为`CPU密集型`任务和`IO密集型`任务。\n\n5. CPU密集型任务执行过程中消耗的主要资源是CPU时间，CPU密集型任务的一个典型例子是加密和解密；IO密集型任务执行过程中消耗的主要资源是IO资源，典型的IO密集型任务就包括文件读写、网络读写等。\n\n6. 基于任务的分割结果是产生多个相互协作的`异质工作者线程`。\n\n7. `Amdahl’s 定律`描述了线程数与多线程程序相对于单线程程序的提速之间的关系。\n   $$\n   S_{max} = \\frac{1}{P + \\frac{1 - P}{N}}\n   $$\n   其中，N为处理器数量，程序中必须串行化的部分耗时占程序全部耗时的比率为P。\n\n8. 为使多线程程序能够获得较大的提速，我们**应该从算法入手，减少程序中必须串行的部分，而不是寄希望于增加线程数**。\n\n9. 线程数设置得过少可能导致无法充分利用处理器资源；而线程数设置得过大则又可能导致过多的上下文切换，从而反倒降低了系统的性能。\n\n10. 线程数的合理值可以根据以下规则设置：\n\n    1. 对于CPU密集型线程，考虑到这类线程执行任务时消耗的主要是处理器资源，我们可以将这类线程的线程数设置为$N_{cpu} $个。因为CPU密集型线程也可能由于某些原因（比如缺页中断）而被切出，此时为了避免处理器资源的浪费，我们也可以为这类线程设置一个额外的线程，即将线程数设置为$N_{cpu}  + 1$\n\n    2. 对于IO密集型线程，考虑到IO操作可能导致上下文切换，为这样的线程设置过多的线程会导致过多的额外系统开销。因此如果一个这样的工作者线程就可以满足我们的要求，那么就不要设置更多的线程数。如果一个工作者线程仍然不够用，那么我们可以考虑将这类线程的数量设置为$2 * N_{cpu} $\n\n11. **挖掘出程序中可并发点**是实现多线程编程的目标——并发计算的前提。\n\n12. 实现并发化的策略包括基于数据的分割策略和基于任务的分割策略。\n\n## 第五章 线程间协作\n\n1. 一个线程因其执行目标动作所需的保护条件未满足而被暂停的过程被称为`等待`。\n\n2. 一个线程更新了系统的状态，使得其他线程所需的保护条件得以满足的时候唤醒那些被暂停的线程的过程就被称为`通知`。\n\n3. 由于一个线程只有在持有一个对象的内部所的情况下才能够调用该对象的wait方法，因此Object.wait()调用总是放在相应对象所引导的临界区之中。\n\n4. 等待线程对保护条件的判断、Object.wait()的执行以及目标动作的执行必须放在同一个对象所引导的临界区之中。\n\n5. `Object.wait()`暂停当前线程时释放的锁只是与该wait方法所属对象的内部锁。当前线程所持有的其他内部锁、显示锁并不会因此而被释放。\n\n6. `Object.notify()`的执行线程持有的相应对象的内部锁只有在Object.notify()调用所在的临界区代码执行结束后才会被释放，而Object.notify()本身并不会将这个内部锁释放。因此，为了 使等待线程在其被唤醒之后能够尽快再次获得相应的内部锁，我们要尽可能地将Object.notify()调用放在靠近临界区结束的地方。\n\n7. `等待线程`和`通知线程`是同步在同一对象之上的两种线程。\n\n8. Java虚拟机会为每个对象维护一个`入口集`用于存储申请该对象内部锁的线程。Java虚拟机还会为每个对象维护一个被称为`等待集`的队列，该队列用于存储该对象上的等待线程。Object.wait()将当前线程暂停并释放相应的内部锁的同时会将当前线程存入该方法所属对象的等待集中。\n\n9. wait/notify的开销及问题\n\n   1. 过早唤醒问题\n\n   2. 信号丢失问题\n\n   3. 欺骗性唤醒问题\n\n   4. 上下文切换问题\n\n10. 只有在有证据表明使用`Object.notify()`足够的情况下才使用`Object.notify()`，只有在下列条件全部满足的情况下才能够用于替代`notifyAll`方法：\n\n    1. 一次通知仅需要唤醒至多一个线程。\n\n    2. 相应对象的等待集中仅包含同质等待线程。\n\n11. `join(long)`允许我们指定一个超时时间。如果目标线程没有在指定的时间内终止，那么当前线程也会继续运行。`join(long)`实际上就是使用了`wait/notify`来实现的。\n\n12. Java虚拟机会在目标线程的run方法运行结束后执行该线程的`notifyAll`方法来通知所有的等待线程。\n\n13. `Condition`接口可作为`wait/notify`的替代品来实现等待/通知，它为解决过早唤醒问题提供了支持，并解决了`Object.wait(long)`不能区分其返回是否是由等待超时而导致的问题。\n\n14. `Condition.await()/signal()`也要求其执行线程持有创建该Condition实例的显示锁。Condition实例也被称为条件变量或者条件队列。每个Condition实例内部都维护了一个用于存储等待线程的队列。\n\n15. `Condition`接口本身只是对解决过早唤醒问题提供了支持。要真正解决过早唤醒问题，我们需要通过应用代码维护保护条件与条件变量的await方法来实现其等待，并使通知线程在更新了相关共享变量之后，仅调用与这些共享变量有关的保护条件所对应的条件变量的`signal/signalAll`方法来实现通知。\n\n16. `Condition.awaitUntil(Date deadline)`可以用于实现带超时时间限制的等待，并且该方法的返回值能够区分该方法调用是由于等待超时而返回还是由于其他线程执行了相应条件变量的`signal/signalAll`方法而返回。\n\n17. 等待线程因执行`Condition.await()/awaitUntil(Date)`而被暂停的同时，其持有的相应显示锁也会被释放，等待线程被唤醒之后得以继续运行时需要再次申请相应的显示锁，然后等待线程对`Condition.await()/awaitUntil(Date)`的调用才能返回。\n\n18. `CountDownLatch`可以用来实现一个线程等待其他线程完成一组特定的操作之后才继续运行。这组操作被称为`先决操作`。\n\n19. `CountDownLatch`内部计数器值达到0后其值就恒定不变，后续执行该CountDownLatch实例的await方法的任何一个线程都不会被暂停。为了避免等待线程永远被暂停，`CountDownLatch.countDown()`调用必须放在代码中总是可以被执行到的地方，例如`finally`块中。\n\n20. 使用`CyclicBarrier`实现等待的线程被称为`参与方`，参与方只需要执行`CyclicBarrier.await()`就可以实现等待。\n\n21. 最后一个线程执行`CyclicBarrier.await()`会使得使用相应`CyclicBarrier`实例的其他所有参与方被唤醒，而最后一个线程自身并不会被暂停。\n\n22. 由于`CyclicBarrier`内部实现是基于条件变量的，因此`CyclicBarrier`的开销与条件变量的开销相似，其主要开销在可能产生的上下文切换。\n\n23. CyclicBarrier内部使用了一个条件变量trip来实现等待/通知。CyclicBarrier内部实现使用了分代的概念用于表示CyclicBarrier实例是可以重复使用的。\n\n24. 最后一个线程相当于通知线程，它执行费CyclicBarrier.await()会使得相应实例的parties值变为0，此时该线程会先执行barrierAction.run()，然后再执行 trip.signalAll()来唤醒所有等待线程。接着，开始下一个分代，即使得CyclicBarrier的parties指又重新恢复为其初始值。\n\n25. CyclicBarrier的典型应用场景包括以下几个:\n\n    1. 使得迭代算法并发化。\n\n    2. 在测试代码中模拟高并发。\n\n26. 将产品存入传输通道的线程就被称为生产者线程，从传输通道中取出产品进行消费的线程就被称为消费者线程。\n\n27. 一个方法或者操作如果能够导致其执行线程被暂停，那么我们就称相应的方法/操作为阻塞方法。阻塞方法能够导致上下文切换。\n\n28. 阻塞队列按照其存储空间的容量是否受限制来划分，可分为有界队列和无界队列。有界队列的存储容量限制是由应用程序制定的，无界队列的最大存储容量为Interger.MAX_VALUE($2^{31} - 1$)个元素。\n\n29. ArrayBlockingQueue的缺点是其内部在实现put、take操作的时候使用的是同一个锁，从而可能导致锁的高争用，进而导致较多的上下文切换。\n\n30. LinkedBlockingQueue既能实现无界队列，也能实现有界队列。\n\n31. LinkedBlockingQueue的优点是其内部在实现\bput、take操作的时候分别使用了两个显示锁（putLock和takeLock），这\b降低了锁争用的可能性。LinkedBlockingQueue的内部存储空间是一个链表，而链表节点所需的存储空间是动态分配的，put操作、take操作都会导致链表节点的动态创建和移除，因此LinkedBlockingQueue的缺点是它可能增加垃圾回收的负担。\n\n32. SynchronousQueue可以被看做一种特殊的有界队列。\n\n33. SynchronousQueue适合于在消费者处理能力和生产者处理能力相差不大的情况下使用。\n34. ArrayBlockingQueue和SynchronousQueue都既支持非公平调度也支持公平调度，而LinkedBlockingQueue仅支持非公平调度。\n35. 如果生产者线程和消费者线程之间的并发程度比较大，那么这些线程对传输通道内部所使用的锁的争用可能性也随之增加。这时，有界队列的实现适合选用LinkedBlockingQueue，否则我们可以考虑ArrayBlockingQueue。\n36. 使用无界队列作为传输通道的一个好处是put操作并不会导致生产者线程被阻塞。一般我们在使用无界队列作为传输通道的时候会同时限制生产者的生产速率。\n37. Semaphore.acquire() 和 Semaphore.release()总是配对使用。\n38. Semaphore.release()调用总是应该放在一个finally块中。\n39. 创建Semaphore时如果构造函数中的参数permits值为1，那么所创建的Semaphore实例相当于一个互斥锁。与其他互斥锁不同的是，由于一个线程可以在未执行过Semaphore.acquire()的情况下执行Semaphore.release()，因此这种互斥锁允许一个线程释放另一个线程所持有的锁。\n40. PipedOutputStream和PipedInputStream适合在两个线程间使用，即适用于单生产者-单消费者的情形。\n41. 输出异常的处理。如果生产者线程在其执行过程中出现了不可恢复的异常，那么消费者线程就会永远也无法读取到新的数据。\n42. 当消费者线程消费一个已填充的缓冲区时，另外一个缓冲区可以由生产者线程进行填充，从而实现了数据生成与消费的并发。这种缓冲技术就被称为双缓冲。\n43. Exchanger.exchange(V)的返回值是对方线程执行该方法时所指定的参数x的值。因此，Exchanger.exchange(V)的返回值就造成一种生产者线程和消费者线程之间交换缓冲区的效果。\n44. 中断可以被看做由一个线程发送给另一个线程的一种指示，该指示用于表示发起线程希望目标线程停止其正在执行的操作。中断仅仅代表发起线程的一个诉求，目标线程可能会满足发起线程的诉求，也可能根本不会理会发起线程的诉求。Java平台会为每个线程维护一个被称为中断标记的布尔型状态变量用于表示相应线程释放接收到了中断。\n45. 目标线程检查中断标记后所执行的操作，被称为目标线程对中断的响应，简称中断响应。\n46. 能够响应中断的方法通常是在执行阻塞操作之前判断中断标志，若中断标志值为true则抛出InterruptedException。\n47. 如果发起线程给目标线程发送中断的那一刻，目标线程已经由于执行了一些阻塞方法操作而被暂停，那么此时Java虚拟机可能会设置目标线程的线程中断标记并将该线程唤醒，从而使目标线程被唤醒后继续执行的代码再次得到相应中断的机会。所以，给目标线程发送中断还能够产生唤醒目标线程的效果。\n48. 在单生产者-单消费者模式中，停止生产者、消费者线程有一种简单的方法：生产者线程在其终止前往传’输通道中存入一个特殊产品作为消费者线程的线程停止标记，消费者线程取出这个产品之后就可以退出run方法而终止了。\n\n## 第六章 保障线程安全的设计技术\n","slug":"reading/java-multithread-programming-guide-in-action-digest","published":1,"updated":"2019-06-04T01:29:57.498Z","_id":"cjxze3gqg00350cvwvkwr261w","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>书籍作者：黄文海<br>出版社：电子工业出版社</p>\n</blockquote>\n<h2 id=\"思维导图\"><a href=\"#思维导图\" class=\"headerlink\" title=\"思维导图\"></a>思维导图</h2><p><a href=\"https://mubu.com/doc/lW2C-KYYy0\" target=\"_blank\" rel=\"noopener\">全文思维导图</a></p>\n<h2 id=\"第一章-走进Java世界中的线程\"><a href=\"#第一章-走进Java世界中的线程\" class=\"headerlink\" title=\"第一章 走进Java世界中的线程\"></a>第一章 走进Java世界中的线程</h2><ol>\n<li><code>进程</code>是程序向操作系统申请资源的基本单位，<code>线程</code>是进程中可独立执行的最小单位。</li>\n<li>一个进程可以包含多个线程。</li>\n<li>线程所要完成的计算被称为<code>任务</code>。</li>\n<li>启动一个线程的实质是请求Java虚拟机运行相应的线程，而这个线程具体何时能够运行是由线程调度器决定的。</li>\n<li>Java虚拟机会为每个线程分配调用栈所需的内存空间。</li>\n<li>Java平台中的任意一段代码总是由确定的线程负责执行的，这个线程就相应的被称为这段代码的<code>执行线程</code>。可以通过调用Thread.currentThread()来获取这段代码的执行线程。</li>\n<li>线程的属性：</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>类型及用途</th>\n<th>注意事项</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>编号（ID）</td>\n<td>Long。用于标识不同的线程。</td>\n<td>不同线程虽然拥有的编号不同，但是某个编号的线程运行结束后，该编号可能被后续创建的线程使用，这种编号的唯一性只在Java虚拟机的一次运行中有效。</td>\n</tr>\n<tr>\n<td>名称（name）</td>\n<td>String。用于区分不同线程。（面向人）默认值与线程编号有关，默认值格式为：“Thread-线程编号”</td>\n<td>为每一个线程设置一个简短而含义明确的名称有助于多线程程序的调试和问题定位。</td>\n</tr>\n<tr>\n<td>线程类别（Daemon）</td>\n<td>boolean。true表示相应的线程为守护线程，否则表示相应的线程为用户线程。</td>\n<td>该属性必须在线程启动之前设置，否则setDaemon方法会抛出异常。负责一些关键任务的线程不适合设置为守护线程。</td>\n</tr>\n<tr>\n<td>优先级（Priority）</td>\n<td>int。该属性本质上是给线程调度器的提示，用于表示应用程序希望线程能够优先得以运行。Java定义了1~10的10个优先级，默认值为5。</td>\n<td>一般使用默认优先级即可。</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"8\">\n<li><code>用户线程</code>会阻止Java虚拟机的正常停止，即一个Java虚拟机只有在其所有用户线程都运行结束的情况下才能正常停止。而<code>守护线程</code>则不会影响Java虚拟机的正常停止，守护线程通常用于执行一些重要性不是很高的任务，例如用于监视其他线程的运行情况。</li>\n<li>Thread的<code>join</code>方法的作用相当于执行该方法的线程和线程调度器说：“我得先暂停一下，等到另外一个线程运行结束后我才能继续干活。”</li>\n<li><code>yield</code>静态方法的作用相当于执行该方法的线程对线程调度器说：“我现在不急，如果别人需要处理器资源极度话先给他用吧。当然，如果没有其他人要用，我也不介意继续占用。”</li>\n<li><code>sleep</code>静态方法的作用相当于执行该方法的线程对线程调度器说：“我想小憩一会儿，过段时间再叫醒我继续干活吧。”</li>\n<li>假设线程A所执行的代码创建了线程B，那么，习惯上我们称线程B为线程A的<code>子线程</code>，相应地线程A就被称为线程B的<code>父线程</code>。</li>\n<li>在Java平台中，一个线程是否是守护线程默认取决于其父线程。</li>\n<li>一个线程的优先级默认值为该线程的父线程的优先级。</li>\n<li><code>Thread.State</code>是一个枚举类型，用来表示线程的当前状态。<ol>\n<li><code>NEW</code>：一个已创建而未启动的线程处于该状态。 </li>\n<li><code>RUNNABLE</code>：该状态可以被看成一个复合状态。它包括两个子状态：READY和RUNNING。</li>\n<li><code>BLOCKED</code>：线程进行阻塞式操作或申请由其他线程正在独占的资源时，相应的线程会处于该状态。</li>\n<li><code>WAITING</code>：执行某些特定方法之后就会处于这种等待状态，包括：Object.wait(),Thread.join(),LockSupport.park(),Condition.await()。能够使相应线程从WAITING变更为RUNNABLE的相应方法包括：Objeck.notify()/notifyAll()、LockSupport.unpark()、Condition.signal()。</li>\n<li><code>TIMED WAITING</code>：限时等待状态。</li>\n<li><code>TERMINATED</code>：已执行结束的线程处于该状态。</li>\n</ol>\n</li>\n<li>Java程序的线程转储包含的线程具体信息包括线程的属性、生命周期状态、线程的调用栈以及锁相关的信息。</li>\n<li>多线程编程具有以下优势：<ol>\n<li>提高系统的<strong>吞吐率</strong>。</li>\n<li>提高<strong>响应性</strong>。</li>\n<li>充分利用多核优势。</li>\n<li>最小化对系统资源的使用。</li>\n<li>简化程序的结构</li>\n</ol>\n</li>\n<li>多线程编程的风险：<ol>\n<li>线程安全问题。</li>\n<li>线程活性问题。</li>\n<li>上下文切换。</li>\n<li>可靠性。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"第二章-多线程编程的目标与挑战\"><a href=\"#第二章-多线程编程的目标与挑战\" class=\"headerlink\" title=\"第二章 多线程编程的目标与挑战\"></a>第二章 多线程编程的目标与挑战</h2><ol>\n<li>多线程编程的实质就是将任务的处理方式由串行改为<code>并发</code>，即实现并发化，以发挥并发的优势。</li>\n<li><code>状态变量</code>：即类的实例变量、静态变量。</li>\n<li><code>共享变量</code>：即可以被多个线程共同访问的变量。</li>\n<li><code>竞态</code>是指计算的正确性依赖于相对时间顺序或者线程的交错。</li>\n<li>竞态往往伴随着读取<code>脏数据</code>问题。</li>\n<li>竞态的两种模式：<code>read-modify-write</code>（读-改-写）和<code>check-then-act</code>（检测后行动）。</li>\n<li>如果一个类在单线程环境下能够运行正常，并且在多线程环境下，在其使用方不必为其做任何改变的情况下也能运作正常，那么我们就称其是<code>线程安全</code>的，相应地，我们称这个类具有线程安全性。</li>\n<li>对于涉及共享变量访问的操作，若该操作从其执行线程以外的任意线程来看是不可分割的，那么该操作就是原子操作，相应地我们称该操作具有<code>原子性</code>。</li>\n<li>Java中有两种方式来实现原子性。一种是使用<code>锁</code>，另一种是利用处理器提供的专门<code>CAS</code>指令。</li>\n<li>在多线程环境下，一个线程对某个变量进行更新之后，后续访问该变量的线程可能无法立刻读取到这个更新的结果，甚至永远也无法读取到这个更新的结果，这就是线程安全的另一个表现形式：<code>可见性</code>。</li>\n<li>可见性问题可能来源于JIT编译器的优化，也可能来源于<code>寄存器</code>和<code>高速缓存</code>。</li>\n<li>虽然一个处理器的高速缓存中的内容不能被另一个处理器直接读取，但是一个处理器可以通过<code>缓存一致性协议</code>来读取其他处理器的高速缓存的数据，并将读到的数据更新到该处理器的高速缓存中。</li>\n<li><code>volatile</code>关键字所起到的一个作用就是，提示JIT编译器被修饰的变量可能被多个线程共享，以阻止JIT编译器做出可能导致程序运行不正常的优化。另外一个作用是读取一个volatile关键字修饰的变量会使相应的处理器执行刷新处理器缓存的动作，写一个volatile关键字修饰的变量会使相应的处理器执行冲刷处理器缓存的动作，从而保障可见性。</li>\n<li>对于同一个共享变量而言，一个线程更新了该变量的值之后，其他线程能够读取到这个更新后的值，那么这个值就被称为该变量的相对新值。</li>\n<li>父线程在启动子线程之前对共享变量的更新对于子线程来说是可见的。</li>\n<li>一个线程终止后该线程对共享变量的更新对于调用该线程的<code>join</code>方法的线程而言是可见的。</li>\n<li><code>有序性</code>指在什么情况下一个处理器上运行的一个线程所执行的内存访问操作在另一个处理器上运行的其他线程看起来是乱序的。</li>\n<li><code>重排序</code>是对内存访问有关的操作所做的一种优化，它可以在不影响单线程程序正确性的情况下提升程序的性能。重排序主要包括：<code>指令重排序</code>和<code>存储子系统重排序</code>。</li>\n<li>重排序可能导致线程安全问题。</li>\n<li>重排序不是必然出现的。</li>\n<li>处理器也可能执行指令重排序，这使得执行顺序和程序顺序不一致，处理器对指令进行重排序也被称为处理器的乱序执行。处理器乱序执行并不会对单线程程序的正确性产生影响。</li>\n<li>主内存相对于处理器是一个慢速设备。为了避免其拖后腿，处理器并不是直接访问主内存，而是通过高速缓存访问主内存的。</li>\n<li>内存重排序包括：LoadLoad重排序、StoreStore重排序、LoadStore重排序、StoreLoad重排序。</li>\n<li>存在数据依赖关系的语句不会被重排序，只有不存在数据依赖关系的语句才可能会被重排序。</li>\n<li>可见性是有序性的基础，有序性影响可见性。</li>\n<li>一个线程由于其时间片用完或者其自身原因被迫或者主动暂停其运行时，另外一个线程可以被操作系统选中占用处理器开始或者继续其运行。这种一个线程暂停，另一个线程被选中开始或者继续运行的过程就叫做<code>上下文切换</code>。</li>\n<li>进度信息就被称为上下文，它一般包括通用寄存器的内容和程序计数器的内容。</li>\n<li>自发性上下文切换指线程由于其自身因素导致的切出。如执行以下指令：Thread.sleep()、Object.wait()、Thread.join()、LockSupport.park()。</li>\n<li>非自发性上下文切换指线程由于线程调度器的原因被迫切出。</li>\n<li>上下文切换的开销包括<strong>直接开销</strong>和<strong>间接开销</strong>。<ol>\n<li>操作系统保存和恢复上下文所需的开销，这主要是处理器时间开销。</li>\n<li>线程调度器进行线程调度的开销。</li>\n<li>处理器高速缓存重新加载的开销。</li>\n<li>上下文切换也可能导致整个一级高速缓存中的内容被冲刷。</li>\n</ol>\n</li>\n<li>这些由于资源稀缺性或者程序自身的问题和缺陷导致线程一直处于非RUNNABLE状态，或者线程虽然处于RUNNABLE状态但是其要执行的任务却一直无法进展的现象就被称为<code>线程活性故障</code>。常见的活性故障包括：<ol>\n<li>死锁</li>\n<li>锁死</li>\n<li>活锁</li>\n<li>饥饿</li>\n</ol>\n</li>\n<li>一次只能够被一个线程占用的资源被称为<code>排他性</code>资源。在一个线程占用一个排他性资源进行访问时，其他线程视图访问该资源的现象就被称为<code>资源争用</code>。</li>\n<li>同一时间内，处于运行状态的线程数量越多，我们就称并发程度越高，简称<code>高并发</code>。</li>\n<li>在多个线程申请同一个排他性资源的情况下，决定哪个线程会被授予该资源的独占权，即选择哪个申请者占用该资源的过程就是<code>资源的调度</code>。</li>\n<li>如果资源的任何一个先申请者总是能够比任何一个后申请者先获得该资源的独占权，那么相应的资源调度策略就被称为是<code>公平</code>的，如果资源的后申请者可能比先申请者先获得资源的独占权，那么相应的资源调度策略就被称为<code>非公平</code>的。</li>\n<li>在极端的情况下，非公平调度策略可能导致等待队列中的线程永远无法获得其所需的资源，即出现<code>饥饿</code>。</li>\n<li>一般来说，非公平调度策略的<strong>吞吐率高</strong>，即单位时间内它可以为更多的申请者调配资源。其缺点是，从申请者个体的角度来看这些申请者获得相应资源的独占权所需要的<strong>时间偏差</strong>可能比较大。</li>\n<li>非公平调度策略可能带来一个好处——减少上下文切换的次数。</li>\n<li>多数线程占用资源的时间相当长的情况下不适合使用<strong>非公平调度策略</strong>。</li>\n<li>非公平调度策略是我们多数情况下的<strong>首选</strong>调度策略。其优点是吞吐率较大；缺点是资源申请者申请资源所需的时间偏差可能较大，并可能导致饥饿。公平调度策略适合在资源的时间相对长或资源的平均申请时间间隔相对长的情况下，或者对资源申请所需的时间偏差有所要求的情况下使用。其优点是线程申请资源所需的时间偏差较小，并且不会导致线程饥饿现象；其缺点是吞吐率较小。</li>\n</ol>\n<h2 id=\"第三章-Java线程同步机制\"><a href=\"#第三章-Java线程同步机制\" class=\"headerlink\" title=\"第三章 Java线程同步机制\"></a>第三章 Java线程同步机制</h2><ol>\n<li><p><code>线程同步机制</code>是一套用于协调线程间的数据访问及活动的机制，该机制用用户保障线程安全以及实现这些线程的共同目标。</p>\n</li>\n<li><p>线程安全问题的产生前提是多个线程并发访问共享变量、共享资源。</p>\n</li>\n<li><p>锁的持有线程在其获得锁之后和释放锁之前这段时间内所执行的代码被称为<code>临界区</code>。</p>\n</li>\n<li><p>Java平台中的锁包括<code>内部锁</code>和<code>显示锁</code>。</p>\n</li>\n<li><p>锁是通过<code>互斥</code>保障原子性的。</p>\n</li>\n<li><p>一个锁实例锁保护的共享数据的数量大小就被称为锁的<code>粒度</code>。</p>\n</li>\n<li><p>锁的开销包括锁的申请和释放锁产生的开销，以及锁可能导致的上下文切换的开销，这些开销主要是处理器时间。</p>\n</li>\n<li><p><code>锁泄漏</code>是指一个线程获得某个锁之后，由于程序的错误缺陷致使该锁一直无法被释放而导致其他线程一直无法获得该锁的现象。</p>\n</li>\n<li><p>Java平台中的任何一个对象都有唯一的一个与之关联的锁。这种锁被称为<code>监视器</code>或者<code>内部锁</code>。内部锁是一种<code>排他锁</code>，它能保障原子性、可见性和有序性。</p>\n</li>\n<li><p>Java虚拟机会为每个内部锁分配一个<code>入口集</code>，用于记录等待获得相应内部锁的线程。多个线程申请同一个锁的时候，只有一个申请者能够成为该锁的持有线程，而其他申请者的申请操作会失败。</p>\n</li>\n<li><p>公平锁保障锁调度的公平性往往是以增加了线程的暂停和唤醒的可能性，即增加了上下文切换为代价的。因此公平锁适合于锁被持有的时间相对长或者线程申请锁的平均间隔时间相对长的情形。总得来说使用公平锁的开销比使用非公平锁的开销要大，因此显式锁默认使用的是非公平调度策略。</p>\n</li>\n<li><p><code>读写锁</code>是一种改进型的排它锁，也被称为共享/排它锁。读锁是<code>共享</code>的，写锁是<code>排他</code>的。</p>\n</li>\n<li><p>读写锁适合于在以下条件同时得以满足的场景中使用：</p>\n<ol>\n<li>只读操作比写操作要频繁得多。</li>\n<li>读线程持有锁的时间比较长。</li>\n</ol>\n</li>\n<li><p><code>ReetrantReadWriteLock</code>所实现的读写锁是<code>个可重入锁</code>。ReetrantReadWriteLock支持写锁的<code>降级</code>，即一个线程持有读写锁的写锁的情况下可以继续获得相应的读锁。</p>\n</li>\n<li><p><code>ReetrantReadWriteLock</code>并不支持锁的升级。读线程如果要转而申请写锁，需要先释放读锁，然后申请相应的写锁。</p>\n</li>\n<li><p><code>内存屏障</code>是对一类仅针对内存读、写操作指令的跨处理器架构的比较底层的抽象。内存屏障是被插入到两个指令之间进行使用的，其作用是<strong>禁止编译器、处理器重排序从而保障有序性</strong>。</p>\n</li>\n<li><p>按照可见性保障来划分，<code>内存屏障</code>可分为<code>加载屏障</code>和<code>存储屏障</code>。加载屏障的作用是<strong>刷新处理器缓存</strong>，存储屏障的作用是<strong>冲刷处理器缓存</strong>。Java虚拟机会在MonitorExit对应的机器码指令之后插入一个<code>存储屏障</code>，这就保障了写线程在释放锁之前在临界区中对共享变量所做的更新对读线程是可同步的。相应的，Java虚拟机会在MonitorEnter对应的机器码指令之后临界区开始之前的地方插入一个<code>加载屏障</code>，这使得读线程的执行处理器能够将写线程对相应共享变量所做的更新从其他处理器同步到该处理器的高速缓存中。</p>\n</li>\n<li><p>按照有序性保障来划分，<code>内存屏障</code>可以分为<code>获取屏障</code>和<code>释放屏障</code>。获取屏障的使用方式是在一个读操作之后插入该内存屏障，其作用是<strong>禁止该读操作与其后的任何读写操作之间进行重排序</strong>，这相当于在进行后续操作之前先要获得相应共享数据的所有权。释放屏障的使用方式是在一个写操作之前插入该内存屏障，其作用是<strong>禁止该写操作与其前面的任何读写操作之间进行重排序</strong>。Java虚拟机会在MonitorEnter对应的机器码指令之后临界区开始之前的地方插入一个获取屏障，并在临界区结束之后MonitorExit对应的机器码指令之前的地方插入一个释放屏障。</p>\n</li>\n<li><p>临界区之外的语句可以被重排序到临界区之内，而临界区内的操作无法被重排序到临界区之外。</p>\n<ol>\n<li><p>临界区内的操作不允许被重排序到临界区之外。</p>\n</li>\n<li><p>临界区内的操作之间允许被重排序。</p>\n</li>\n<li><p>临界区外的操作之间可以被重排序。</p>\n</li>\n<li><p>锁申请与锁释放操作不能被重排序。</p>\n</li>\n<li><p>两个锁申请操作不能被重排序。</p>\n</li>\n<li><p>两个锁释放操作不能被重排序。</p>\n</li>\n<li><p>临界区外的操作可以被重排到临界区之内。</p>\n</li>\n</ol>\n</li>\n<li><p><code>volatile</code>变量不会被编译器分配到寄存器进行存储，对volatile变量的读写操作都是内存访问操作。</p>\n</li>\n<li><p><code>volatile</code>关键字常被称为<code>轻量级锁</code>，其作用与锁的作用有相同的地方：保证可见性和有序性。原子性方面它仅能保证写volatile变量操作的原子性，但没有锁的排他性。其次，volatile关键字的使用不会引起上下文切换。</p>\n</li>\n<li><p>一个赋值操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">volatile</span> Map aMap = <span class=\"keyword\">new</span> HashMap();</span><br></pre></td></tr></table></figure>\n<p>可以分解为如下伪代码所示的几个子操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objRef = allocate(HashMap.class); <span class=\"comment\">// 子操作1：分配对象所需的存储空间</span></span><br><span class=\"line\">invokeConstructor(objRef); <span class=\"comment\">// 子操作2：初始化objRef引用的对象</span></span><br><span class=\"line\">aMap = objRef; <span class=\"comment\">// 子操作3：将对象引用写入变量aMap</span></span><br></pre></td></tr></table></figure>\n<p>虽然volatile关键字仅保障其中的子操作3是一个原子操作，但是由于子操作1与子操作2仅涉及局部变量而未涉及共享变量，因此对变量aMap的赋值操作仍然是一个原子操作。</p>\n</li>\n<li><p>对于volatile变量的写操作，Java虚拟机会在操作之前插入一个<code>释放屏障</code>，并在该操作之后插入一个<code>存储屏障</code>。</p>\n</li>\n<li><p>对于volatile变量的读操作，Java虚拟机会在操作之前插入一个<code>加载屏障</code>，并在该操作之后插入一个<code>获取屏障</code>。</p>\n</li>\n<li><p>写volatile变量操作与该操作之前的任何读、写操作<strong>不会被重排序</strong>。</p>\n</li>\n<li><p>读volatile变量操作与该操作之后的任何读、写操作<strong>不会被重排序</strong>。</p>\n</li>\n<li><p>volatile关键字在可见性方面仅仅是保证读线程能够读取到共享变量的相对新值。对于引用型变量和数组变量，volatile关键字并不能保证读线程能够读取到对象相应的字段、元素的相对新值。</p>\n</li>\n<li><p>volatile变量的读、写操作都不会导致上下文切换，因此volatile的开销比锁要小。</p>\n</li>\n<li><p>volatile使用的典型场景：</p>\n<ol>\n<li><p>使用volatile变量作为<code>状态标志</code>。</p>\n</li>\n<li><p>使用volatile保障<code>可见性</code>。</p>\n</li>\n<li><p>使用volatile变量代替锁。</p>\n</li>\n<li><p>使用volatile实现简易版的读写锁。</p>\n</li>\n</ol>\n</li>\n<li><p>volatile关键字并非锁的代替品，volatile关键字和锁各有其适用条件。前者更适合于多个线程共享一个状态变量，而后者更适合于多个线程共享一组状态变量。某些情形下，我们可以将多个线程共享的一组状态变量合并成一个对象，用一个volatile变量来引用该对象，从而使我们不必要使用锁。</p>\n</li>\n<li><p><code>原子变量类</code>是基于CAS实现的能够保障对共享变量进行<code>read-modify-write</code>更新操作的原子性和可见性的一组工具类。</p>\n</li>\n<li><p><code>对象发布</code>是指使对象能够被其作用域之外的线程访问。</p>\n</li>\n<li><p>常见的对象发布形式包括：</p>\n<ol>\n<li><p>将对象引用存储到public变量中。</p>\n</li>\n<li><p>在非private方法中返回一个对象。</p>\n</li>\n<li><p>创建内部类，使得当前对象能够被这个内部类使用。</p>\n</li>\n<li><p>通过方法调用将对象传递给外部方法。</p>\n</li>\n</ol>\n</li>\n<li><p><code>static</code>关键字在多线程环境下有其特殊的含义，它能够保证一个线程即使在未使用其他同步机制的情况下也总是可以读取到一个类的静态变量的初始值。</p>\n</li>\n<li><p>对于引用型静态变量，<code>static</code>关键字还能够保障一个线程读取到该变量的初始值时，这个值所指向的对象已经初始化完毕。</p>\n</li>\n<li><p><code>static</code> 关键字仅仅保障读线程能够读取到相应字段的初始值，而不是相对新值。</p>\n</li>\n<li><p>当一个对象被发布到其他线程的时候，该对象的所有<code>final</code>字段都是初始化完毕的。</p>\n</li>\n<li><p>对于引用型<code>final</code>字段，<code>final</code>关键字还进一步确保该字段所引用的对象已经初始化完毕，即这些线程读取该字段所引用的对象的各个字段时所读取到的值都是相应字段的初始值。</p>\n</li>\n<li><p>当一个对象的引用对其他线程可见的时候，这些线程所看到的该对象的final字段必然是初始化完毕的。final关键字的作用仅是这种有序性的保障，它并不能保障包含final字段的对象的引用自身对其他线程的可见性。</p>\n</li>\n<li><p><code>安全发布</code>就是指对象以一种线程安全的方式被发布。</p>\n</li>\n<li><p>当一个对象的发布出现我们不期望的结果或者对象发布本身不是我们所期望的时候，我们就称该对象<code>逸出</code>。</p>\n</li>\n<li><p>对象逸出包括：</p>\n<ol>\n<li><p>在构造函器中将this赋值给一个共享变量。</p>\n</li>\n<li><p>在构造器中将this作为方法参数传递给其他方法。</p>\n</li>\n<li><p>在构造器中启动基于匿名类的线程。</p>\n</li>\n</ol>\n</li>\n<li><p>一个对象在其初始化过程中没有出现this逸出，我们就称该对象为正确创建的对象。</p>\n</li>\n<li><p>实现对象的安全发布，通常可以依照以下顺序选择适用且开销最小的线程同步机制。</p>\n<ol>\n<li><p>使用staic关键字引用该对象的变量。</p>\n</li>\n<li><p>使用final关键字修饰引用该对象的变量。</p>\n</li>\n<li><p>使用volatile关键字修饰引用该对象的变量。</p>\n</li>\n<li><p>使用AtomicReference来引用该对象。</p>\n</li>\n<li><p>对访问该对象的代码进行加锁。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"第四章-牛刀小试：玩转线程\"><a href=\"#第四章-牛刀小试：玩转线程\" class=\"headerlink\" title=\"第四章 牛刀小试：玩转线程\"></a>第四章 牛刀小试：玩转线程</h2><ol>\n<li><p>多线程编程中分而治之的使用主要有两种方式：<strong>基于数据的分割</strong>和<strong>基于任务的分割</strong>。</p>\n</li>\n<li><p>基于数据的分割的结果是产生多个<code>同质工作者线程</code>，即任务处理逻辑相同的线程。需要考虑如下因素：</p>\n<ol>\n<li><p>工作者线程数量的合理设置问题。</p>\n</li>\n<li><p>工作者线程的异常处理问题。</p>\n</li>\n<li><p>原始输入规模未知问题。</p>\n</li>\n<li><p>程序的复杂性增加的问题。</p>\n</li>\n</ol>\n</li>\n<li><p>为了提高任务的执行效率，我们可能使用多个线程去共同完成一个任务的执行。这就是基于任务的分割，其基本思想就是将任务按照一定的规则分解成若干子任务，并使用专门的工作者线程去执行这些子任务，从而实现任务的并发执行。</p>\n</li>\n<li><p>线程所执行的任务按照 其消耗的主要资源可划分为<code>CPU密集型</code>任务和<code>IO密集型</code>任务。</p>\n</li>\n<li><p>CPU密集型任务执行过程中消耗的主要资源是CPU时间，CPU密集型任务的一个典型例子是加密和解密；IO密集型任务执行过程中消耗的主要资源是IO资源，典型的IO密集型任务就包括文件读写、网络读写等。</p>\n</li>\n<li><p>基于任务的分割结果是产生多个相互协作的<code>异质工作者线程</code>。</p>\n</li>\n<li><p><code>Amdahl’s 定律</code>描述了线程数与多线程程序相对于单线程程序的提速之间的关系。<br>$$<br>S_{max} = \\frac{1}{P + \\frac{1 - P}{N}}<br>$$<br>其中，N为处理器数量，程序中必须串行化的部分耗时占程序全部耗时的比率为P。</p>\n</li>\n<li><p>为使多线程程序能够获得较大的提速，我们<strong>应该从算法入手，减少程序中必须串行的部分，而不是寄希望于增加线程数</strong>。</p>\n</li>\n<li><p>线程数设置得过少可能导致无法充分利用处理器资源；而线程数设置得过大则又可能导致过多的上下文切换，从而反倒降低了系统的性能。</p>\n</li>\n<li><p>线程数的合理值可以根据以下规则设置：</p>\n<ol>\n<li><p>对于CPU密集型线程，考虑到这类线程执行任务时消耗的主要是处理器资源，我们可以将这类线程的线程数设置为$N_{cpu} $个。因为CPU密集型线程也可能由于某些原因（比如缺页中断）而被切出，此时为了避免处理器资源的浪费，我们也可以为这类线程设置一个额外的线程，即将线程数设置为$N_{cpu}  + 1$</p>\n</li>\n<li><p>对于IO密集型线程，考虑到IO操作可能导致上下文切换，为这样的线程设置过多的线程会导致过多的额外系统开销。因此如果一个这样的工作者线程就可以满足我们的要求，那么就不要设置更多的线程数。如果一个工作者线程仍然不够用，那么我们可以考虑将这类线程的数量设置为$2 * N_{cpu} $</p>\n</li>\n</ol>\n</li>\n<li><p><strong>挖掘出程序中可并发点</strong>是实现多线程编程的目标——并发计算的前提。</p>\n</li>\n<li><p>实现并发化的策略包括基于数据的分割策略和基于任务的分割策略。</p>\n</li>\n</ol>\n<h2 id=\"第五章-线程间协作\"><a href=\"#第五章-线程间协作\" class=\"headerlink\" title=\"第五章 线程间协作\"></a>第五章 线程间协作</h2><ol>\n<li><p>一个线程因其执行目标动作所需的保护条件未满足而被暂停的过程被称为<code>等待</code>。</p>\n</li>\n<li><p>一个线程更新了系统的状态，使得其他线程所需的保护条件得以满足的时候唤醒那些被暂停的线程的过程就被称为<code>通知</code>。</p>\n</li>\n<li><p>由于一个线程只有在持有一个对象的内部所的情况下才能够调用该对象的wait方法，因此Object.wait()调用总是放在相应对象所引导的临界区之中。</p>\n</li>\n<li><p>等待线程对保护条件的判断、Object.wait()的执行以及目标动作的执行必须放在同一个对象所引导的临界区之中。</p>\n</li>\n<li><p><code>Object.wait()</code>暂停当前线程时释放的锁只是与该wait方法所属对象的内部锁。当前线程所持有的其他内部锁、显示锁并不会因此而被释放。</p>\n</li>\n<li><p><code>Object.notify()</code>的执行线程持有的相应对象的内部锁只有在Object.notify()调用所在的临界区代码执行结束后才会被释放，而Object.notify()本身并不会将这个内部锁释放。因此，为了 使等待线程在其被唤醒之后能够尽快再次获得相应的内部锁，我们要尽可能地将Object.notify()调用放在靠近临界区结束的地方。</p>\n</li>\n<li><p><code>等待线程</code>和<code>通知线程</code>是同步在同一对象之上的两种线程。</p>\n</li>\n<li><p>Java虚拟机会为每个对象维护一个<code>入口集</code>用于存储申请该对象内部锁的线程。Java虚拟机还会为每个对象维护一个被称为<code>等待集</code>的队列，该队列用于存储该对象上的等待线程。Object.wait()将当前线程暂停并释放相应的内部锁的同时会将当前线程存入该方法所属对象的等待集中。</p>\n</li>\n<li><p>wait/notify的开销及问题</p>\n<ol>\n<li><p>过早唤醒问题</p>\n</li>\n<li><p>信号丢失问题</p>\n</li>\n<li><p>欺骗性唤醒问题</p>\n</li>\n<li><p>上下文切换问题</p>\n</li>\n</ol>\n</li>\n<li><p>只有在有证据表明使用<code>Object.notify()</code>足够的情况下才使用<code>Object.notify()</code>，只有在下列条件全部满足的情况下才能够用于替代<code>notifyAll</code>方法：</p>\n<ol>\n<li><p>一次通知仅需要唤醒至多一个线程。</p>\n</li>\n<li><p>相应对象的等待集中仅包含同质等待线程。</p>\n</li>\n</ol>\n</li>\n<li><p><code>join(long)</code>允许我们指定一个超时时间。如果目标线程没有在指定的时间内终止，那么当前线程也会继续运行。<code>join(long)</code>实际上就是使用了<code>wait/notify</code>来实现的。</p>\n</li>\n<li><p>Java虚拟机会在目标线程的run方法运行结束后执行该线程的<code>notifyAll</code>方法来通知所有的等待线程。</p>\n</li>\n<li><p><code>Condition</code>接口可作为<code>wait/notify</code>的替代品来实现等待/通知，它为解决过早唤醒问题提供了支持，并解决了<code>Object.wait(long)</code>不能区分其返回是否是由等待超时而导致的问题。</p>\n</li>\n<li><p><code>Condition.await()/signal()</code>也要求其执行线程持有创建该Condition实例的显示锁。Condition实例也被称为条件变量或者条件队列。每个Condition实例内部都维护了一个用于存储等待线程的队列。</p>\n</li>\n<li><p><code>Condition</code>接口本身只是对解决过早唤醒问题提供了支持。要真正解决过早唤醒问题，我们需要通过应用代码维护保护条件与条件变量的await方法来实现其等待，并使通知线程在更新了相关共享变量之后，仅调用与这些共享变量有关的保护条件所对应的条件变量的<code>signal/signalAll</code>方法来实现通知。</p>\n</li>\n<li><p><code>Condition.awaitUntil(Date deadline)</code>可以用于实现带超时时间限制的等待，并且该方法的返回值能够区分该方法调用是由于等待超时而返回还是由于其他线程执行了相应条件变量的<code>signal/signalAll</code>方法而返回。</p>\n</li>\n<li><p>等待线程因执行<code>Condition.await()/awaitUntil(Date)</code>而被暂停的同时，其持有的相应显示锁也会被释放，等待线程被唤醒之后得以继续运行时需要再次申请相应的显示锁，然后等待线程对<code>Condition.await()/awaitUntil(Date)</code>的调用才能返回。</p>\n</li>\n<li><p><code>CountDownLatch</code>可以用来实现一个线程等待其他线程完成一组特定的操作之后才继续运行。这组操作被称为<code>先决操作</code>。</p>\n</li>\n<li><p><code>CountDownLatch</code>内部计数器值达到0后其值就恒定不变，后续执行该CountDownLatch实例的await方法的任何一个线程都不会被暂停。为了避免等待线程永远被暂停，<code>CountDownLatch.countDown()</code>调用必须放在代码中总是可以被执行到的地方，例如<code>finally</code>块中。</p>\n</li>\n<li><p>使用<code>CyclicBarrier</code>实现等待的线程被称为<code>参与方</code>，参与方只需要执行<code>CyclicBarrier.await()</code>就可以实现等待。</p>\n</li>\n<li><p>最后一个线程执行<code>CyclicBarrier.await()</code>会使得使用相应<code>CyclicBarrier</code>实例的其他所有参与方被唤醒，而最后一个线程自身并不会被暂停。</p>\n</li>\n<li><p>由于<code>CyclicBarrier</code>内部实现是基于条件变量的，因此<code>CyclicBarrier</code>的开销与条件变量的开销相似，其主要开销在可能产生的上下文切换。</p>\n</li>\n<li><p>CyclicBarrier内部使用了一个条件变量trip来实现等待/通知。CyclicBarrier内部实现使用了分代的概念用于表示CyclicBarrier实例是可以重复使用的。</p>\n</li>\n<li><p>最后一个线程相当于通知线程，它执行费CyclicBarrier.await()会使得相应实例的parties值变为0，此时该线程会先执行barrierAction.run()，然后再执行 trip.signalAll()来唤醒所有等待线程。接着，开始下一个分代，即使得CyclicBarrier的parties指又重新恢复为其初始值。</p>\n</li>\n<li><p>CyclicBarrier的典型应用场景包括以下几个:</p>\n<ol>\n<li><p>使得迭代算法并发化。</p>\n</li>\n<li><p>在测试代码中模拟高并发。</p>\n</li>\n</ol>\n</li>\n<li><p>将产品存入传输通道的线程就被称为生产者线程，从传输通道中取出产品进行消费的线程就被称为消费者线程。</p>\n</li>\n<li><p>一个方法或者操作如果能够导致其执行线程被暂停，那么我们就称相应的方法/操作为阻塞方法。阻塞方法能够导致上下文切换。</p>\n</li>\n<li><p>阻塞队列按照其存储空间的容量是否受限制来划分，可分为有界队列和无界队列。有界队列的存储容量限制是由应用程序制定的，无界队列的最大存储容量为Interger.MAX_VALUE($2^{31} - 1$)个元素。</p>\n</li>\n<li><p>ArrayBlockingQueue的缺点是其内部在实现put、take操作的时候使用的是同一个锁，从而可能导致锁的高争用，进而导致较多的上下文切换。</p>\n</li>\n<li><p>LinkedBlockingQueue既能实现无界队列，也能实现有界队列。</p>\n</li>\n<li><p>LinkedBlockingQueue的优点是其内部在实现\bput、take操作的时候分别使用了两个显示锁（putLock和takeLock），这\b降低了锁争用的可能性。LinkedBlockingQueue的内部存储空间是一个链表，而链表节点所需的存储空间是动态分配的，put操作、take操作都会导致链表节点的动态创建和移除，因此LinkedBlockingQueue的缺点是它可能增加垃圾回收的负担。</p>\n</li>\n<li><p>SynchronousQueue可以被看做一种特殊的有界队列。</p>\n</li>\n<li><p>SynchronousQueue适合于在消费者处理能力和生产者处理能力相差不大的情况下使用。</p>\n</li>\n<li>ArrayBlockingQueue和SynchronousQueue都既支持非公平调度也支持公平调度，而LinkedBlockingQueue仅支持非公平调度。</li>\n<li>如果生产者线程和消费者线程之间的并发程度比较大，那么这些线程对传输通道内部所使用的锁的争用可能性也随之增加。这时，有界队列的实现适合选用LinkedBlockingQueue，否则我们可以考虑ArrayBlockingQueue。</li>\n<li>使用无界队列作为传输通道的一个好处是put操作并不会导致生产者线程被阻塞。一般我们在使用无界队列作为传输通道的时候会同时限制生产者的生产速率。</li>\n<li>Semaphore.acquire() 和 Semaphore.release()总是配对使用。</li>\n<li>Semaphore.release()调用总是应该放在一个finally块中。</li>\n<li>创建Semaphore时如果构造函数中的参数permits值为1，那么所创建的Semaphore实例相当于一个互斥锁。与其他互斥锁不同的是，由于一个线程可以在未执行过Semaphore.acquire()的情况下执行Semaphore.release()，因此这种互斥锁允许一个线程释放另一个线程所持有的锁。</li>\n<li>PipedOutputStream和PipedInputStream适合在两个线程间使用，即适用于单生产者-单消费者的情形。</li>\n<li>输出异常的处理。如果生产者线程在其执行过程中出现了不可恢复的异常，那么消费者线程就会永远也无法读取到新的数据。</li>\n<li>当消费者线程消费一个已填充的缓冲区时，另外一个缓冲区可以由生产者线程进行填充，从而实现了数据生成与消费的并发。这种缓冲技术就被称为双缓冲。</li>\n<li>Exchanger.exchange(V)的返回值是对方线程执行该方法时所指定的参数x的值。因此，Exchanger.exchange(V)的返回值就造成一种生产者线程和消费者线程之间交换缓冲区的效果。</li>\n<li>中断可以被看做由一个线程发送给另一个线程的一种指示，该指示用于表示发起线程希望目标线程停止其正在执行的操作。中断仅仅代表发起线程的一个诉求，目标线程可能会满足发起线程的诉求，也可能根本不会理会发起线程的诉求。Java平台会为每个线程维护一个被称为中断标记的布尔型状态变量用于表示相应线程释放接收到了中断。</li>\n<li>目标线程检查中断标记后所执行的操作，被称为目标线程对中断的响应，简称中断响应。</li>\n<li>能够响应中断的方法通常是在执行阻塞操作之前判断中断标志，若中断标志值为true则抛出InterruptedException。</li>\n<li>如果发起线程给目标线程发送中断的那一刻，目标线程已经由于执行了一些阻塞方法操作而被暂停，那么此时Java虚拟机可能会设置目标线程的线程中断标记并将该线程唤醒，从而使目标线程被唤醒后继续执行的代码再次得到相应中断的机会。所以，给目标线程发送中断还能够产生唤醒目标线程的效果。</li>\n<li>在单生产者-单消费者模式中，停止生产者、消费者线程有一种简单的方法：生产者线程在其终止前往传’输通道中存入一个特殊产品作为消费者线程的线程停止标记，消费者线程取出这个产品之后就可以退出run方法而终止了。</li>\n</ol>\n<h2 id=\"第六章-保障线程安全的设计技术\"><a href=\"#第六章-保障线程安全的设计技术\" class=\"headerlink\" title=\"第六章 保障线程安全的设计技术\"></a>第六章 保障线程安全的设计技术</h2>","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<blockquote>\n<p>书籍作者：黄文海<br>出版社：电子工业出版社</p>\n</blockquote>\n<h2 id=\"思维导图\"><a href=\"#思维导图\" class=\"headerlink\" title=\"思维导图\"></a>思维导图</h2><p><a href=\"https://mubu.com/doc/lW2C-KYYy0\" target=\"_blank\" rel=\"noopener\">全文思维导图</a></p>\n<h2 id=\"第一章-走进Java世界中的线程\"><a href=\"#第一章-走进Java世界中的线程\" class=\"headerlink\" title=\"第一章 走进Java世界中的线程\"></a>第一章 走进Java世界中的线程</h2><ol>\n<li><code>进程</code>是程序向操作系统申请资源的基本单位，<code>线程</code>是进程中可独立执行的最小单位。</li>\n<li>一个进程可以包含多个线程。</li>\n<li>线程所要完成的计算被称为<code>任务</code>。</li>\n<li>启动一个线程的实质是请求Java虚拟机运行相应的线程，而这个线程具体何时能够运行是由线程调度器决定的。</li>\n<li>Java虚拟机会为每个线程分配调用栈所需的内存空间。</li>\n<li>Java平台中的任意一段代码总是由确定的线程负责执行的，这个线程就相应的被称为这段代码的<code>执行线程</code>。可以通过调用Thread.currentThread()来获取这段代码的执行线程。</li>\n<li>线程的属性：</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>类型及用途</th>\n<th>注意事项</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>编号（ID）</td>\n<td>Long。用于标识不同的线程。</td>\n<td>不同线程虽然拥有的编号不同，但是某个编号的线程运行结束后，该编号可能被后续创建的线程使用，这种编号的唯一性只在Java虚拟机的一次运行中有效。</td>\n</tr>\n<tr>\n<td>名称（name）</td>\n<td>String。用于区分不同线程。（面向人）默认值与线程编号有关，默认值格式为：“Thread-线程编号”</td>\n<td>为每一个线程设置一个简短而含义明确的名称有助于多线程程序的调试和问题定位。</td>\n</tr>\n<tr>\n<td>线程类别（Daemon）</td>\n<td>boolean。true表示相应的线程为守护线程，否则表示相应的线程为用户线程。</td>\n<td>该属性必须在线程启动之前设置，否则setDaemon方法会抛出异常。负责一些关键任务的线程不适合设置为守护线程。</td>\n</tr>\n<tr>\n<td>优先级（Priority）</td>\n<td>int。该属性本质上是给线程调度器的提示，用于表示应用程序希望线程能够优先得以运行。Java定义了1~10的10个优先级，默认值为5。</td>\n<td>一般使用默认优先级即可。</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"8\">\n<li><code>用户线程</code>会阻止Java虚拟机的正常停止，即一个Java虚拟机只有在其所有用户线程都运行结束的情况下才能正常停止。而<code>守护线程</code>则不会影响Java虚拟机的正常停止，守护线程通常用于执行一些重要性不是很高的任务，例如用于监视其他线程的运行情况。</li>\n<li>Thread的<code>join</code>方法的作用相当于执行该方法的线程和线程调度器说：“我得先暂停一下，等到另外一个线程运行结束后我才能继续干活。”</li>\n<li><code>yield</code>静态方法的作用相当于执行该方法的线程对线程调度器说：“我现在不急，如果别人需要处理器资源极度话先给他用吧。当然，如果没有其他人要用，我也不介意继续占用。”</li>\n<li><code>sleep</code>静态方法的作用相当于执行该方法的线程对线程调度器说：“我想小憩一会儿，过段时间再叫醒我继续干活吧。”</li>\n<li>假设线程A所执行的代码创建了线程B，那么，习惯上我们称线程B为线程A的<code>子线程</code>，相应地线程A就被称为线程B的<code>父线程</code>。</li>\n<li>在Java平台中，一个线程是否是守护线程默认取决于其父线程。</li>\n<li>一个线程的优先级默认值为该线程的父线程的优先级。</li>\n<li><code>Thread.State</code>是一个枚举类型，用来表示线程的当前状态。<ol>\n<li><code>NEW</code>：一个已创建而未启动的线程处于该状态。 </li>\n<li><code>RUNNABLE</code>：该状态可以被看成一个复合状态。它包括两个子状态：READY和RUNNING。</li>\n<li><code>BLOCKED</code>：线程进行阻塞式操作或申请由其他线程正在独占的资源时，相应的线程会处于该状态。</li>\n<li><code>WAITING</code>：执行某些特定方法之后就会处于这种等待状态，包括：Object.wait(),Thread.join(),LockSupport.park(),Condition.await()。能够使相应线程从WAITING变更为RUNNABLE的相应方法包括：Objeck.notify()/notifyAll()、LockSupport.unpark()、Condition.signal()。</li>\n<li><code>TIMED WAITING</code>：限时等待状态。</li>\n<li><code>TERMINATED</code>：已执行结束的线程处于该状态。</li>\n</ol>\n</li>\n<li>Java程序的线程转储包含的线程具体信息包括线程的属性、生命周期状态、线程的调用栈以及锁相关的信息。</li>\n<li>多线程编程具有以下优势：<ol>\n<li>提高系统的<strong>吞吐率</strong>。</li>\n<li>提高<strong>响应性</strong>。</li>\n<li>充分利用多核优势。</li>\n<li>最小化对系统资源的使用。</li>\n<li>简化程序的结构</li>\n</ol>\n</li>\n<li>多线程编程的风险：<ol>\n<li>线程安全问题。</li>\n<li>线程活性问题。</li>\n<li>上下文切换。</li>\n<li>可靠性。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"第二章-多线程编程的目标与挑战\"><a href=\"#第二章-多线程编程的目标与挑战\" class=\"headerlink\" title=\"第二章 多线程编程的目标与挑战\"></a>第二章 多线程编程的目标与挑战</h2><ol>\n<li>多线程编程的实质就是将任务的处理方式由串行改为<code>并发</code>，即实现并发化，以发挥并发的优势。</li>\n<li><code>状态变量</code>：即类的实例变量、静态变量。</li>\n<li><code>共享变量</code>：即可以被多个线程共同访问的变量。</li>\n<li><code>竞态</code>是指计算的正确性依赖于相对时间顺序或者线程的交错。</li>\n<li>竞态往往伴随着读取<code>脏数据</code>问题。</li>\n<li>竞态的两种模式：<code>read-modify-write</code>（读-改-写）和<code>check-then-act</code>（检测后行动）。</li>\n<li>如果一个类在单线程环境下能够运行正常，并且在多线程环境下，在其使用方不必为其做任何改变的情况下也能运作正常，那么我们就称其是<code>线程安全</code>的，相应地，我们称这个类具有线程安全性。</li>\n<li>对于涉及共享变量访问的操作，若该操作从其执行线程以外的任意线程来看是不可分割的，那么该操作就是原子操作，相应地我们称该操作具有<code>原子性</code>。</li>\n<li>Java中有两种方式来实现原子性。一种是使用<code>锁</code>，另一种是利用处理器提供的专门<code>CAS</code>指令。</li>\n<li>在多线程环境下，一个线程对某个变量进行更新之后，后续访问该变量的线程可能无法立刻读取到这个更新的结果，甚至永远也无法读取到这个更新的结果，这就是线程安全的另一个表现形式：<code>可见性</code>。</li>\n<li>可见性问题可能来源于JIT编译器的优化，也可能来源于<code>寄存器</code>和<code>高速缓存</code>。</li>\n<li>虽然一个处理器的高速缓存中的内容不能被另一个处理器直接读取，但是一个处理器可以通过<code>缓存一致性协议</code>来读取其他处理器的高速缓存的数据，并将读到的数据更新到该处理器的高速缓存中。</li>\n<li><code>volatile</code>关键字所起到的一个作用就是，提示JIT编译器被修饰的变量可能被多个线程共享，以阻止JIT编译器做出可能导致程序运行不正常的优化。另外一个作用是读取一个volatile关键字修饰的变量会使相应的处理器执行刷新处理器缓存的动作，写一个volatile关键字修饰的变量会使相应的处理器执行冲刷处理器缓存的动作，从而保障可见性。</li>\n<li>对于同一个共享变量而言，一个线程更新了该变量的值之后，其他线程能够读取到这个更新后的值，那么这个值就被称为该变量的相对新值。</li>\n<li>父线程在启动子线程之前对共享变量的更新对于子线程来说是可见的。</li>\n<li>一个线程终止后该线程对共享变量的更新对于调用该线程的<code>join</code>方法的线程而言是可见的。</li>\n<li><code>有序性</code>指在什么情况下一个处理器上运行的一个线程所执行的内存访问操作在另一个处理器上运行的其他线程看起来是乱序的。</li>\n<li><code>重排序</code>是对内存访问有关的操作所做的一种优化，它可以在不影响单线程程序正确性的情况下提升程序的性能。重排序主要包括：<code>指令重排序</code>和<code>存储子系统重排序</code>。</li>\n<li>重排序可能导致线程安全问题。</li>\n<li>重排序不是必然出现的。</li>\n<li>处理器也可能执行指令重排序，这使得执行顺序和程序顺序不一致，处理器对指令进行重排序也被称为处理器的乱序执行。处理器乱序执行并不会对单线程程序的正确性产生影响。</li>\n<li>主内存相对于处理器是一个慢速设备。为了避免其拖后腿，处理器并不是直接访问主内存，而是通过高速缓存访问主内存的。</li>\n<li>内存重排序包括：LoadLoad重排序、StoreStore重排序、LoadStore重排序、StoreLoad重排序。</li>\n<li>存在数据依赖关系的语句不会被重排序，只有不存在数据依赖关系的语句才可能会被重排序。</li>\n<li>可见性是有序性的基础，有序性影响可见性。</li>\n<li>一个线程由于其时间片用完或者其自身原因被迫或者主动暂停其运行时，另外一个线程可以被操作系统选中占用处理器开始或者继续其运行。这种一个线程暂停，另一个线程被选中开始或者继续运行的过程就叫做<code>上下文切换</code>。</li>\n<li>进度信息就被称为上下文，它一般包括通用寄存器的内容和程序计数器的内容。</li>\n<li>自发性上下文切换指线程由于其自身因素导致的切出。如执行以下指令：Thread.sleep()、Object.wait()、Thread.join()、LockSupport.park()。</li>\n<li>非自发性上下文切换指线程由于线程调度器的原因被迫切出。</li>\n<li>上下文切换的开销包括<strong>直接开销</strong>和<strong>间接开销</strong>。<ol>\n<li>操作系统保存和恢复上下文所需的开销，这主要是处理器时间开销。</li>\n<li>线程调度器进行线程调度的开销。</li>\n<li>处理器高速缓存重新加载的开销。</li>\n<li>上下文切换也可能导致整个一级高速缓存中的内容被冲刷。</li>\n</ol>\n</li>\n<li>这些由于资源稀缺性或者程序自身的问题和缺陷导致线程一直处于非RUNNABLE状态，或者线程虽然处于RUNNABLE状态但是其要执行的任务却一直无法进展的现象就被称为<code>线程活性故障</code>。常见的活性故障包括：<ol>\n<li>死锁</li>\n<li>锁死</li>\n<li>活锁</li>\n<li>饥饿</li>\n</ol>\n</li>\n<li>一次只能够被一个线程占用的资源被称为<code>排他性</code>资源。在一个线程占用一个排他性资源进行访问时，其他线程视图访问该资源的现象就被称为<code>资源争用</code>。</li>\n<li>同一时间内，处于运行状态的线程数量越多，我们就称并发程度越高，简称<code>高并发</code>。</li>\n<li>在多个线程申请同一个排他性资源的情况下，决定哪个线程会被授予该资源的独占权，即选择哪个申请者占用该资源的过程就是<code>资源的调度</code>。</li>\n<li>如果资源的任何一个先申请者总是能够比任何一个后申请者先获得该资源的独占权，那么相应的资源调度策略就被称为是<code>公平</code>的，如果资源的后申请者可能比先申请者先获得资源的独占权，那么相应的资源调度策略就被称为<code>非公平</code>的。</li>\n<li>在极端的情况下，非公平调度策略可能导致等待队列中的线程永远无法获得其所需的资源，即出现<code>饥饿</code>。</li>\n<li>一般来说，非公平调度策略的<strong>吞吐率高</strong>，即单位时间内它可以为更多的申请者调配资源。其缺点是，从申请者个体的角度来看这些申请者获得相应资源的独占权所需要的<strong>时间偏差</strong>可能比较大。</li>\n<li>非公平调度策略可能带来一个好处——减少上下文切换的次数。</li>\n<li>多数线程占用资源的时间相当长的情况下不适合使用<strong>非公平调度策略</strong>。</li>\n<li>非公平调度策略是我们多数情况下的<strong>首选</strong>调度策略。其优点是吞吐率较大；缺点是资源申请者申请资源所需的时间偏差可能较大，并可能导致饥饿。公平调度策略适合在资源的时间相对长或资源的平均申请时间间隔相对长的情况下，或者对资源申请所需的时间偏差有所要求的情况下使用。其优点是线程申请资源所需的时间偏差较小，并且不会导致线程饥饿现象；其缺点是吞吐率较小。</li>\n</ol>\n<h2 id=\"第三章-Java线程同步机制\"><a href=\"#第三章-Java线程同步机制\" class=\"headerlink\" title=\"第三章 Java线程同步机制\"></a>第三章 Java线程同步机制</h2><ol>\n<li><p><code>线程同步机制</code>是一套用于协调线程间的数据访问及活动的机制，该机制用用户保障线程安全以及实现这些线程的共同目标。</p>\n</li>\n<li><p>线程安全问题的产生前提是多个线程并发访问共享变量、共享资源。</p>\n</li>\n<li><p>锁的持有线程在其获得锁之后和释放锁之前这段时间内所执行的代码被称为<code>临界区</code>。</p>\n</li>\n<li><p>Java平台中的锁包括<code>内部锁</code>和<code>显示锁</code>。</p>\n</li>\n<li><p>锁是通过<code>互斥</code>保障原子性的。</p>\n</li>\n<li><p>一个锁实例锁保护的共享数据的数量大小就被称为锁的<code>粒度</code>。</p>\n</li>\n<li><p>锁的开销包括锁的申请和释放锁产生的开销，以及锁可能导致的上下文切换的开销，这些开销主要是处理器时间。</p>\n</li>\n<li><p><code>锁泄漏</code>是指一个线程获得某个锁之后，由于程序的错误缺陷致使该锁一直无法被释放而导致其他线程一直无法获得该锁的现象。</p>\n</li>\n<li><p>Java平台中的任何一个对象都有唯一的一个与之关联的锁。这种锁被称为<code>监视器</code>或者<code>内部锁</code>。内部锁是一种<code>排他锁</code>，它能保障原子性、可见性和有序性。</p>\n</li>\n<li><p>Java虚拟机会为每个内部锁分配一个<code>入口集</code>，用于记录等待获得相应内部锁的线程。多个线程申请同一个锁的时候，只有一个申请者能够成为该锁的持有线程，而其他申请者的申请操作会失败。</p>\n</li>\n<li><p>公平锁保障锁调度的公平性往往是以增加了线程的暂停和唤醒的可能性，即增加了上下文切换为代价的。因此公平锁适合于锁被持有的时间相对长或者线程申请锁的平均间隔时间相对长的情形。总得来说使用公平锁的开销比使用非公平锁的开销要大，因此显式锁默认使用的是非公平调度策略。</p>\n</li>\n<li><p><code>读写锁</code>是一种改进型的排它锁，也被称为共享/排它锁。读锁是<code>共享</code>的，写锁是<code>排他</code>的。</p>\n</li>\n<li><p>读写锁适合于在以下条件同时得以满足的场景中使用：</p>\n<ol>\n<li>只读操作比写操作要频繁得多。</li>\n<li>读线程持有锁的时间比较长。</li>\n</ol>\n</li>\n<li><p><code>ReetrantReadWriteLock</code>所实现的读写锁是<code>个可重入锁</code>。ReetrantReadWriteLock支持写锁的<code>降级</code>，即一个线程持有读写锁的写锁的情况下可以继续获得相应的读锁。</p>\n</li>\n<li><p><code>ReetrantReadWriteLock</code>并不支持锁的升级。读线程如果要转而申请写锁，需要先释放读锁，然后申请相应的写锁。</p>\n</li>\n<li><p><code>内存屏障</code>是对一类仅针对内存读、写操作指令的跨处理器架构的比较底层的抽象。内存屏障是被插入到两个指令之间进行使用的，其作用是<strong>禁止编译器、处理器重排序从而保障有序性</strong>。</p>\n</li>\n<li><p>按照可见性保障来划分，<code>内存屏障</code>可分为<code>加载屏障</code>和<code>存储屏障</code>。加载屏障的作用是<strong>刷新处理器缓存</strong>，存储屏障的作用是<strong>冲刷处理器缓存</strong>。Java虚拟机会在MonitorExit对应的机器码指令之后插入一个<code>存储屏障</code>，这就保障了写线程在释放锁之前在临界区中对共享变量所做的更新对读线程是可同步的。相应的，Java虚拟机会在MonitorEnter对应的机器码指令之后临界区开始之前的地方插入一个<code>加载屏障</code>，这使得读线程的执行处理器能够将写线程对相应共享变量所做的更新从其他处理器同步到该处理器的高速缓存中。</p>\n</li>\n<li><p>按照有序性保障来划分，<code>内存屏障</code>可以分为<code>获取屏障</code>和<code>释放屏障</code>。获取屏障的使用方式是在一个读操作之后插入该内存屏障，其作用是<strong>禁止该读操作与其后的任何读写操作之间进行重排序</strong>，这相当于在进行后续操作之前先要获得相应共享数据的所有权。释放屏障的使用方式是在一个写操作之前插入该内存屏障，其作用是<strong>禁止该写操作与其前面的任何读写操作之间进行重排序</strong>。Java虚拟机会在MonitorEnter对应的机器码指令之后临界区开始之前的地方插入一个获取屏障，并在临界区结束之后MonitorExit对应的机器码指令之前的地方插入一个释放屏障。</p>\n</li>\n<li><p>临界区之外的语句可以被重排序到临界区之内，而临界区内的操作无法被重排序到临界区之外。</p>\n<ol>\n<li><p>临界区内的操作不允许被重排序到临界区之外。</p>\n</li>\n<li><p>临界区内的操作之间允许被重排序。</p>\n</li>\n<li><p>临界区外的操作之间可以被重排序。</p>\n</li>\n<li><p>锁申请与锁释放操作不能被重排序。</p>\n</li>\n<li><p>两个锁申请操作不能被重排序。</p>\n</li>\n<li><p>两个锁释放操作不能被重排序。</p>\n</li>\n<li><p>临界区外的操作可以被重排到临界区之内。</p>\n</li>\n</ol>\n</li>\n<li><p><code>volatile</code>变量不会被编译器分配到寄存器进行存储，对volatile变量的读写操作都是内存访问操作。</p>\n</li>\n<li><p><code>volatile</code>关键字常被称为<code>轻量级锁</code>，其作用与锁的作用有相同的地方：保证可见性和有序性。原子性方面它仅能保证写volatile变量操作的原子性，但没有锁的排他性。其次，volatile关键字的使用不会引起上下文切换。</p>\n</li>\n<li><p>一个赋值操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">volatile</span> Map aMap = <span class=\"keyword\">new</span> HashMap();</span><br></pre></td></tr></table></figure>\n<p>可以分解为如下伪代码所示的几个子操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objRef = allocate(HashMap.class); <span class=\"comment\">// 子操作1：分配对象所需的存储空间</span></span><br><span class=\"line\">invokeConstructor(objRef); <span class=\"comment\">// 子操作2：初始化objRef引用的对象</span></span><br><span class=\"line\">aMap = objRef; <span class=\"comment\">// 子操作3：将对象引用写入变量aMap</span></span><br></pre></td></tr></table></figure>\n<p>虽然volatile关键字仅保障其中的子操作3是一个原子操作，但是由于子操作1与子操作2仅涉及局部变量而未涉及共享变量，因此对变量aMap的赋值操作仍然是一个原子操作。</p>\n</li>\n<li><p>对于volatile变量的写操作，Java虚拟机会在操作之前插入一个<code>释放屏障</code>，并在该操作之后插入一个<code>存储屏障</code>。</p>\n</li>\n<li><p>对于volatile变量的读操作，Java虚拟机会在操作之前插入一个<code>加载屏障</code>，并在该操作之后插入一个<code>获取屏障</code>。</p>\n</li>\n<li><p>写volatile变量操作与该操作之前的任何读、写操作<strong>不会被重排序</strong>。</p>\n</li>\n<li><p>读volatile变量操作与该操作之后的任何读、写操作<strong>不会被重排序</strong>。</p>\n</li>\n<li><p>volatile关键字在可见性方面仅仅是保证读线程能够读取到共享变量的相对新值。对于引用型变量和数组变量，volatile关键字并不能保证读线程能够读取到对象相应的字段、元素的相对新值。</p>\n</li>\n<li><p>volatile变量的读、写操作都不会导致上下文切换，因此volatile的开销比锁要小。</p>\n</li>\n<li><p>volatile使用的典型场景：</p>\n<ol>\n<li><p>使用volatile变量作为<code>状态标志</code>。</p>\n</li>\n<li><p>使用volatile保障<code>可见性</code>。</p>\n</li>\n<li><p>使用volatile变量代替锁。</p>\n</li>\n<li><p>使用volatile实现简易版的读写锁。</p>\n</li>\n</ol>\n</li>\n<li><p>volatile关键字并非锁的代替品，volatile关键字和锁各有其适用条件。前者更适合于多个线程共享一个状态变量，而后者更适合于多个线程共享一组状态变量。某些情形下，我们可以将多个线程共享的一组状态变量合并成一个对象，用一个volatile变量来引用该对象，从而使我们不必要使用锁。</p>\n</li>\n<li><p><code>原子变量类</code>是基于CAS实现的能够保障对共享变量进行<code>read-modify-write</code>更新操作的原子性和可见性的一组工具类。</p>\n</li>\n<li><p><code>对象发布</code>是指使对象能够被其作用域之外的线程访问。</p>\n</li>\n<li><p>常见的对象发布形式包括：</p>\n<ol>\n<li><p>将对象引用存储到public变量中。</p>\n</li>\n<li><p>在非private方法中返回一个对象。</p>\n</li>\n<li><p>创建内部类，使得当前对象能够被这个内部类使用。</p>\n</li>\n<li><p>通过方法调用将对象传递给外部方法。</p>\n</li>\n</ol>\n</li>\n<li><p><code>static</code>关键字在多线程环境下有其特殊的含义，它能够保证一个线程即使在未使用其他同步机制的情况下也总是可以读取到一个类的静态变量的初始值。</p>\n</li>\n<li><p>对于引用型静态变量，<code>static</code>关键字还能够保障一个线程读取到该变量的初始值时，这个值所指向的对象已经初始化完毕。</p>\n</li>\n<li><p><code>static</code> 关键字仅仅保障读线程能够读取到相应字段的初始值，而不是相对新值。</p>\n</li>\n<li><p>当一个对象被发布到其他线程的时候，该对象的所有<code>final</code>字段都是初始化完毕的。</p>\n</li>\n<li><p>对于引用型<code>final</code>字段，<code>final</code>关键字还进一步确保该字段所引用的对象已经初始化完毕，即这些线程读取该字段所引用的对象的各个字段时所读取到的值都是相应字段的初始值。</p>\n</li>\n<li><p>当一个对象的引用对其他线程可见的时候，这些线程所看到的该对象的final字段必然是初始化完毕的。final关键字的作用仅是这种有序性的保障，它并不能保障包含final字段的对象的引用自身对其他线程的可见性。</p>\n</li>\n<li><p><code>安全发布</code>就是指对象以一种线程安全的方式被发布。</p>\n</li>\n<li><p>当一个对象的发布出现我们不期望的结果或者对象发布本身不是我们所期望的时候，我们就称该对象<code>逸出</code>。</p>\n</li>\n<li><p>对象逸出包括：</p>\n<ol>\n<li><p>在构造函器中将this赋值给一个共享变量。</p>\n</li>\n<li><p>在构造器中将this作为方法参数传递给其他方法。</p>\n</li>\n<li><p>在构造器中启动基于匿名类的线程。</p>\n</li>\n</ol>\n</li>\n<li><p>一个对象在其初始化过程中没有出现this逸出，我们就称该对象为正确创建的对象。</p>\n</li>\n<li><p>实现对象的安全发布，通常可以依照以下顺序选择适用且开销最小的线程同步机制。</p>\n<ol>\n<li><p>使用staic关键字引用该对象的变量。</p>\n</li>\n<li><p>使用final关键字修饰引用该对象的变量。</p>\n</li>\n<li><p>使用volatile关键字修饰引用该对象的变量。</p>\n</li>\n<li><p>使用AtomicReference来引用该对象。</p>\n</li>\n<li><p>对访问该对象的代码进行加锁。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"第四章-牛刀小试：玩转线程\"><a href=\"#第四章-牛刀小试：玩转线程\" class=\"headerlink\" title=\"第四章 牛刀小试：玩转线程\"></a>第四章 牛刀小试：玩转线程</h2><ol>\n<li><p>多线程编程中分而治之的使用主要有两种方式：<strong>基于数据的分割</strong>和<strong>基于任务的分割</strong>。</p>\n</li>\n<li><p>基于数据的分割的结果是产生多个<code>同质工作者线程</code>，即任务处理逻辑相同的线程。需要考虑如下因素：</p>\n<ol>\n<li><p>工作者线程数量的合理设置问题。</p>\n</li>\n<li><p>工作者线程的异常处理问题。</p>\n</li>\n<li><p>原始输入规模未知问题。</p>\n</li>\n<li><p>程序的复杂性增加的问题。</p>\n</li>\n</ol>\n</li>\n<li><p>为了提高任务的执行效率，我们可能使用多个线程去共同完成一个任务的执行。这就是基于任务的分割，其基本思想就是将任务按照一定的规则分解成若干子任务，并使用专门的工作者线程去执行这些子任务，从而实现任务的并发执行。</p>\n</li>\n<li><p>线程所执行的任务按照 其消耗的主要资源可划分为<code>CPU密集型</code>任务和<code>IO密集型</code>任务。</p>\n</li>\n<li><p>CPU密集型任务执行过程中消耗的主要资源是CPU时间，CPU密集型任务的一个典型例子是加密和解密；IO密集型任务执行过程中消耗的主要资源是IO资源，典型的IO密集型任务就包括文件读写、网络读写等。</p>\n</li>\n<li><p>基于任务的分割结果是产生多个相互协作的<code>异质工作者线程</code>。</p>\n</li>\n<li><p><code>Amdahl’s 定律</code>描述了线程数与多线程程序相对于单线程程序的提速之间的关系。<br>$$<br>S_{max} = \\frac{1}{P + \\frac{1 - P}{N}}<br>$$<br>其中，N为处理器数量，程序中必须串行化的部分耗时占程序全部耗时的比率为P。</p>\n</li>\n<li><p>为使多线程程序能够获得较大的提速，我们<strong>应该从算法入手，减少程序中必须串行的部分，而不是寄希望于增加线程数</strong>。</p>\n</li>\n<li><p>线程数设置得过少可能导致无法充分利用处理器资源；而线程数设置得过大则又可能导致过多的上下文切换，从而反倒降低了系统的性能。</p>\n</li>\n<li><p>线程数的合理值可以根据以下规则设置：</p>\n<ol>\n<li><p>对于CPU密集型线程，考虑到这类线程执行任务时消耗的主要是处理器资源，我们可以将这类线程的线程数设置为$N_{cpu} $个。因为CPU密集型线程也可能由于某些原因（比如缺页中断）而被切出，此时为了避免处理器资源的浪费，我们也可以为这类线程设置一个额外的线程，即将线程数设置为$N_{cpu}  + 1$</p>\n</li>\n<li><p>对于IO密集型线程，考虑到IO操作可能导致上下文切换，为这样的线程设置过多的线程会导致过多的额外系统开销。因此如果一个这样的工作者线程就可以满足我们的要求，那么就不要设置更多的线程数。如果一个工作者线程仍然不够用，那么我们可以考虑将这类线程的数量设置为$2 * N_{cpu} $</p>\n</li>\n</ol>\n</li>\n<li><p><strong>挖掘出程序中可并发点</strong>是实现多线程编程的目标——并发计算的前提。</p>\n</li>\n<li><p>实现并发化的策略包括基于数据的分割策略和基于任务的分割策略。</p>\n</li>\n</ol>\n<h2 id=\"第五章-线程间协作\"><a href=\"#第五章-线程间协作\" class=\"headerlink\" title=\"第五章 线程间协作\"></a>第五章 线程间协作</h2><ol>\n<li><p>一个线程因其执行目标动作所需的保护条件未满足而被暂停的过程被称为<code>等待</code>。</p>\n</li>\n<li><p>一个线程更新了系统的状态，使得其他线程所需的保护条件得以满足的时候唤醒那些被暂停的线程的过程就被称为<code>通知</code>。</p>\n</li>\n<li><p>由于一个线程只有在持有一个对象的内部所的情况下才能够调用该对象的wait方法，因此Object.wait()调用总是放在相应对象所引导的临界区之中。</p>\n</li>\n<li><p>等待线程对保护条件的判断、Object.wait()的执行以及目标动作的执行必须放在同一个对象所引导的临界区之中。</p>\n</li>\n<li><p><code>Object.wait()</code>暂停当前线程时释放的锁只是与该wait方法所属对象的内部锁。当前线程所持有的其他内部锁、显示锁并不会因此而被释放。</p>\n</li>\n<li><p><code>Object.notify()</code>的执行线程持有的相应对象的内部锁只有在Object.notify()调用所在的临界区代码执行结束后才会被释放，而Object.notify()本身并不会将这个内部锁释放。因此，为了 使等待线程在其被唤醒之后能够尽快再次获得相应的内部锁，我们要尽可能地将Object.notify()调用放在靠近临界区结束的地方。</p>\n</li>\n<li><p><code>等待线程</code>和<code>通知线程</code>是同步在同一对象之上的两种线程。</p>\n</li>\n<li><p>Java虚拟机会为每个对象维护一个<code>入口集</code>用于存储申请该对象内部锁的线程。Java虚拟机还会为每个对象维护一个被称为<code>等待集</code>的队列，该队列用于存储该对象上的等待线程。Object.wait()将当前线程暂停并释放相应的内部锁的同时会将当前线程存入该方法所属对象的等待集中。</p>\n</li>\n<li><p>wait/notify的开销及问题</p>\n<ol>\n<li><p>过早唤醒问题</p>\n</li>\n<li><p>信号丢失问题</p>\n</li>\n<li><p>欺骗性唤醒问题</p>\n</li>\n<li><p>上下文切换问题</p>\n</li>\n</ol>\n</li>\n<li><p>只有在有证据表明使用<code>Object.notify()</code>足够的情况下才使用<code>Object.notify()</code>，只有在下列条件全部满足的情况下才能够用于替代<code>notifyAll</code>方法：</p>\n<ol>\n<li><p>一次通知仅需要唤醒至多一个线程。</p>\n</li>\n<li><p>相应对象的等待集中仅包含同质等待线程。</p>\n</li>\n</ol>\n</li>\n<li><p><code>join(long)</code>允许我们指定一个超时时间。如果目标线程没有在指定的时间内终止，那么当前线程也会继续运行。<code>join(long)</code>实际上就是使用了<code>wait/notify</code>来实现的。</p>\n</li>\n<li><p>Java虚拟机会在目标线程的run方法运行结束后执行该线程的<code>notifyAll</code>方法来通知所有的等待线程。</p>\n</li>\n<li><p><code>Condition</code>接口可作为<code>wait/notify</code>的替代品来实现等待/通知，它为解决过早唤醒问题提供了支持，并解决了<code>Object.wait(long)</code>不能区分其返回是否是由等待超时而导致的问题。</p>\n</li>\n<li><p><code>Condition.await()/signal()</code>也要求其执行线程持有创建该Condition实例的显示锁。Condition实例也被称为条件变量或者条件队列。每个Condition实例内部都维护了一个用于存储等待线程的队列。</p>\n</li>\n<li><p><code>Condition</code>接口本身只是对解决过早唤醒问题提供了支持。要真正解决过早唤醒问题，我们需要通过应用代码维护保护条件与条件变量的await方法来实现其等待，并使通知线程在更新了相关共享变量之后，仅调用与这些共享变量有关的保护条件所对应的条件变量的<code>signal/signalAll</code>方法来实现通知。</p>\n</li>\n<li><p><code>Condition.awaitUntil(Date deadline)</code>可以用于实现带超时时间限制的等待，并且该方法的返回值能够区分该方法调用是由于等待超时而返回还是由于其他线程执行了相应条件变量的<code>signal/signalAll</code>方法而返回。</p>\n</li>\n<li><p>等待线程因执行<code>Condition.await()/awaitUntil(Date)</code>而被暂停的同时，其持有的相应显示锁也会被释放，等待线程被唤醒之后得以继续运行时需要再次申请相应的显示锁，然后等待线程对<code>Condition.await()/awaitUntil(Date)</code>的调用才能返回。</p>\n</li>\n<li><p><code>CountDownLatch</code>可以用来实现一个线程等待其他线程完成一组特定的操作之后才继续运行。这组操作被称为<code>先决操作</code>。</p>\n</li>\n<li><p><code>CountDownLatch</code>内部计数器值达到0后其值就恒定不变，后续执行该CountDownLatch实例的await方法的任何一个线程都不会被暂停。为了避免等待线程永远被暂停，<code>CountDownLatch.countDown()</code>调用必须放在代码中总是可以被执行到的地方，例如<code>finally</code>块中。</p>\n</li>\n<li><p>使用<code>CyclicBarrier</code>实现等待的线程被称为<code>参与方</code>，参与方只需要执行<code>CyclicBarrier.await()</code>就可以实现等待。</p>\n</li>\n<li><p>最后一个线程执行<code>CyclicBarrier.await()</code>会使得使用相应<code>CyclicBarrier</code>实例的其他所有参与方被唤醒，而最后一个线程自身并不会被暂停。</p>\n</li>\n<li><p>由于<code>CyclicBarrier</code>内部实现是基于条件变量的，因此<code>CyclicBarrier</code>的开销与条件变量的开销相似，其主要开销在可能产生的上下文切换。</p>\n</li>\n<li><p>CyclicBarrier内部使用了一个条件变量trip来实现等待/通知。CyclicBarrier内部实现使用了分代的概念用于表示CyclicBarrier实例是可以重复使用的。</p>\n</li>\n<li><p>最后一个线程相当于通知线程，它执行费CyclicBarrier.await()会使得相应实例的parties值变为0，此时该线程会先执行barrierAction.run()，然后再执行 trip.signalAll()来唤醒所有等待线程。接着，开始下一个分代，即使得CyclicBarrier的parties指又重新恢复为其初始值。</p>\n</li>\n<li><p>CyclicBarrier的典型应用场景包括以下几个:</p>\n<ol>\n<li><p>使得迭代算法并发化。</p>\n</li>\n<li><p>在测试代码中模拟高并发。</p>\n</li>\n</ol>\n</li>\n<li><p>将产品存入传输通道的线程就被称为生产者线程，从传输通道中取出产品进行消费的线程就被称为消费者线程。</p>\n</li>\n<li><p>一个方法或者操作如果能够导致其执行线程被暂停，那么我们就称相应的方法/操作为阻塞方法。阻塞方法能够导致上下文切换。</p>\n</li>\n<li><p>阻塞队列按照其存储空间的容量是否受限制来划分，可分为有界队列和无界队列。有界队列的存储容量限制是由应用程序制定的，无界队列的最大存储容量为Interger.MAX_VALUE($2^{31} - 1$)个元素。</p>\n</li>\n<li><p>ArrayBlockingQueue的缺点是其内部在实现put、take操作的时候使用的是同一个锁，从而可能导致锁的高争用，进而导致较多的上下文切换。</p>\n</li>\n<li><p>LinkedBlockingQueue既能实现无界队列，也能实现有界队列。</p>\n</li>\n<li><p>LinkedBlockingQueue的优点是其内部在实现\bput、take操作的时候分别使用了两个显示锁（putLock和takeLock），这\b降低了锁争用的可能性。LinkedBlockingQueue的内部存储空间是一个链表，而链表节点所需的存储空间是动态分配的，put操作、take操作都会导致链表节点的动态创建和移除，因此LinkedBlockingQueue的缺点是它可能增加垃圾回收的负担。</p>\n</li>\n<li><p>SynchronousQueue可以被看做一种特殊的有界队列。</p>\n</li>\n<li><p>SynchronousQueue适合于在消费者处理能力和生产者处理能力相差不大的情况下使用。</p>\n</li>\n<li>ArrayBlockingQueue和SynchronousQueue都既支持非公平调度也支持公平调度，而LinkedBlockingQueue仅支持非公平调度。</li>\n<li>如果生产者线程和消费者线程之间的并发程度比较大，那么这些线程对传输通道内部所使用的锁的争用可能性也随之增加。这时，有界队列的实现适合选用LinkedBlockingQueue，否则我们可以考虑ArrayBlockingQueue。</li>\n<li>使用无界队列作为传输通道的一个好处是put操作并不会导致生产者线程被阻塞。一般我们在使用无界队列作为传输通道的时候会同时限制生产者的生产速率。</li>\n<li>Semaphore.acquire() 和 Semaphore.release()总是配对使用。</li>\n<li>Semaphore.release()调用总是应该放在一个finally块中。</li>\n<li>创建Semaphore时如果构造函数中的参数permits值为1，那么所创建的Semaphore实例相当于一个互斥锁。与其他互斥锁不同的是，由于一个线程可以在未执行过Semaphore.acquire()的情况下执行Semaphore.release()，因此这种互斥锁允许一个线程释放另一个线程所持有的锁。</li>\n<li>PipedOutputStream和PipedInputStream适合在两个线程间使用，即适用于单生产者-单消费者的情形。</li>\n<li>输出异常的处理。如果生产者线程在其执行过程中出现了不可恢复的异常，那么消费者线程就会永远也无法读取到新的数据。</li>\n<li>当消费者线程消费一个已填充的缓冲区时，另外一个缓冲区可以由生产者线程进行填充，从而实现了数据生成与消费的并发。这种缓冲技术就被称为双缓冲。</li>\n<li>Exchanger.exchange(V)的返回值是对方线程执行该方法时所指定的参数x的值。因此，Exchanger.exchange(V)的返回值就造成一种生产者线程和消费者线程之间交换缓冲区的效果。</li>\n<li>中断可以被看做由一个线程发送给另一个线程的一种指示，该指示用于表示发起线程希望目标线程停止其正在执行的操作。中断仅仅代表发起线程的一个诉求，目标线程可能会满足发起线程的诉求，也可能根本不会理会发起线程的诉求。Java平台会为每个线程维护一个被称为中断标记的布尔型状态变量用于表示相应线程释放接收到了中断。</li>\n<li>目标线程检查中断标记后所执行的操作，被称为目标线程对中断的响应，简称中断响应。</li>\n<li>能够响应中断的方法通常是在执行阻塞操作之前判断中断标志，若中断标志值为true则抛出InterruptedException。</li>\n<li>如果发起线程给目标线程发送中断的那一刻，目标线程已经由于执行了一些阻塞方法操作而被暂停，那么此时Java虚拟机可能会设置目标线程的线程中断标记并将该线程唤醒，从而使目标线程被唤醒后继续执行的代码再次得到相应中断的机会。所以，给目标线程发送中断还能够产生唤醒目标线程的效果。</li>\n<li>在单生产者-单消费者模式中，停止生产者、消费者线程有一种简单的方法：生产者线程在其终止前往传’输通道中存入一个特殊产品作为消费者线程的线程停止标记，消费者线程取出这个产品之后就可以退出run方法而终止了。</li>\n</ol>\n<h2 id=\"第六章-保障线程安全的设计技术\"><a href=\"#第六章-保障线程安全的设计技术\" class=\"headerlink\" title=\"第六章 保障线程安全的设计技术\"></a>第六章 保障线程安全的设计技术</h2>"},{"_content":"","source":"_posts/java/basic/java-data-type.md","raw":"","slug":"java/basic/java-data-type","published":1,"date":"2019-01-02T14:25:23.238Z","updated":"2019-01-02T14:25:23.238Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxze3gqg00360cvwj6qr8zpg","content":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":""},{"_content":"","source":"_posts/java/basic/java-operator.md","raw":"","slug":"java/basic/java-operator","published":1,"date":"2019-01-02T14:25:23.238Z","updated":"2019-01-02T14:25:23.238Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxze3gqg00380cvwwy1ni3bz","content":"<script>\n        document.querySelectorAll('.github-emoji')\n          .forEach(el => {\n            if (!el.dataset.src) { return; }\n            const img = document.createElement('img');\n            img.style = 'display:none !important;';\n            img.src = el.dataset.src;\n            img.addEventListener('error', () => {\n              img.remove();\n              el.style.color = 'inherit';\n              el.style.backgroundImage = 'none';\n              el.style.background = 'none';\n            });\n            img.addEventListener('load', () => {\n              img.remove();\n            });\n            document.body.appendChild(img);\n          });\n      </script>","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":""},{"title":"领域驱动设计实施步骤","date":"2018-12-28T16:01:00.000Z","_content":"\n# 领域驱动设计实施步骤\n\n## 一、画业务流程图\n\n## 二、从业务流程图中抽象出核心业务流程\n","source":"_posts/architecture/domain-driven-design/ddd-steps.md","raw":"---\ntitle: 领域驱动设计实施步骤\ntags: \n - 领域驱动\ncategories: 编程\ndate: 2018-12-29 00:01:00\n---\n\n# 领域驱动设计实施步骤\n\n## 一、画业务流程图\n\n## 二、从业务流程图中抽象出核心业务流程\n","slug":"architecture/domain-driven-design/ddd-steps","published":1,"updated":"2019-06-04T01:29:57.093Z","_id":"cjxze3gt8003c0cvwedynwmt3","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"领域驱动设计实施步骤\"><a href=\"#领域驱动设计实施步骤\" class=\"headerlink\" title=\"领域驱动设计实施步骤\"></a>领域驱动设计实施步骤</h1><h2 id=\"一、画业务流程图\"><a href=\"#一、画业务流程图\" class=\"headerlink\" title=\"一、画业务流程图\"></a>一、画业务流程图</h2><h2 id=\"二、从业务流程图中抽象出核心业务流程\"><a href=\"#二、从业务流程图中抽象出核心业务流程\" class=\"headerlink\" title=\"二、从业务流程图中抽象出核心业务流程\"></a>二、从业务流程图中抽象出核心业务流程</h2>","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h1 id=\"领域驱动设计实施步骤\"><a href=\"#领域驱动设计实施步骤\" class=\"headerlink\" title=\"领域驱动设计实施步骤\"></a>领域驱动设计实施步骤</h1><h2 id=\"一、画业务流程图\"><a href=\"#一、画业务流程图\" class=\"headerlink\" title=\"一、画业务流程图\"></a>一、画业务流程图</h2><h2 id=\"二、从业务流程图中抽象出核心业务流程\"><a href=\"#二、从业务流程图中抽象出核心业务流程\" class=\"headerlink\" title=\"二、从业务流程图中抽象出核心业务流程\"></a>二、从业务流程图中抽象出核心业务流程</h2>"},{"title":"【Java基础篇】启航","date":"2018-12-28T16:01:00.000Z","_content":"\n> 无论最终的结果是什么，只要这是自己选择的道路。 -- 《龙与虎》\n\n## 前言\n\nJava 开发入门篇十分简单，相信聪明的你已经完成了新手村的任务，顺利打败了小Boss，开启这一新的篇章。​\n\n本篇主要内容是介绍Java开发中的基础概念和基本知识，包括Java程序的基本组成，Java中的类与对象，数据类型，变量与常量，运算符，控制流程，接口，封装、继承与多态等等。这些基本要素是组成Java程序必不可少的部分，要想对Java有一个全面的认识，那么就必须认真掌握好这些基本知识。\n\n就像学习高深莫测的武林秘籍之前必须要先学会一些基本的武功招式那样，本篇的重要性不言而喻。为了不让这个过程太过枯燥，本篇将继续完善上一篇中的计算器，以它为基础进行分析，并随着学习的深入，让它的功能变得越来越强大。当然，除了这个计算器之外，还会有很多小栗子伴随其中，以加深大家对这个部分的理解。\n\n之后的每一篇开头，都会引用一句励志的英文来作为鼓励，希望它能给你一些精神力量上的鼓舞。\n\n那么，年轻的勇士，继续你的征程吧！\n","source":"_posts/java/basic/java-basic.md","raw":"---\ntitle: 【Java基础篇】启航\ntags: \n - Java基础\n - Java\ncategories: 编程\ndate: 2018-12-29 00:01:00\n---\n\n> 无论最终的结果是什么，只要这是自己选择的道路。 -- 《龙与虎》\n\n## 前言\n\nJava 开发入门篇十分简单，相信聪明的你已经完成了新手村的任务，顺利打败了小Boss，开启这一新的篇章。​\n\n本篇主要内容是介绍Java开发中的基础概念和基本知识，包括Java程序的基本组成，Java中的类与对象，数据类型，变量与常量，运算符，控制流程，接口，封装、继承与多态等等。这些基本要素是组成Java程序必不可少的部分，要想对Java有一个全面的认识，那么就必须认真掌握好这些基本知识。\n\n就像学习高深莫测的武林秘籍之前必须要先学会一些基本的武功招式那样，本篇的重要性不言而喻。为了不让这个过程太过枯燥，本篇将继续完善上一篇中的计算器，以它为基础进行分析，并随着学习的深入，让它的功能变得越来越强大。当然，除了这个计算器之外，还会有很多小栗子伴随其中，以加深大家对这个部分的理解。\n\n之后的每一篇开头，都会引用一句励志的英文来作为鼓励，希望它能给你一些精神力量上的鼓舞。\n\n那么，年轻的勇士，继续你的征程吧！\n","slug":"java/basic/java-basic","published":1,"updated":"2019-06-04T01:29:57.095Z","_id":"cjxze3gt8003d0cvwb0lqwidg","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>无论最终的结果是什么，只要这是自己选择的道路。 – 《龙与虎》</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Java 开发入门篇十分简单，相信聪明的你已经完成了新手村的任务，顺利打败了小Boss，开启这一新的篇章。​</p>\n<p>本篇主要内容是介绍Java开发中的基础概念和基本知识，包括Java程序的基本组成，Java中的类与对象，数据类型，变量与常量，运算符，控制流程，接口，封装、继承与多态等等。这些基本要素是组成Java程序必不可少的部分，要想对Java有一个全面的认识，那么就必须认真掌握好这些基本知识。</p>\n<p>就像学习高深莫测的武林秘籍之前必须要先学会一些基本的武功招式那样，本篇的重要性不言而喻。为了不让这个过程太过枯燥，本篇将继续完善上一篇中的计算器，以它为基础进行分析，并随着学习的深入，让它的功能变得越来越强大。当然，除了这个计算器之外，还会有很多小栗子伴随其中，以加深大家对这个部分的理解。</p>\n<p>之后的每一篇开头，都会引用一句励志的英文来作为鼓励，希望它能给你一些精神力量上的鼓舞。</p>\n<p>那么，年轻的勇士，继续你的征程吧！</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<blockquote>\n<p>无论最终的结果是什么，只要这是自己选择的道路。 – 《龙与虎》</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Java 开发入门篇十分简单，相信聪明的你已经完成了新手村的任务，顺利打败了小Boss，开启这一新的篇章。​</p>\n<p>本篇主要内容是介绍Java开发中的基础概念和基本知识，包括Java程序的基本组成，Java中的类与对象，数据类型，变量与常量，运算符，控制流程，接口，封装、继承与多态等等。这些基本要素是组成Java程序必不可少的部分，要想对Java有一个全面的认识，那么就必须认真掌握好这些基本知识。</p>\n<p>就像学习高深莫测的武林秘籍之前必须要先学会一些基本的武功招式那样，本篇的重要性不言而喻。为了不让这个过程太过枯燥，本篇将继续完善上一篇中的计算器，以它为基础进行分析，并随着学习的深入，让它的功能变得越来越强大。当然，除了这个计算器之外，还会有很多小栗子伴随其中，以加深大家对这个部分的理解。</p>\n<p>之后的每一篇开头，都会引用一句励志的英文来作为鼓励，希望它能给你一些精神力量上的鼓舞。</p>\n<p>那么，年轻的勇士，继续你的征程吧！</p>\n"},{"title":"初识领域驱动","date":"2018-12-28T16:01:00.000Z","_content":"\n## 背景说明\n\n之前一直有研究领域驱动设计，但都仅限于理论方面，对于如何应用没有很清晰的想法。\n\n本篇将记录在这个过程中查阅DDD相关资料后总结出的心得体会，并记录在实施过程中遇到的问题，最后还会配以一个Web应用的小栗子来加深大家对DDD的理解。\n\n## 关于领域驱动\n\n领域驱动设计（DDD）是一种优秀的系统设计思想，它引入了一种全新的视角来审视软件开发，为复杂多变的系统开发提供了一个可落地的解决方案。\n\n传统的设计方案往往是“面向数据库编程”，使用贫血模型，将对象抽空，实现逻辑全部放在service中，导致service中的逻辑会变得很重，面对需求变更或者调整时的灵活性大打折扣。\n\n领域驱动设计则强调从领域和模型出发，先为整体业务建模，抽象出核心的逻辑，然后再去如何存储和展示。就像作文一样，先写下要表达的中心主题，然后再去围绕主题展开铺垫和设计。\n\n如果你从未接触过相关内容，相信本篇内容能够给你启发，让你获得一个全新的视角，如果能在工作中掌握和应用这种设计方式，那么加班也许就会离你而去了。（手动滑稽）\n\n好了，话不多说，上车吧。\n\n## 参考列表\n\n1、《领域驱动设计》Eric Evans\n\n2、《实现领域驱动设计》 Vaughn Vernon\n\n3、[DDD理论学习系列——案例及目录](https://www.jianshu.com/p/6e2917551e63)\n","source":"_posts/architecture/domain-driven-design/ddd-recommendation.md","raw":"---\ntitle: 初识领域驱动\ntags: \n - 领域驱动\ncategories: 编程\ndate: 2018-12-29 00:01:00\n---\n\n## 背景说明\n\n之前一直有研究领域驱动设计，但都仅限于理论方面，对于如何应用没有很清晰的想法。\n\n本篇将记录在这个过程中查阅DDD相关资料后总结出的心得体会，并记录在实施过程中遇到的问题，最后还会配以一个Web应用的小栗子来加深大家对DDD的理解。\n\n## 关于领域驱动\n\n领域驱动设计（DDD）是一种优秀的系统设计思想，它引入了一种全新的视角来审视软件开发，为复杂多变的系统开发提供了一个可落地的解决方案。\n\n传统的设计方案往往是“面向数据库编程”，使用贫血模型，将对象抽空，实现逻辑全部放在service中，导致service中的逻辑会变得很重，面对需求变更或者调整时的灵活性大打折扣。\n\n领域驱动设计则强调从领域和模型出发，先为整体业务建模，抽象出核心的逻辑，然后再去如何存储和展示。就像作文一样，先写下要表达的中心主题，然后再去围绕主题展开铺垫和设计。\n\n如果你从未接触过相关内容，相信本篇内容能够给你启发，让你获得一个全新的视角，如果能在工作中掌握和应用这种设计方式，那么加班也许就会离你而去了。（手动滑稽）\n\n好了，话不多说，上车吧。\n\n## 参考列表\n\n1、《领域驱动设计》Eric Evans\n\n2、《实现领域驱动设计》 Vaughn Vernon\n\n3、[DDD理论学习系列——案例及目录](https://www.jianshu.com/p/6e2917551e63)\n","slug":"architecture/domain-driven-design/ddd-recommendation","published":1,"updated":"2019-06-04T01:29:57.093Z","_id":"cjxze3gti003f0cvww7vef0nc","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"背景说明\"><a href=\"#背景说明\" class=\"headerlink\" title=\"背景说明\"></a>背景说明</h2><p>之前一直有研究领域驱动设计，但都仅限于理论方面，对于如何应用没有很清晰的想法。</p>\n<p>本篇将记录在这个过程中查阅DDD相关资料后总结出的心得体会，并记录在实施过程中遇到的问题，最后还会配以一个Web应用的小栗子来加深大家对DDD的理解。</p>\n<h2 id=\"关于领域驱动\"><a href=\"#关于领域驱动\" class=\"headerlink\" title=\"关于领域驱动\"></a>关于领域驱动</h2><p>领域驱动设计（DDD）是一种优秀的系统设计思想，它引入了一种全新的视角来审视软件开发，为复杂多变的系统开发提供了一个可落地的解决方案。</p>\n<p>传统的设计方案往往是“面向数据库编程”，使用贫血模型，将对象抽空，实现逻辑全部放在service中，导致service中的逻辑会变得很重，面对需求变更或者调整时的灵活性大打折扣。</p>\n<p>领域驱动设计则强调从领域和模型出发，先为整体业务建模，抽象出核心的逻辑，然后再去如何存储和展示。就像作文一样，先写下要表达的中心主题，然后再去围绕主题展开铺垫和设计。</p>\n<p>如果你从未接触过相关内容，相信本篇内容能够给你启发，让你获得一个全新的视角，如果能在工作中掌握和应用这种设计方式，那么加班也许就会离你而去了。（手动滑稽）</p>\n<p>好了，话不多说，上车吧。</p>\n<h2 id=\"参考列表\"><a href=\"#参考列表\" class=\"headerlink\" title=\"参考列表\"></a>参考列表</h2><p>1、《领域驱动设计》Eric Evans</p>\n<p>2、《实现领域驱动设计》 Vaughn Vernon</p>\n<p>3、<a href=\"https://www.jianshu.com/p/6e2917551e63\" target=\"_blank\" rel=\"noopener\">DDD理论学习系列——案例及目录</a></p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"背景说明\"><a href=\"#背景说明\" class=\"headerlink\" title=\"背景说明\"></a>背景说明</h2><p>之前一直有研究领域驱动设计，但都仅限于理论方面，对于如何应用没有很清晰的想法。</p>\n<p>本篇将记录在这个过程中查阅DDD相关资料后总结出的心得体会，并记录在实施过程中遇到的问题，最后还会配以一个Web应用的小栗子来加深大家对DDD的理解。</p>\n<h2 id=\"关于领域驱动\"><a href=\"#关于领域驱动\" class=\"headerlink\" title=\"关于领域驱动\"></a>关于领域驱动</h2><p>领域驱动设计（DDD）是一种优秀的系统设计思想，它引入了一种全新的视角来审视软件开发，为复杂多变的系统开发提供了一个可落地的解决方案。</p>\n<p>传统的设计方案往往是“面向数据库编程”，使用贫血模型，将对象抽空，实现逻辑全部放在service中，导致service中的逻辑会变得很重，面对需求变更或者调整时的灵活性大打折扣。</p>\n<p>领域驱动设计则强调从领域和模型出发，先为整体业务建模，抽象出核心的逻辑，然后再去如何存储和展示。就像作文一样，先写下要表达的中心主题，然后再去围绕主题展开铺垫和设计。</p>\n<p>如果你从未接触过相关内容，相信本篇内容能够给你启发，让你获得一个全新的视角，如果能在工作中掌握和应用这种设计方式，那么加班也许就会离你而去了。（手动滑稽）</p>\n<p>好了，话不多说，上车吧。</p>\n<h2 id=\"参考列表\"><a href=\"#参考列表\" class=\"headerlink\" title=\"参考列表\"></a>参考列表</h2><p>1、《领域驱动设计》Eric Evans</p>\n<p>2、《实现领域驱动设计》 Vaughn Vernon</p>\n<p>3、<a href=\"https://www.jianshu.com/p/6e2917551e63\" target=\"_blank\" rel=\"noopener\">DDD理论学习系列——案例及目录</a></p>\n"},{"title":"领域驱动设计大纲","date":"2018-12-28T16:01:00.000Z","_content":"\n## 前言\n\n领域驱动设计（Domain-Driven-Design）是一种十分优秀的系统设计思想，本系列将从理论和实战两个方面来对DDD进行介绍，以下是大纲。\n\n1. 什么是领域驱动设计\n2. 面向数据库编程与事务脚本\n3. 应用领域驱动设计有什么好处\n4. 领域驱动设计中的基本概念\n   1. 实体\n   2. 聚合根\n   3. 值对象\n   4. 仓储\n   5. 领域服务\n   6. 领域事件\n   7. 工厂\n5. 领域驱动设计如何落地\n6. MVC与DDD\n7. 六边形架构\n8. 领域驱动设计有什么缺点","source":"_posts/architecture/domain-driven-design/ddd-outline.md","raw":"---\ntitle: 领域驱动设计大纲\ntags: \n - 领域驱动\ncategories: 编程\ndate: 2018-12-29 00:01:00\n---\n\n## 前言\n\n领域驱动设计（Domain-Driven-Design）是一种十分优秀的系统设计思想，本系列将从理论和实战两个方面来对DDD进行介绍，以下是大纲。\n\n1. 什么是领域驱动设计\n2. 面向数据库编程与事务脚本\n3. 应用领域驱动设计有什么好处\n4. 领域驱动设计中的基本概念\n   1. 实体\n   2. 聚合根\n   3. 值对象\n   4. 仓储\n   5. 领域服务\n   6. 领域事件\n   7. 工厂\n5. 领域驱动设计如何落地\n6. MVC与DDD\n7. 六边形架构\n8. 领域驱动设计有什么缺点","slug":"architecture/domain-driven-design/ddd-outline","published":1,"updated":"2019-06-04T01:29:57.093Z","_id":"cjxze3gti003g0cvwmpx266el","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>领域驱动设计（Domain-Driven-Design）是一种十分优秀的系统设计思想，本系列将从理论和实战两个方面来对DDD进行介绍，以下是大纲。</p>\n<ol>\n<li>什么是领域驱动设计</li>\n<li>面向数据库编程与事务脚本</li>\n<li>应用领域驱动设计有什么好处</li>\n<li>领域驱动设计中的基本概念<ol>\n<li>实体</li>\n<li>聚合根</li>\n<li>值对象</li>\n<li>仓储</li>\n<li>领域服务</li>\n<li>领域事件</li>\n<li>工厂</li>\n</ol>\n</li>\n<li>领域驱动设计如何落地</li>\n<li>MVC与DDD</li>\n<li>六边形架构</li>\n<li>领域驱动设计有什么缺点</li>\n</ol>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>领域驱动设计（Domain-Driven-Design）是一种十分优秀的系统设计思想，本系列将从理论和实战两个方面来对DDD进行介绍，以下是大纲。</p>\n<ol>\n<li>什么是领域驱动设计</li>\n<li>面向数据库编程与事务脚本</li>\n<li>应用领域驱动设计有什么好处</li>\n<li>领域驱动设计中的基本概念<ol>\n<li>实体</li>\n<li>聚合根</li>\n<li>值对象</li>\n<li>仓储</li>\n<li>领域服务</li>\n<li>领域事件</li>\n<li>工厂</li>\n</ol>\n</li>\n<li>领域驱动设计如何落地</li>\n<li>MVC与DDD</li>\n<li>六边形架构</li>\n<li>领域驱动设计有什么缺点</li>\n</ol>\n"},{"title":"Java面试每日一题系列","date":"2019-01-02T00:00:00.000Z","_content":"\n## 前言\n\n面试是求职过程中必不可少的环节，但面试中的考题与实际开发中的知识往往相去甚远，所谓`“面试造火箭，开发修螺丝”`，说的就是这么回事，如果不认真准备，仅仅使用平时开发的经验去面试的话，很容易一败涂地。\n\n写这个主题的目的是对当前Java面试中常出现的考点进行总结和分析，以每日一题的形式来进行，不仅会给出面试题的答案，也会做出相应解释，并将相关知识点进行串联，以求对考题有全面的理解。既是给自己的总结，也希望能给需要的人一些帮助。\n\n准备面试就跟准备考试是一样的，所谓**万变不离其宗**，理解基本原理，掌握核心科技才是最重要的，不管考题再如何变化，都能应对自如。很多人准备面试时仅仅是将答案死记硬背，不求理解，所以往往当面试官再深入一点询问或者题型一变就露馅了。\n\n## 大纲\n\nJava面试每日一题系列包含面试的方方面面，从初级、中级到高级面试题都会囊括，涉及到的主题会以标签的形式展示，点击相应标签即可查看所有相关内容。涉及到的知识点也会在解析部分有相应的链接，如果对相应知识点有疑惑的地方，也可以跳转到相应部分进行阅读。\n\n本系列主要分为以下几个篇章：\n\n1. JDK篇\n2. 多线程篇\n3. JVM篇\n4. Spring篇\n5. Dubbo篇\n6. 设计模式篇\n7. 分布式篇\n8. Mysql篇\n9. Redis篇\n10. 算法篇\n\n每天会整理一道面试题并放入其中的一个篇章中，希望整理的内容能对你有所帮助，如果发现内容中有明显错误或者不合理的地方，希望能及时指出，必定会虚心接受。（我写的bug怎么可能有错误.jpg）\n\n那么，废话就不多说了，一起来探索吧！","source":"_posts/java/interview/daily-interview-test.md","raw":"---\ntitle: Java面试每日一题系列\ntags: \n - Java\n - 面试\ncategories: 编程\ndate: 2019-01-02 08:00:00\n---\n\n## 前言\n\n面试是求职过程中必不可少的环节，但面试中的考题与实际开发中的知识往往相去甚远，所谓`“面试造火箭，开发修螺丝”`，说的就是这么回事，如果不认真准备，仅仅使用平时开发的经验去面试的话，很容易一败涂地。\n\n写这个主题的目的是对当前Java面试中常出现的考点进行总结和分析，以每日一题的形式来进行，不仅会给出面试题的答案，也会做出相应解释，并将相关知识点进行串联，以求对考题有全面的理解。既是给自己的总结，也希望能给需要的人一些帮助。\n\n准备面试就跟准备考试是一样的，所谓**万变不离其宗**，理解基本原理，掌握核心科技才是最重要的，不管考题再如何变化，都能应对自如。很多人准备面试时仅仅是将答案死记硬背，不求理解，所以往往当面试官再深入一点询问或者题型一变就露馅了。\n\n## 大纲\n\nJava面试每日一题系列包含面试的方方面面，从初级、中级到高级面试题都会囊括，涉及到的主题会以标签的形式展示，点击相应标签即可查看所有相关内容。涉及到的知识点也会在解析部分有相应的链接，如果对相应知识点有疑惑的地方，也可以跳转到相应部分进行阅读。\n\n本系列主要分为以下几个篇章：\n\n1. JDK篇\n2. 多线程篇\n3. JVM篇\n4. Spring篇\n5. Dubbo篇\n6. 设计模式篇\n7. 分布式篇\n8. Mysql篇\n9. Redis篇\n10. 算法篇\n\n每天会整理一道面试题并放入其中的一个篇章中，希望整理的内容能对你有所帮助，如果发现内容中有明显错误或者不合理的地方，希望能及时指出，必定会虚心接受。（我写的bug怎么可能有错误.jpg）\n\n那么，废话就不多说了，一起来探索吧！","slug":"java/interview/daily-interview-test","published":1,"updated":"2019-06-04T01:29:57.099Z","_id":"cjxze3gti003i0cvw5iyp6f9l","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>面试是求职过程中必不可少的环节，但面试中的考题与实际开发中的知识往往相去甚远，所谓<code>“面试造火箭，开发修螺丝”</code>，说的就是这么回事，如果不认真准备，仅仅使用平时开发的经验去面试的话，很容易一败涂地。</p>\n<p>写这个主题的目的是对当前Java面试中常出现的考点进行总结和分析，以每日一题的形式来进行，不仅会给出面试题的答案，也会做出相应解释，并将相关知识点进行串联，以求对考题有全面的理解。既是给自己的总结，也希望能给需要的人一些帮助。</p>\n<p>准备面试就跟准备考试是一样的，所谓<strong>万变不离其宗</strong>，理解基本原理，掌握核心科技才是最重要的，不管考题再如何变化，都能应对自如。很多人准备面试时仅仅是将答案死记硬背，不求理解，所以往往当面试官再深入一点询问或者题型一变就露馅了。</p>\n<h2 id=\"大纲\"><a href=\"#大纲\" class=\"headerlink\" title=\"大纲\"></a>大纲</h2><p>Java面试每日一题系列包含面试的方方面面，从初级、中级到高级面试题都会囊括，涉及到的主题会以标签的形式展示，点击相应标签即可查看所有相关内容。涉及到的知识点也会在解析部分有相应的链接，如果对相应知识点有疑惑的地方，也可以跳转到相应部分进行阅读。</p>\n<p>本系列主要分为以下几个篇章：</p>\n<ol>\n<li>JDK篇</li>\n<li>多线程篇</li>\n<li>JVM篇</li>\n<li>Spring篇</li>\n<li>Dubbo篇</li>\n<li>设计模式篇</li>\n<li>分布式篇</li>\n<li>Mysql篇</li>\n<li>Redis篇</li>\n<li>算法篇</li>\n</ol>\n<p>每天会整理一道面试题并放入其中的一个篇章中，希望整理的内容能对你有所帮助，如果发现内容中有明显错误或者不合理的地方，希望能及时指出，必定会虚心接受。（我写的bug怎么可能有错误.jpg）</p>\n<p>那么，废话就不多说了，一起来探索吧！</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>面试是求职过程中必不可少的环节，但面试中的考题与实际开发中的知识往往相去甚远，所谓<code>“面试造火箭，开发修螺丝”</code>，说的就是这么回事，如果不认真准备，仅仅使用平时开发的经验去面试的话，很容易一败涂地。</p>\n<p>写这个主题的目的是对当前Java面试中常出现的考点进行总结和分析，以每日一题的形式来进行，不仅会给出面试题的答案，也会做出相应解释，并将相关知识点进行串联，以求对考题有全面的理解。既是给自己的总结，也希望能给需要的人一些帮助。</p>\n<p>准备面试就跟准备考试是一样的，所谓<strong>万变不离其宗</strong>，理解基本原理，掌握核心科技才是最重要的，不管考题再如何变化，都能应对自如。很多人准备面试时仅仅是将答案死记硬背，不求理解，所以往往当面试官再深入一点询问或者题型一变就露馅了。</p>\n<h2 id=\"大纲\"><a href=\"#大纲\" class=\"headerlink\" title=\"大纲\"></a>大纲</h2><p>Java面试每日一题系列包含面试的方方面面，从初级、中级到高级面试题都会囊括，涉及到的主题会以标签的形式展示，点击相应标签即可查看所有相关内容。涉及到的知识点也会在解析部分有相应的链接，如果对相应知识点有疑惑的地方，也可以跳转到相应部分进行阅读。</p>\n<p>本系列主要分为以下几个篇章：</p>\n<ol>\n<li>JDK篇</li>\n<li>多线程篇</li>\n<li>JVM篇</li>\n<li>Spring篇</li>\n<li>Dubbo篇</li>\n<li>设计模式篇</li>\n<li>分布式篇</li>\n<li>Mysql篇</li>\n<li>Redis篇</li>\n<li>算法篇</li>\n</ol>\n<p>每天会整理一道面试题并放入其中的一个篇章中，希望整理的内容能对你有所帮助，如果发现内容中有明显错误或者不合理的地方，希望能及时指出，必定会虚心接受。（我写的bug怎么可能有错误.jpg）</p>\n<p>那么，废话就不多说了，一起来探索吧！</p>\n"},{"title":"【Java基础篇】四、Java package与import","date":"2018-12-28T16:03:00.000Z","_content":"\n> 共道人间惆怅事，不知今夕是何年。  -- 《周秦行纪》\n\n## 关卡说明\n\n关卡描述：不知你是否还记得上一篇中的代码，前面的两行，这是在Java中特定的格式，想要知道它们是什么含义吗？通过本关你就能获得答案。\n\n过关条件：理解Java中package与import的作用以及如何使用它们\n\n关卡难度：⭐️\n\n## 什么是package\n\n现在再来回顾一下我们上一篇中的代码，首先我们创建了一个类，叫做SimpleCalculator，文件名叫做SimpleCalculator.java。\n\n在最开头有这么一行：\n\n```java\npackage hello;\n```\n\n第一行会声明这个类所在的包名，因为这个类文件是在hello包下的，所以第一行的含义就是表明这个类的位置。\n\n## 为什么要使用package\n\n聪明的你也许会想到，同一个包下面应该不允许存在两个相同的文件名，也就是不允许存在相同的类名。确实如此，这也是package的一个很重要的作用，为类提供一个类似命名空间的管理，避免同名的类产生冲突。\n\n试想一下，如果没有package，所有类都在同一个地方，那就要争先恐后的使用类名了。\n\npackage的另一个作用便是用来将Java文件进行分类管理，比如有同一种用处的类放到同一个包下，方便查找和管理。\n\n## package命名规范\n\n虽然理论上来说，你可以随心所欲、为所欲为的命名你项目中的包，但还是建议你遵循一定的规范，因为如果大家都遵循规范来设计的话，会减少很多交流成本。\n\npackage的命名一般分为几个部分，`身份标识.开发者名/团队名/公司名.项目名.模块名`，对于身份标识，主要是用来标识是个人开发还是团队开发，个人开发主要使用的标识有：indi（个体项目）、onem（单人项目）、pers（个人项目）、priv（私有项目），团队开发主要使用的标识有：team（团队项目）、com（公司项目）。\n\n但其实没有特殊要求的话，使用域名倒写是最常见的，因为域名是不会重复的。\n\n所以比较常见的命名类似于：com.frank.hello.controller，frank是我的英文名，（假装）frank.com是我的域名，hello是项目名，controller则代表这个包下面我会放控制器。（先不用纠结控制器是什么）\n\n所以，如果还没有英文名的话，赶紧给自己找一个吧。你也许会问，如果有人用了跟自己一样的英文名怎么办？\n\n没有关系，反正极大概率上来说，你又不会使用他的包，即使真遇上了，还是有解决办法的，改改项目名，改改包名，不就ok了。\n\n## 使用package的注意事项\n\n1. package必须是程序中可执行的第一行代码\n2. package语句只能有一句，且语句后面有分号\n3. package命名要求包含的所有字符均为小写，同时不能有特殊字符\n4. package可以有多层，每一层有`.`隔开，例如：`package com.frank.hello;`（com是一个文件夹，frank是com下的一个文件夹，hello是frank文件夹下的一个文件夹）\n5. 包的路径符合所开发的系统模块的定义\n6. 如果定义类的时候没有使用package,那么java就认为我们所定义的类位于默认包里面(java.lang)。\n\n## import的作用\n\n在之前的`SimpleCalculator`类中，我们还看到了这么一句代码：\n\n```java\nimport java.util.Scanner;\n```\n\n那么import又是做什么用的呢？\n\nimport是在java文件开头的地方，先说明会用到那些类所在的全路径名，这样我们就能在代码中使用对应的类名，而不是使用全路径。\n\n开发中需要引用到其他包下的类，比如JDK中一些常用的类，那么就需要先使用import告诉编译器我们要引用的类的位置，比如说这里的Scanner。那么你也许会注意到，代码中不是有System吗，是怎么回事呢？为什么不用引入System所在的包呢？\n\n这是一个很好的问题。原因是java.lang这个包实在是太常用了，所以默认可以不用写，编译器会自动引入，编译器只要看到没有使用import引入包名的类，就会去java.lang中找。\n\n那如果要引入一个包下所有类该怎么办呢？\n\n有时候需要用到的类刚好有有多在同一个包下面，一个一个引入，显然太费事，别着急，还有更好的解决办法，可以使用`*`来匹配所有，比如说：\n\n```java\nimport java.util.*\n```\n\n那么就会引入`java.util`包下的所有类。\n\n也许你会觉得，那都使用`*`的方式不就好了。如果这样想，那就大错特错了，包的存在就是为了减少类名冲突，这样每次都使用`*`将大量类引入的话，会更容易产生类名冲突，那就适得其反了。\n\n# 小结\n\n本篇讲解了package和import的用途，希望通过本篇，你能知道代码中前面的那些代码有什么作用，也能在之后的代码编写中知道如何去正确使用它们。","source":"_posts/java/basic/java-package.md","raw":"---\ntitle: 【Java基础篇】四、Java package与import\ntags: \n - Java基础\n - Java\ncategories: 编程\ndate: 2018-12-29 00:03:00\n---\n\n> 共道人间惆怅事，不知今夕是何年。  -- 《周秦行纪》\n\n## 关卡说明\n\n关卡描述：不知你是否还记得上一篇中的代码，前面的两行，这是在Java中特定的格式，想要知道它们是什么含义吗？通过本关你就能获得答案。\n\n过关条件：理解Java中package与import的作用以及如何使用它们\n\n关卡难度：⭐️\n\n## 什么是package\n\n现在再来回顾一下我们上一篇中的代码，首先我们创建了一个类，叫做SimpleCalculator，文件名叫做SimpleCalculator.java。\n\n在最开头有这么一行：\n\n```java\npackage hello;\n```\n\n第一行会声明这个类所在的包名，因为这个类文件是在hello包下的，所以第一行的含义就是表明这个类的位置。\n\n## 为什么要使用package\n\n聪明的你也许会想到，同一个包下面应该不允许存在两个相同的文件名，也就是不允许存在相同的类名。确实如此，这也是package的一个很重要的作用，为类提供一个类似命名空间的管理，避免同名的类产生冲突。\n\n试想一下，如果没有package，所有类都在同一个地方，那就要争先恐后的使用类名了。\n\npackage的另一个作用便是用来将Java文件进行分类管理，比如有同一种用处的类放到同一个包下，方便查找和管理。\n\n## package命名规范\n\n虽然理论上来说，你可以随心所欲、为所欲为的命名你项目中的包，但还是建议你遵循一定的规范，因为如果大家都遵循规范来设计的话，会减少很多交流成本。\n\npackage的命名一般分为几个部分，`身份标识.开发者名/团队名/公司名.项目名.模块名`，对于身份标识，主要是用来标识是个人开发还是团队开发，个人开发主要使用的标识有：indi（个体项目）、onem（单人项目）、pers（个人项目）、priv（私有项目），团队开发主要使用的标识有：team（团队项目）、com（公司项目）。\n\n但其实没有特殊要求的话，使用域名倒写是最常见的，因为域名是不会重复的。\n\n所以比较常见的命名类似于：com.frank.hello.controller，frank是我的英文名，（假装）frank.com是我的域名，hello是项目名，controller则代表这个包下面我会放控制器。（先不用纠结控制器是什么）\n\n所以，如果还没有英文名的话，赶紧给自己找一个吧。你也许会问，如果有人用了跟自己一样的英文名怎么办？\n\n没有关系，反正极大概率上来说，你又不会使用他的包，即使真遇上了，还是有解决办法的，改改项目名，改改包名，不就ok了。\n\n## 使用package的注意事项\n\n1. package必须是程序中可执行的第一行代码\n2. package语句只能有一句，且语句后面有分号\n3. package命名要求包含的所有字符均为小写，同时不能有特殊字符\n4. package可以有多层，每一层有`.`隔开，例如：`package com.frank.hello;`（com是一个文件夹，frank是com下的一个文件夹，hello是frank文件夹下的一个文件夹）\n5. 包的路径符合所开发的系统模块的定义\n6. 如果定义类的时候没有使用package,那么java就认为我们所定义的类位于默认包里面(java.lang)。\n\n## import的作用\n\n在之前的`SimpleCalculator`类中，我们还看到了这么一句代码：\n\n```java\nimport java.util.Scanner;\n```\n\n那么import又是做什么用的呢？\n\nimport是在java文件开头的地方，先说明会用到那些类所在的全路径名，这样我们就能在代码中使用对应的类名，而不是使用全路径。\n\n开发中需要引用到其他包下的类，比如JDK中一些常用的类，那么就需要先使用import告诉编译器我们要引用的类的位置，比如说这里的Scanner。那么你也许会注意到，代码中不是有System吗，是怎么回事呢？为什么不用引入System所在的包呢？\n\n这是一个很好的问题。原因是java.lang这个包实在是太常用了，所以默认可以不用写，编译器会自动引入，编译器只要看到没有使用import引入包名的类，就会去java.lang中找。\n\n那如果要引入一个包下所有类该怎么办呢？\n\n有时候需要用到的类刚好有有多在同一个包下面，一个一个引入，显然太费事，别着急，还有更好的解决办法，可以使用`*`来匹配所有，比如说：\n\n```java\nimport java.util.*\n```\n\n那么就会引入`java.util`包下的所有类。\n\n也许你会觉得，那都使用`*`的方式不就好了。如果这样想，那就大错特错了，包的存在就是为了减少类名冲突，这样每次都使用`*`将大量类引入的话，会更容易产生类名冲突，那就适得其反了。\n\n# 小结\n\n本篇讲解了package和import的用途，希望通过本篇，你能知道代码中前面的那些代码有什么作用，也能在之后的代码编写中知道如何去正确使用它们。","slug":"java/basic/java-package","published":1,"updated":"2019-06-04T01:29:57.096Z","_id":"cjxze3gti003m0cvwyjtapemc","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>共道人间惆怅事，不知今夕是何年。  – 《周秦行纪》</p>\n</blockquote>\n<h2 id=\"关卡说明\"><a href=\"#关卡说明\" class=\"headerlink\" title=\"关卡说明\"></a>关卡说明</h2><p>关卡描述：不知你是否还记得上一篇中的代码，前面的两行，这是在Java中特定的格式，想要知道它们是什么含义吗？通过本关你就能获得答案。</p>\n<p>过关条件：理解Java中package与import的作用以及如何使用它们</p>\n<p>关卡难度：⭐️</p>\n<h2 id=\"什么是package\"><a href=\"#什么是package\" class=\"headerlink\" title=\"什么是package\"></a>什么是package</h2><p>现在再来回顾一下我们上一篇中的代码，首先我们创建了一个类，叫做SimpleCalculator，文件名叫做SimpleCalculator.java。</p>\n<p>在最开头有这么一行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> hello;</span><br></pre></td></tr></table></figure>\n<p>第一行会声明这个类所在的包名，因为这个类文件是在hello包下的，所以第一行的含义就是表明这个类的位置。</p>\n<h2 id=\"为什么要使用package\"><a href=\"#为什么要使用package\" class=\"headerlink\" title=\"为什么要使用package\"></a>为什么要使用package</h2><p>聪明的你也许会想到，同一个包下面应该不允许存在两个相同的文件名，也就是不允许存在相同的类名。确实如此，这也是package的一个很重要的作用，为类提供一个类似命名空间的管理，避免同名的类产生冲突。</p>\n<p>试想一下，如果没有package，所有类都在同一个地方，那就要争先恐后的使用类名了。</p>\n<p>package的另一个作用便是用来将Java文件进行分类管理，比如有同一种用处的类放到同一个包下，方便查找和管理。</p>\n<h2 id=\"package命名规范\"><a href=\"#package命名规范\" class=\"headerlink\" title=\"package命名规范\"></a>package命名规范</h2><p>虽然理论上来说，你可以随心所欲、为所欲为的命名你项目中的包，但还是建议你遵循一定的规范，因为如果大家都遵循规范来设计的话，会减少很多交流成本。</p>\n<p>package的命名一般分为几个部分，<code>身份标识.开发者名/团队名/公司名.项目名.模块名</code>，对于身份标识，主要是用来标识是个人开发还是团队开发，个人开发主要使用的标识有：indi（个体项目）、onem（单人项目）、pers（个人项目）、priv（私有项目），团队开发主要使用的标识有：team（团队项目）、com（公司项目）。</p>\n<p>但其实没有特殊要求的话，使用域名倒写是最常见的，因为域名是不会重复的。</p>\n<p>所以比较常见的命名类似于：com.frank.hello.controller，frank是我的英文名，（假装）frank.com是我的域名，hello是项目名，controller则代表这个包下面我会放控制器。（先不用纠结控制器是什么）</p>\n<p>所以，如果还没有英文名的话，赶紧给自己找一个吧。你也许会问，如果有人用了跟自己一样的英文名怎么办？</p>\n<p>没有关系，反正极大概率上来说，你又不会使用他的包，即使真遇上了，还是有解决办法的，改改项目名，改改包名，不就ok了。</p>\n<h2 id=\"使用package的注意事项\"><a href=\"#使用package的注意事项\" class=\"headerlink\" title=\"使用package的注意事项\"></a>使用package的注意事项</h2><ol>\n<li>package必须是程序中可执行的第一行代码</li>\n<li>package语句只能有一句，且语句后面有分号</li>\n<li>package命名要求包含的所有字符均为小写，同时不能有特殊字符</li>\n<li>package可以有多层，每一层有<code>.</code>隔开，例如：<code>package com.frank.hello;</code>（com是一个文件夹，frank是com下的一个文件夹，hello是frank文件夹下的一个文件夹）</li>\n<li>包的路径符合所开发的系统模块的定义</li>\n<li>如果定义类的时候没有使用package,那么java就认为我们所定义的类位于默认包里面(java.lang)。</li>\n</ol>\n<h2 id=\"import的作用\"><a href=\"#import的作用\" class=\"headerlink\" title=\"import的作用\"></a>import的作用</h2><p>在之前的<code>SimpleCalculator</code>类中，我们还看到了这么一句代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br></pre></td></tr></table></figure>\n<p>那么import又是做什么用的呢？</p>\n<p>import是在java文件开头的地方，先说明会用到那些类所在的全路径名，这样我们就能在代码中使用对应的类名，而不是使用全路径。</p>\n<p>开发中需要引用到其他包下的类，比如JDK中一些常用的类，那么就需要先使用import告诉编译器我们要引用的类的位置，比如说这里的Scanner。那么你也许会注意到，代码中不是有System吗，是怎么回事呢？为什么不用引入System所在的包呢？</p>\n<p>这是一个很好的问题。原因是java.lang这个包实在是太常用了，所以默认可以不用写，编译器会自动引入，编译器只要看到没有使用import引入包名的类，就会去java.lang中找。</p>\n<p>那如果要引入一个包下所有类该怎么办呢？</p>\n<p>有时候需要用到的类刚好有有多在同一个包下面，一个一个引入，显然太费事，别着急，还有更好的解决办法，可以使用<code>*</code>来匹配所有，比如说：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*</span><br></pre></td></tr></table></figure>\n<p>那么就会引入<code>java.util</code>包下的所有类。</p>\n<p>也许你会觉得，那都使用<code>*</code>的方式不就好了。如果这样想，那就大错特错了，包的存在就是为了减少类名冲突，这样每次都使用<code>*</code>将大量类引入的话，会更容易产生类名冲突，那就适得其反了。</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>本篇讲解了package和import的用途，希望通过本篇，你能知道代码中前面的那些代码有什么作用，也能在之后的代码编写中知道如何去正确使用它们。</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<blockquote>\n<p>共道人间惆怅事，不知今夕是何年。  – 《周秦行纪》</p>\n</blockquote>\n<h2 id=\"关卡说明\"><a href=\"#关卡说明\" class=\"headerlink\" title=\"关卡说明\"></a>关卡说明</h2><p>关卡描述：不知你是否还记得上一篇中的代码，前面的两行，这是在Java中特定的格式，想要知道它们是什么含义吗？通过本关你就能获得答案。</p>\n<p>过关条件：理解Java中package与import的作用以及如何使用它们</p>\n<p>关卡难度：⭐️</p>\n<h2 id=\"什么是package\"><a href=\"#什么是package\" class=\"headerlink\" title=\"什么是package\"></a>什么是package</h2><p>现在再来回顾一下我们上一篇中的代码，首先我们创建了一个类，叫做SimpleCalculator，文件名叫做SimpleCalculator.java。</p>\n<p>在最开头有这么一行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> hello;</span><br></pre></td></tr></table></figure>\n<p>第一行会声明这个类所在的包名，因为这个类文件是在hello包下的，所以第一行的含义就是表明这个类的位置。</p>\n<h2 id=\"为什么要使用package\"><a href=\"#为什么要使用package\" class=\"headerlink\" title=\"为什么要使用package\"></a>为什么要使用package</h2><p>聪明的你也许会想到，同一个包下面应该不允许存在两个相同的文件名，也就是不允许存在相同的类名。确实如此，这也是package的一个很重要的作用，为类提供一个类似命名空间的管理，避免同名的类产生冲突。</p>\n<p>试想一下，如果没有package，所有类都在同一个地方，那就要争先恐后的使用类名了。</p>\n<p>package的另一个作用便是用来将Java文件进行分类管理，比如有同一种用处的类放到同一个包下，方便查找和管理。</p>\n<h2 id=\"package命名规范\"><a href=\"#package命名规范\" class=\"headerlink\" title=\"package命名规范\"></a>package命名规范</h2><p>虽然理论上来说，你可以随心所欲、为所欲为的命名你项目中的包，但还是建议你遵循一定的规范，因为如果大家都遵循规范来设计的话，会减少很多交流成本。</p>\n<p>package的命名一般分为几个部分，<code>身份标识.开发者名/团队名/公司名.项目名.模块名</code>，对于身份标识，主要是用来标识是个人开发还是团队开发，个人开发主要使用的标识有：indi（个体项目）、onem（单人项目）、pers（个人项目）、priv（私有项目），团队开发主要使用的标识有：team（团队项目）、com（公司项目）。</p>\n<p>但其实没有特殊要求的话，使用域名倒写是最常见的，因为域名是不会重复的。</p>\n<p>所以比较常见的命名类似于：com.frank.hello.controller，frank是我的英文名，（假装）frank.com是我的域名，hello是项目名，controller则代表这个包下面我会放控制器。（先不用纠结控制器是什么）</p>\n<p>所以，如果还没有英文名的话，赶紧给自己找一个吧。你也许会问，如果有人用了跟自己一样的英文名怎么办？</p>\n<p>没有关系，反正极大概率上来说，你又不会使用他的包，即使真遇上了，还是有解决办法的，改改项目名，改改包名，不就ok了。</p>\n<h2 id=\"使用package的注意事项\"><a href=\"#使用package的注意事项\" class=\"headerlink\" title=\"使用package的注意事项\"></a>使用package的注意事项</h2><ol>\n<li>package必须是程序中可执行的第一行代码</li>\n<li>package语句只能有一句，且语句后面有分号</li>\n<li>package命名要求包含的所有字符均为小写，同时不能有特殊字符</li>\n<li>package可以有多层，每一层有<code>.</code>隔开，例如：<code>package com.frank.hello;</code>（com是一个文件夹，frank是com下的一个文件夹，hello是frank文件夹下的一个文件夹）</li>\n<li>包的路径符合所开发的系统模块的定义</li>\n<li>如果定义类的时候没有使用package,那么java就认为我们所定义的类位于默认包里面(java.lang)。</li>\n</ol>\n<h2 id=\"import的作用\"><a href=\"#import的作用\" class=\"headerlink\" title=\"import的作用\"></a>import的作用</h2><p>在之前的<code>SimpleCalculator</code>类中，我们还看到了这么一句代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br></pre></td></tr></table></figure>\n<p>那么import又是做什么用的呢？</p>\n<p>import是在java文件开头的地方，先说明会用到那些类所在的全路径名，这样我们就能在代码中使用对应的类名，而不是使用全路径。</p>\n<p>开发中需要引用到其他包下的类，比如JDK中一些常用的类，那么就需要先使用import告诉编译器我们要引用的类的位置，比如说这里的Scanner。那么你也许会注意到，代码中不是有System吗，是怎么回事呢？为什么不用引入System所在的包呢？</p>\n<p>这是一个很好的问题。原因是java.lang这个包实在是太常用了，所以默认可以不用写，编译器会自动引入，编译器只要看到没有使用import引入包名的类，就会去java.lang中找。</p>\n<p>那如果要引入一个包下所有类该怎么办呢？</p>\n<p>有时候需要用到的类刚好有有多在同一个包下面，一个一个引入，显然太费事，别着急，还有更好的解决办法，可以使用<code>*</code>来匹配所有，比如说：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*</span><br></pre></td></tr></table></figure>\n<p>那么就会引入<code>java.util</code>包下的所有类。</p>\n<p>也许你会觉得，那都使用<code>*</code>的方式不就好了。如果这样想，那就大错特错了，包的存在就是为了减少类名冲突，这样每次都使用<code>*</code>将大量类引入的话，会更容易产生类名冲突，那就适得其反了。</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>本篇讲解了package和import的用途，希望通过本篇，你能知道代码中前面的那些代码有什么作用，也能在之后的代码编写中知道如何去正确使用它们。</p>\n"},{"title":"【Java基础篇】一、Java 程序基本结构","date":"2018-12-28T16:02:00.000Z","_content":"\n>“No matter how small and unimportant what we are doing may seem, if we do it well, it may soon become the step that will lead us to better things.”\t\t\t\t— Channing Pollock, Writer\n>\n>「不管我们现在所做的事看起来有么的微不足道或不重要，如果我们认真的做，它可能很快就会成为通往美好事物的踏石阶。」\t\t\t\t\t\t\t\t– 詹宁‧布鲁克 (作家)\n\n## 关卡说明\n\n关卡描述：Java程序具有一些固定的形式，本篇将来对此进行简单的说明介绍。\n\n过关条件：理解Java程序的基本组成结构\n\n关卡难度：⭐️\n\n## 一个简单的程序\n\n为了简单起见，本篇以及之后的很多篇里，都会设计很多“玩具”代码，与实际中Java的设计可能相去甚远，本系列中的代示例都是为了说明一些相关概念，让你能够更好的理解Java的相关特性。\n\n下面再来看看上一篇中的栗子：\n\n```java\npackage hello;\n\nimport java.util.Scanner;\n\npublic class SimpleCalculator {\n    public static void main(String[] args){\n        System.out.print(\"请输入一个整数:\");\n        Scanner in = new Scanner(System.in);\n        int a = in.nextInt();\n        System.out.print(\"请再输入一个整数:\");\n        int b = in.nextInt();\n        int sum = a + b;\n        System.out.print(\"这两个数的和为:\" + sum);\n    }\n}\n```\n\n这是一个非常简单的能够运行的Java程序，它有一些基本的结构，下面将对其一一介绍。\n\n前面两句的作用已经在[上一篇](../introduction/java-package.md)中进行说明了，这里就不赘述了。接下来是类的定义：\n\n```java\npublic class SimpleCalculator {\n    ...\n}\n```\n\n这里是定义了一个叫做`SimpleCalculator`的类，`public` 称为*访问修饰符*，用于控制代码的访问级别，关于这部分的内容，会在之后的章节中进行详细的介绍。在这里，`public` 表示这个类的访问权限为任何外部类均可以访问。`class` 是定义一个类的关键字，它的后面是类。关于类的命名规范在之后也会有详细说明。不要忘了后面还有一对大括号，表示类的内部内容。\n\n需要注意的是，**Java是区分大小写的**，如果出现了大小写拼写错误，程序是无法正确运行的。\n\n```java\npublic static void main(String[] args){\n    ...\n}\n```\n\n在类的内部定义了一个main方法，为什么说它是一个方法而不是类呢？因为它位于一个类的内部，并且没有用class关键字修饰，而且符合方法的定义规范。`public`同样可以修饰方法，表示这个方法对于外部类是公开的，可以访问的，`static`表示这是一个静态方法（先不要纠结什么是静态方法），`void`表示这个方法的返回值类型，`main`为方法名，后面跟上一对小括号，里面是参数列表，这里为`String[] args`，表示它接受一个String数组作为参数，`args`为参数名。\n\n也许上面还有许多概念你还不清楚是什么意思，不要着急，先不要纠结于这些细节，先从整体上把握，继续看下去，后面的文章中会有说明。\n\n需要注意的是，`main`方法是java程序中一个十分特殊的方法，它是整个程序的入口，也就是说，程序会从`main`方法开始执行，因此，如果想要代码能够执行，在类的源文件中必须包含一个`main`方法。\n\n方法中的方法体则是我们为了实现功能而设计的自定义代码，在Java中，每个句子必须用分号结束。\n\n```java\nSystem.out.print(\"请输入一个整数:\");\nScanner in = new Scanner(System.in);\nint a = in.nextInt();\nSystem.out.print(\"请再输入一个整数:\");\nint b = in.nextInt();\nint sum = a + b;\nSystem.out.print(\"这两个数的和为:\" + sum);\n```\n\nJava中，点号是用来调用方法或者使用对象的，如：`System.out.print(...)`表示使用`System.out`对象并调用它的`print`方法。\n\n# 小结\n\n至此，本篇的Java的基本结构就介绍完毕了，希望通过本篇，你能知道一个简单Java程序的结构是怎样的以及main方法有什么作用。\n","source":"_posts/java/basic/java-simple-structure.md","raw":"---\ntitle: 【Java基础篇】一、Java 程序基本结构\ntags: \n - Java基础\n - Java\ncategories: 编程\ndate: 2018-12-29 00:02:00\n---\n\n>“No matter how small and unimportant what we are doing may seem, if we do it well, it may soon become the step that will lead us to better things.”\t\t\t\t— Channing Pollock, Writer\n>\n>「不管我们现在所做的事看起来有么的微不足道或不重要，如果我们认真的做，它可能很快就会成为通往美好事物的踏石阶。」\t\t\t\t\t\t\t\t– 詹宁‧布鲁克 (作家)\n\n## 关卡说明\n\n关卡描述：Java程序具有一些固定的形式，本篇将来对此进行简单的说明介绍。\n\n过关条件：理解Java程序的基本组成结构\n\n关卡难度：⭐️\n\n## 一个简单的程序\n\n为了简单起见，本篇以及之后的很多篇里，都会设计很多“玩具”代码，与实际中Java的设计可能相去甚远，本系列中的代示例都是为了说明一些相关概念，让你能够更好的理解Java的相关特性。\n\n下面再来看看上一篇中的栗子：\n\n```java\npackage hello;\n\nimport java.util.Scanner;\n\npublic class SimpleCalculator {\n    public static void main(String[] args){\n        System.out.print(\"请输入一个整数:\");\n        Scanner in = new Scanner(System.in);\n        int a = in.nextInt();\n        System.out.print(\"请再输入一个整数:\");\n        int b = in.nextInt();\n        int sum = a + b;\n        System.out.print(\"这两个数的和为:\" + sum);\n    }\n}\n```\n\n这是一个非常简单的能够运行的Java程序，它有一些基本的结构，下面将对其一一介绍。\n\n前面两句的作用已经在[上一篇](../introduction/java-package.md)中进行说明了，这里就不赘述了。接下来是类的定义：\n\n```java\npublic class SimpleCalculator {\n    ...\n}\n```\n\n这里是定义了一个叫做`SimpleCalculator`的类，`public` 称为*访问修饰符*，用于控制代码的访问级别，关于这部分的内容，会在之后的章节中进行详细的介绍。在这里，`public` 表示这个类的访问权限为任何外部类均可以访问。`class` 是定义一个类的关键字，它的后面是类。关于类的命名规范在之后也会有详细说明。不要忘了后面还有一对大括号，表示类的内部内容。\n\n需要注意的是，**Java是区分大小写的**，如果出现了大小写拼写错误，程序是无法正确运行的。\n\n```java\npublic static void main(String[] args){\n    ...\n}\n```\n\n在类的内部定义了一个main方法，为什么说它是一个方法而不是类呢？因为它位于一个类的内部，并且没有用class关键字修饰，而且符合方法的定义规范。`public`同样可以修饰方法，表示这个方法对于外部类是公开的，可以访问的，`static`表示这是一个静态方法（先不要纠结什么是静态方法），`void`表示这个方法的返回值类型，`main`为方法名，后面跟上一对小括号，里面是参数列表，这里为`String[] args`，表示它接受一个String数组作为参数，`args`为参数名。\n\n也许上面还有许多概念你还不清楚是什么意思，不要着急，先不要纠结于这些细节，先从整体上把握，继续看下去，后面的文章中会有说明。\n\n需要注意的是，`main`方法是java程序中一个十分特殊的方法，它是整个程序的入口，也就是说，程序会从`main`方法开始执行，因此，如果想要代码能够执行，在类的源文件中必须包含一个`main`方法。\n\n方法中的方法体则是我们为了实现功能而设计的自定义代码，在Java中，每个句子必须用分号结束。\n\n```java\nSystem.out.print(\"请输入一个整数:\");\nScanner in = new Scanner(System.in);\nint a = in.nextInt();\nSystem.out.print(\"请再输入一个整数:\");\nint b = in.nextInt();\nint sum = a + b;\nSystem.out.print(\"这两个数的和为:\" + sum);\n```\n\nJava中，点号是用来调用方法或者使用对象的，如：`System.out.print(...)`表示使用`System.out`对象并调用它的`print`方法。\n\n# 小结\n\n至此，本篇的Java的基本结构就介绍完毕了，希望通过本篇，你能知道一个简单Java程序的结构是怎样的以及main方法有什么作用。\n","slug":"java/basic/java-simple-structure","published":1,"updated":"2019-06-04T01:29:57.096Z","_id":"cjxze3gts003p0cvwtocl9s2y","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>“No matter how small and unimportant what we are doing may seem, if we do it well, it may soon become the step that will lead us to better things.”                — Channing Pollock, Writer</p>\n<p>「不管我们现在所做的事看起来有么的微不足道或不重要，如果我们认真的做，它可能很快就会成为通往美好事物的踏石阶。」                                – 詹宁‧布鲁克 (作家)</p>\n</blockquote>\n<h2 id=\"关卡说明\"><a href=\"#关卡说明\" class=\"headerlink\" title=\"关卡说明\"></a>关卡说明</h2><p>关卡描述：Java程序具有一些固定的形式，本篇将来对此进行简单的说明介绍。</p>\n<p>过关条件：理解Java程序的基本组成结构</p>\n<p>关卡难度：⭐️</p>\n<h2 id=\"一个简单的程序\"><a href=\"#一个简单的程序\" class=\"headerlink\" title=\"一个简单的程序\"></a>一个简单的程序</h2><p>为了简单起见，本篇以及之后的很多篇里，都会设计很多“玩具”代码，与实际中Java的设计可能相去甚远，本系列中的代示例都是为了说明一些相关概念，让你能够更好的理解Java的相关特性。</p>\n<p>下面再来看看上一篇中的栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> hello;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleCalculator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        System.out.print(<span class=\"string\">\"请输入一个整数:\"</span>);</span><br><span class=\"line\">        Scanner in = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = in.nextInt();</span><br><span class=\"line\">        System.out.print(<span class=\"string\">\"请再输入一个整数:\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b = in.nextInt();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = a + b;</span><br><span class=\"line\">        System.out.print(<span class=\"string\">\"这两个数的和为:\"</span> + sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个非常简单的能够运行的Java程序，它有一些基本的结构，下面将对其一一介绍。</p>\n<p>前面两句的作用已经在<a href=\"../introduction/java-package.md\">上一篇</a>中进行说明了，这里就不赘述了。接下来是类的定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleCalculator</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里是定义了一个叫做<code>SimpleCalculator</code>的类，<code>public</code> 称为<em>访问修饰符</em>，用于控制代码的访问级别，关于这部分的内容，会在之后的章节中进行详细的介绍。在这里，<code>public</code> 表示这个类的访问权限为任何外部类均可以访问。<code>class</code> 是定义一个类的关键字，它的后面是类。关于类的命名规范在之后也会有详细说明。不要忘了后面还有一对大括号，表示类的内部内容。</p>\n<p>需要注意的是，<strong>Java是区分大小写的</strong>，如果出现了大小写拼写错误，程序是无法正确运行的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在类的内部定义了一个main方法，为什么说它是一个方法而不是类呢？因为它位于一个类的内部，并且没有用class关键字修饰，而且符合方法的定义规范。<code>public</code>同样可以修饰方法，表示这个方法对于外部类是公开的，可以访问的，<code>static</code>表示这是一个静态方法（先不要纠结什么是静态方法），<code>void</code>表示这个方法的返回值类型，<code>main</code>为方法名，后面跟上一对小括号，里面是参数列表，这里为<code>String[] args</code>，表示它接受一个String数组作为参数，<code>args</code>为参数名。</p>\n<p>也许上面还有许多概念你还不清楚是什么意思，不要着急，先不要纠结于这些细节，先从整体上把握，继续看下去，后面的文章中会有说明。</p>\n<p>需要注意的是，<code>main</code>方法是java程序中一个十分特殊的方法，它是整个程序的入口，也就是说，程序会从<code>main</code>方法开始执行，因此，如果想要代码能够执行，在类的源文件中必须包含一个<code>main</code>方法。</p>\n<p>方法中的方法体则是我们为了实现功能而设计的自定义代码，在Java中，每个句子必须用分号结束。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.print(<span class=\"string\">\"请输入一个整数:\"</span>);</span><br><span class=\"line\">Scanner in = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\"><span class=\"keyword\">int</span> a = in.nextInt();</span><br><span class=\"line\">System.out.print(<span class=\"string\">\"请再输入一个整数:\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = in.nextInt();</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum = a + b;</span><br><span class=\"line\">System.out.print(<span class=\"string\">\"这两个数的和为:\"</span> + sum);</span><br></pre></td></tr></table></figure>\n<p>Java中，点号是用来调用方法或者使用对象的，如：<code>System.out.print(...)</code>表示使用<code>System.out</code>对象并调用它的<code>print</code>方法。</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>至此，本篇的Java的基本结构就介绍完毕了，希望通过本篇，你能知道一个简单Java程序的结构是怎样的以及main方法有什么作用。</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<blockquote>\n<p>“No matter how small and unimportant what we are doing may seem, if we do it well, it may soon become the step that will lead us to better things.”                — Channing Pollock, Writer</p>\n<p>「不管我们现在所做的事看起来有么的微不足道或不重要，如果我们认真的做，它可能很快就会成为通往美好事物的踏石阶。」                                – 詹宁‧布鲁克 (作家)</p>\n</blockquote>\n<h2 id=\"关卡说明\"><a href=\"#关卡说明\" class=\"headerlink\" title=\"关卡说明\"></a>关卡说明</h2><p>关卡描述：Java程序具有一些固定的形式，本篇将来对此进行简单的说明介绍。</p>\n<p>过关条件：理解Java程序的基本组成结构</p>\n<p>关卡难度：⭐️</p>\n<h2 id=\"一个简单的程序\"><a href=\"#一个简单的程序\" class=\"headerlink\" title=\"一个简单的程序\"></a>一个简单的程序</h2><p>为了简单起见，本篇以及之后的很多篇里，都会设计很多“玩具”代码，与实际中Java的设计可能相去甚远，本系列中的代示例都是为了说明一些相关概念，让你能够更好的理解Java的相关特性。</p>\n<p>下面再来看看上一篇中的栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> hello;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleCalculator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        System.out.print(<span class=\"string\">\"请输入一个整数:\"</span>);</span><br><span class=\"line\">        Scanner in = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = in.nextInt();</span><br><span class=\"line\">        System.out.print(<span class=\"string\">\"请再输入一个整数:\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b = in.nextInt();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = a + b;</span><br><span class=\"line\">        System.out.print(<span class=\"string\">\"这两个数的和为:\"</span> + sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个非常简单的能够运行的Java程序，它有一些基本的结构，下面将对其一一介绍。</p>\n<p>前面两句的作用已经在<a href=\"../introduction/java-package.md\">上一篇</a>中进行说明了，这里就不赘述了。接下来是类的定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleCalculator</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里是定义了一个叫做<code>SimpleCalculator</code>的类，<code>public</code> 称为<em>访问修饰符</em>，用于控制代码的访问级别，关于这部分的内容，会在之后的章节中进行详细的介绍。在这里，<code>public</code> 表示这个类的访问权限为任何外部类均可以访问。<code>class</code> 是定义一个类的关键字，它的后面是类。关于类的命名规范在之后也会有详细说明。不要忘了后面还有一对大括号，表示类的内部内容。</p>\n<p>需要注意的是，<strong>Java是区分大小写的</strong>，如果出现了大小写拼写错误，程序是无法正确运行的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在类的内部定义了一个main方法，为什么说它是一个方法而不是类呢？因为它位于一个类的内部，并且没有用class关键字修饰，而且符合方法的定义规范。<code>public</code>同样可以修饰方法，表示这个方法对于外部类是公开的，可以访问的，<code>static</code>表示这是一个静态方法（先不要纠结什么是静态方法），<code>void</code>表示这个方法的返回值类型，<code>main</code>为方法名，后面跟上一对小括号，里面是参数列表，这里为<code>String[] args</code>，表示它接受一个String数组作为参数，<code>args</code>为参数名。</p>\n<p>也许上面还有许多概念你还不清楚是什么意思，不要着急，先不要纠结于这些细节，先从整体上把握，继续看下去，后面的文章中会有说明。</p>\n<p>需要注意的是，<code>main</code>方法是java程序中一个十分特殊的方法，它是整个程序的入口，也就是说，程序会从<code>main</code>方法开始执行，因此，如果想要代码能够执行，在类的源文件中必须包含一个<code>main</code>方法。</p>\n<p>方法中的方法体则是我们为了实现功能而设计的自定义代码，在Java中，每个句子必须用分号结束。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.print(<span class=\"string\">\"请输入一个整数:\"</span>);</span><br><span class=\"line\">Scanner in = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\"><span class=\"keyword\">int</span> a = in.nextInt();</span><br><span class=\"line\">System.out.print(<span class=\"string\">\"请再输入一个整数:\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = in.nextInt();</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum = a + b;</span><br><span class=\"line\">System.out.print(<span class=\"string\">\"这两个数的和为:\"</span> + sum);</span><br></pre></td></tr></table></figure>\n<p>Java中，点号是用来调用方法或者使用对象的，如：<code>System.out.print(...)</code>表示使用<code>System.out</code>对象并调用它的<code>print</code>方法。</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>至此，本篇的Java的基本结构就介绍完毕了，希望通过本篇，你能知道一个简单Java程序的结构是怎样的以及main方法有什么作用。</p>\n"},{"title":"【Java基础篇】二、Java 变量","date":"2018-12-28T16:04:00.000Z","_content":"\n>**“The superior man makes the difficulty to be overcome his first interest; success comes only later.”**\n>\n>— William Jennings Bryan\n>\n>**「优秀的人将克服困难当做第一优先，成功只是之后的附带品。」**    – 威廉‧詹宁斯‧布莱恩 (政客)\n\n## 关卡说明\n\n关卡描述：变量是Java程序中最常见的内容，是设计Java程序必不可少的部分。\n\n过关条件：理解什么是变量，为什么需要使用变量，以及如何使用它们\n\n关卡难度：⭐️\n\n## 变量\n\n什么是变量？为什么要有变量？怎么使用它？\n\n如果你不能很好的回答这三个问题，那么就带着这些疑问来完成本次挑战吧，相信你必能有所收获。\n\n### 什么是变量\n\n在一个Java程序中，通常需要很多个步骤才能实现我们想要的功能，比如之前设计的计算器，就需要先提示用户输入，读取输入的值，然后再将它们相加后输出。我们日常生活中的事情也是类似的，拿吃饭而言，我们需要先把饭盛到碗里，然后再加点菜，再往嘴里塞。\n\n这里的碗就相当于变量，我们用它来盛饭，也就是存放中间过程的一些处理结果，饭是我们从锅里盛出来的，是经过我们处理过的。\n\n也许这样说还是有些抽象，我们继续看之前的栗子：\n\n```java\npublic static void main(String[] args){\n    System.out.print(\"请输入一个整数:\");\n    Scanner in = new Scanner(System.in);\n    int a = in.nextInt();\n    System.out.print(\"请再输入一个整数:\");\n    int b = in.nextInt();\n    int sum = a + b;\n    System.out.print(\"这两个数的和为:\" + sum);\n}\n```\n\n在第三行，我们定义了一个变量`in`，用来存放Scanner实例引用，在第四行，我们定义了一个变量`a`，用来存放用户输入的第一个整数，第六行里我们又定义了一个变量`b`，用来接收用户输入的第二个整数，然后在第七行定义了一个变量`sum`，用来存放变量`a`和变量`b`的和。\n\n虽然是一个简单的程序，但是我们已经使用了四个变量，可见其应用的广泛性和重要性。变量就如同程序的血液，是一个程序能顺利运转的不可或缺的部分。\n\n### 为什么需要变量\n\n那么有没有可能不使用任何变量呢？其实也是可以的，比如这样：\n\n```java\npublic static void main(String[] args){\n    System.out.print(\"我是一个最简单的程序，我不使用变量\");\n}\n```\n\nemmm，毕竟这样的需求只是极少的一部分，绝大部分的应用还是比较繁杂的，所以变量便不可避免的需要使用。\n\n另外，使用变量还可以使得程序逻辑变得更加清晰，通过使用变量，将整个流程的步骤变得更加清晰明确。就好比说吃饭，不再是模糊的一个动作，而是分为盛饭，夹菜，吃饭这几个具体的步骤了。\n\n### 如何使用变量\n\n要想使用变量，就必须先定义一个变量，或者说声明一个变量。声明变量的格式为：\n\n```java\n[类名] + [变量名]\n```\n\n例如：`int a` 中 `int` 是变量的类型，`a` 是变量的名字。\n\n可以在声明变量的同时给它赋一个初始值，也可以在之后改变变量的值。声明变量之后，必须使用赋值语句对变量显式初始化，千万不要使用未初始化的变量，否则会被编译器视为错误的代码。\n\n想要对一个变量进行赋值，就需要将变量放在`=` 左边，然后将java表达式放在等号的右边。\n\n举个小栗子：\n\n```java\npublic static void main(String[] args){\n    int a = 1;\n    System.out.println(\"变量a的值为：\" + a);\n    a = 2;\n    System.out.println(\"变量a的值为：\" + a);\n    a = 3;\n    System.out.println(\"变量a的值为：\" + a);\n    int b;\n    System.out.println(\"变量b的值为：\" + b);\n    b = a;\n    System.out.println(\"变量b的值为：\" + b);\n}\n```\n\n那么程序将会输出：\n\n```java\n变量a的值为：1\n变量a的值为：2\n变量a的值为：3\n变量b的值为：0\n变量b的值为：3\n```\n\n补充说明一下，`System.out.println` 与 `System.out.print` 的区别是，前者会在内容输出完成之后添加一个换行。\n\n### 变量的命名规范\n\n变量名必须以字母开头，并且由字母、数字或者下划线和$构成，对于长度理论上来说是没有限制的，此外，java中的保留字是不能用作变量名的，保留字也就是java中的关键字，比如之前的 `public`、`static`、`int`、`void`等等，在后续的学习中，会不断接触到各种关键字。\n\n变量命名最好符合它使用的意义，能表现其作用，因为往往在一个程序中会出现非常多的变量，如果变量命名都像`a1`、`a2`、`a3`这样看了让人摸不着头脑的形式，那么将使得代码的阅读和维护变得十分困难。永远不要忘记，代码是用来阅读的。\n\n在Java中，变量的命名通常使用小驼峰命名法，也就是第一个单词的首字母小写，其余单词的首字母大写，比如：`totalDays`、`paperWidth`。\n\n## 小结\n\n至此，关于变量的介绍就结束了，变量是Java中最重要也是最基础的组成部分，希望你能很好的理解和掌握它。\n","source":"_posts/java/basic/java-variable.md","raw":"---\ntitle: 【Java基础篇】二、Java 变量\ntags: \n - Java基础\n - Java\ncategories: 编程\ndate: 2018-12-29 00:04:00\n---\n\n>**“The superior man makes the difficulty to be overcome his first interest; success comes only later.”**\n>\n>— William Jennings Bryan\n>\n>**「优秀的人将克服困难当做第一优先，成功只是之后的附带品。」**    – 威廉‧詹宁斯‧布莱恩 (政客)\n\n## 关卡说明\n\n关卡描述：变量是Java程序中最常见的内容，是设计Java程序必不可少的部分。\n\n过关条件：理解什么是变量，为什么需要使用变量，以及如何使用它们\n\n关卡难度：⭐️\n\n## 变量\n\n什么是变量？为什么要有变量？怎么使用它？\n\n如果你不能很好的回答这三个问题，那么就带着这些疑问来完成本次挑战吧，相信你必能有所收获。\n\n### 什么是变量\n\n在一个Java程序中，通常需要很多个步骤才能实现我们想要的功能，比如之前设计的计算器，就需要先提示用户输入，读取输入的值，然后再将它们相加后输出。我们日常生活中的事情也是类似的，拿吃饭而言，我们需要先把饭盛到碗里，然后再加点菜，再往嘴里塞。\n\n这里的碗就相当于变量，我们用它来盛饭，也就是存放中间过程的一些处理结果，饭是我们从锅里盛出来的，是经过我们处理过的。\n\n也许这样说还是有些抽象，我们继续看之前的栗子：\n\n```java\npublic static void main(String[] args){\n    System.out.print(\"请输入一个整数:\");\n    Scanner in = new Scanner(System.in);\n    int a = in.nextInt();\n    System.out.print(\"请再输入一个整数:\");\n    int b = in.nextInt();\n    int sum = a + b;\n    System.out.print(\"这两个数的和为:\" + sum);\n}\n```\n\n在第三行，我们定义了一个变量`in`，用来存放Scanner实例引用，在第四行，我们定义了一个变量`a`，用来存放用户输入的第一个整数，第六行里我们又定义了一个变量`b`，用来接收用户输入的第二个整数，然后在第七行定义了一个变量`sum`，用来存放变量`a`和变量`b`的和。\n\n虽然是一个简单的程序，但是我们已经使用了四个变量，可见其应用的广泛性和重要性。变量就如同程序的血液，是一个程序能顺利运转的不可或缺的部分。\n\n### 为什么需要变量\n\n那么有没有可能不使用任何变量呢？其实也是可以的，比如这样：\n\n```java\npublic static void main(String[] args){\n    System.out.print(\"我是一个最简单的程序，我不使用变量\");\n}\n```\n\nemmm，毕竟这样的需求只是极少的一部分，绝大部分的应用还是比较繁杂的，所以变量便不可避免的需要使用。\n\n另外，使用变量还可以使得程序逻辑变得更加清晰，通过使用变量，将整个流程的步骤变得更加清晰明确。就好比说吃饭，不再是模糊的一个动作，而是分为盛饭，夹菜，吃饭这几个具体的步骤了。\n\n### 如何使用变量\n\n要想使用变量，就必须先定义一个变量，或者说声明一个变量。声明变量的格式为：\n\n```java\n[类名] + [变量名]\n```\n\n例如：`int a` 中 `int` 是变量的类型，`a` 是变量的名字。\n\n可以在声明变量的同时给它赋一个初始值，也可以在之后改变变量的值。声明变量之后，必须使用赋值语句对变量显式初始化，千万不要使用未初始化的变量，否则会被编译器视为错误的代码。\n\n想要对一个变量进行赋值，就需要将变量放在`=` 左边，然后将java表达式放在等号的右边。\n\n举个小栗子：\n\n```java\npublic static void main(String[] args){\n    int a = 1;\n    System.out.println(\"变量a的值为：\" + a);\n    a = 2;\n    System.out.println(\"变量a的值为：\" + a);\n    a = 3;\n    System.out.println(\"变量a的值为：\" + a);\n    int b;\n    System.out.println(\"变量b的值为：\" + b);\n    b = a;\n    System.out.println(\"变量b的值为：\" + b);\n}\n```\n\n那么程序将会输出：\n\n```java\n变量a的值为：1\n变量a的值为：2\n变量a的值为：3\n变量b的值为：0\n变量b的值为：3\n```\n\n补充说明一下，`System.out.println` 与 `System.out.print` 的区别是，前者会在内容输出完成之后添加一个换行。\n\n### 变量的命名规范\n\n变量名必须以字母开头，并且由字母、数字或者下划线和$构成，对于长度理论上来说是没有限制的，此外，java中的保留字是不能用作变量名的，保留字也就是java中的关键字，比如之前的 `public`、`static`、`int`、`void`等等，在后续的学习中，会不断接触到各种关键字。\n\n变量命名最好符合它使用的意义，能表现其作用，因为往往在一个程序中会出现非常多的变量，如果变量命名都像`a1`、`a2`、`a3`这样看了让人摸不着头脑的形式，那么将使得代码的阅读和维护变得十分困难。永远不要忘记，代码是用来阅读的。\n\n在Java中，变量的命名通常使用小驼峰命名法，也就是第一个单词的首字母小写，其余单词的首字母大写，比如：`totalDays`、`paperWidth`。\n\n## 小结\n\n至此，关于变量的介绍就结束了，变量是Java中最重要也是最基础的组成部分，希望你能很好的理解和掌握它。\n","slug":"java/basic/java-variable","published":1,"updated":"2019-06-04T01:29:57.096Z","_id":"cjxze3gts003t0cvw5vjgjxgw","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p><strong>“The superior man makes the difficulty to be overcome his first interest; success comes only later.”</strong></p>\n<p>— William Jennings Bryan</p>\n<p><strong>「优秀的人将克服困难当做第一优先，成功只是之后的附带品。」</strong>    – 威廉‧詹宁斯‧布莱恩 (政客)</p>\n</blockquote>\n<h2 id=\"关卡说明\"><a href=\"#关卡说明\" class=\"headerlink\" title=\"关卡说明\"></a>关卡说明</h2><p>关卡描述：变量是Java程序中最常见的内容，是设计Java程序必不可少的部分。</p>\n<p>过关条件：理解什么是变量，为什么需要使用变量，以及如何使用它们</p>\n<p>关卡难度：⭐️</p>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>什么是变量？为什么要有变量？怎么使用它？</p>\n<p>如果你不能很好的回答这三个问题，那么就带着这些疑问来完成本次挑战吧，相信你必能有所收获。</p>\n<h3 id=\"什么是变量\"><a href=\"#什么是变量\" class=\"headerlink\" title=\"什么是变量\"></a>什么是变量</h3><p>在一个Java程序中，通常需要很多个步骤才能实现我们想要的功能，比如之前设计的计算器，就需要先提示用户输入，读取输入的值，然后再将它们相加后输出。我们日常生活中的事情也是类似的，拿吃饭而言，我们需要先把饭盛到碗里，然后再加点菜，再往嘴里塞。</p>\n<p>这里的碗就相当于变量，我们用它来盛饭，也就是存放中间过程的一些处理结果，饭是我们从锅里盛出来的，是经过我们处理过的。</p>\n<p>也许这样说还是有些抽象，我们继续看之前的栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    System.out.print(<span class=\"string\">\"请输入一个整数:\"</span>);</span><br><span class=\"line\">    Scanner in = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = in.nextInt();</span><br><span class=\"line\">    System.out.print(<span class=\"string\">\"请再输入一个整数:\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = in.nextInt();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = a + b;</span><br><span class=\"line\">    System.out.print(<span class=\"string\">\"这两个数的和为:\"</span> + sum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在第三行，我们定义了一个变量<code>in</code>，用来存放Scanner实例引用，在第四行，我们定义了一个变量<code>a</code>，用来存放用户输入的第一个整数，第六行里我们又定义了一个变量<code>b</code>，用来接收用户输入的第二个整数，然后在第七行定义了一个变量<code>sum</code>，用来存放变量<code>a</code>和变量<code>b</code>的和。</p>\n<p>虽然是一个简单的程序，但是我们已经使用了四个变量，可见其应用的广泛性和重要性。变量就如同程序的血液，是一个程序能顺利运转的不可或缺的部分。</p>\n<h3 id=\"为什么需要变量\"><a href=\"#为什么需要变量\" class=\"headerlink\" title=\"为什么需要变量\"></a>为什么需要变量</h3><p>那么有没有可能不使用任何变量呢？其实也是可以的，比如这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    System.out.print(<span class=\"string\">\"我是一个最简单的程序，我不使用变量\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>emmm，毕竟这样的需求只是极少的一部分，绝大部分的应用还是比较繁杂的，所以变量便不可避免的需要使用。</p>\n<p>另外，使用变量还可以使得程序逻辑变得更加清晰，通过使用变量，将整个流程的步骤变得更加清晰明确。就好比说吃饭，不再是模糊的一个动作，而是分为盛饭，夹菜，吃饭这几个具体的步骤了。</p>\n<h3 id=\"如何使用变量\"><a href=\"#如何使用变量\" class=\"headerlink\" title=\"如何使用变量\"></a>如何使用变量</h3><p>要想使用变量，就必须先定义一个变量，或者说声明一个变量。声明变量的格式为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[类名] + [变量名]</span><br></pre></td></tr></table></figure>\n<p>例如：<code>int a</code> 中 <code>int</code> 是变量的类型，<code>a</code> 是变量的名字。</p>\n<p>可以在声明变量的同时给它赋一个初始值，也可以在之后改变变量的值。声明变量之后，必须使用赋值语句对变量显式初始化，千万不要使用未初始化的变量，否则会被编译器视为错误的代码。</p>\n<p>想要对一个变量进行赋值，就需要将变量放在<code>=</code> 左边，然后将java表达式放在等号的右边。</p>\n<p>举个小栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"变量a的值为：\"</span> + a);</span><br><span class=\"line\">    a = <span class=\"number\">2</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"变量a的值为：\"</span> + a);</span><br><span class=\"line\">    a = <span class=\"number\">3</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"变量a的值为：\"</span> + a);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"变量b的值为：\"</span> + b);</span><br><span class=\"line\">    b = a;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"变量b的值为：\"</span> + b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么程序将会输出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">变量a的值为：<span class=\"number\">1</span></span><br><span class=\"line\">变量a的值为：<span class=\"number\">2</span></span><br><span class=\"line\">变量a的值为：<span class=\"number\">3</span></span><br><span class=\"line\">变量b的值为：<span class=\"number\">0</span></span><br><span class=\"line\">变量b的值为：<span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>补充说明一下，<code>System.out.println</code> 与 <code>System.out.print</code> 的区别是，前者会在内容输出完成之后添加一个换行。</p>\n<h3 id=\"变量的命名规范\"><a href=\"#变量的命名规范\" class=\"headerlink\" title=\"变量的命名规范\"></a>变量的命名规范</h3><p>变量名必须以字母开头，并且由字母、数字或者下划线和$构成，对于长度理论上来说是没有限制的，此外，java中的保留字是不能用作变量名的，保留字也就是java中的关键字，比如之前的 <code>public</code>、<code>static</code>、<code>int</code>、<code>void</code>等等，在后续的学习中，会不断接触到各种关键字。</p>\n<p>变量命名最好符合它使用的意义，能表现其作用，因为往往在一个程序中会出现非常多的变量，如果变量命名都像<code>a1</code>、<code>a2</code>、<code>a3</code>这样看了让人摸不着头脑的形式，那么将使得代码的阅读和维护变得十分困难。永远不要忘记，代码是用来阅读的。</p>\n<p>在Java中，变量的命名通常使用小驼峰命名法，也就是第一个单词的首字母小写，其余单词的首字母大写，比如：<code>totalDays</code>、<code>paperWidth</code>。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>至此，关于变量的介绍就结束了，变量是Java中最重要也是最基础的组成部分，希望你能很好的理解和掌握它。</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<blockquote>\n<p><strong>“The superior man makes the difficulty to be overcome his first interest; success comes only later.”</strong></p>\n<p>— William Jennings Bryan</p>\n<p><strong>「优秀的人将克服困难当做第一优先，成功只是之后的附带品。」</strong>    – 威廉‧詹宁斯‧布莱恩 (政客)</p>\n</blockquote>\n<h2 id=\"关卡说明\"><a href=\"#关卡说明\" class=\"headerlink\" title=\"关卡说明\"></a>关卡说明</h2><p>关卡描述：变量是Java程序中最常见的内容，是设计Java程序必不可少的部分。</p>\n<p>过关条件：理解什么是变量，为什么需要使用变量，以及如何使用它们</p>\n<p>关卡难度：⭐️</p>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>什么是变量？为什么要有变量？怎么使用它？</p>\n<p>如果你不能很好的回答这三个问题，那么就带着这些疑问来完成本次挑战吧，相信你必能有所收获。</p>\n<h3 id=\"什么是变量\"><a href=\"#什么是变量\" class=\"headerlink\" title=\"什么是变量\"></a>什么是变量</h3><p>在一个Java程序中，通常需要很多个步骤才能实现我们想要的功能，比如之前设计的计算器，就需要先提示用户输入，读取输入的值，然后再将它们相加后输出。我们日常生活中的事情也是类似的，拿吃饭而言，我们需要先把饭盛到碗里，然后再加点菜，再往嘴里塞。</p>\n<p>这里的碗就相当于变量，我们用它来盛饭，也就是存放中间过程的一些处理结果，饭是我们从锅里盛出来的，是经过我们处理过的。</p>\n<p>也许这样说还是有些抽象，我们继续看之前的栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    System.out.print(<span class=\"string\">\"请输入一个整数:\"</span>);</span><br><span class=\"line\">    Scanner in = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = in.nextInt();</span><br><span class=\"line\">    System.out.print(<span class=\"string\">\"请再输入一个整数:\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = in.nextInt();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = a + b;</span><br><span class=\"line\">    System.out.print(<span class=\"string\">\"这两个数的和为:\"</span> + sum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在第三行，我们定义了一个变量<code>in</code>，用来存放Scanner实例引用，在第四行，我们定义了一个变量<code>a</code>，用来存放用户输入的第一个整数，第六行里我们又定义了一个变量<code>b</code>，用来接收用户输入的第二个整数，然后在第七行定义了一个变量<code>sum</code>，用来存放变量<code>a</code>和变量<code>b</code>的和。</p>\n<p>虽然是一个简单的程序，但是我们已经使用了四个变量，可见其应用的广泛性和重要性。变量就如同程序的血液，是一个程序能顺利运转的不可或缺的部分。</p>\n<h3 id=\"为什么需要变量\"><a href=\"#为什么需要变量\" class=\"headerlink\" title=\"为什么需要变量\"></a>为什么需要变量</h3><p>那么有没有可能不使用任何变量呢？其实也是可以的，比如这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    System.out.print(<span class=\"string\">\"我是一个最简单的程序，我不使用变量\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>emmm，毕竟这样的需求只是极少的一部分，绝大部分的应用还是比较繁杂的，所以变量便不可避免的需要使用。</p>\n<p>另外，使用变量还可以使得程序逻辑变得更加清晰，通过使用变量，将整个流程的步骤变得更加清晰明确。就好比说吃饭，不再是模糊的一个动作，而是分为盛饭，夹菜，吃饭这几个具体的步骤了。</p>\n<h3 id=\"如何使用变量\"><a href=\"#如何使用变量\" class=\"headerlink\" title=\"如何使用变量\"></a>如何使用变量</h3><p>要想使用变量，就必须先定义一个变量，或者说声明一个变量。声明变量的格式为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[类名] + [变量名]</span><br></pre></td></tr></table></figure>\n<p>例如：<code>int a</code> 中 <code>int</code> 是变量的类型，<code>a</code> 是变量的名字。</p>\n<p>可以在声明变量的同时给它赋一个初始值，也可以在之后改变变量的值。声明变量之后，必须使用赋值语句对变量显式初始化，千万不要使用未初始化的变量，否则会被编译器视为错误的代码。</p>\n<p>想要对一个变量进行赋值，就需要将变量放在<code>=</code> 左边，然后将java表达式放在等号的右边。</p>\n<p>举个小栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"变量a的值为：\"</span> + a);</span><br><span class=\"line\">    a = <span class=\"number\">2</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"变量a的值为：\"</span> + a);</span><br><span class=\"line\">    a = <span class=\"number\">3</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"变量a的值为：\"</span> + a);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"变量b的值为：\"</span> + b);</span><br><span class=\"line\">    b = a;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"变量b的值为：\"</span> + b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么程序将会输出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">变量a的值为：<span class=\"number\">1</span></span><br><span class=\"line\">变量a的值为：<span class=\"number\">2</span></span><br><span class=\"line\">变量a的值为：<span class=\"number\">3</span></span><br><span class=\"line\">变量b的值为：<span class=\"number\">0</span></span><br><span class=\"line\">变量b的值为：<span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>补充说明一下，<code>System.out.println</code> 与 <code>System.out.print</code> 的区别是，前者会在内容输出完成之后添加一个换行。</p>\n<h3 id=\"变量的命名规范\"><a href=\"#变量的命名规范\" class=\"headerlink\" title=\"变量的命名规范\"></a>变量的命名规范</h3><p>变量名必须以字母开头，并且由字母、数字或者下划线和$构成，对于长度理论上来说是没有限制的，此外，java中的保留字是不能用作变量名的，保留字也就是java中的关键字，比如之前的 <code>public</code>、<code>static</code>、<code>int</code>、<code>void</code>等等，在后续的学习中，会不断接触到各种关键字。</p>\n<p>变量命名最好符合它使用的意义，能表现其作用，因为往往在一个程序中会出现非常多的变量，如果变量命名都像<code>a1</code>、<code>a2</code>、<code>a3</code>这样看了让人摸不着头脑的形式，那么将使得代码的阅读和维护变得十分困难。永远不要忘记，代码是用来阅读的。</p>\n<p>在Java中，变量的命名通常使用小驼峰命名法，也就是第一个单词的首字母小写，其余单词的首字母大写，比如：<code>totalDays</code>、<code>paperWidth</code>。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>至此，关于变量的介绍就结束了，变量是Java中最重要也是最基础的组成部分，希望你能很好的理解和掌握它。</p>\n"},{"title":"【Java入门篇】一、Java开发环境搭建——概念说明","date":"2018-12-28T11:00:01.000Z","_content":"\n> 如果不能忠于自己的心，胜负又有什么价值呢？\n\n## 说明\n\n前面说到Java也有一个大工厂，可以让你随心所欲的创建想要创建的事物，但是想要使用这个工厂，还得先部署这个工厂，它就是JDK。\n\n在此之前，先介绍几个概念：JVM、JRE、JDK。\n\n## JVM（Java Virtual Machine）\n\nJVM 即 Java虚拟机，是Java这个大工厂中的熔炉，也是驱动这个工厂运行的核心组件。\n\nJava是能够跨平台运行的，也就是说，同样的代码可以不经修改的在windows系统、linux系统、mac系统上运行并得到相同的结果。JVM在这个过程中扮演着十分重要的角色，它就像一位翻译官，由它间接的与具体的系统打交道。不同系统有着不同的指令集，可以理解为有不同的语言，但JVM这位翻译官精通各个系统的语言，可以将我们的代码翻译给系统去执行。Java代码被编译为.class文件后，由虚拟机将字节码文件解释成具体平台上的机器指令。\n\nJVM其实是一种规范，只要按这种规范设计的产品都可以叫做虚拟机，目前来说比较主流的虚拟机有，HotSpot、J9 VM、Zing VM。\n\n## JRE（Java Runtime Environment）\n\nJRE 即 Java运行时环境，是运行 Java 程序必不可少的，既然是运行，自然要包含JVM，同时还包含了JVM标准实现及Java核心类库，提供了Java运行时必要的基础信息。光有JVM无法完成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。 可以这样理解，JVM只是一名翻译官，还需要各个助理才能完成各项具体任务，JRE 并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器）。\n\n## JDK（Java Development Kit）\n\nJDK 是 Java 语言的软件开发工具包，是 Java 开发者所必须的内容，也就是我们之后要部署的东西，主要包含了各种类库和工具，当然也包含了一个JRE。\n\n综上所述，JDK中包含有JRE，JRE中包含有JVM，所以JDK在手，天下我有【手动滑稽】。想要进行Java开发，就必须要部署JDK环境，但如果只是想要运行Java开发的软件，那么安装一个JRE就足够了。\n","source":"_posts/java/introduction/java-environment.md","raw":"---\ntitle: 【Java入门篇】一、Java开发环境搭建——概念说明\ntags: \n - Java入门\n - Java\n - 环境搭建\ncategories: 编程\ndate: 2018-12-28 19:00:01\n---\n\n> 如果不能忠于自己的心，胜负又有什么价值呢？\n\n## 说明\n\n前面说到Java也有一个大工厂，可以让你随心所欲的创建想要创建的事物，但是想要使用这个工厂，还得先部署这个工厂，它就是JDK。\n\n在此之前，先介绍几个概念：JVM、JRE、JDK。\n\n## JVM（Java Virtual Machine）\n\nJVM 即 Java虚拟机，是Java这个大工厂中的熔炉，也是驱动这个工厂运行的核心组件。\n\nJava是能够跨平台运行的，也就是说，同样的代码可以不经修改的在windows系统、linux系统、mac系统上运行并得到相同的结果。JVM在这个过程中扮演着十分重要的角色，它就像一位翻译官，由它间接的与具体的系统打交道。不同系统有着不同的指令集，可以理解为有不同的语言，但JVM这位翻译官精通各个系统的语言，可以将我们的代码翻译给系统去执行。Java代码被编译为.class文件后，由虚拟机将字节码文件解释成具体平台上的机器指令。\n\nJVM其实是一种规范，只要按这种规范设计的产品都可以叫做虚拟机，目前来说比较主流的虚拟机有，HotSpot、J9 VM、Zing VM。\n\n## JRE（Java Runtime Environment）\n\nJRE 即 Java运行时环境，是运行 Java 程序必不可少的，既然是运行，自然要包含JVM，同时还包含了JVM标准实现及Java核心类库，提供了Java运行时必要的基础信息。光有JVM无法完成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。 可以这样理解，JVM只是一名翻译官，还需要各个助理才能完成各项具体任务，JRE 并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器）。\n\n## JDK（Java Development Kit）\n\nJDK 是 Java 语言的软件开发工具包，是 Java 开发者所必须的内容，也就是我们之后要部署的东西，主要包含了各种类库和工具，当然也包含了一个JRE。\n\n综上所述，JDK中包含有JRE，JRE中包含有JVM，所以JDK在手，天下我有【手动滑稽】。想要进行Java开发，就必须要部署JDK环境，但如果只是想要运行Java开发的软件，那么安装一个JRE就足够了。\n","slug":"java/introduction/java-environment","published":1,"updated":"2019-06-04T01:29:57.318Z","_id":"cjxze3gu2003w0cvwfcifyf9a","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>如果不能忠于自己的心，胜负又有什么价值呢？</p>\n</blockquote>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>前面说到Java也有一个大工厂，可以让你随心所欲的创建想要创建的事物，但是想要使用这个工厂，还得先部署这个工厂，它就是JDK。</p>\n<p>在此之前，先介绍几个概念：JVM、JRE、JDK。</p>\n<h2 id=\"JVM（Java-Virtual-Machine）\"><a href=\"#JVM（Java-Virtual-Machine）\" class=\"headerlink\" title=\"JVM（Java Virtual Machine）\"></a>JVM（Java Virtual Machine）</h2><p>JVM 即 Java虚拟机，是Java这个大工厂中的熔炉，也是驱动这个工厂运行的核心组件。</p>\n<p>Java是能够跨平台运行的，也就是说，同样的代码可以不经修改的在windows系统、linux系统、mac系统上运行并得到相同的结果。JVM在这个过程中扮演着十分重要的角色，它就像一位翻译官，由它间接的与具体的系统打交道。不同系统有着不同的指令集，可以理解为有不同的语言，但JVM这位翻译官精通各个系统的语言，可以将我们的代码翻译给系统去执行。Java代码被编译为.class文件后，由虚拟机将字节码文件解释成具体平台上的机器指令。</p>\n<p>JVM其实是一种规范，只要按这种规范设计的产品都可以叫做虚拟机，目前来说比较主流的虚拟机有，HotSpot、J9 VM、Zing VM。</p>\n<h2 id=\"JRE（Java-Runtime-Environment）\"><a href=\"#JRE（Java-Runtime-Environment）\" class=\"headerlink\" title=\"JRE（Java Runtime Environment）\"></a>JRE（Java Runtime Environment）</h2><p>JRE 即 Java运行时环境，是运行 Java 程序必不可少的，既然是运行，自然要包含JVM，同时还包含了JVM标准实现及Java核心类库，提供了Java运行时必要的基础信息。光有JVM无法完成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。 可以这样理解，JVM只是一名翻译官，还需要各个助理才能完成各项具体任务，JRE 并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器）。</p>\n<h2 id=\"JDK（Java-Development-Kit）\"><a href=\"#JDK（Java-Development-Kit）\" class=\"headerlink\" title=\"JDK（Java Development Kit）\"></a>JDK（Java Development Kit）</h2><p>JDK 是 Java 语言的软件开发工具包，是 Java 开发者所必须的内容，也就是我们之后要部署的东西，主要包含了各种类库和工具，当然也包含了一个JRE。</p>\n<p>综上所述，JDK中包含有JRE，JRE中包含有JVM，所以JDK在手，天下我有【手动滑稽】。想要进行Java开发，就必须要部署JDK环境，但如果只是想要运行Java开发的软件，那么安装一个JRE就足够了。</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<blockquote>\n<p>如果不能忠于自己的心，胜负又有什么价值呢？</p>\n</blockquote>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>前面说到Java也有一个大工厂，可以让你随心所欲的创建想要创建的事物，但是想要使用这个工厂，还得先部署这个工厂，它就是JDK。</p>\n<p>在此之前，先介绍几个概念：JVM、JRE、JDK。</p>\n<h2 id=\"JVM（Java-Virtual-Machine）\"><a href=\"#JVM（Java-Virtual-Machine）\" class=\"headerlink\" title=\"JVM（Java Virtual Machine）\"></a>JVM（Java Virtual Machine）</h2><p>JVM 即 Java虚拟机，是Java这个大工厂中的熔炉，也是驱动这个工厂运行的核心组件。</p>\n<p>Java是能够跨平台运行的，也就是说，同样的代码可以不经修改的在windows系统、linux系统、mac系统上运行并得到相同的结果。JVM在这个过程中扮演着十分重要的角色，它就像一位翻译官，由它间接的与具体的系统打交道。不同系统有着不同的指令集，可以理解为有不同的语言，但JVM这位翻译官精通各个系统的语言，可以将我们的代码翻译给系统去执行。Java代码被编译为.class文件后，由虚拟机将字节码文件解释成具体平台上的机器指令。</p>\n<p>JVM其实是一种规范，只要按这种规范设计的产品都可以叫做虚拟机，目前来说比较主流的虚拟机有，HotSpot、J9 VM、Zing VM。</p>\n<h2 id=\"JRE（Java-Runtime-Environment）\"><a href=\"#JRE（Java-Runtime-Environment）\" class=\"headerlink\" title=\"JRE（Java Runtime Environment）\"></a>JRE（Java Runtime Environment）</h2><p>JRE 即 Java运行时环境，是运行 Java 程序必不可少的，既然是运行，自然要包含JVM，同时还包含了JVM标准实现及Java核心类库，提供了Java运行时必要的基础信息。光有JVM无法完成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。 可以这样理解，JVM只是一名翻译官，还需要各个助理才能完成各项具体任务，JRE 并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器）。</p>\n<h2 id=\"JDK（Java-Development-Kit）\"><a href=\"#JDK（Java-Development-Kit）\" class=\"headerlink\" title=\"JDK（Java Development Kit）\"></a>JDK（Java Development Kit）</h2><p>JDK 是 Java 语言的软件开发工具包，是 Java 开发者所必须的内容，也就是我们之后要部署的东西，主要包含了各种类库和工具，当然也包含了一个JRE。</p>\n<p>综上所述，JDK中包含有JRE，JRE中包含有JVM，所以JDK在手，天下我有【手动滑稽】。想要进行Java开发，就必须要部署JDK环境，但如果只是想要运行Java开发的软件，那么安装一个JRE就足够了。</p>\n"},{"title":"【Java入门篇】三、Java开发环境搭建——Mac篇","date":"2018-12-28T11:00:03.000Z","_content":"\n> 人非圣贤，孰能无过？过而能改，善莫大焉。 --《左传》\n\n## 步骤说明\n\n主要分为以下几个步骤：\n\n1.到Oracle官网下载JDK1.8安装包。\n\n2.打开获取到的安装包按步骤安装到系统上。\n\n3.配置系统的环境变量。\n\n4.验证JDK1.8是否安装成功。\n\n【由于电脑上已经安装过了jdk8，所以偷懒把别人的文章搬过来了，[原文链接](https://blog.csdn.net/deliciousion/article/details/78046007)】\n\n## 一、下载JDK8\n\n通过下面Oracle官网找到对应的JDK1.8安装包\n\nhttps://www.oracle.com/index.html\n\n打开后如下所示，Oracle主页内容经常变动，读者打开后很有可能不一样。\n\n{% asset_img 1-jdk-mac.png jdk-mac %}\n\n拉到页面底部，找到“Download Java for Developers”，如下红框所示。\n\n{% asset_img 2-jdk-mac.png jdk-mac %}\n\n点开链接后，如下图所示，再点击红框位置，只下载JDK1.8，红框右边的链接是JDK1.8加上NetBeans，一个挺好用的JAVA IDE（集成化开发环境），有需要的可以下载。\n\n{% asset_img 3-jdk-mac.png jdk-mac %}\n\n进入页面后第一步，点击“Accept License Agreement”同意许可证协议。第二步选择JDK对应的操作系统。本次选择“MAC OS X”，最后把相应的安装包下载到本地。\n\n{% asset_img 4-jdk-mac.png jdk-mac %}\n\n## 二、安装JDK\n\n下载完成后，我们得到一个dmg的安装包，如下图所示，名称为 jdk-8u144-macosx-x64.dmg ，表示这是Java 8版本号为144的JDK安装包。\n\n{% asset_img 5-jdk-mac.png jdk-mac %}\n\n双击dmg安装包，打开如下图所示窗口。按照红框的提示，便可轻松完成安装。\n\n{% asset_img 6-jdk-mac.png jdk-mac %}\n\n再双击中间的pkg文件，开始安装，如下图所示。\n\n{% asset_img 7-jdk-mac.png jdk-mac %}\n\n{% asset_img 9-jdk-mac.png jdk-mac %}\n\n{% asset_img 10-jdk-mac.png jdk-mac %}\n\n## 三、配置系统的环境变量\n\n上一步骤，实标上，我们只是把JDK1.8的文件复制到操作系统上。但是我们如果要在terminal终端上使JAVA命令，还有让其实应用知道JDK1.8环境的存在，那我们还需要配置系统的环境变量。\n\n首先我们得知道JDK目录安装在哪里，按照下面的路径我们可以找到JDK的主目录，如下图所示。这里有两个目录是因为本机较早前安装过早期版本的JDK1.8。\n\n/Library/Java/JavaVirtualMachines\n\n{% asset_img 11-jdk-mac.png jdk-mac %}\n\n\n由于MAC文件系统结构，与WINDOWS有所不一样，所以jdk的真实主目录如下\n\n/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home\n\n打开terminal终端，默认打开在自身home家目录下，也可通过cd命令直接跳到家目录。\n\n{% asset_img 12-jdk-mac.png jdk-mac %}\n\n通过 vim .bash_profile 命令打开启动文件，修改内容\n\n{% asset_img 13-jdk-mac.png jdk-mac %}\n\n进入vim，按I进入编辑状态。添加如下内容，如下图所示。再按ESC，输入“:wq”保存退出。配置系统环境变量结束。\n\n{% asset_img 14-jdk-mac.png jdk-mac %}\n\n添加如下内容：\n\n```bash\nexport JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home\n```\n\n注意将jdk1.8.0_45这里改为你下载的JDK版本，不清楚的话，到/Library/Java/JavaVirtualMachines/这个目录下找找。\n\n## 四、验证JDK1.8是否安装成功。\n\n在终端输入java,有如下画面，证明配置成功\n\n{% asset_img 15-jdk-mac.png jdk-mac %}\n\n或输入java -version，有如下版本信息。\n\n{% asset_img 16-jdk-mac.png jdk-mac %}\n\n至此，整个安装JDK1.8过程结束\n","source":"_posts/java/introduction/java-environment-mac.md","raw":"---\ntitle: 【Java入门篇】三、Java开发环境搭建——Mac篇\ntags: \n - Java入门\n - Java\n - 环境搭建\ncategories: 编程\ndate: 2018-12-28 19:00:03\n---\n\n> 人非圣贤，孰能无过？过而能改，善莫大焉。 --《左传》\n\n## 步骤说明\n\n主要分为以下几个步骤：\n\n1.到Oracle官网下载JDK1.8安装包。\n\n2.打开获取到的安装包按步骤安装到系统上。\n\n3.配置系统的环境变量。\n\n4.验证JDK1.8是否安装成功。\n\n【由于电脑上已经安装过了jdk8，所以偷懒把别人的文章搬过来了，[原文链接](https://blog.csdn.net/deliciousion/article/details/78046007)】\n\n## 一、下载JDK8\n\n通过下面Oracle官网找到对应的JDK1.8安装包\n\nhttps://www.oracle.com/index.html\n\n打开后如下所示，Oracle主页内容经常变动，读者打开后很有可能不一样。\n\n{% asset_img 1-jdk-mac.png jdk-mac %}\n\n拉到页面底部，找到“Download Java for Developers”，如下红框所示。\n\n{% asset_img 2-jdk-mac.png jdk-mac %}\n\n点开链接后，如下图所示，再点击红框位置，只下载JDK1.8，红框右边的链接是JDK1.8加上NetBeans，一个挺好用的JAVA IDE（集成化开发环境），有需要的可以下载。\n\n{% asset_img 3-jdk-mac.png jdk-mac %}\n\n进入页面后第一步，点击“Accept License Agreement”同意许可证协议。第二步选择JDK对应的操作系统。本次选择“MAC OS X”，最后把相应的安装包下载到本地。\n\n{% asset_img 4-jdk-mac.png jdk-mac %}\n\n## 二、安装JDK\n\n下载完成后，我们得到一个dmg的安装包，如下图所示，名称为 jdk-8u144-macosx-x64.dmg ，表示这是Java 8版本号为144的JDK安装包。\n\n{% asset_img 5-jdk-mac.png jdk-mac %}\n\n双击dmg安装包，打开如下图所示窗口。按照红框的提示，便可轻松完成安装。\n\n{% asset_img 6-jdk-mac.png jdk-mac %}\n\n再双击中间的pkg文件，开始安装，如下图所示。\n\n{% asset_img 7-jdk-mac.png jdk-mac %}\n\n{% asset_img 9-jdk-mac.png jdk-mac %}\n\n{% asset_img 10-jdk-mac.png jdk-mac %}\n\n## 三、配置系统的环境变量\n\n上一步骤，实标上，我们只是把JDK1.8的文件复制到操作系统上。但是我们如果要在terminal终端上使JAVA命令，还有让其实应用知道JDK1.8环境的存在，那我们还需要配置系统的环境变量。\n\n首先我们得知道JDK目录安装在哪里，按照下面的路径我们可以找到JDK的主目录，如下图所示。这里有两个目录是因为本机较早前安装过早期版本的JDK1.8。\n\n/Library/Java/JavaVirtualMachines\n\n{% asset_img 11-jdk-mac.png jdk-mac %}\n\n\n由于MAC文件系统结构，与WINDOWS有所不一样，所以jdk的真实主目录如下\n\n/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home\n\n打开terminal终端，默认打开在自身home家目录下，也可通过cd命令直接跳到家目录。\n\n{% asset_img 12-jdk-mac.png jdk-mac %}\n\n通过 vim .bash_profile 命令打开启动文件，修改内容\n\n{% asset_img 13-jdk-mac.png jdk-mac %}\n\n进入vim，按I进入编辑状态。添加如下内容，如下图所示。再按ESC，输入“:wq”保存退出。配置系统环境变量结束。\n\n{% asset_img 14-jdk-mac.png jdk-mac %}\n\n添加如下内容：\n\n```bash\nexport JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home\n```\n\n注意将jdk1.8.0_45这里改为你下载的JDK版本，不清楚的话，到/Library/Java/JavaVirtualMachines/这个目录下找找。\n\n## 四、验证JDK1.8是否安装成功。\n\n在终端输入java,有如下画面，证明配置成功\n\n{% asset_img 15-jdk-mac.png jdk-mac %}\n\n或输入java -version，有如下版本信息。\n\n{% asset_img 16-jdk-mac.png jdk-mac %}\n\n至此，整个安装JDK1.8过程结束\n","slug":"java/introduction/java-environment-mac","published":1,"updated":"2019-06-04T01:29:57.294Z","_id":"cjxze3guc00400cvw3xggpta5","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>人非圣贤，孰能无过？过而能改，善莫大焉。 –《左传》</p>\n</blockquote>\n<h2 id=\"步骤说明\"><a href=\"#步骤说明\" class=\"headerlink\" title=\"步骤说明\"></a>步骤说明</h2><p>主要分为以下几个步骤：</p>\n<p>1.到Oracle官网下载JDK1.8安装包。</p>\n<p>2.打开获取到的安装包按步骤安装到系统上。</p>\n<p>3.配置系统的环境变量。</p>\n<p>4.验证JDK1.8是否安装成功。</p>\n<p>【由于电脑上已经安装过了jdk8，所以偷懒把别人的文章搬过来了，<a href=\"https://blog.csdn.net/deliciousion/article/details/78046007\" target=\"_blank\" rel=\"noopener\">原文链接</a>】</p>\n<h2 id=\"一、下载JDK8\"><a href=\"#一、下载JDK8\" class=\"headerlink\" title=\"一、下载JDK8\"></a>一、下载JDK8</h2><p>通过下面Oracle官网找到对应的JDK1.8安装包</p>\n<p><a href=\"https://www.oracle.com/index.html\" target=\"_blank\" rel=\"noopener\">https://www.oracle.com/index.html</a></p>\n<p>打开后如下所示，Oracle主页内容经常变动，读者打开后很有可能不一样。</p>\n<img src=\"/programming/java/introduction/java-environment-mac/1-jdk-mac.png\" title=\"jdk-mac\">\n<p>拉到页面底部，找到“Download Java for Developers”，如下红框所示。</p>\n<img src=\"/programming/java/introduction/java-environment-mac/2-jdk-mac.png\" title=\"jdk-mac\">\n<p>点开链接后，如下图所示，再点击红框位置，只下载JDK1.8，红框右边的链接是JDK1.8加上NetBeans，一个挺好用的JAVA IDE（集成化开发环境），有需要的可以下载。</p>\n<img src=\"/programming/java/introduction/java-environment-mac/3-jdk-mac.png\" title=\"jdk-mac\">\n<p>进入页面后第一步，点击“Accept License Agreement”同意许可证协议。第二步选择JDK对应的操作系统。本次选择“MAC OS X”，最后把相应的安装包下载到本地。</p>\n<img src=\"/programming/java/introduction/java-environment-mac/4-jdk-mac.png\" title=\"jdk-mac\">\n<h2 id=\"二、安装JDK\"><a href=\"#二、安装JDK\" class=\"headerlink\" title=\"二、安装JDK\"></a>二、安装JDK</h2><p>下载完成后，我们得到一个dmg的安装包，如下图所示，名称为 jdk-8u144-macosx-x64.dmg ，表示这是Java 8版本号为144的JDK安装包。</p>\n<img src=\"/programming/java/introduction/java-environment-mac/5-jdk-mac.png\" title=\"jdk-mac\">\n<p>双击dmg安装包，打开如下图所示窗口。按照红框的提示，便可轻松完成安装。</p>\n<img src=\"/programming/java/introduction/java-environment-mac/6-jdk-mac.png\" title=\"jdk-mac\">\n<p>再双击中间的pkg文件，开始安装，如下图所示。</p>\n<img src=\"/programming/java/introduction/java-environment-mac/7-jdk-mac.png\" title=\"jdk-mac\">\n<img src=\"/programming/java/introduction/java-environment-mac/9-jdk-mac.png\" title=\"jdk-mac\">\n<img src=\"/programming/java/introduction/java-environment-mac/10-jdk-mac.png\" title=\"jdk-mac\">\n<h2 id=\"三、配置系统的环境变量\"><a href=\"#三、配置系统的环境变量\" class=\"headerlink\" title=\"三、配置系统的环境变量\"></a>三、配置系统的环境变量</h2><p>上一步骤，实标上，我们只是把JDK1.8的文件复制到操作系统上。但是我们如果要在terminal终端上使JAVA命令，还有让其实应用知道JDK1.8环境的存在，那我们还需要配置系统的环境变量。</p>\n<p>首先我们得知道JDK目录安装在哪里，按照下面的路径我们可以找到JDK的主目录，如下图所示。这里有两个目录是因为本机较早前安装过早期版本的JDK1.8。</p>\n<p>/Library/Java/JavaVirtualMachines</p>\n<img src=\"/programming/java/introduction/java-environment-mac/11-jdk-mac.png\" title=\"jdk-mac\">\n<p>由于MAC文件系统结构，与WINDOWS有所不一样，所以jdk的真实主目录如下</p>\n<p>/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home</p>\n<p>打开terminal终端，默认打开在自身home家目录下，也可通过cd命令直接跳到家目录。</p>\n<img src=\"/programming/java/introduction/java-environment-mac/12-jdk-mac.png\" title=\"jdk-mac\">\n<p>通过 vim .bash_profile 命令打开启动文件，修改内容</p>\n<img src=\"/programming/java/introduction/java-environment-mac/13-jdk-mac.png\" title=\"jdk-mac\">\n<p>进入vim，按I进入编辑状态。添加如下内容，如下图所示。再按ESC，输入“:wq”保存退出。配置系统环境变量结束。</p>\n<img src=\"/programming/java/introduction/java-environment-mac/14-jdk-mac.png\" title=\"jdk-mac\">\n<p>添加如下内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home</span><br></pre></td></tr></table></figure>\n<p>注意将jdk1.8.0_45这里改为你下载的JDK版本，不清楚的话，到/Library/Java/JavaVirtualMachines/这个目录下找找。</p>\n<h2 id=\"四、验证JDK1-8是否安装成功。\"><a href=\"#四、验证JDK1-8是否安装成功。\" class=\"headerlink\" title=\"四、验证JDK1.8是否安装成功。\"></a>四、验证JDK1.8是否安装成功。</h2><p>在终端输入java,有如下画面，证明配置成功</p>\n<img src=\"/programming/java/introduction/java-environment-mac/15-jdk-mac.png\" title=\"jdk-mac\">\n<p>或输入java -version，有如下版本信息。</p>\n<img src=\"/programming/java/introduction/java-environment-mac/16-jdk-mac.png\" title=\"jdk-mac\">\n<p>至此，整个安装JDK1.8过程结束</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<blockquote>\n<p>人非圣贤，孰能无过？过而能改，善莫大焉。 –《左传》</p>\n</blockquote>\n<h2 id=\"步骤说明\"><a href=\"#步骤说明\" class=\"headerlink\" title=\"步骤说明\"></a>步骤说明</h2><p>主要分为以下几个步骤：</p>\n<p>1.到Oracle官网下载JDK1.8安装包。</p>\n<p>2.打开获取到的安装包按步骤安装到系统上。</p>\n<p>3.配置系统的环境变量。</p>\n<p>4.验证JDK1.8是否安装成功。</p>\n<p>【由于电脑上已经安装过了jdk8，所以偷懒把别人的文章搬过来了，<a href=\"https://blog.csdn.net/deliciousion/article/details/78046007\" target=\"_blank\" rel=\"noopener\">原文链接</a>】</p>\n<h2 id=\"一、下载JDK8\"><a href=\"#一、下载JDK8\" class=\"headerlink\" title=\"一、下载JDK8\"></a>一、下载JDK8</h2><p>通过下面Oracle官网找到对应的JDK1.8安装包</p>\n<p><a href=\"https://www.oracle.com/index.html\" target=\"_blank\" rel=\"noopener\">https://www.oracle.com/index.html</a></p>\n<p>打开后如下所示，Oracle主页内容经常变动，读者打开后很有可能不一样。</p>\n<img src=\"/programming/java/introduction/java-environment-mac/1-jdk-mac.png\" title=\"jdk-mac\">\n<p>拉到页面底部，找到“Download Java for Developers”，如下红框所示。</p>\n<img src=\"/programming/java/introduction/java-environment-mac/2-jdk-mac.png\" title=\"jdk-mac\">\n<p>点开链接后，如下图所示，再点击红框位置，只下载JDK1.8，红框右边的链接是JDK1.8加上NetBeans，一个挺好用的JAVA IDE（集成化开发环境），有需要的可以下载。</p>\n<img src=\"/programming/java/introduction/java-environment-mac/3-jdk-mac.png\" title=\"jdk-mac\">\n<p>进入页面后第一步，点击“Accept License Agreement”同意许可证协议。第二步选择JDK对应的操作系统。本次选择“MAC OS X”，最后把相应的安装包下载到本地。</p>\n<img src=\"/programming/java/introduction/java-environment-mac/4-jdk-mac.png\" title=\"jdk-mac\">\n<h2 id=\"二、安装JDK\"><a href=\"#二、安装JDK\" class=\"headerlink\" title=\"二、安装JDK\"></a>二、安装JDK</h2><p>下载完成后，我们得到一个dmg的安装包，如下图所示，名称为 jdk-8u144-macosx-x64.dmg ，表示这是Java 8版本号为144的JDK安装包。</p>\n<img src=\"/programming/java/introduction/java-environment-mac/5-jdk-mac.png\" title=\"jdk-mac\">\n<p>双击dmg安装包，打开如下图所示窗口。按照红框的提示，便可轻松完成安装。</p>\n<img src=\"/programming/java/introduction/java-environment-mac/6-jdk-mac.png\" title=\"jdk-mac\">\n<p>再双击中间的pkg文件，开始安装，如下图所示。</p>\n<img src=\"/programming/java/introduction/java-environment-mac/7-jdk-mac.png\" title=\"jdk-mac\">\n<img src=\"/programming/java/introduction/java-environment-mac/9-jdk-mac.png\" title=\"jdk-mac\">\n<img src=\"/programming/java/introduction/java-environment-mac/10-jdk-mac.png\" title=\"jdk-mac\">\n<h2 id=\"三、配置系统的环境变量\"><a href=\"#三、配置系统的环境变量\" class=\"headerlink\" title=\"三、配置系统的环境变量\"></a>三、配置系统的环境变量</h2><p>上一步骤，实标上，我们只是把JDK1.8的文件复制到操作系统上。但是我们如果要在terminal终端上使JAVA命令，还有让其实应用知道JDK1.8环境的存在，那我们还需要配置系统的环境变量。</p>\n<p>首先我们得知道JDK目录安装在哪里，按照下面的路径我们可以找到JDK的主目录，如下图所示。这里有两个目录是因为本机较早前安装过早期版本的JDK1.8。</p>\n<p>/Library/Java/JavaVirtualMachines</p>\n<img src=\"/programming/java/introduction/java-environment-mac/11-jdk-mac.png\" title=\"jdk-mac\">\n<p>由于MAC文件系统结构，与WINDOWS有所不一样，所以jdk的真实主目录如下</p>\n<p>/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home</p>\n<p>打开terminal终端，默认打开在自身home家目录下，也可通过cd命令直接跳到家目录。</p>\n<img src=\"/programming/java/introduction/java-environment-mac/12-jdk-mac.png\" title=\"jdk-mac\">\n<p>通过 vim .bash_profile 命令打开启动文件，修改内容</p>\n<img src=\"/programming/java/introduction/java-environment-mac/13-jdk-mac.png\" title=\"jdk-mac\">\n<p>进入vim，按I进入编辑状态。添加如下内容，如下图所示。再按ESC，输入“:wq”保存退出。配置系统环境变量结束。</p>\n<img src=\"/programming/java/introduction/java-environment-mac/14-jdk-mac.png\" title=\"jdk-mac\">\n<p>添加如下内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home</span><br></pre></td></tr></table></figure>\n<p>注意将jdk1.8.0_45这里改为你下载的JDK版本，不清楚的话，到/Library/Java/JavaVirtualMachines/这个目录下找找。</p>\n<h2 id=\"四、验证JDK1-8是否安装成功。\"><a href=\"#四、验证JDK1-8是否安装成功。\" class=\"headerlink\" title=\"四、验证JDK1.8是否安装成功。\"></a>四、验证JDK1.8是否安装成功。</h2><p>在终端输入java,有如下画面，证明配置成功</p>\n<img src=\"/programming/java/introduction/java-environment-mac/15-jdk-mac.png\" title=\"jdk-mac\">\n<p>或输入java -version，有如下版本信息。</p>\n<img src=\"/programming/java/introduction/java-environment-mac/16-jdk-mac.png\" title=\"jdk-mac\">\n<p>至此，整个安装JDK1.8过程结束</p>\n"},{"title":"【Java基础篇】三、Java 类与对象","date":"2018-12-28T16:05:00.000Z","_content":"\n# Java 类与对象\n\n>**“Sometimes we stare so long at a door that is closing that we see too late the one that is open.”**\n>\n>— Alexander Graham Bell, Inventor\n>\n>**「我们有时候专注于消失中的机会太久，以致于太晚发现开启的机会。」**– 亚历山大‧贝尔 (发明家)\n\n## 关卡说明\n\n关卡描述：Java是一门面向对象的语言，类和对象是Java中最重要的概念，本关将介绍这两个重要的概念，并通过一个简单的栗子来进行说明，你能否通过本关的考验呢？\n\n过关条件：理解面向对象编程的特点，理解Java中类和对象的关系，以及如何使用它们\n\n关卡难度：⭐️⭐️\n\n## 面向对象程序设计\n\n面向对象编程（Object Oriented Programming 简称OOP）是当今主流的程序设计规范，Java是完全面向对象的，所以必须熟悉OOP才能编写出优秀的Java代码。\n\n面向对象编程，顾名思义，重点就在于这个对象，没有对象怎么编程（手动滑稽）。咳咳，言归正传，面向对象的程序是由许许多多的对象组成，每个对象具有一定的属性和行为，通过对象之间的交互来实现软件的功能。从根本上来说，只要这个对象能满足功能要求，就不必关心它的具体实现过程。换句话说，不管是黑猫白猫，能抓耗子的猫就是好猫。\n\n传统的程序设计是面向过程编程，在传统的程序设计过程中，通常需要先设计一系列的算法来求解问题，然后再考虑存储数据的方式。这就是所谓的：\n\n> 算法 + 数据结构 = 程序\n\n在面向过程的设计中，算法是放在第一位的，数据结构是为了适应算法而存在的。\n\n而在OOP中，这个顺序刚好相反，数据结构放在第一位，然后再考虑操作数据的算法。\n\n两种开发方式各有利弊，一些简单的问题，使用面向过程的开发方式是比较容易的，因为它符合人们的惯常思考方式，先这样做，再那样做，最后得到一个什么样的结果。而面向对象的编程适合于解决更复杂的问题。比如实现一个网站也许需要1000个函数，这些过程可能会对一组全局的数据进行操作。如果采用面向对象的方式来设计，可能只需要大约100个类，每个类10个方法，而且大多数情况下，面向过程开发的代码中有很多设计是可以使用面向对象的方式简化和复用的。所以后者显然更容易掌握和维护，而且如果万一某个数据出了问题，在10个方法中排查总比在1000个函数中排查要容易得多。\n\n## Java中的类和对象\n\n既然面向对象编程这么优秀，那么我们就来好好认识一下这其中的主人公——类和对象。\n\n“类”是对具有相同属性的一系列事物的抽象，比如说，“人类”，描述的就是有“人”这个共同属性和行为的群体，普通的人都有两只手，两只脚等基本外貌特征，也具有说话，吃东西等能力，比如“轿车”描述的是有四个轮子，可以驾驶，可以载人的小型车辆，不管你是黑色的奔驰还是白色的宝马，都可以叫做轿车。\n\n那么什么是对象呢？对象就是类的某个具体实例，就好比你和我都是“人类”的一个具体实例，所以我们都是“人类”的一个对象。你家车库里的那辆轿车（不管是奔驰还是大众），也是“轿车”的一个对象。\n\n> 类是抽象的概念，是对具有共同特征的事物的抽象，而对象则是具体的概念，是指某一个具体的实例。\n\n类可以看作是对象的模子，可以用它来生产任意多个对象。\n\n## 类的定义\n\n先来看一个小栗子，我们来定义一个人类：\n\n```java\npublic class Person{\n    private String name;\n    private int age;\n    \n    public Person(String name, int age){\n        this.name = name;\n        this.age = age;\n    }\n    \n    public void eat(){\n        System.out.println(\"开始吃饭...\");\n    }\n    \n    public void say(){\n        System.out.println(\"我叫\" + name + \"，我今年\" + age + \"岁\");\n    }\n}\n```\n\n这里我们定义了一个类，类的名字叫做`Person`，它有两个属性，一个是`name`，一个是`age`。并且有三个方法，一个是构造函数，两个是Person的行为，吃饭和说话。\n\n可以看到，定义类的时候，我们是这样的：\n\n```java\npublic class Person{\n\t...\n}\n```\n\n定义类的格式为：\n\n> [访问权限修饰符] + class + [类名] \n\n其中访问权限修饰符用来表示类是否可以被外部类访问，`public`是最宽松的访问权限，表示这个类可以被外部的类访问和使用。关于访问权限修饰符，后面还会有更详细的介绍。\n\n`class`是用来声明一个类的关键字。什么是关键字呢？可以理解为一种声明，就像武功招式一样，大都会有一个起手式。Java中的关键字其实不多，常用的就更少，所以在之后的学习过程中慢慢掌握就好了，不用太担心。\n\n关于类名，跟变量名一样，必须以字母开头，可以由字母、数字和下划线和$组成，但跟变量命名不同的是，Java中的类名规范通常使用大驼峰命名法，即每个单词的首字母都大写。比如：SmallCar、SecondhandBook。\n\n## 类的组成\n\n一个类主要由实例域和方法域组成，实例域由类的成员变量组成，上面的栗子中，Person类的实例域为：\n\n```java\nprivate String name;\nprivate int age;\n```\n\n这是Person类的两个成员变量，也叫Person类的属性，一个人有名字和年龄，在这里对应的两个属性就是`name`和`age`。\n\n成员变量定义的规则为：\n\n> [访问修饰符] + [成员变量类型] + [变量名]\n\n接下来是方法域，顾名思义便是由各种方法组成的。方法的定义规则为：\n\n> [访问修饰符] + [方法返回值类型] + [方法名]\n\n```java\npublic void eat(){\n    System.out.println(\"开始吃饭...\");\n}\n\npublic void say(){\n    System.out.println(\"我叫\" + name + \"，我今年\" + age + \"岁\");\n}\n```\n\n这里，`void`表示当前方法无返回值。方法的命名跟变量的命名规则一样，也使用小驼峰命名法。需要注意的一点是，无论是类名、方法名还是变量名，都需要具有一定的意义，也就是要能够传达出它代表的含义，做到见名知义。像`a1`、`a2`这样的命名就尽量不要出现。\n\n也许你会好奇，上面不是还有一个方法吗？为什看起来有点奇怪呢？为什么它不使用小驼峰，为什么它跟类名是一样的？\n\n```java\npublic Person(String name, int age){\n    this.name = name;\n    this.age = age;\n}\n```\n\n这是一个好问题，它叫做**构造函数**，是创建变量时使用的一个特殊的方法，与类名同名。这个方法有两个参数，一个是`String`类型，一个是`int`类型，`name`和`age`是参数名，跟变量名类似。这里面还用了一个`this`关键字，代表当前对象，可以看到参数名跟上面的成员变量名相同，为了将它们区分开来，就使用了`this.name`和`this.age`来表示成员变量。这个方法的作用就是接收传进来的两个参数，并将它们分别赋值给成员变量。关于构造函数的具体作用会在之后的篇章里做说明，这里就先不详细介绍了。\n\n## 对象的创建和使用\n\n既然已经有了类，那么如何创建对象呢？这时候就需要使用新的招式——`new`关键字。下面我们在Person类中加入一个main方法（如果不记得main方法是干嘛的了，可以翻看一下上一篇的内容），并在其中创建一个Person对象并调用它的方法。\n\n```java\npublic class Person {\n    ...\n\n    public static void main(String[] args){\n        Person alice = new Person(\"Alice\", 18);\n        alice.say();\n        alice.eat();\n    }\n}\n```\n\n输出如下：\n\n```bash\n我叫Alice，我今年18岁\n开始吃饭...\n```\n\n老规矩，我们来逐行分析，首先我们使用了`new`关键字创建了一个对象：\n\n```java\nPerson alice = new Person(\"Alice\", 18);\n```\n\n在前面我们已经介绍过变量的声明方式了，回顾一下：\n\n> [类名] + [变量名]\n\nPerson是类名，alice是变量的名字，后面半段的作用是创建对象。往里面传了两个参数：`Alice`和`18`。创建好对象后，赋值给alice变量。\n\n然后我们分别调用了两个方法，`say`和`eat`。方法调用的格式为：\n\n> [对象] + 点号 + [方法名] + [参数]\n\n```java\nalice.say();\nalice.eat();\n```\n\n这两个方法都不需要传参数，可以直接调用。这样，我们就完成了创建对象并调用的全过程。\n\n# 小结\n\n本篇文章到此就告一段落了，本篇内容相对较多一点，而且也是相当重要的一篇，希望能仔细阅读，能通过本篇的学习了解类和对象是什么，以及如何使用。\n\n也许到这里你还有很多疑惑，但没有关系，在之后的学习和练习的过程中，相信你会慢慢理解的。当然，也欢迎留言提问，博主看到后会统一回复的。","source":"_posts/java/basic/java-class.md","raw":"---\ntitle: 【Java基础篇】三、Java 类与对象\ntags: \n - Java基础\n - Java\ncategories: 编程\ndate: 2018-12-29 00:05:00\n---\n\n# Java 类与对象\n\n>**“Sometimes we stare so long at a door that is closing that we see too late the one that is open.”**\n>\n>— Alexander Graham Bell, Inventor\n>\n>**「我们有时候专注于消失中的机会太久，以致于太晚发现开启的机会。」**– 亚历山大‧贝尔 (发明家)\n\n## 关卡说明\n\n关卡描述：Java是一门面向对象的语言，类和对象是Java中最重要的概念，本关将介绍这两个重要的概念，并通过一个简单的栗子来进行说明，你能否通过本关的考验呢？\n\n过关条件：理解面向对象编程的特点，理解Java中类和对象的关系，以及如何使用它们\n\n关卡难度：⭐️⭐️\n\n## 面向对象程序设计\n\n面向对象编程（Object Oriented Programming 简称OOP）是当今主流的程序设计规范，Java是完全面向对象的，所以必须熟悉OOP才能编写出优秀的Java代码。\n\n面向对象编程，顾名思义，重点就在于这个对象，没有对象怎么编程（手动滑稽）。咳咳，言归正传，面向对象的程序是由许许多多的对象组成，每个对象具有一定的属性和行为，通过对象之间的交互来实现软件的功能。从根本上来说，只要这个对象能满足功能要求，就不必关心它的具体实现过程。换句话说，不管是黑猫白猫，能抓耗子的猫就是好猫。\n\n传统的程序设计是面向过程编程，在传统的程序设计过程中，通常需要先设计一系列的算法来求解问题，然后再考虑存储数据的方式。这就是所谓的：\n\n> 算法 + 数据结构 = 程序\n\n在面向过程的设计中，算法是放在第一位的，数据结构是为了适应算法而存在的。\n\n而在OOP中，这个顺序刚好相反，数据结构放在第一位，然后再考虑操作数据的算法。\n\n两种开发方式各有利弊，一些简单的问题，使用面向过程的开发方式是比较容易的，因为它符合人们的惯常思考方式，先这样做，再那样做，最后得到一个什么样的结果。而面向对象的编程适合于解决更复杂的问题。比如实现一个网站也许需要1000个函数，这些过程可能会对一组全局的数据进行操作。如果采用面向对象的方式来设计，可能只需要大约100个类，每个类10个方法，而且大多数情况下，面向过程开发的代码中有很多设计是可以使用面向对象的方式简化和复用的。所以后者显然更容易掌握和维护，而且如果万一某个数据出了问题，在10个方法中排查总比在1000个函数中排查要容易得多。\n\n## Java中的类和对象\n\n既然面向对象编程这么优秀，那么我们就来好好认识一下这其中的主人公——类和对象。\n\n“类”是对具有相同属性的一系列事物的抽象，比如说，“人类”，描述的就是有“人”这个共同属性和行为的群体，普通的人都有两只手，两只脚等基本外貌特征，也具有说话，吃东西等能力，比如“轿车”描述的是有四个轮子，可以驾驶，可以载人的小型车辆，不管你是黑色的奔驰还是白色的宝马，都可以叫做轿车。\n\n那么什么是对象呢？对象就是类的某个具体实例，就好比你和我都是“人类”的一个具体实例，所以我们都是“人类”的一个对象。你家车库里的那辆轿车（不管是奔驰还是大众），也是“轿车”的一个对象。\n\n> 类是抽象的概念，是对具有共同特征的事物的抽象，而对象则是具体的概念，是指某一个具体的实例。\n\n类可以看作是对象的模子，可以用它来生产任意多个对象。\n\n## 类的定义\n\n先来看一个小栗子，我们来定义一个人类：\n\n```java\npublic class Person{\n    private String name;\n    private int age;\n    \n    public Person(String name, int age){\n        this.name = name;\n        this.age = age;\n    }\n    \n    public void eat(){\n        System.out.println(\"开始吃饭...\");\n    }\n    \n    public void say(){\n        System.out.println(\"我叫\" + name + \"，我今年\" + age + \"岁\");\n    }\n}\n```\n\n这里我们定义了一个类，类的名字叫做`Person`，它有两个属性，一个是`name`，一个是`age`。并且有三个方法，一个是构造函数，两个是Person的行为，吃饭和说话。\n\n可以看到，定义类的时候，我们是这样的：\n\n```java\npublic class Person{\n\t...\n}\n```\n\n定义类的格式为：\n\n> [访问权限修饰符] + class + [类名] \n\n其中访问权限修饰符用来表示类是否可以被外部类访问，`public`是最宽松的访问权限，表示这个类可以被外部的类访问和使用。关于访问权限修饰符，后面还会有更详细的介绍。\n\n`class`是用来声明一个类的关键字。什么是关键字呢？可以理解为一种声明，就像武功招式一样，大都会有一个起手式。Java中的关键字其实不多，常用的就更少，所以在之后的学习过程中慢慢掌握就好了，不用太担心。\n\n关于类名，跟变量名一样，必须以字母开头，可以由字母、数字和下划线和$组成，但跟变量命名不同的是，Java中的类名规范通常使用大驼峰命名法，即每个单词的首字母都大写。比如：SmallCar、SecondhandBook。\n\n## 类的组成\n\n一个类主要由实例域和方法域组成，实例域由类的成员变量组成，上面的栗子中，Person类的实例域为：\n\n```java\nprivate String name;\nprivate int age;\n```\n\n这是Person类的两个成员变量，也叫Person类的属性，一个人有名字和年龄，在这里对应的两个属性就是`name`和`age`。\n\n成员变量定义的规则为：\n\n> [访问修饰符] + [成员变量类型] + [变量名]\n\n接下来是方法域，顾名思义便是由各种方法组成的。方法的定义规则为：\n\n> [访问修饰符] + [方法返回值类型] + [方法名]\n\n```java\npublic void eat(){\n    System.out.println(\"开始吃饭...\");\n}\n\npublic void say(){\n    System.out.println(\"我叫\" + name + \"，我今年\" + age + \"岁\");\n}\n```\n\n这里，`void`表示当前方法无返回值。方法的命名跟变量的命名规则一样，也使用小驼峰命名法。需要注意的一点是，无论是类名、方法名还是变量名，都需要具有一定的意义，也就是要能够传达出它代表的含义，做到见名知义。像`a1`、`a2`这样的命名就尽量不要出现。\n\n也许你会好奇，上面不是还有一个方法吗？为什看起来有点奇怪呢？为什么它不使用小驼峰，为什么它跟类名是一样的？\n\n```java\npublic Person(String name, int age){\n    this.name = name;\n    this.age = age;\n}\n```\n\n这是一个好问题，它叫做**构造函数**，是创建变量时使用的一个特殊的方法，与类名同名。这个方法有两个参数，一个是`String`类型，一个是`int`类型，`name`和`age`是参数名，跟变量名类似。这里面还用了一个`this`关键字，代表当前对象，可以看到参数名跟上面的成员变量名相同，为了将它们区分开来，就使用了`this.name`和`this.age`来表示成员变量。这个方法的作用就是接收传进来的两个参数，并将它们分别赋值给成员变量。关于构造函数的具体作用会在之后的篇章里做说明，这里就先不详细介绍了。\n\n## 对象的创建和使用\n\n既然已经有了类，那么如何创建对象呢？这时候就需要使用新的招式——`new`关键字。下面我们在Person类中加入一个main方法（如果不记得main方法是干嘛的了，可以翻看一下上一篇的内容），并在其中创建一个Person对象并调用它的方法。\n\n```java\npublic class Person {\n    ...\n\n    public static void main(String[] args){\n        Person alice = new Person(\"Alice\", 18);\n        alice.say();\n        alice.eat();\n    }\n}\n```\n\n输出如下：\n\n```bash\n我叫Alice，我今年18岁\n开始吃饭...\n```\n\n老规矩，我们来逐行分析，首先我们使用了`new`关键字创建了一个对象：\n\n```java\nPerson alice = new Person(\"Alice\", 18);\n```\n\n在前面我们已经介绍过变量的声明方式了，回顾一下：\n\n> [类名] + [变量名]\n\nPerson是类名，alice是变量的名字，后面半段的作用是创建对象。往里面传了两个参数：`Alice`和`18`。创建好对象后，赋值给alice变量。\n\n然后我们分别调用了两个方法，`say`和`eat`。方法调用的格式为：\n\n> [对象] + 点号 + [方法名] + [参数]\n\n```java\nalice.say();\nalice.eat();\n```\n\n这两个方法都不需要传参数，可以直接调用。这样，我们就完成了创建对象并调用的全过程。\n\n# 小结\n\n本篇文章到此就告一段落了，本篇内容相对较多一点，而且也是相当重要的一篇，希望能仔细阅读，能通过本篇的学习了解类和对象是什么，以及如何使用。\n\n也许到这里你还有很多疑惑，但没有关系，在之后的学习和练习的过程中，相信你会慢慢理解的。当然，也欢迎留言提问，博主看到后会统一回复的。","slug":"java/basic/java-class","published":1,"updated":"2019-06-04T01:29:57.095Z","_id":"cjxze3gum00430cvwm6fg8irc","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Java-类与对象\"><a href=\"#Java-类与对象\" class=\"headerlink\" title=\"Java 类与对象\"></a>Java 类与对象</h1><blockquote>\n<p><strong>“Sometimes we stare so long at a door that is closing that we see too late the one that is open.”</strong></p>\n<p>— Alexander Graham Bell, Inventor</p>\n<p><strong>「我们有时候专注于消失中的机会太久，以致于太晚发现开启的机会。」</strong>– 亚历山大‧贝尔 (发明家)</p>\n</blockquote>\n<h2 id=\"关卡说明\"><a href=\"#关卡说明\" class=\"headerlink\" title=\"关卡说明\"></a>关卡说明</h2><p>关卡描述：Java是一门面向对象的语言，类和对象是Java中最重要的概念，本关将介绍这两个重要的概念，并通过一个简单的栗子来进行说明，你能否通过本关的考验呢？</p>\n<p>过关条件：理解面向对象编程的特点，理解Java中类和对象的关系，以及如何使用它们</p>\n<p>关卡难度：⭐️⭐️</p>\n<h2 id=\"面向对象程序设计\"><a href=\"#面向对象程序设计\" class=\"headerlink\" title=\"面向对象程序设计\"></a>面向对象程序设计</h2><p>面向对象编程（Object Oriented Programming 简称OOP）是当今主流的程序设计规范，Java是完全面向对象的，所以必须熟悉OOP才能编写出优秀的Java代码。</p>\n<p>面向对象编程，顾名思义，重点就在于这个对象，没有对象怎么编程（手动滑稽）。咳咳，言归正传，面向对象的程序是由许许多多的对象组成，每个对象具有一定的属性和行为，通过对象之间的交互来实现软件的功能。从根本上来说，只要这个对象能满足功能要求，就不必关心它的具体实现过程。换句话说，不管是黑猫白猫，能抓耗子的猫就是好猫。</p>\n<p>传统的程序设计是面向过程编程，在传统的程序设计过程中，通常需要先设计一系列的算法来求解问题，然后再考虑存储数据的方式。这就是所谓的：</p>\n<blockquote>\n<p>算法 + 数据结构 = 程序</p>\n</blockquote>\n<p>在面向过程的设计中，算法是放在第一位的，数据结构是为了适应算法而存在的。</p>\n<p>而在OOP中，这个顺序刚好相反，数据结构放在第一位，然后再考虑操作数据的算法。</p>\n<p>两种开发方式各有利弊，一些简单的问题，使用面向过程的开发方式是比较容易的，因为它符合人们的惯常思考方式，先这样做，再那样做，最后得到一个什么样的结果。而面向对象的编程适合于解决更复杂的问题。比如实现一个网站也许需要1000个函数，这些过程可能会对一组全局的数据进行操作。如果采用面向对象的方式来设计，可能只需要大约100个类，每个类10个方法，而且大多数情况下，面向过程开发的代码中有很多设计是可以使用面向对象的方式简化和复用的。所以后者显然更容易掌握和维护，而且如果万一某个数据出了问题，在10个方法中排查总比在1000个函数中排查要容易得多。</p>\n<h2 id=\"Java中的类和对象\"><a href=\"#Java中的类和对象\" class=\"headerlink\" title=\"Java中的类和对象\"></a>Java中的类和对象</h2><p>既然面向对象编程这么优秀，那么我们就来好好认识一下这其中的主人公——类和对象。</p>\n<p>“类”是对具有相同属性的一系列事物的抽象，比如说，“人类”，描述的就是有“人”这个共同属性和行为的群体，普通的人都有两只手，两只脚等基本外貌特征，也具有说话，吃东西等能力，比如“轿车”描述的是有四个轮子，可以驾驶，可以载人的小型车辆，不管你是黑色的奔驰还是白色的宝马，都可以叫做轿车。</p>\n<p>那么什么是对象呢？对象就是类的某个具体实例，就好比你和我都是“人类”的一个具体实例，所以我们都是“人类”的一个对象。你家车库里的那辆轿车（不管是奔驰还是大众），也是“轿车”的一个对象。</p>\n<blockquote>\n<p>类是抽象的概念，是对具有共同特征的事物的抽象，而对象则是具体的概念，是指某一个具体的实例。</p>\n</blockquote>\n<p>类可以看作是对象的模子，可以用它来生产任意多个对象。</p>\n<h2 id=\"类的定义\"><a href=\"#类的定义\" class=\"headerlink\" title=\"类的定义\"></a>类的定义</h2><p>先来看一个小栗子，我们来定义一个人类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"开始吃饭...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"我叫\"</span> + name + <span class=\"string\">\"，我今年\"</span> + age + <span class=\"string\">\"岁\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们定义了一个类，类的名字叫做<code>Person</code>，它有两个属性，一个是<code>name</code>，一个是<code>age</code>。并且有三个方法，一个是构造函数，两个是Person的行为，吃饭和说话。</p>\n<p>可以看到，定义类的时候，我们是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义类的格式为：</p>\n<blockquote>\n<p>[访问权限修饰符] + class + [类名] </p>\n</blockquote>\n<p>其中访问权限修饰符用来表示类是否可以被外部类访问，<code>public</code>是最宽松的访问权限，表示这个类可以被外部的类访问和使用。关于访问权限修饰符，后面还会有更详细的介绍。</p>\n<p><code>class</code>是用来声明一个类的关键字。什么是关键字呢？可以理解为一种声明，就像武功招式一样，大都会有一个起手式。Java中的关键字其实不多，常用的就更少，所以在之后的学习过程中慢慢掌握就好了，不用太担心。</p>\n<p>关于类名，跟变量名一样，必须以字母开头，可以由字母、数字和下划线和$组成，但跟变量命名不同的是，Java中的类名规范通常使用大驼峰命名法，即每个单词的首字母都大写。比如：SmallCar、SecondhandBook。</p>\n<h2 id=\"类的组成\"><a href=\"#类的组成\" class=\"headerlink\" title=\"类的组成\"></a>类的组成</h2><p>一个类主要由实例域和方法域组成，实例域由类的成员变量组成，上面的栗子中，Person类的实例域为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br></pre></td></tr></table></figure>\n<p>这是Person类的两个成员变量，也叫Person类的属性，一个人有名字和年龄，在这里对应的两个属性就是<code>name</code>和<code>age</code>。</p>\n<p>成员变量定义的规则为：</p>\n<blockquote>\n<p>[访问修饰符] + [成员变量类型] + [变量名]</p>\n</blockquote>\n<p>接下来是方法域，顾名思义便是由各种方法组成的。方法的定义规则为：</p>\n<blockquote>\n<p>[访问修饰符] + [方法返回值类型] + [方法名]</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"开始吃饭...\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"我叫\"</span> + name + <span class=\"string\">\"，我今年\"</span> + age + <span class=\"string\">\"岁\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里，<code>void</code>表示当前方法无返回值。方法的命名跟变量的命名规则一样，也使用小驼峰命名法。需要注意的一点是，无论是类名、方法名还是变量名，都需要具有一定的意义，也就是要能够传达出它代表的含义，做到见名知义。像<code>a1</code>、<code>a2</code>这样的命名就尽量不要出现。</p>\n<p>也许你会好奇，上面不是还有一个方法吗？为什看起来有点奇怪呢？为什么它不使用小驼峰，为什么它跟类名是一样的？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个好问题，它叫做<strong>构造函数</strong>，是创建变量时使用的一个特殊的方法，与类名同名。这个方法有两个参数，一个是<code>String</code>类型，一个是<code>int</code>类型，<code>name</code>和<code>age</code>是参数名，跟变量名类似。这里面还用了一个<code>this</code>关键字，代表当前对象，可以看到参数名跟上面的成员变量名相同，为了将它们区分开来，就使用了<code>this.name</code>和<code>this.age</code>来表示成员变量。这个方法的作用就是接收传进来的两个参数，并将它们分别赋值给成员变量。关于构造函数的具体作用会在之后的篇章里做说明，这里就先不详细介绍了。</p>\n<h2 id=\"对象的创建和使用\"><a href=\"#对象的创建和使用\" class=\"headerlink\" title=\"对象的创建和使用\"></a>对象的创建和使用</h2><p>既然已经有了类，那么如何创建对象呢？这时候就需要使用新的招式——<code>new</code>关键字。下面我们在Person类中加入一个main方法（如果不记得main方法是干嘛的了，可以翻看一下上一篇的内容），并在其中创建一个Person对象并调用它的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Person alice = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Alice\"</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">        alice.say();</span><br><span class=\"line\">        alice.eat();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我叫Alice，我今年18岁</span><br><span class=\"line\">开始吃饭...</span><br></pre></td></tr></table></figure>\n<p>老规矩，我们来逐行分析，首先我们使用了<code>new</code>关键字创建了一个对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person alice = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Alice\"</span>, <span class=\"number\">18</span>);</span><br></pre></td></tr></table></figure>\n<p>在前面我们已经介绍过变量的声明方式了，回顾一下：</p>\n<blockquote>\n<p>[类名] + [变量名]</p>\n</blockquote>\n<p>Person是类名，alice是变量的名字，后面半段的作用是创建对象。往里面传了两个参数：<code>Alice</code>和<code>18</code>。创建好对象后，赋值给alice变量。</p>\n<p>然后我们分别调用了两个方法，<code>say</code>和<code>eat</code>。方法调用的格式为：</p>\n<blockquote>\n<p>[对象] + 点号 + [方法名] + [参数]</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alice.say();</span><br><span class=\"line\">alice.eat();</span><br></pre></td></tr></table></figure>\n<p>这两个方法都不需要传参数，可以直接调用。这样，我们就完成了创建对象并调用的全过程。</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>本篇文章到此就告一段落了，本篇内容相对较多一点，而且也是相当重要的一篇，希望能仔细阅读，能通过本篇的学习了解类和对象是什么，以及如何使用。</p>\n<p>也许到这里你还有很多疑惑，但没有关系，在之后的学习和练习的过程中，相信你会慢慢理解的。当然，也欢迎留言提问，博主看到后会统一回复的。</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h1 id=\"Java-类与对象\"><a href=\"#Java-类与对象\" class=\"headerlink\" title=\"Java 类与对象\"></a>Java 类与对象</h1><blockquote>\n<p><strong>“Sometimes we stare so long at a door that is closing that we see too late the one that is open.”</strong></p>\n<p>— Alexander Graham Bell, Inventor</p>\n<p><strong>「我们有时候专注于消失中的机会太久，以致于太晚发现开启的机会。」</strong>– 亚历山大‧贝尔 (发明家)</p>\n</blockquote>\n<h2 id=\"关卡说明\"><a href=\"#关卡说明\" class=\"headerlink\" title=\"关卡说明\"></a>关卡说明</h2><p>关卡描述：Java是一门面向对象的语言，类和对象是Java中最重要的概念，本关将介绍这两个重要的概念，并通过一个简单的栗子来进行说明，你能否通过本关的考验呢？</p>\n<p>过关条件：理解面向对象编程的特点，理解Java中类和对象的关系，以及如何使用它们</p>\n<p>关卡难度：⭐️⭐️</p>\n<h2 id=\"面向对象程序设计\"><a href=\"#面向对象程序设计\" class=\"headerlink\" title=\"面向对象程序设计\"></a>面向对象程序设计</h2><p>面向对象编程（Object Oriented Programming 简称OOP）是当今主流的程序设计规范，Java是完全面向对象的，所以必须熟悉OOP才能编写出优秀的Java代码。</p>\n<p>面向对象编程，顾名思义，重点就在于这个对象，没有对象怎么编程（手动滑稽）。咳咳，言归正传，面向对象的程序是由许许多多的对象组成，每个对象具有一定的属性和行为，通过对象之间的交互来实现软件的功能。从根本上来说，只要这个对象能满足功能要求，就不必关心它的具体实现过程。换句话说，不管是黑猫白猫，能抓耗子的猫就是好猫。</p>\n<p>传统的程序设计是面向过程编程，在传统的程序设计过程中，通常需要先设计一系列的算法来求解问题，然后再考虑存储数据的方式。这就是所谓的：</p>\n<blockquote>\n<p>算法 + 数据结构 = 程序</p>\n</blockquote>\n<p>在面向过程的设计中，算法是放在第一位的，数据结构是为了适应算法而存在的。</p>\n<p>而在OOP中，这个顺序刚好相反，数据结构放在第一位，然后再考虑操作数据的算法。</p>\n<p>两种开发方式各有利弊，一些简单的问题，使用面向过程的开发方式是比较容易的，因为它符合人们的惯常思考方式，先这样做，再那样做，最后得到一个什么样的结果。而面向对象的编程适合于解决更复杂的问题。比如实现一个网站也许需要1000个函数，这些过程可能会对一组全局的数据进行操作。如果采用面向对象的方式来设计，可能只需要大约100个类，每个类10个方法，而且大多数情况下，面向过程开发的代码中有很多设计是可以使用面向对象的方式简化和复用的。所以后者显然更容易掌握和维护，而且如果万一某个数据出了问题，在10个方法中排查总比在1000个函数中排查要容易得多。</p>\n<h2 id=\"Java中的类和对象\"><a href=\"#Java中的类和对象\" class=\"headerlink\" title=\"Java中的类和对象\"></a>Java中的类和对象</h2><p>既然面向对象编程这么优秀，那么我们就来好好认识一下这其中的主人公——类和对象。</p>\n<p>“类”是对具有相同属性的一系列事物的抽象，比如说，“人类”，描述的就是有“人”这个共同属性和行为的群体，普通的人都有两只手，两只脚等基本外貌特征，也具有说话，吃东西等能力，比如“轿车”描述的是有四个轮子，可以驾驶，可以载人的小型车辆，不管你是黑色的奔驰还是白色的宝马，都可以叫做轿车。</p>\n<p>那么什么是对象呢？对象就是类的某个具体实例，就好比你和我都是“人类”的一个具体实例，所以我们都是“人类”的一个对象。你家车库里的那辆轿车（不管是奔驰还是大众），也是“轿车”的一个对象。</p>\n<blockquote>\n<p>类是抽象的概念，是对具有共同特征的事物的抽象，而对象则是具体的概念，是指某一个具体的实例。</p>\n</blockquote>\n<p>类可以看作是对象的模子，可以用它来生产任意多个对象。</p>\n<h2 id=\"类的定义\"><a href=\"#类的定义\" class=\"headerlink\" title=\"类的定义\"></a>类的定义</h2><p>先来看一个小栗子，我们来定义一个人类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"开始吃饭...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"我叫\"</span> + name + <span class=\"string\">\"，我今年\"</span> + age + <span class=\"string\">\"岁\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们定义了一个类，类的名字叫做<code>Person</code>，它有两个属性，一个是<code>name</code>，一个是<code>age</code>。并且有三个方法，一个是构造函数，两个是Person的行为，吃饭和说话。</p>\n<p>可以看到，定义类的时候，我们是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义类的格式为：</p>\n<blockquote>\n<p>[访问权限修饰符] + class + [类名] </p>\n</blockquote>\n<p>其中访问权限修饰符用来表示类是否可以被外部类访问，<code>public</code>是最宽松的访问权限，表示这个类可以被外部的类访问和使用。关于访问权限修饰符，后面还会有更详细的介绍。</p>\n<p><code>class</code>是用来声明一个类的关键字。什么是关键字呢？可以理解为一种声明，就像武功招式一样，大都会有一个起手式。Java中的关键字其实不多，常用的就更少，所以在之后的学习过程中慢慢掌握就好了，不用太担心。</p>\n<p>关于类名，跟变量名一样，必须以字母开头，可以由字母、数字和下划线和$组成，但跟变量命名不同的是，Java中的类名规范通常使用大驼峰命名法，即每个单词的首字母都大写。比如：SmallCar、SecondhandBook。</p>\n<h2 id=\"类的组成\"><a href=\"#类的组成\" class=\"headerlink\" title=\"类的组成\"></a>类的组成</h2><p>一个类主要由实例域和方法域组成，实例域由类的成员变量组成，上面的栗子中，Person类的实例域为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br></pre></td></tr></table></figure>\n<p>这是Person类的两个成员变量，也叫Person类的属性，一个人有名字和年龄，在这里对应的两个属性就是<code>name</code>和<code>age</code>。</p>\n<p>成员变量定义的规则为：</p>\n<blockquote>\n<p>[访问修饰符] + [成员变量类型] + [变量名]</p>\n</blockquote>\n<p>接下来是方法域，顾名思义便是由各种方法组成的。方法的定义规则为：</p>\n<blockquote>\n<p>[访问修饰符] + [方法返回值类型] + [方法名]</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"开始吃饭...\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"我叫\"</span> + name + <span class=\"string\">\"，我今年\"</span> + age + <span class=\"string\">\"岁\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里，<code>void</code>表示当前方法无返回值。方法的命名跟变量的命名规则一样，也使用小驼峰命名法。需要注意的一点是，无论是类名、方法名还是变量名，都需要具有一定的意义，也就是要能够传达出它代表的含义，做到见名知义。像<code>a1</code>、<code>a2</code>这样的命名就尽量不要出现。</p>\n<p>也许你会好奇，上面不是还有一个方法吗？为什看起来有点奇怪呢？为什么它不使用小驼峰，为什么它跟类名是一样的？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个好问题，它叫做<strong>构造函数</strong>，是创建变量时使用的一个特殊的方法，与类名同名。这个方法有两个参数，一个是<code>String</code>类型，一个是<code>int</code>类型，<code>name</code>和<code>age</code>是参数名，跟变量名类似。这里面还用了一个<code>this</code>关键字，代表当前对象，可以看到参数名跟上面的成员变量名相同，为了将它们区分开来，就使用了<code>this.name</code>和<code>this.age</code>来表示成员变量。这个方法的作用就是接收传进来的两个参数，并将它们分别赋值给成员变量。关于构造函数的具体作用会在之后的篇章里做说明，这里就先不详细介绍了。</p>\n<h2 id=\"对象的创建和使用\"><a href=\"#对象的创建和使用\" class=\"headerlink\" title=\"对象的创建和使用\"></a>对象的创建和使用</h2><p>既然已经有了类，那么如何创建对象呢？这时候就需要使用新的招式——<code>new</code>关键字。下面我们在Person类中加入一个main方法（如果不记得main方法是干嘛的了，可以翻看一下上一篇的内容），并在其中创建一个Person对象并调用它的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Person alice = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Alice\"</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">        alice.say();</span><br><span class=\"line\">        alice.eat();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我叫Alice，我今年18岁</span><br><span class=\"line\">开始吃饭...</span><br></pre></td></tr></table></figure>\n<p>老规矩，我们来逐行分析，首先我们使用了<code>new</code>关键字创建了一个对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person alice = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Alice\"</span>, <span class=\"number\">18</span>);</span><br></pre></td></tr></table></figure>\n<p>在前面我们已经介绍过变量的声明方式了，回顾一下：</p>\n<blockquote>\n<p>[类名] + [变量名]</p>\n</blockquote>\n<p>Person是类名，alice是变量的名字，后面半段的作用是创建对象。往里面传了两个参数：<code>Alice</code>和<code>18</code>。创建好对象后，赋值给alice变量。</p>\n<p>然后我们分别调用了两个方法，<code>say</code>和<code>eat</code>。方法调用的格式为：</p>\n<blockquote>\n<p>[对象] + 点号 + [方法名] + [参数]</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alice.say();</span><br><span class=\"line\">alice.eat();</span><br></pre></td></tr></table></figure>\n<p>这两个方法都不需要传参数，可以直接调用。这样，我们就完成了创建对象并调用的全过程。</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>本篇文章到此就告一段落了，本篇内容相对较多一点，而且也是相当重要的一篇，希望能仔细阅读，能通过本篇的学习了解类和对象是什么，以及如何使用。</p>\n<p>也许到这里你还有很多疑惑，但没有关系，在之后的学习和练习的过程中，相信你会慢慢理解的。当然，也欢迎留言提问，博主看到后会统一回复的。</p>\n"},{"title":"【Java入门篇】五、Java 开发简介","date":"2018-12-28T11:00:05.000Z","_content":"\n> 每个人都衣冠楚楚，从来没有人会关心光芒万丈的外表下那藏在角落的，发了霉的落寞。  -- 《西风》\n\n## 前言\n\n万事开头难，如果你已经顺利通过了前面安装环境的考验，那么恭喜你已经拿到了Java世界的钥匙，在打开这扇大门之前，我想再说说我玩这个游戏的一些经验，希望能帮助你在这个游戏里有更好的表现。\n\n前面两篇已经介绍了Java开发环境搭建和IDE的下载安装，如果进行顺利的话，那么现在世界上最好的语言之一和世界上最好用的Java IDE（没有之一，不接受反驳）已经握在了你的手中。所以现在你所需要学习的，就是如何使用这些工具。\n\n但在此之前，还想先说一说其他的内容。\n\n## 关于方向\n\n当你下定决心走上Java的探索之旅时，你需要确定一个大概的方向，有方向才会有学习下去的动力。\n\n如果只是单纯的想体验一下Java开发是怎样的，那么可以跟着本系列文章进行尝试，选择学习使用Java来开发一个你想要的功能，比如学习如何用Java来开发一个定时提醒功能，在固定时间或者某些特定事件发生后给你发送闹铃提示或者邮件提示。又比如使用Java来开发QQ、微信机器人，自动接收群友消息并自动回复。兴趣是最好的老师，选择一个你感兴趣的方向，你才能走的更远。\n\n如果你打算使用Java来找工作，并有较充沛的学习时间预算，那么我建议你多花一点时间在基础的内容上，把Java基础的部分啃透会让你在之后的学习里轻松很多。\n\n如果你对Java有着强烈的兴趣，对Java有过一段时间的自学，但却因为无法坚持而中途放弃，那么我建议你找一批共同学习的伙伴，在相互交流探讨中，也许可以激发你学习的动力。\n\n很多人会问，我不是学计算机相关的专业，我以前从未接触过编程，但是我想学Java，以后会不会不好找工作？跟别人比是不是没有竞争力？\n\n对此，我只能负责任的说，是的，但也不全是。\n\n有时候，选择比努力更重要，别人选了计算机专业，软件工程专业，在IT行业找工作，相对而言确实比非相关专业的人要容易一点。别人学了计算机四年，比你有优势不是应该的吗。\n\n但也不要因此就觉得跨专业，跨行业是不可能的事情，事实上，很多Java从业者都不是计算机相关专业，他们带着各种各样的目的，通过各自的方法也同样走上了这条道路。\n\n我分享的初衷，是希望能让那些对编程充满热情，但是却对未来充满迷茫和困惑的人提供一点方向。\n\n## 关于努力\n\n确定了方向，剩下的事情就只有努力了，就像在学生时代那样，想要考出更好的成绩，只需要不断的刷题学习和总结。\n\n其实Java学习过程也一样，在Java这个游戏里，必须不断打怪升级才能提升自己，才能接到奖励更丰富的任务，也能获得更高的声望，声望高的人才能在这个游戏里获得别人的认可。\n\n那如何在这个游戏里获得更好的游戏体验，如何更快更好的提升自我呢？那就是借助前人的经验，在这个游戏里有大批的老玩家，他们在这个游戏世界里已经徜徉了多年，有的满足于每天接循环任务来获取金币，有的喜欢去野外探险，寻找boss挑战，有的喜欢刷副本，企图刷出绝世装备。他们大都有一个自己的经验法则来帮助他们在这个游戏里更好的生存和发展。如果能在这个游戏里交到一个亦师亦友的朋友，那么无疑能给你极大的帮助。\n\n但需要说明的一点是，努力的方式并不一定是通用的，因为每个人擅长的领域不一样，有的人反应很快，擅长单挑，所以通常是竞技场的常客，有的人擅长指挥，副本里队长名单里总有他们的身影。 就像之前所说，选择有时候比努力更重要，选择自己擅长的领域和方向去发展，也许会让你在这个游戏里有更重要的价值。\n\n至于如何努力，我个人觉得，看书应该是首选，经典的书籍往往经过了反复斟酌的优质内容，才有了现在的口碑，所以书籍内容不会有太多漏洞，不会像有些不负责任的博主，写博客只是为了博得关注，遇到不确定的地方，要么仅凭自己猜测，要么一笔带过，误导了很多读者。\n\n如果看书实在看不下去的话，可以看看经典的视频教程，慕课网的教程个人觉得还算不错，讲解比较形象，有兴趣的话可以去看看。\n\n如果还是不行，那就找两个有意思的项目来研究一下。想想看如何用Java来提高生活质量，或者来帮助你完成一些重复性的体力劳动。比如用Java来批量爬取图片，批量将txt文件导入Excel等等。\n\n## 正式起航\n\n这几篇大概把我平生的废话都说完了，一本正经的胡说八道了这么久，有点不习惯。如果让你感到无聊了，十分抱歉。【面壁中】\n\n如果你看完这些废话，觉得自己还是很有兴趣继续看下去，那么就让我们红尘作伴，活得潇潇洒洒。啊，说错了，说错了，让我们一起开始Java游戏世界的试炼吧！:stuck_out_tongue_closed_eyes:\n","source":"_posts/java/introduction/java-introduction.md","raw":"---\ntitle: 【Java入门篇】五、Java 开发简介\ntags: \n - Java入门\n - Java\ncategories: 编程\ndate: 2018-12-28 19:00:05\n---\n\n> 每个人都衣冠楚楚，从来没有人会关心光芒万丈的外表下那藏在角落的，发了霉的落寞。  -- 《西风》\n\n## 前言\n\n万事开头难，如果你已经顺利通过了前面安装环境的考验，那么恭喜你已经拿到了Java世界的钥匙，在打开这扇大门之前，我想再说说我玩这个游戏的一些经验，希望能帮助你在这个游戏里有更好的表现。\n\n前面两篇已经介绍了Java开发环境搭建和IDE的下载安装，如果进行顺利的话，那么现在世界上最好的语言之一和世界上最好用的Java IDE（没有之一，不接受反驳）已经握在了你的手中。所以现在你所需要学习的，就是如何使用这些工具。\n\n但在此之前，还想先说一说其他的内容。\n\n## 关于方向\n\n当你下定决心走上Java的探索之旅时，你需要确定一个大概的方向，有方向才会有学习下去的动力。\n\n如果只是单纯的想体验一下Java开发是怎样的，那么可以跟着本系列文章进行尝试，选择学习使用Java来开发一个你想要的功能，比如学习如何用Java来开发一个定时提醒功能，在固定时间或者某些特定事件发生后给你发送闹铃提示或者邮件提示。又比如使用Java来开发QQ、微信机器人，自动接收群友消息并自动回复。兴趣是最好的老师，选择一个你感兴趣的方向，你才能走的更远。\n\n如果你打算使用Java来找工作，并有较充沛的学习时间预算，那么我建议你多花一点时间在基础的内容上，把Java基础的部分啃透会让你在之后的学习里轻松很多。\n\n如果你对Java有着强烈的兴趣，对Java有过一段时间的自学，但却因为无法坚持而中途放弃，那么我建议你找一批共同学习的伙伴，在相互交流探讨中，也许可以激发你学习的动力。\n\n很多人会问，我不是学计算机相关的专业，我以前从未接触过编程，但是我想学Java，以后会不会不好找工作？跟别人比是不是没有竞争力？\n\n对此，我只能负责任的说，是的，但也不全是。\n\n有时候，选择比努力更重要，别人选了计算机专业，软件工程专业，在IT行业找工作，相对而言确实比非相关专业的人要容易一点。别人学了计算机四年，比你有优势不是应该的吗。\n\n但也不要因此就觉得跨专业，跨行业是不可能的事情，事实上，很多Java从业者都不是计算机相关专业，他们带着各种各样的目的，通过各自的方法也同样走上了这条道路。\n\n我分享的初衷，是希望能让那些对编程充满热情，但是却对未来充满迷茫和困惑的人提供一点方向。\n\n## 关于努力\n\n确定了方向，剩下的事情就只有努力了，就像在学生时代那样，想要考出更好的成绩，只需要不断的刷题学习和总结。\n\n其实Java学习过程也一样，在Java这个游戏里，必须不断打怪升级才能提升自己，才能接到奖励更丰富的任务，也能获得更高的声望，声望高的人才能在这个游戏里获得别人的认可。\n\n那如何在这个游戏里获得更好的游戏体验，如何更快更好的提升自我呢？那就是借助前人的经验，在这个游戏里有大批的老玩家，他们在这个游戏世界里已经徜徉了多年，有的满足于每天接循环任务来获取金币，有的喜欢去野外探险，寻找boss挑战，有的喜欢刷副本，企图刷出绝世装备。他们大都有一个自己的经验法则来帮助他们在这个游戏里更好的生存和发展。如果能在这个游戏里交到一个亦师亦友的朋友，那么无疑能给你极大的帮助。\n\n但需要说明的一点是，努力的方式并不一定是通用的，因为每个人擅长的领域不一样，有的人反应很快，擅长单挑，所以通常是竞技场的常客，有的人擅长指挥，副本里队长名单里总有他们的身影。 就像之前所说，选择有时候比努力更重要，选择自己擅长的领域和方向去发展，也许会让你在这个游戏里有更重要的价值。\n\n至于如何努力，我个人觉得，看书应该是首选，经典的书籍往往经过了反复斟酌的优质内容，才有了现在的口碑，所以书籍内容不会有太多漏洞，不会像有些不负责任的博主，写博客只是为了博得关注，遇到不确定的地方，要么仅凭自己猜测，要么一笔带过，误导了很多读者。\n\n如果看书实在看不下去的话，可以看看经典的视频教程，慕课网的教程个人觉得还算不错，讲解比较形象，有兴趣的话可以去看看。\n\n如果还是不行，那就找两个有意思的项目来研究一下。想想看如何用Java来提高生活质量，或者来帮助你完成一些重复性的体力劳动。比如用Java来批量爬取图片，批量将txt文件导入Excel等等。\n\n## 正式起航\n\n这几篇大概把我平生的废话都说完了，一本正经的胡说八道了这么久，有点不习惯。如果让你感到无聊了，十分抱歉。【面壁中】\n\n如果你看完这些废话，觉得自己还是很有兴趣继续看下去，那么就让我们红尘作伴，活得潇潇洒洒。啊，说错了，说错了，让我们一起开始Java游戏世界的试炼吧！:stuck_out_tongue_closed_eyes:\n","slug":"java/introduction/java-introduction","published":1,"updated":"2019-06-04T01:29:57.327Z","_id":"cjxze3guw00470cvw56eqtear","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>每个人都衣冠楚楚，从来没有人会关心光芒万丈的外表下那藏在角落的，发了霉的落寞。  – 《西风》</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>万事开头难，如果你已经顺利通过了前面安装环境的考验，那么恭喜你已经拿到了Java世界的钥匙，在打开这扇大门之前，我想再说说我玩这个游戏的一些经验，希望能帮助你在这个游戏里有更好的表现。</p>\n<p>前面两篇已经介绍了Java开发环境搭建和IDE的下载安装，如果进行顺利的话，那么现在世界上最好的语言之一和世界上最好用的Java IDE（没有之一，不接受反驳）已经握在了你的手中。所以现在你所需要学习的，就是如何使用这些工具。</p>\n<p>但在此之前，还想先说一说其他的内容。</p>\n<h2 id=\"关于方向\"><a href=\"#关于方向\" class=\"headerlink\" title=\"关于方向\"></a>关于方向</h2><p>当你下定决心走上Java的探索之旅时，你需要确定一个大概的方向，有方向才会有学习下去的动力。</p>\n<p>如果只是单纯的想体验一下Java开发是怎样的，那么可以跟着本系列文章进行尝试，选择学习使用Java来开发一个你想要的功能，比如学习如何用Java来开发一个定时提醒功能，在固定时间或者某些特定事件发生后给你发送闹铃提示或者邮件提示。又比如使用Java来开发QQ、微信机器人，自动接收群友消息并自动回复。兴趣是最好的老师，选择一个你感兴趣的方向，你才能走的更远。</p>\n<p>如果你打算使用Java来找工作，并有较充沛的学习时间预算，那么我建议你多花一点时间在基础的内容上，把Java基础的部分啃透会让你在之后的学习里轻松很多。</p>\n<p>如果你对Java有着强烈的兴趣，对Java有过一段时间的自学，但却因为无法坚持而中途放弃，那么我建议你找一批共同学习的伙伴，在相互交流探讨中，也许可以激发你学习的动力。</p>\n<p>很多人会问，我不是学计算机相关的专业，我以前从未接触过编程，但是我想学Java，以后会不会不好找工作？跟别人比是不是没有竞争力？</p>\n<p>对此，我只能负责任的说，是的，但也不全是。</p>\n<p>有时候，选择比努力更重要，别人选了计算机专业，软件工程专业，在IT行业找工作，相对而言确实比非相关专业的人要容易一点。别人学了计算机四年，比你有优势不是应该的吗。</p>\n<p>但也不要因此就觉得跨专业，跨行业是不可能的事情，事实上，很多Java从业者都不是计算机相关专业，他们带着各种各样的目的，通过各自的方法也同样走上了这条道路。</p>\n<p>我分享的初衷，是希望能让那些对编程充满热情，但是却对未来充满迷茫和困惑的人提供一点方向。</p>\n<h2 id=\"关于努力\"><a href=\"#关于努力\" class=\"headerlink\" title=\"关于努力\"></a>关于努力</h2><p>确定了方向，剩下的事情就只有努力了，就像在学生时代那样，想要考出更好的成绩，只需要不断的刷题学习和总结。</p>\n<p>其实Java学习过程也一样，在Java这个游戏里，必须不断打怪升级才能提升自己，才能接到奖励更丰富的任务，也能获得更高的声望，声望高的人才能在这个游戏里获得别人的认可。</p>\n<p>那如何在这个游戏里获得更好的游戏体验，如何更快更好的提升自我呢？那就是借助前人的经验，在这个游戏里有大批的老玩家，他们在这个游戏世界里已经徜徉了多年，有的满足于每天接循环任务来获取金币，有的喜欢去野外探险，寻找boss挑战，有的喜欢刷副本，企图刷出绝世装备。他们大都有一个自己的经验法则来帮助他们在这个游戏里更好的生存和发展。如果能在这个游戏里交到一个亦师亦友的朋友，那么无疑能给你极大的帮助。</p>\n<p>但需要说明的一点是，努力的方式并不一定是通用的，因为每个人擅长的领域不一样，有的人反应很快，擅长单挑，所以通常是竞技场的常客，有的人擅长指挥，副本里队长名单里总有他们的身影。 就像之前所说，选择有时候比努力更重要，选择自己擅长的领域和方向去发展，也许会让你在这个游戏里有更重要的价值。</p>\n<p>至于如何努力，我个人觉得，看书应该是首选，经典的书籍往往经过了反复斟酌的优质内容，才有了现在的口碑，所以书籍内容不会有太多漏洞，不会像有些不负责任的博主，写博客只是为了博得关注，遇到不确定的地方，要么仅凭自己猜测，要么一笔带过，误导了很多读者。</p>\n<p>如果看书实在看不下去的话，可以看看经典的视频教程，慕课网的教程个人觉得还算不错，讲解比较形象，有兴趣的话可以去看看。</p>\n<p>如果还是不行，那就找两个有意思的项目来研究一下。想想看如何用Java来提高生活质量，或者来帮助你完成一些重复性的体力劳动。比如用Java来批量爬取图片，批量将txt文件导入Excel等等。</p>\n<h2 id=\"正式起航\"><a href=\"#正式起航\" class=\"headerlink\" title=\"正式起航\"></a>正式起航</h2><p>这几篇大概把我平生的废话都说完了，一本正经的胡说八道了这么久，有点不习惯。如果让你感到无聊了，十分抱歉。【面壁中】</p>\n<p>如果你看完这些废话，觉得自己还是很有兴趣继续看下去，那么就让我们红尘作伴，活得潇潇洒洒。啊，说错了，说错了，让我们一起开始Java游戏世界的试炼吧！:stuck_out_tongue_closed_eyes:</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<blockquote>\n<p>每个人都衣冠楚楚，从来没有人会关心光芒万丈的外表下那藏在角落的，发了霉的落寞。  – 《西风》</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>万事开头难，如果你已经顺利通过了前面安装环境的考验，那么恭喜你已经拿到了Java世界的钥匙，在打开这扇大门之前，我想再说说我玩这个游戏的一些经验，希望能帮助你在这个游戏里有更好的表现。</p>\n<p>前面两篇已经介绍了Java开发环境搭建和IDE的下载安装，如果进行顺利的话，那么现在世界上最好的语言之一和世界上最好用的Java IDE（没有之一，不接受反驳）已经握在了你的手中。所以现在你所需要学习的，就是如何使用这些工具。</p>\n<p>但在此之前，还想先说一说其他的内容。</p>\n<h2 id=\"关于方向\"><a href=\"#关于方向\" class=\"headerlink\" title=\"关于方向\"></a>关于方向</h2><p>当你下定决心走上Java的探索之旅时，你需要确定一个大概的方向，有方向才会有学习下去的动力。</p>\n<p>如果只是单纯的想体验一下Java开发是怎样的，那么可以跟着本系列文章进行尝试，选择学习使用Java来开发一个你想要的功能，比如学习如何用Java来开发一个定时提醒功能，在固定时间或者某些特定事件发生后给你发送闹铃提示或者邮件提示。又比如使用Java来开发QQ、微信机器人，自动接收群友消息并自动回复。兴趣是最好的老师，选择一个你感兴趣的方向，你才能走的更远。</p>\n<p>如果你打算使用Java来找工作，并有较充沛的学习时间预算，那么我建议你多花一点时间在基础的内容上，把Java基础的部分啃透会让你在之后的学习里轻松很多。</p>\n<p>如果你对Java有着强烈的兴趣，对Java有过一段时间的自学，但却因为无法坚持而中途放弃，那么我建议你找一批共同学习的伙伴，在相互交流探讨中，也许可以激发你学习的动力。</p>\n<p>很多人会问，我不是学计算机相关的专业，我以前从未接触过编程，但是我想学Java，以后会不会不好找工作？跟别人比是不是没有竞争力？</p>\n<p>对此，我只能负责任的说，是的，但也不全是。</p>\n<p>有时候，选择比努力更重要，别人选了计算机专业，软件工程专业，在IT行业找工作，相对而言确实比非相关专业的人要容易一点。别人学了计算机四年，比你有优势不是应该的吗。</p>\n<p>但也不要因此就觉得跨专业，跨行业是不可能的事情，事实上，很多Java从业者都不是计算机相关专业，他们带着各种各样的目的，通过各自的方法也同样走上了这条道路。</p>\n<p>我分享的初衷，是希望能让那些对编程充满热情，但是却对未来充满迷茫和困惑的人提供一点方向。</p>\n<h2 id=\"关于努力\"><a href=\"#关于努力\" class=\"headerlink\" title=\"关于努力\"></a>关于努力</h2><p>确定了方向，剩下的事情就只有努力了，就像在学生时代那样，想要考出更好的成绩，只需要不断的刷题学习和总结。</p>\n<p>其实Java学习过程也一样，在Java这个游戏里，必须不断打怪升级才能提升自己，才能接到奖励更丰富的任务，也能获得更高的声望，声望高的人才能在这个游戏里获得别人的认可。</p>\n<p>那如何在这个游戏里获得更好的游戏体验，如何更快更好的提升自我呢？那就是借助前人的经验，在这个游戏里有大批的老玩家，他们在这个游戏世界里已经徜徉了多年，有的满足于每天接循环任务来获取金币，有的喜欢去野外探险，寻找boss挑战，有的喜欢刷副本，企图刷出绝世装备。他们大都有一个自己的经验法则来帮助他们在这个游戏里更好的生存和发展。如果能在这个游戏里交到一个亦师亦友的朋友，那么无疑能给你极大的帮助。</p>\n<p>但需要说明的一点是，努力的方式并不一定是通用的，因为每个人擅长的领域不一样，有的人反应很快，擅长单挑，所以通常是竞技场的常客，有的人擅长指挥，副本里队长名单里总有他们的身影。 就像之前所说，选择有时候比努力更重要，选择自己擅长的领域和方向去发展，也许会让你在这个游戏里有更重要的价值。</p>\n<p>至于如何努力，我个人觉得，看书应该是首选，经典的书籍往往经过了反复斟酌的优质内容，才有了现在的口碑，所以书籍内容不会有太多漏洞，不会像有些不负责任的博主，写博客只是为了博得关注，遇到不确定的地方，要么仅凭自己猜测，要么一笔带过，误导了很多读者。</p>\n<p>如果看书实在看不下去的话，可以看看经典的视频教程，慕课网的教程个人觉得还算不错，讲解比较形象，有兴趣的话可以去看看。</p>\n<p>如果还是不行，那就找两个有意思的项目来研究一下。想想看如何用Java来提高生活质量，或者来帮助你完成一些重复性的体力劳动。比如用Java来批量爬取图片，批量将txt文件导入Excel等等。</p>\n<h2 id=\"正式起航\"><a href=\"#正式起航\" class=\"headerlink\" title=\"正式起航\"></a>正式起航</h2><p>这几篇大概把我平生的废话都说完了，一本正经的胡说八道了这么久，有点不习惯。如果让你感到无聊了，十分抱歉。【面壁中】</p>\n<p>如果你看完这些废话，觉得自己还是很有兴趣继续看下去，那么就让我们红尘作伴，活得潇潇洒洒。啊，说错了，说错了，让我们一起开始Java游戏世界的试炼吧！:stuck_out_tongue_closed_eyes:</p>\n"},{"title":"WeakHashMap源码详解","date":"2019-01-03T15:10:00.000Z","_content":"\n> 源码详解系列均基于`JDK8`进行解析\n\n## 说明\n\n在Java容器详解系列文章的最后，介绍一个相对特殊的成员：`WeakHashMap`，从名字可以看出它是一个 `Map`。它的使用上跟`HashMap`并没有什么区别，所以很多地方这里就不做过多介绍了，可以翻看一下前面HashMap中的内容。本篇主要介绍它与HashMap的不同之处。\n\n`WeakHashMap` 特殊之处在于`WeakHashMap` 里的`entry`可能会被垃圾回收器自动删除，也就是说即使你没有调用`remove()`或者`clear()`方法，它的entry也可能会慢慢变少。所以多次调用比如isEmpty，containsKey，size等方法时可能会返回不同的结果。\n\n接下来希望能带着这么几个问题来进行阅读：\n\n1、WeakHashMap中的Entry为什么会自动被回收。\n\n2、WeakHashMap与HashMap的区别是什么。\n\n3、WeakHashMap的引用场景有哪些。\n\n## WeakHashMap探秘\n\n从说明可以看出，WeakHashMap的特殊之处便在于它的Entry与众不同，里面的Entry会被垃圾回收器自动回收，那么问题来了，为什么会被自动回收呢？HashMap里的Entry并不会被自动回收，除非把它从Map中移除掉。\n\n其实这个秘密就在于[弱引用](../reference/weak-reference.html)，WeakHashMap中的key是间接保存在弱引用中的，所以当key没有被继续使用时，就可能会在GC的时候被回收掉。\n\n只有key对象是使用弱引用保存的，value对象实际上仍旧是通过普通的强引用来保持的，所以应该确保value不会直接或者间接的保持其对应key的强引用，因为这样会阻止key被回收。\n\n如果对于引用类型不熟悉的话，可以先阅读[这篇文章](../reference/four-kinds-of-reference.html)。\n\n下面来从源码角度看看具体是如何实现这个特性的。\n\n## 继承结构\n\n{% asset_img weakhashmap-1.png weakhashmap-1 %}\n\nWeakHashMap并不是继承自HashMap，而是继承自AbstractMap，跟HashMap的继承结构差不多。\n\n## 存储结构\n\nWeakHashMap中的数据结构是数组+链表的形式，这一点跟HashMap也是一致的，但不同的是，在JDK8中，当发生较多key冲突的时候，HashMap中会由链表转为红黑树，而WeakHashMap则一直使用链表进行存储。\n\n{% asset_img weakhashmap-4.png weakhashmap-4 %}\n\n## 成员变量\n\n```java\n// 默认初始容量，必须是2的幂\nprivate static final int DEFAULT_INITIAL_CAPACITY = 16;\n\n// 最大容量\nprivate static final int MAXIMUM_CAPACITY = 1 << 30;\n\n// 默认装载因子\nprivate static final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n// Entry数组，长度必须为2的幂\nEntry<K,V>[] table;\n\n// 元素个数\nprivate int size;\n\n// 阈值 \nprivate int threshold;\n\n// 装载因子\nprivate final float loadFactor;\n\n// 引用队列\nprivate final ReferenceQueue<Object> queue = new ReferenceQueue<>();\n\n// 修改次数\nint modCount;\n```\n\n跟HashMap的成员变量几乎一致，这里多了一个ReferenceQueue，用来存放那些已经被回收了的弱引用对象。如果想知道ReferenceQueue是如何工作的，可以参考[这篇文章](../reference/reference-queue-code-detail.html)。\n\n## 构造函数\n\nWeakHashMap中也有四个构造函数：\n\n```java\npublic WeakHashMap(int initialCapacity, float loadFactor) {\n\t...\n}\n\npublic WeakHashMap(int initialCapacity) {\n    this(initialCapacity, DEFAULT_LOAD_FACTOR);\n}\n\npublic WeakHashMap() {\n    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);\n}\n\npublic WeakHashMap(Map<? extends K, ? extends V> m) {\n    this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1,\n                  DEFAULT_INITIAL_CAPACITY),\n         DEFAULT_LOAD_FACTOR);\n    putAll(m);\n}\n```\n\n可以看到后三个，都是调用的第一个构造函数，下面再来看一下第一个构造函数的内容：\n\n```java\n// 校验initialCapacity\nif (initialCapacity < 0)\n    throw new IllegalArgumentException(\"Illegal Initial Capacity: \"+\n                                       initialCapacity);\nif (initialCapacity > MAXIMUM_CAPACITY)\n    initialCapacity = MAXIMUM_CAPACITY;\n\n// 校验loadFactor\nif (loadFactor <= 0 || Float.isNaN(loadFactor))\n    throw new IllegalArgumentException(\"Illegal Load factor: \"+\n                                       loadFactor);\nint capacity = 1;\n// 将容量设置为大于initialCapacity的最小2的幂\nwhile (capacity < initialCapacity)\n    capacity <<= 1;\ntable = newTable(capacity);\nthis.loadFactor = loadFactor;\nthreshold = (int)(capacity * loadFactor);\n```\n\n再看看newTable函数。\n\n```java\nprivate Entry<K,V>[] newTable(int n) {\n    return (Entry<K,V>[]) new Entry<?,?>[n];\n}\n```\n\n这里其实只是简单的创建一个Entry数组。\n\n## Entry剖析\n\n接下来看看WeakHashMap中的核心角色——Entry。上面已经看到了，WeakHashMap中的table是一个Entry数组：\n\n```java\nEntry<K,V>[] table;\n```\n\n来看看Entry长什么样：\n\n```java\nprivate static class Entry<K,V> extends WeakReference<Object> implements Map.Entry<K,V> {\n\t...   \n}\n```\n\nEntry继承自WeakReference，继承关系图如下：\n\n{% asset_img weakhashmap-2.png weakhashmap-2 %}\n\n再来看看Entry中的内容：\n\n```java\n// 成员变量\nV value;\nfinal int hash;\nEntry<K,V> next;\n\n// 构造函数\nEntry(Object key, V value,\n      ReferenceQueue<Object> queue,\n      int hash, Entry<K,V> next) {\n    super(key, queue);\n    this.value = value;\n    this.hash  = hash;\n    this.next  = next;\n}\n```\n\n细心的你可能会发现，哎？key哪里去了，成员变量里没有key。别着急，看看构造函数就可以发现，它调用了父类的构造函数。\n\n```java\nsuper(key, queue);\n```\n\n这里调用的WeakReference的构造函数，将key传入Reference中，保存在referent成员变量中。对Reference和WeakReference不熟悉的话可以参考[这篇文章](../reference/reference-code-detail.html)和[这篇文章](../reference/weak-reference-code-detail.html)。\n\n再看看其它几个方法：\n\n```java\n@SuppressWarnings(\"unchecked\")\npublic K getKey() {\n    // 这里调用了Reference的get方法，从中取出referent对象\n    // WeakHashMap中，key如果为null会使用NULL_KEY来替代\n    return (K) WeakHashMap.unmaskNull(get());\n}\n\npublic V getValue() {\n    return value;\n}\n\npublic V setValue(V newValue) {\n    V oldValue = value;\n    value = newValue;\n    return oldValue;\n}\n\npublic boolean equals(Object o) {\n    if (!(o instanceof Map.Entry))\n        return false;\n    Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n    K k1 = getKey();\n    Object k2 = e.getKey();\n    if (k1 == k2 || (k1 != null && k1.equals(k2))) {\n        V v1 = getValue();\n        Object v2 = e.getValue();\n        if (v1 == v2 || (v1 != null && v1.equals(v2)))\n            return true;\n    }\n    return false;\n}\n\npublic int hashCode() {\n    K k = getKey();\n    V v = getValue();\n    // 这里只是简单的把key和value的hashcode做一个异或处理\n    return Objects.hashCode(k) ^ Objects.hashCode(v);\n}\n\npublic String toString() {\n    return getKey() + \"=\" + getValue();\n}\n```\n\n这里稍微说一下getKey方法，调用了WeakHashMap.unmaskNull，之所以要调用这个方法，其实是因为WeakHashMap中对key为null时的特殊处理，会将其指向一个特殊的内部变量：\n\n```java\nprivate static final Object NULL_KEY = new Object();\n```\n\n与其对应的两个方法便是：\n\n```java\nprivate static Object maskNull(Object key) {\n    return (key == null) ? NULL_KEY : key;\n}\n\nstatic Object unmaskNull(Object key) {\n    return (key == NULL_KEY) ? null : key;\n}\n```\n\n所以，其他WeakHashMap中的Entry最大的不同就是继承自WeakReference，并把key保存在了WeakReference中。可以说WeakHashMap的特性绝大部分都是WeakReference的功劳。\n\n## 常用方法\n\n主要的方法有这些：\n\n```java\nvoid                   clear()\nObject                 clone()\nboolean                containsKey(Object key)\nboolean                containsValue(Object value)\nSet<Entry<K, V>>       entrySet()\nV                      get(Object key)\nboolean                isEmpty()\nSet<K>                 keySet()\nV                      put(K key, V value)\nvoid                   putAll(Map<? extends K, ? extends V> map)\nV                      remove(Object key)\nint                    size()\nCollection<V>          values()\n```\n\n这里选其中的三个最常用的方法进行解析：\n\n### put方法\n\n```java\npublic V put(K key, V value) {\n    // 处理null值\n    Object k = maskNull(key);\n    // 计算hash\n    int h = hash(k);\n    // 获取table\n    Entry<K,V>[] tab = getTable();\n    // 计算下标\n    int i = indexFor(h, tab.length);\n\n    // 查找Entry\n    for (Entry<K,V> e = tab[i]; e != null; e = e.next) {\n        if (h == e.hash && eq(k, e.get())) {\n            V oldValue = e.value;\n            if (value != oldValue)\n                e.value = value;\n            return oldValue;\n        }\n    }\n\t\n    modCount++;\n    Entry<K,V> e = tab[i];\n    tab[i] = new Entry<>(k, value, queue, h, e);\n    // 如果元素个数超过阈值，则进行扩容\n    if (++size >= threshold)\n        resize(tab.length * 2);\n    return null;\n}\n```\n\n这里涉及到的方法比较多，不慌不慌，一个一个来。\n\n先来看看hash方法：\n\n```java\nfinal int hash(Object k) {\n    int h = k.hashCode();\n    // 这里做了二次散列，来扩大低位的影响\n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n}\n```\n\nhash方法对key的hashcode进行了二次散列，主要是为了扩大低位的影响。因为Entry数组的大小是2的幂，在进行查找的时候，进行掩码处理，如果不进行二次散列，那么低位对index就完全没有影响了，如果不清楚也没有关系，之后在get方法里会有说明。\n\n至于为什么要选20,12,7,4。emmm，大概是效果奇佳吧（一本正经的胡说八道，有兴趣的话可以自行研究）。\n\n再看看indexFor函数，这里就是将数组长度减1后与hashcode做一个位与操作，因为length必定是2的幂，所以减1后就变成了掩码，再进行与操作就能直接得到hashcode mod length的结果了，但是这样操作效率会更高。\n\n```java\nprivate static int indexFor(int h, int length) {\n    return h & (length-1);\n}\n```\n\n再来看看getTable方法：\n\n```java\nprivate Entry<K,V>[] getTable() {\n    // 清除被回收的Entry对象\n    expungeStaleEntries();\n    return table;\n}\n\nprivate void expungeStaleEntries() {\n    for (Object x; (x = queue.poll()) != null; ) {\n        // 循环获取引用队列中的对象\n        synchronized (queue) {\n            @SuppressWarnings(\"unchecked\")\n            Entry<K,V> e = (Entry<K,V>) x;\n            // 查找对应的位置\n            int i = indexFor(e.hash, table.length);\n\n            // 找到之前的Entry\n            Entry<K,V> prev = table[i];\n            Entry<K,V> p = prev;\n            // 在链表中寻找\n            while (p != null) {\n                Entry<K,V> next = p.next;\n                if (p == e) {\n                    if (prev == e)\n                        table[i] = next;\n                    else\n                        prev.next = next;\n                    // 将对应的value置为null，帮助GC回收\n                    e.value = null;\n                    size--;\n                    break;\n                }\n                prev = p;\n                p = next;\n            }\n        }\n    }\n}\n```\n\n所以每次调用getTable的时候，都会将table中key已经被回收掉的Entry移除掉。\n\nresize方法：\n\n```java\nvoid resize(int newCapacity) {\n    // 获取当前table\n    Entry<K,V>[] oldTable = getTable();\n    int oldCapacity = oldTable.length;\n    if (oldCapacity == MAXIMUM_CAPACITY) {\n        threshold = Integer.MAX_VALUE;\n        return;\n    }\n\n    // 新建一个table\n    Entry<K,V>[] newTable = newTable(newCapacity);\n    // 将旧table中的内容复制到新table中\n    transfer(oldTable, newTable);\n    table = newTable;\n\n    if (size >= threshold / 2) {\n        threshold = (int)(newCapacity * loadFactor);\n    } else {\n        expungeStaleEntries();\n        transfer(newTable, oldTable);\n        table = oldTable;\n    }\n}\n// 新建Entry数组\nprivate Entry<K,V>[] newTable(int n) {\n    return (Entry<K,V>[]) new Entry<?,?>[n];\n}\n\nprivate void transfer(Entry<K,V>[] src, Entry<K,V>[] dest) {\n    for (int j = 0; j < src.length; ++j) {\n        Entry<K,V> e = src[j];\n        src[j] = null;\n        while (e != null) {\n            Entry<K,V> next = e.next;\n            Object key = e.get();\n            if (key == null) {\n                e.next = null; \n                e.value = null; \n                size--;\n            } else {\n                int i = indexFor(e.hash, dest.length);\n                e.next = dest[i];\n                dest[i] = e;\n            }\n            e = next;\n        }\n    }\n}\n```\n\n### get方法\n\n```java\npublic V get(Object key) {\n    // 对null值特殊处理\n    Object k = maskNull(key);\n    // 取key的hash值\n    int h = hash(k);\n    // 取当前table\n    Entry<K,V>[] tab = getTable();\n    // 获取下标\n    int index = indexFor(h, tab.length);\n    Entry<K,V> e = tab[index];\n    // 链表中查找元素\n    while (e != null) {\n        if (e.hash == h && eq(k, e.get()))\n            return e.value;\n        e = e.next;\n    }\n    return null;\n}\n```\n\n在查找元素的时候调用了一个eq方法：\n\n```java\nprivate static boolean eq(Object x, Object y) {\n    return x == y || x.equals(y);\n}\n```\n\n### remove方法\n\n```java\npublic V remove(Object key) {\n    // 对null值特殊处理\n    Object k = maskNull(key);\n    // 取key的hash\n    int h = hash(k);\n    // 取当前table\n    Entry<K,V>[] tab = getTable();\n    // 计算下标\n    int i = indexFor(h, tab.length);\n    Entry<K,V> prev = tab[i];\n    Entry<K,V> e = prev;\n\n    while (e != null) {\n        Entry<K,V> next = e.next;\n        // 查找对应Entry\n        if (h == e.hash && eq(k, e.get())) {\n            modCount++;\n            size--;\n            if (prev == e)\n                tab[i] = next;\n            else\n                prev.next = next;\n            // 如果找到，返回对应Entry的value\n            return e.value;\n        }\n        prev = e;\n        e = next;\n    }\n\n    return null;\n}\n```\n\n## 使用栗子\n\n```java\npublic class WeakHashMapTest {\n    public static void main(String[] args){\n        testWeakHashMap();\n    }\n\n    private static void testWeakHashMap() {\n        // 创建3个String对象用来做key\n        String w1 = new String(\"key1\");\n        String w2 = new String(\"key2\");\n        String w3 = new String(\"key3\");\n\n        // 新建WeakHashMap\n        Map weakHashMap = new WeakHashMap();\n\n        // 添加键值对\n        weakHashMap.put(w1, \"v1\");\n        weakHashMap.put(w2, \"v2\");\n        weakHashMap.put(w3, \"v3\");\n\n        // 打印出weakHashMap\n        System.out.printf(\"weakHashMap:%s\\n\", weakHashMap);\n\n        // containsKey(Object key) :是否包含键key\n        System.out.printf(\"contains key key1 : %s\\n\",weakHashMap.containsKey(\"key1\"));\n        System.out.printf(\"contains key key4 : %s\\n\",weakHashMap.containsKey(\"key4\"));\n\n        // containsValue(Object value) :是否包含值value\n        System.out.printf(\"contains value v1 : %s\\n\",weakHashMap.containsValue(\"v1\"));\n        System.out.printf(\"contains value 0 : %s\\n\",weakHashMap.containsValue(0));\n\n        // remove(Object key) ： 删除键key对应的键值对\n        weakHashMap.remove(\"three\");\n\n        System.out.printf(\"weakHashMap: %s\\n\", weakHashMap);\n\n\n        // ---- 测试 WeakHashMap 的自动回收特性 ----\n\n        // 将w1设置null。\n        // 这意味着“弱键”w1再没有被其它对象引用，调用gc时会回收WeakHashMap中与“w1”对应的键值对\n        w1 = null;\n\n        // 内存回收。这里，会回收WeakHashMap中与“w1”对应的键值对\n        System.gc();\n\n        // 遍历WeakHashMap\n        Iterator iter = weakHashMap.entrySet().iterator();\n        while (iter.hasNext()) {\n            Map.Entry en = (Map.Entry)iter.next();\n            System.out.printf(\"next : %s - %s\\n\",en.getKey(),en.getValue());\n        }\n        // 打印WeakHashMap的实际大小\n        System.out.printf(\"after gc WeakHashMap size:%s\\n\", weakHashMap.size());\n    }\n}\n```\n\n输出如下：\n\n```java\nweakHashMap:{key1=w1, key2=w2, key3=w3}\ncontains key key1 : true\ncontains key key4 : false\ncontains value w1 : true\ncontains value 0 : false\nweakHashMap: {key1=w1, key2=w2, key3=w3}\nnext : key2 - w2\nnext : key3 - w3\nafter gc WeakHashMap size:2\n```\n\n可以看到，w1对应的Entry被回收掉了，这就是WeakHashMap的最重要特性，当然，实际使用的时候一般不会这样使用，\n\n## 应用场景\n\n由于WeakHashMap可以自动清除Entry，所以比较适合用于存储非必需对象，用作缓存非常合适。\n\n```java\npublic final class ConcurrentCache<K,V> {\n\n    private final int size;\n\n    private final Map<K,V> eden;\n\n    private final Map<K,V> longterm;\n\n    public ConcurrentCache(int size) {\n        this.size = size;\n        this.eden = new ConcurrentHashMap<>(size);\n        this.longterm = new WeakHashMap<>(size);\n    }\n\n    public V get(K k) {\n        V v = this.eden.get(k);\n        if (v == null) {\n            synchronized (longterm) {\n                v = this.longterm.get(k);\n            }\n            if (v != null) {\n                this.eden.put(k, v);\n            }\n        }\n        return v;\n    }\n\n    public void put(K k, V v) {\n        if (this.eden.size() >= size) {\n            synchronized (longterm) {\n                this.longterm.putAll(this.eden);\n            }\n            this.eden.clear();\n        }\n        this.eden.put(k, v);\n    }\n}\n```\n\n在put方法里，在插入一个键值对时，先检查eden缓存的容量是不是超过了阈值，如果没有超就直接放入eden缓存，如果超了就将eden中所有的键值对都放入longterm（这里longterm类似于老年代，eden类似于年轻代），再将eden清空并插入相应键值对。\n\n在get方法中，也是优先从eden中找对应的value，如果没有则进入longterm缓存中查找，找到后就加入eden缓存并返回。\n\n这样设计的好处是，能将相对常用的对象都能在eden缓存中找到，不常用的则存入longterm缓存，并且由于WeakHashMap能自动清除Entry，所以不用担心longterm中键值对过多而导致OOM。\n\nWeakHashMap还有这样一个不错的应用场景，配合事务进行使用，存储事务过程中的各类信息。可以使用如下结构：\n\n```java\nWeakHashMap<String,Map<K,V>> transactionCache;\n```\n\n这里key为String类型，可以用来标志区分不同的事务，起到一个事务id的作用。value是一个map，可以是一个简单的HashMap或者LinkedHashMap，用来存放在事务中需要使用到的信息。\n\n在事务开始时创建一个事务id，并用它来作为key，事务结束后，将这个强引用消除掉，这样既能保证在事务中可以获取到所需要的信息，又能自动释放掉map中的所有信息。\n\n## 小结\n\n- WeakHashMap是一个会自动清除Entry的Map\n- WeakHashMap的操作与HashMap完全一致\n- WeakHashMap内部数据结构是数组+链表\n- WeakHashMap常被用作缓存","source":"_posts/java/collection/weakhashmap-code-detail.md","raw":"---\ntitle: WeakHashMap源码详解\ntags: \n - Java\n - Java集合\ncategories: 编程\ndate: 2019-01-03 23:10:00\n---\n\n> 源码详解系列均基于`JDK8`进行解析\n\n## 说明\n\n在Java容器详解系列文章的最后，介绍一个相对特殊的成员：`WeakHashMap`，从名字可以看出它是一个 `Map`。它的使用上跟`HashMap`并没有什么区别，所以很多地方这里就不做过多介绍了，可以翻看一下前面HashMap中的内容。本篇主要介绍它与HashMap的不同之处。\n\n`WeakHashMap` 特殊之处在于`WeakHashMap` 里的`entry`可能会被垃圾回收器自动删除，也就是说即使你没有调用`remove()`或者`clear()`方法，它的entry也可能会慢慢变少。所以多次调用比如isEmpty，containsKey，size等方法时可能会返回不同的结果。\n\n接下来希望能带着这么几个问题来进行阅读：\n\n1、WeakHashMap中的Entry为什么会自动被回收。\n\n2、WeakHashMap与HashMap的区别是什么。\n\n3、WeakHashMap的引用场景有哪些。\n\n## WeakHashMap探秘\n\n从说明可以看出，WeakHashMap的特殊之处便在于它的Entry与众不同，里面的Entry会被垃圾回收器自动回收，那么问题来了，为什么会被自动回收呢？HashMap里的Entry并不会被自动回收，除非把它从Map中移除掉。\n\n其实这个秘密就在于[弱引用](../reference/weak-reference.html)，WeakHashMap中的key是间接保存在弱引用中的，所以当key没有被继续使用时，就可能会在GC的时候被回收掉。\n\n只有key对象是使用弱引用保存的，value对象实际上仍旧是通过普通的强引用来保持的，所以应该确保value不会直接或者间接的保持其对应key的强引用，因为这样会阻止key被回收。\n\n如果对于引用类型不熟悉的话，可以先阅读[这篇文章](../reference/four-kinds-of-reference.html)。\n\n下面来从源码角度看看具体是如何实现这个特性的。\n\n## 继承结构\n\n{% asset_img weakhashmap-1.png weakhashmap-1 %}\n\nWeakHashMap并不是继承自HashMap，而是继承自AbstractMap，跟HashMap的继承结构差不多。\n\n## 存储结构\n\nWeakHashMap中的数据结构是数组+链表的形式，这一点跟HashMap也是一致的，但不同的是，在JDK8中，当发生较多key冲突的时候，HashMap中会由链表转为红黑树，而WeakHashMap则一直使用链表进行存储。\n\n{% asset_img weakhashmap-4.png weakhashmap-4 %}\n\n## 成员变量\n\n```java\n// 默认初始容量，必须是2的幂\nprivate static final int DEFAULT_INITIAL_CAPACITY = 16;\n\n// 最大容量\nprivate static final int MAXIMUM_CAPACITY = 1 << 30;\n\n// 默认装载因子\nprivate static final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n// Entry数组，长度必须为2的幂\nEntry<K,V>[] table;\n\n// 元素个数\nprivate int size;\n\n// 阈值 \nprivate int threshold;\n\n// 装载因子\nprivate final float loadFactor;\n\n// 引用队列\nprivate final ReferenceQueue<Object> queue = new ReferenceQueue<>();\n\n// 修改次数\nint modCount;\n```\n\n跟HashMap的成员变量几乎一致，这里多了一个ReferenceQueue，用来存放那些已经被回收了的弱引用对象。如果想知道ReferenceQueue是如何工作的，可以参考[这篇文章](../reference/reference-queue-code-detail.html)。\n\n## 构造函数\n\nWeakHashMap中也有四个构造函数：\n\n```java\npublic WeakHashMap(int initialCapacity, float loadFactor) {\n\t...\n}\n\npublic WeakHashMap(int initialCapacity) {\n    this(initialCapacity, DEFAULT_LOAD_FACTOR);\n}\n\npublic WeakHashMap() {\n    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);\n}\n\npublic WeakHashMap(Map<? extends K, ? extends V> m) {\n    this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1,\n                  DEFAULT_INITIAL_CAPACITY),\n         DEFAULT_LOAD_FACTOR);\n    putAll(m);\n}\n```\n\n可以看到后三个，都是调用的第一个构造函数，下面再来看一下第一个构造函数的内容：\n\n```java\n// 校验initialCapacity\nif (initialCapacity < 0)\n    throw new IllegalArgumentException(\"Illegal Initial Capacity: \"+\n                                       initialCapacity);\nif (initialCapacity > MAXIMUM_CAPACITY)\n    initialCapacity = MAXIMUM_CAPACITY;\n\n// 校验loadFactor\nif (loadFactor <= 0 || Float.isNaN(loadFactor))\n    throw new IllegalArgumentException(\"Illegal Load factor: \"+\n                                       loadFactor);\nint capacity = 1;\n// 将容量设置为大于initialCapacity的最小2的幂\nwhile (capacity < initialCapacity)\n    capacity <<= 1;\ntable = newTable(capacity);\nthis.loadFactor = loadFactor;\nthreshold = (int)(capacity * loadFactor);\n```\n\n再看看newTable函数。\n\n```java\nprivate Entry<K,V>[] newTable(int n) {\n    return (Entry<K,V>[]) new Entry<?,?>[n];\n}\n```\n\n这里其实只是简单的创建一个Entry数组。\n\n## Entry剖析\n\n接下来看看WeakHashMap中的核心角色——Entry。上面已经看到了，WeakHashMap中的table是一个Entry数组：\n\n```java\nEntry<K,V>[] table;\n```\n\n来看看Entry长什么样：\n\n```java\nprivate static class Entry<K,V> extends WeakReference<Object> implements Map.Entry<K,V> {\n\t...   \n}\n```\n\nEntry继承自WeakReference，继承关系图如下：\n\n{% asset_img weakhashmap-2.png weakhashmap-2 %}\n\n再来看看Entry中的内容：\n\n```java\n// 成员变量\nV value;\nfinal int hash;\nEntry<K,V> next;\n\n// 构造函数\nEntry(Object key, V value,\n      ReferenceQueue<Object> queue,\n      int hash, Entry<K,V> next) {\n    super(key, queue);\n    this.value = value;\n    this.hash  = hash;\n    this.next  = next;\n}\n```\n\n细心的你可能会发现，哎？key哪里去了，成员变量里没有key。别着急，看看构造函数就可以发现，它调用了父类的构造函数。\n\n```java\nsuper(key, queue);\n```\n\n这里调用的WeakReference的构造函数，将key传入Reference中，保存在referent成员变量中。对Reference和WeakReference不熟悉的话可以参考[这篇文章](../reference/reference-code-detail.html)和[这篇文章](../reference/weak-reference-code-detail.html)。\n\n再看看其它几个方法：\n\n```java\n@SuppressWarnings(\"unchecked\")\npublic K getKey() {\n    // 这里调用了Reference的get方法，从中取出referent对象\n    // WeakHashMap中，key如果为null会使用NULL_KEY来替代\n    return (K) WeakHashMap.unmaskNull(get());\n}\n\npublic V getValue() {\n    return value;\n}\n\npublic V setValue(V newValue) {\n    V oldValue = value;\n    value = newValue;\n    return oldValue;\n}\n\npublic boolean equals(Object o) {\n    if (!(o instanceof Map.Entry))\n        return false;\n    Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n    K k1 = getKey();\n    Object k2 = e.getKey();\n    if (k1 == k2 || (k1 != null && k1.equals(k2))) {\n        V v1 = getValue();\n        Object v2 = e.getValue();\n        if (v1 == v2 || (v1 != null && v1.equals(v2)))\n            return true;\n    }\n    return false;\n}\n\npublic int hashCode() {\n    K k = getKey();\n    V v = getValue();\n    // 这里只是简单的把key和value的hashcode做一个异或处理\n    return Objects.hashCode(k) ^ Objects.hashCode(v);\n}\n\npublic String toString() {\n    return getKey() + \"=\" + getValue();\n}\n```\n\n这里稍微说一下getKey方法，调用了WeakHashMap.unmaskNull，之所以要调用这个方法，其实是因为WeakHashMap中对key为null时的特殊处理，会将其指向一个特殊的内部变量：\n\n```java\nprivate static final Object NULL_KEY = new Object();\n```\n\n与其对应的两个方法便是：\n\n```java\nprivate static Object maskNull(Object key) {\n    return (key == null) ? NULL_KEY : key;\n}\n\nstatic Object unmaskNull(Object key) {\n    return (key == NULL_KEY) ? null : key;\n}\n```\n\n所以，其他WeakHashMap中的Entry最大的不同就是继承自WeakReference，并把key保存在了WeakReference中。可以说WeakHashMap的特性绝大部分都是WeakReference的功劳。\n\n## 常用方法\n\n主要的方法有这些：\n\n```java\nvoid                   clear()\nObject                 clone()\nboolean                containsKey(Object key)\nboolean                containsValue(Object value)\nSet<Entry<K, V>>       entrySet()\nV                      get(Object key)\nboolean                isEmpty()\nSet<K>                 keySet()\nV                      put(K key, V value)\nvoid                   putAll(Map<? extends K, ? extends V> map)\nV                      remove(Object key)\nint                    size()\nCollection<V>          values()\n```\n\n这里选其中的三个最常用的方法进行解析：\n\n### put方法\n\n```java\npublic V put(K key, V value) {\n    // 处理null值\n    Object k = maskNull(key);\n    // 计算hash\n    int h = hash(k);\n    // 获取table\n    Entry<K,V>[] tab = getTable();\n    // 计算下标\n    int i = indexFor(h, tab.length);\n\n    // 查找Entry\n    for (Entry<K,V> e = tab[i]; e != null; e = e.next) {\n        if (h == e.hash && eq(k, e.get())) {\n            V oldValue = e.value;\n            if (value != oldValue)\n                e.value = value;\n            return oldValue;\n        }\n    }\n\t\n    modCount++;\n    Entry<K,V> e = tab[i];\n    tab[i] = new Entry<>(k, value, queue, h, e);\n    // 如果元素个数超过阈值，则进行扩容\n    if (++size >= threshold)\n        resize(tab.length * 2);\n    return null;\n}\n```\n\n这里涉及到的方法比较多，不慌不慌，一个一个来。\n\n先来看看hash方法：\n\n```java\nfinal int hash(Object k) {\n    int h = k.hashCode();\n    // 这里做了二次散列，来扩大低位的影响\n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n}\n```\n\nhash方法对key的hashcode进行了二次散列，主要是为了扩大低位的影响。因为Entry数组的大小是2的幂，在进行查找的时候，进行掩码处理，如果不进行二次散列，那么低位对index就完全没有影响了，如果不清楚也没有关系，之后在get方法里会有说明。\n\n至于为什么要选20,12,7,4。emmm，大概是效果奇佳吧（一本正经的胡说八道，有兴趣的话可以自行研究）。\n\n再看看indexFor函数，这里就是将数组长度减1后与hashcode做一个位与操作，因为length必定是2的幂，所以减1后就变成了掩码，再进行与操作就能直接得到hashcode mod length的结果了，但是这样操作效率会更高。\n\n```java\nprivate static int indexFor(int h, int length) {\n    return h & (length-1);\n}\n```\n\n再来看看getTable方法：\n\n```java\nprivate Entry<K,V>[] getTable() {\n    // 清除被回收的Entry对象\n    expungeStaleEntries();\n    return table;\n}\n\nprivate void expungeStaleEntries() {\n    for (Object x; (x = queue.poll()) != null; ) {\n        // 循环获取引用队列中的对象\n        synchronized (queue) {\n            @SuppressWarnings(\"unchecked\")\n            Entry<K,V> e = (Entry<K,V>) x;\n            // 查找对应的位置\n            int i = indexFor(e.hash, table.length);\n\n            // 找到之前的Entry\n            Entry<K,V> prev = table[i];\n            Entry<K,V> p = prev;\n            // 在链表中寻找\n            while (p != null) {\n                Entry<K,V> next = p.next;\n                if (p == e) {\n                    if (prev == e)\n                        table[i] = next;\n                    else\n                        prev.next = next;\n                    // 将对应的value置为null，帮助GC回收\n                    e.value = null;\n                    size--;\n                    break;\n                }\n                prev = p;\n                p = next;\n            }\n        }\n    }\n}\n```\n\n所以每次调用getTable的时候，都会将table中key已经被回收掉的Entry移除掉。\n\nresize方法：\n\n```java\nvoid resize(int newCapacity) {\n    // 获取当前table\n    Entry<K,V>[] oldTable = getTable();\n    int oldCapacity = oldTable.length;\n    if (oldCapacity == MAXIMUM_CAPACITY) {\n        threshold = Integer.MAX_VALUE;\n        return;\n    }\n\n    // 新建一个table\n    Entry<K,V>[] newTable = newTable(newCapacity);\n    // 将旧table中的内容复制到新table中\n    transfer(oldTable, newTable);\n    table = newTable;\n\n    if (size >= threshold / 2) {\n        threshold = (int)(newCapacity * loadFactor);\n    } else {\n        expungeStaleEntries();\n        transfer(newTable, oldTable);\n        table = oldTable;\n    }\n}\n// 新建Entry数组\nprivate Entry<K,V>[] newTable(int n) {\n    return (Entry<K,V>[]) new Entry<?,?>[n];\n}\n\nprivate void transfer(Entry<K,V>[] src, Entry<K,V>[] dest) {\n    for (int j = 0; j < src.length; ++j) {\n        Entry<K,V> e = src[j];\n        src[j] = null;\n        while (e != null) {\n            Entry<K,V> next = e.next;\n            Object key = e.get();\n            if (key == null) {\n                e.next = null; \n                e.value = null; \n                size--;\n            } else {\n                int i = indexFor(e.hash, dest.length);\n                e.next = dest[i];\n                dest[i] = e;\n            }\n            e = next;\n        }\n    }\n}\n```\n\n### get方法\n\n```java\npublic V get(Object key) {\n    // 对null值特殊处理\n    Object k = maskNull(key);\n    // 取key的hash值\n    int h = hash(k);\n    // 取当前table\n    Entry<K,V>[] tab = getTable();\n    // 获取下标\n    int index = indexFor(h, tab.length);\n    Entry<K,V> e = tab[index];\n    // 链表中查找元素\n    while (e != null) {\n        if (e.hash == h && eq(k, e.get()))\n            return e.value;\n        e = e.next;\n    }\n    return null;\n}\n```\n\n在查找元素的时候调用了一个eq方法：\n\n```java\nprivate static boolean eq(Object x, Object y) {\n    return x == y || x.equals(y);\n}\n```\n\n### remove方法\n\n```java\npublic V remove(Object key) {\n    // 对null值特殊处理\n    Object k = maskNull(key);\n    // 取key的hash\n    int h = hash(k);\n    // 取当前table\n    Entry<K,V>[] tab = getTable();\n    // 计算下标\n    int i = indexFor(h, tab.length);\n    Entry<K,V> prev = tab[i];\n    Entry<K,V> e = prev;\n\n    while (e != null) {\n        Entry<K,V> next = e.next;\n        // 查找对应Entry\n        if (h == e.hash && eq(k, e.get())) {\n            modCount++;\n            size--;\n            if (prev == e)\n                tab[i] = next;\n            else\n                prev.next = next;\n            // 如果找到，返回对应Entry的value\n            return e.value;\n        }\n        prev = e;\n        e = next;\n    }\n\n    return null;\n}\n```\n\n## 使用栗子\n\n```java\npublic class WeakHashMapTest {\n    public static void main(String[] args){\n        testWeakHashMap();\n    }\n\n    private static void testWeakHashMap() {\n        // 创建3个String对象用来做key\n        String w1 = new String(\"key1\");\n        String w2 = new String(\"key2\");\n        String w3 = new String(\"key3\");\n\n        // 新建WeakHashMap\n        Map weakHashMap = new WeakHashMap();\n\n        // 添加键值对\n        weakHashMap.put(w1, \"v1\");\n        weakHashMap.put(w2, \"v2\");\n        weakHashMap.put(w3, \"v3\");\n\n        // 打印出weakHashMap\n        System.out.printf(\"weakHashMap:%s\\n\", weakHashMap);\n\n        // containsKey(Object key) :是否包含键key\n        System.out.printf(\"contains key key1 : %s\\n\",weakHashMap.containsKey(\"key1\"));\n        System.out.printf(\"contains key key4 : %s\\n\",weakHashMap.containsKey(\"key4\"));\n\n        // containsValue(Object value) :是否包含值value\n        System.out.printf(\"contains value v1 : %s\\n\",weakHashMap.containsValue(\"v1\"));\n        System.out.printf(\"contains value 0 : %s\\n\",weakHashMap.containsValue(0));\n\n        // remove(Object key) ： 删除键key对应的键值对\n        weakHashMap.remove(\"three\");\n\n        System.out.printf(\"weakHashMap: %s\\n\", weakHashMap);\n\n\n        // ---- 测试 WeakHashMap 的自动回收特性 ----\n\n        // 将w1设置null。\n        // 这意味着“弱键”w1再没有被其它对象引用，调用gc时会回收WeakHashMap中与“w1”对应的键值对\n        w1 = null;\n\n        // 内存回收。这里，会回收WeakHashMap中与“w1”对应的键值对\n        System.gc();\n\n        // 遍历WeakHashMap\n        Iterator iter = weakHashMap.entrySet().iterator();\n        while (iter.hasNext()) {\n            Map.Entry en = (Map.Entry)iter.next();\n            System.out.printf(\"next : %s - %s\\n\",en.getKey(),en.getValue());\n        }\n        // 打印WeakHashMap的实际大小\n        System.out.printf(\"after gc WeakHashMap size:%s\\n\", weakHashMap.size());\n    }\n}\n```\n\n输出如下：\n\n```java\nweakHashMap:{key1=w1, key2=w2, key3=w3}\ncontains key key1 : true\ncontains key key4 : false\ncontains value w1 : true\ncontains value 0 : false\nweakHashMap: {key1=w1, key2=w2, key3=w3}\nnext : key2 - w2\nnext : key3 - w3\nafter gc WeakHashMap size:2\n```\n\n可以看到，w1对应的Entry被回收掉了，这就是WeakHashMap的最重要特性，当然，实际使用的时候一般不会这样使用，\n\n## 应用场景\n\n由于WeakHashMap可以自动清除Entry，所以比较适合用于存储非必需对象，用作缓存非常合适。\n\n```java\npublic final class ConcurrentCache<K,V> {\n\n    private final int size;\n\n    private final Map<K,V> eden;\n\n    private final Map<K,V> longterm;\n\n    public ConcurrentCache(int size) {\n        this.size = size;\n        this.eden = new ConcurrentHashMap<>(size);\n        this.longterm = new WeakHashMap<>(size);\n    }\n\n    public V get(K k) {\n        V v = this.eden.get(k);\n        if (v == null) {\n            synchronized (longterm) {\n                v = this.longterm.get(k);\n            }\n            if (v != null) {\n                this.eden.put(k, v);\n            }\n        }\n        return v;\n    }\n\n    public void put(K k, V v) {\n        if (this.eden.size() >= size) {\n            synchronized (longterm) {\n                this.longterm.putAll(this.eden);\n            }\n            this.eden.clear();\n        }\n        this.eden.put(k, v);\n    }\n}\n```\n\n在put方法里，在插入一个键值对时，先检查eden缓存的容量是不是超过了阈值，如果没有超就直接放入eden缓存，如果超了就将eden中所有的键值对都放入longterm（这里longterm类似于老年代，eden类似于年轻代），再将eden清空并插入相应键值对。\n\n在get方法中，也是优先从eden中找对应的value，如果没有则进入longterm缓存中查找，找到后就加入eden缓存并返回。\n\n这样设计的好处是，能将相对常用的对象都能在eden缓存中找到，不常用的则存入longterm缓存，并且由于WeakHashMap能自动清除Entry，所以不用担心longterm中键值对过多而导致OOM。\n\nWeakHashMap还有这样一个不错的应用场景，配合事务进行使用，存储事务过程中的各类信息。可以使用如下结构：\n\n```java\nWeakHashMap<String,Map<K,V>> transactionCache;\n```\n\n这里key为String类型，可以用来标志区分不同的事务，起到一个事务id的作用。value是一个map，可以是一个简单的HashMap或者LinkedHashMap，用来存放在事务中需要使用到的信息。\n\n在事务开始时创建一个事务id，并用它来作为key，事务结束后，将这个强引用消除掉，这样既能保证在事务中可以获取到所需要的信息，又能自动释放掉map中的所有信息。\n\n## 小结\n\n- WeakHashMap是一个会自动清除Entry的Map\n- WeakHashMap的操作与HashMap完全一致\n- WeakHashMap内部数据结构是数组+链表\n- WeakHashMap常被用作缓存","slug":"java/collection/weakhashmap-code-detail","published":1,"updated":"2019-06-04T01:29:57.097Z","_id":"cjxze3guw004a0cvw1sd62ppr","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>源码详解系列均基于<code>JDK8</code>进行解析</p>\n</blockquote>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>在Java容器详解系列文章的最后，介绍一个相对特殊的成员：<code>WeakHashMap</code>，从名字可以看出它是一个 <code>Map</code>。它的使用上跟<code>HashMap</code>并没有什么区别，所以很多地方这里就不做过多介绍了，可以翻看一下前面HashMap中的内容。本篇主要介绍它与HashMap的不同之处。</p>\n<p><code>WeakHashMap</code> 特殊之处在于<code>WeakHashMap</code> 里的<code>entry</code>可能会被垃圾回收器自动删除，也就是说即使你没有调用<code>remove()</code>或者<code>clear()</code>方法，它的entry也可能会慢慢变少。所以多次调用比如isEmpty，containsKey，size等方法时可能会返回不同的结果。</p>\n<p>接下来希望能带着这么几个问题来进行阅读：</p>\n<p>1、WeakHashMap中的Entry为什么会自动被回收。</p>\n<p>2、WeakHashMap与HashMap的区别是什么。</p>\n<p>3、WeakHashMap的引用场景有哪些。</p>\n<h2 id=\"WeakHashMap探秘\"><a href=\"#WeakHashMap探秘\" class=\"headerlink\" title=\"WeakHashMap探秘\"></a>WeakHashMap探秘</h2><p>从说明可以看出，WeakHashMap的特殊之处便在于它的Entry与众不同，里面的Entry会被垃圾回收器自动回收，那么问题来了，为什么会被自动回收呢？HashMap里的Entry并不会被自动回收，除非把它从Map中移除掉。</p>\n<p>其实这个秘密就在于<a href=\"../reference/weak-reference.html\">弱引用</a>，WeakHashMap中的key是间接保存在弱引用中的，所以当key没有被继续使用时，就可能会在GC的时候被回收掉。</p>\n<p>只有key对象是使用弱引用保存的，value对象实际上仍旧是通过普通的强引用来保持的，所以应该确保value不会直接或者间接的保持其对应key的强引用，因为这样会阻止key被回收。</p>\n<p>如果对于引用类型不熟悉的话，可以先阅读<a href=\"../reference/four-kinds-of-reference.html\">这篇文章</a>。</p>\n<p>下面来从源码角度看看具体是如何实现这个特性的。</p>\n<h2 id=\"继承结构\"><a href=\"#继承结构\" class=\"headerlink\" title=\"继承结构\"></a>继承结构</h2><img src=\"/programming/java/collection/weakhashmap-code-detail/weakhashmap-1.png\" title=\"weakhashmap-1\">\n<p>WeakHashMap并不是继承自HashMap，而是继承自AbstractMap，跟HashMap的继承结构差不多。</p>\n<h2 id=\"存储结构\"><a href=\"#存储结构\" class=\"headerlink\" title=\"存储结构\"></a>存储结构</h2><p>WeakHashMap中的数据结构是数组+链表的形式，这一点跟HashMap也是一致的，但不同的是，在JDK8中，当发生较多key冲突的时候，HashMap中会由链表转为红黑树，而WeakHashMap则一直使用链表进行存储。</p>\n<img src=\"/programming/java/collection/weakhashmap-code-detail/weakhashmap-4.png\" title=\"weakhashmap-4\">\n<h2 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认初始容量，必须是2的幂</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 最大容量</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 默认装载因子</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Entry数组，长度必须为2的幂</span></span><br><span class=\"line\">Entry&lt;K,V&gt;[] table;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 元素个数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 阈值 </span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> threshold;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 装载因子</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用队列</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReferenceQueue&lt;Object&gt; queue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 修改次数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> modCount;</span><br></pre></td></tr></table></figure>\n<p>跟HashMap的成员变量几乎一致，这里多了一个ReferenceQueue，用来存放那些已经被回收了的弱引用对象。如果想知道ReferenceQueue是如何工作的，可以参考<a href=\"../reference/reference-queue-code-detail.html\">这篇文章</a>。</p>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>WeakHashMap中也有四个构造函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WeakHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WeakHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WeakHashMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WeakHashMap</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(Math.max((<span class=\"keyword\">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class=\"number\">1</span>,</span><br><span class=\"line\">                  DEFAULT_INITIAL_CAPACITY),</span><br><span class=\"line\">         DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\">    putAll(m);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到后三个，都是调用的第一个构造函数，下面再来看一下第一个构造函数的内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 校验initialCapacity</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Initial Capacity: \"</span>+</span><br><span class=\"line\">                                       initialCapacity);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">    initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 校验loadFactor</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Load factor: \"</span>+</span><br><span class=\"line\">                                       loadFactor);</span><br><span class=\"line\"><span class=\"keyword\">int</span> capacity = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// 将容量设置为大于initialCapacity的最小2的幂</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (capacity &lt; initialCapacity)</span><br><span class=\"line\">    capacity &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">table = newTable(capacity);</span><br><span class=\"line\"><span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">threshold = (<span class=\"keyword\">int</span>)(capacity * loadFactor);</span><br></pre></td></tr></table></figure>\n<p>再看看newTable函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Entry&lt;K,V&gt;[] newTable(<span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Entry&lt;K,V&gt;[]) <span class=\"keyword\">new</span> Entry&lt;?,?&gt;[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里其实只是简单的创建一个Entry数组。</p>\n<h2 id=\"Entry剖析\"><a href=\"#Entry剖析\" class=\"headerlink\" title=\"Entry剖析\"></a>Entry剖析</h2><p>接下来看看WeakHashMap中的核心角色——Entry。上面已经看到了，WeakHashMap中的table是一个Entry数组：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Entry&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>\n<p>来看看Entry长什么样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">Object</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">\t...   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Entry继承自WeakReference，继承关系图如下：</p>\n<img src=\"/programming/java/collection/weakhashmap-code-detail/weakhashmap-2.png\" title=\"weakhashmap-2\">\n<p>再来看看Entry中的内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 成员变量</span></span><br><span class=\"line\">V value;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;</span><br><span class=\"line\">Entry&lt;K,V&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">Entry(Object key, V value,</span><br><span class=\"line\">      ReferenceQueue&lt;Object&gt; queue,</span><br><span class=\"line\">      <span class=\"keyword\">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(key, queue);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.hash  = hash;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next  = next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>细心的你可能会发现，哎？key哪里去了，成员变量里没有key。别着急，看看构造函数就可以发现，它调用了父类的构造函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">super</span>(key, queue);</span><br></pre></td></tr></table></figure>\n<p>这里调用的WeakReference的构造函数，将key传入Reference中，保存在referent成员变量中。对Reference和WeakReference不熟悉的话可以参考<a href=\"../reference/reference-code-detail.html\">这篇文章</a>和<a href=\"../reference/weak-reference-code-detail.html\">这篇文章</a>。</p>\n<p>再看看其它几个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> K <span class=\"title\">getKey</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里调用了Reference的get方法，从中取出referent对象</span></span><br><span class=\"line\">    <span class=\"comment\">// WeakHashMap中，key如果为null会使用NULL_KEY来替代</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (K) WeakHashMap.unmaskNull(get());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">setValue</span><span class=\"params\">(V newValue)</span> </span>&#123;</span><br><span class=\"line\">    V oldValue = value;</span><br><span class=\"line\">    value = newValue;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(o <span class=\"keyword\">instanceof</span> Map.Entry))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class=\"line\">    K k1 = getKey();</span><br><span class=\"line\">    Object k2 = e.getKey();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k1 == k2 || (k1 != <span class=\"keyword\">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class=\"line\">        V v1 = getValue();</span><br><span class=\"line\">        Object v2 = e.getValue();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v1 == v2 || (v1 != <span class=\"keyword\">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    K k = getKey();</span><br><span class=\"line\">    V v = getValue();</span><br><span class=\"line\">    <span class=\"comment\">// 这里只是简单的把key和value的hashcode做一个异或处理</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Objects.hashCode(k) ^ Objects.hashCode(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getKey() + <span class=\"string\">\"=\"</span> + getValue();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里稍微说一下getKey方法，调用了WeakHashMap.unmaskNull，之所以要调用这个方法，其实是因为WeakHashMap中对key为null时的特殊处理，会将其指向一个特殊的内部变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object NULL_KEY = <span class=\"keyword\">new</span> Object();</span><br></pre></td></tr></table></figure>\n<p>与其对应的两个方法便是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Object <span class=\"title\">maskNull</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? NULL_KEY : key;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> Object <span class=\"title\">unmaskNull</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == NULL_KEY) ? <span class=\"keyword\">null</span> : key;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，其他WeakHashMap中的Entry最大的不同就是继承自WeakReference，并把key保存在了WeakReference中。可以说WeakHashMap的特性绝大部分都是WeakReference的功劳。</p>\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><p>主要的方法有这些：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>                   <span class=\"title\">clear</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">Object                 <span class=\"title\">clone</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span>                <span class=\"title\">containsKey</span><span class=\"params\">(Object key)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span>                <span class=\"title\">containsValue</span><span class=\"params\">(Object value)</span></span></span><br><span class=\"line\"><span class=\"function\">Set&lt;Entry&lt;K, V&gt;&gt;       <span class=\"title\">entrySet</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">V                      <span class=\"title\">get</span><span class=\"params\">(Object key)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span>                <span class=\"title\">isEmpty</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">Set&lt;K&gt;                 <span class=\"title\">keySet</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">V                      <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>                   <span class=\"title\">putAll</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; map)</span></span></span><br><span class=\"line\"><span class=\"function\">V                      <span class=\"title\">remove</span><span class=\"params\">(Object key)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>                    <span class=\"title\">size</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">Collection&lt;V&gt;          <span class=\"title\">values</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n<p>这里选其中的三个最常用的方法进行解析：</p>\n<h3 id=\"put方法\"><a href=\"#put方法\" class=\"headerlink\" title=\"put方法\"></a>put方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理null值</span></span><br><span class=\"line\">    Object k = maskNull(key);</span><br><span class=\"line\">    <span class=\"comment\">// 计算hash</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = hash(k);</span><br><span class=\"line\">    <span class=\"comment\">// 获取table</span></span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    <span class=\"comment\">// 计算下标</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(h, tab.length);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 查找Entry</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = tab[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (value != oldValue)</span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    Entry&lt;K,V&gt; e = tab[i];</span><br><span class=\"line\">    tab[i] = <span class=\"keyword\">new</span> Entry&lt;&gt;(k, value, queue, h, e);</span><br><span class=\"line\">    <span class=\"comment\">// 如果元素个数超过阈值，则进行扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt;= threshold)</span><br><span class=\"line\">        resize(tab.length * <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里涉及到的方法比较多，不慌不慌，一个一个来。</p>\n<p>先来看看hash方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = k.hashCode();</span><br><span class=\"line\">    <span class=\"comment\">// 这里做了二次散列，来扩大低位的影响</span></span><br><span class=\"line\">    h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>hash方法对key的hashcode进行了二次散列，主要是为了扩大低位的影响。因为Entry数组的大小是2的幂，在进行查找的时候，进行掩码处理，如果不进行二次散列，那么低位对index就完全没有影响了，如果不清楚也没有关系，之后在get方法里会有说明。</p>\n<p>至于为什么要选20,12,7,4。emmm，大概是效果奇佳吧（一本正经的胡说八道，有兴趣的话可以自行研究）。</p>\n<p>再看看indexFor函数，这里就是将数组长度减1后与hashcode做一个位与操作，因为length必定是2的幂，所以减1后就变成了掩码，再进行与操作就能直接得到hashcode mod length的结果了，但是这样操作效率会更高。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再来看看getTable方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Entry&lt;K,V&gt;[] getTable() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 清除被回收的Entry对象</span></span><br><span class=\"line\">    expungeStaleEntries();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> table;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">expungeStaleEntries</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Object x; (x = queue.poll()) != <span class=\"keyword\">null</span>; ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 循环获取引用队列中的对象</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (queue) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class=\"line\">            <span class=\"comment\">// 查找对应的位置</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = indexFor(e.hash, table.length);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 找到之前的Entry</span></span><br><span class=\"line\">            Entry&lt;K,V&gt; prev = table[i];</span><br><span class=\"line\">            Entry&lt;K,V&gt; p = prev;</span><br><span class=\"line\">            <span class=\"comment\">// 在链表中寻找</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                Entry&lt;K,V&gt; next = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prev == e)</span><br><span class=\"line\">                        table[i] = next;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                        prev.next = next;</span><br><span class=\"line\">                    <span class=\"comment\">// 将对应的value置为null，帮助GC回收</span></span><br><span class=\"line\">                    e.value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    size--;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以每次调用getTable的时候，都会将table中key已经被回收掉的Entry移除掉。</p>\n<p>resize方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">(<span class=\"keyword\">int</span> newCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前table</span></span><br><span class=\"line\">    Entry&lt;K,V&gt;[] oldTable = getTable();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = oldTable.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">        threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 新建一个table</span></span><br><span class=\"line\">    Entry&lt;K,V&gt;[] newTable = newTable(newCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// 将旧table中的内容复制到新table中</span></span><br><span class=\"line\">    transfer(oldTable, newTable);</span><br><span class=\"line\">    table = newTable;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size &gt;= threshold / <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        threshold = (<span class=\"keyword\">int</span>)(newCapacity * loadFactor);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        expungeStaleEntries();</span><br><span class=\"line\">        transfer(newTable, oldTable);</span><br><span class=\"line\">        table = oldTable;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 新建Entry数组</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Entry&lt;K,V&gt;[] newTable(<span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Entry&lt;K,V&gt;[]) <span class=\"keyword\">new</span> Entry&lt;?,?&gt;[n];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">(Entry&lt;K,V&gt;[] src, Entry&lt;K,V&gt;[] dest)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; src.length; ++j) &#123;</span><br><span class=\"line\">        Entry&lt;K,V&gt; e = src[j];</span><br><span class=\"line\">        src[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Entry&lt;K,V&gt; next = e.next;</span><br><span class=\"line\">            Object key = e.get();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                e.next = <span class=\"keyword\">null</span>; </span><br><span class=\"line\">                e.value = <span class=\"keyword\">null</span>; </span><br><span class=\"line\">                size--;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> i = indexFor(e.hash, dest.length);</span><br><span class=\"line\">                e.next = dest[i];</span><br><span class=\"line\">                dest[i] = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            e = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"get方法\"><a href=\"#get方法\" class=\"headerlink\" title=\"get方法\"></a>get方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 对null值特殊处理</span></span><br><span class=\"line\">    Object k = maskNull(key);</span><br><span class=\"line\">    <span class=\"comment\">// 取key的hash值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = hash(k);</span><br><span class=\"line\">    <span class=\"comment\">// 取当前table</span></span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    <span class=\"comment\">// 获取下标</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = indexFor(h, tab.length);</span><br><span class=\"line\">    Entry&lt;K,V&gt; e = tab[index];</span><br><span class=\"line\">    <span class=\"comment\">// 链表中查找元素</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == h &amp;&amp; eq(k, e.get()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">        e = e.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在查找元素的时候调用了一个eq方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">eq</span><span class=\"params\">(Object x, Object y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x == y || x.equals(y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"remove方法\"><a href=\"#remove方法\" class=\"headerlink\" title=\"remove方法\"></a>remove方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 对null值特殊处理</span></span><br><span class=\"line\">    Object k = maskNull(key);</span><br><span class=\"line\">    <span class=\"comment\">// 取key的hash</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = hash(k);</span><br><span class=\"line\">    <span class=\"comment\">// 取当前table</span></span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    <span class=\"comment\">// 计算下标</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(h, tab.length);</span><br><span class=\"line\">    Entry&lt;K,V&gt; prev = tab[i];</span><br><span class=\"line\">    Entry&lt;K,V&gt; e = prev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Entry&lt;K,V&gt; next = e.next;</span><br><span class=\"line\">        <span class=\"comment\">// 查找对应Entry</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class=\"line\">            modCount++;</span><br><span class=\"line\">            size--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev == e)</span><br><span class=\"line\">                tab[i] = next;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                prev.next = next;</span><br><span class=\"line\">            <span class=\"comment\">// 如果找到，返回对应Entry的value</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        prev = e;</span><br><span class=\"line\">        e = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用栗子\"><a href=\"#使用栗子\" class=\"headerlink\" title=\"使用栗子\"></a>使用栗子</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WeakHashMapTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        testWeakHashMap();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testWeakHashMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建3个String对象用来做key</span></span><br><span class=\"line\">        String w1 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"key1\"</span>);</span><br><span class=\"line\">        String w2 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"key2\"</span>);</span><br><span class=\"line\">        String w3 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"key3\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 新建WeakHashMap</span></span><br><span class=\"line\">        Map weakHashMap = <span class=\"keyword\">new</span> WeakHashMap();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加键值对</span></span><br><span class=\"line\">        weakHashMap.put(w1, <span class=\"string\">\"v1\"</span>);</span><br><span class=\"line\">        weakHashMap.put(w2, <span class=\"string\">\"v2\"</span>);</span><br><span class=\"line\">        weakHashMap.put(w3, <span class=\"string\">\"v3\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 打印出weakHashMap</span></span><br><span class=\"line\">        System.out.printf(<span class=\"string\">\"weakHashMap:%s\\n\"</span>, weakHashMap);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// containsKey(Object key) :是否包含键key</span></span><br><span class=\"line\">        System.out.printf(<span class=\"string\">\"contains key key1 : %s\\n\"</span>,weakHashMap.containsKey(<span class=\"string\">\"key1\"</span>));</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">\"contains key key4 : %s\\n\"</span>,weakHashMap.containsKey(<span class=\"string\">\"key4\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// containsValue(Object value) :是否包含值value</span></span><br><span class=\"line\">        System.out.printf(<span class=\"string\">\"contains value v1 : %s\\n\"</span>,weakHashMap.containsValue(<span class=\"string\">\"v1\"</span>));</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">\"contains value 0 : %s\\n\"</span>,weakHashMap.containsValue(<span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// remove(Object key) ： 删除键key对应的键值对</span></span><br><span class=\"line\">        weakHashMap.remove(<span class=\"string\">\"three\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.printf(<span class=\"string\">\"weakHashMap: %s\\n\"</span>, weakHashMap);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ---- 测试 WeakHashMap 的自动回收特性 ----</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将w1设置null。</span></span><br><span class=\"line\">        <span class=\"comment\">// 这意味着“弱键”w1再没有被其它对象引用，调用gc时会回收WeakHashMap中与“w1”对应的键值对</span></span><br><span class=\"line\">        w1 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 内存回收。这里，会回收WeakHashMap中与“w1”对应的键值对</span></span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 遍历WeakHashMap</span></span><br><span class=\"line\">        Iterator iter = weakHashMap.entrySet().iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">            Map.Entry en = (Map.Entry)iter.next();</span><br><span class=\"line\">            System.out.printf(<span class=\"string\">\"next : %s - %s\\n\"</span>,en.getKey(),en.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 打印WeakHashMap的实际大小</span></span><br><span class=\"line\">        System.out.printf(<span class=\"string\">\"after gc WeakHashMap size:%s\\n\"</span>, weakHashMap.size());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">weakHashMap:&#123;key1=w1, key2=w2, key3=w3&#125;</span><br><span class=\"line\">contains key key1 : <span class=\"keyword\">true</span></span><br><span class=\"line\">contains key key4 : <span class=\"keyword\">false</span></span><br><span class=\"line\">contains value w1 : <span class=\"keyword\">true</span></span><br><span class=\"line\">contains value <span class=\"number\">0</span> : <span class=\"keyword\">false</span></span><br><span class=\"line\">weakHashMap: &#123;key1=w1, key2=w2, key3=w3&#125;</span><br><span class=\"line\">next : key2 - w2</span><br><span class=\"line\">next : key3 - w3</span><br><span class=\"line\">after gc WeakHashMap size:<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，w1对应的Entry被回收掉了，这就是WeakHashMap的最重要特性，当然，实际使用的时候一般不会这样使用，</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>由于WeakHashMap可以自动清除Entry，所以比较适合用于存储非必需对象，用作缓存非常合适。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcurrentCache</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;K,V&gt; eden;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;K,V&gt; longterm;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConcurrentCache</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.size = size;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.eden = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;(size);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.longterm = <span class=\"keyword\">new</span> WeakHashMap&lt;&gt;(size);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(K k)</span> </span>&#123;</span><br><span class=\"line\">        V v = <span class=\"keyword\">this</span>.eden.get(k);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (longterm) &#123;</span><br><span class=\"line\">                v = <span class=\"keyword\">this</span>.longterm.get(k);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (v != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.eden.put(k, v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(K k, V v)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.eden.size() &gt;= size) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (longterm) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.longterm.putAll(<span class=\"keyword\">this</span>.eden);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.eden.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.eden.put(k, v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在put方法里，在插入一个键值对时，先检查eden缓存的容量是不是超过了阈值，如果没有超就直接放入eden缓存，如果超了就将eden中所有的键值对都放入longterm（这里longterm类似于老年代，eden类似于年轻代），再将eden清空并插入相应键值对。</p>\n<p>在get方法中，也是优先从eden中找对应的value，如果没有则进入longterm缓存中查找，找到后就加入eden缓存并返回。</p>\n<p>这样设计的好处是，能将相对常用的对象都能在eden缓存中找到，不常用的则存入longterm缓存，并且由于WeakHashMap能自动清除Entry，所以不用担心longterm中键值对过多而导致OOM。</p>\n<p>WeakHashMap还有这样一个不错的应用场景，配合事务进行使用，存储事务过程中的各类信息。可以使用如下结构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WeakHashMap&lt;String,Map&lt;K,V&gt;&gt; transactionCache;</span><br></pre></td></tr></table></figure>\n<p>这里key为String类型，可以用来标志区分不同的事务，起到一个事务id的作用。value是一个map，可以是一个简单的HashMap或者LinkedHashMap，用来存放在事务中需要使用到的信息。</p>\n<p>在事务开始时创建一个事务id，并用它来作为key，事务结束后，将这个强引用消除掉，这样既能保证在事务中可以获取到所需要的信息，又能自动释放掉map中的所有信息。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>WeakHashMap是一个会自动清除Entry的Map</li>\n<li>WeakHashMap的操作与HashMap完全一致</li>\n<li>WeakHashMap内部数据结构是数组+链表</li>\n<li>WeakHashMap常被用作缓存</li>\n</ul>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<blockquote>\n<p>源码详解系列均基于<code>JDK8</code>进行解析</p>\n</blockquote>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>在Java容器详解系列文章的最后，介绍一个相对特殊的成员：<code>WeakHashMap</code>，从名字可以看出它是一个 <code>Map</code>。它的使用上跟<code>HashMap</code>并没有什么区别，所以很多地方这里就不做过多介绍了，可以翻看一下前面HashMap中的内容。本篇主要介绍它与HashMap的不同之处。</p>\n<p><code>WeakHashMap</code> 特殊之处在于<code>WeakHashMap</code> 里的<code>entry</code>可能会被垃圾回收器自动删除，也就是说即使你没有调用<code>remove()</code>或者<code>clear()</code>方法，它的entry也可能会慢慢变少。所以多次调用比如isEmpty，containsKey，size等方法时可能会返回不同的结果。</p>\n<p>接下来希望能带着这么几个问题来进行阅读：</p>\n<p>1、WeakHashMap中的Entry为什么会自动被回收。</p>\n<p>2、WeakHashMap与HashMap的区别是什么。</p>\n<p>3、WeakHashMap的引用场景有哪些。</p>\n<h2 id=\"WeakHashMap探秘\"><a href=\"#WeakHashMap探秘\" class=\"headerlink\" title=\"WeakHashMap探秘\"></a>WeakHashMap探秘</h2><p>从说明可以看出，WeakHashMap的特殊之处便在于它的Entry与众不同，里面的Entry会被垃圾回收器自动回收，那么问题来了，为什么会被自动回收呢？HashMap里的Entry并不会被自动回收，除非把它从Map中移除掉。</p>\n<p>其实这个秘密就在于<a href=\"../reference/weak-reference.html\">弱引用</a>，WeakHashMap中的key是间接保存在弱引用中的，所以当key没有被继续使用时，就可能会在GC的时候被回收掉。</p>\n<p>只有key对象是使用弱引用保存的，value对象实际上仍旧是通过普通的强引用来保持的，所以应该确保value不会直接或者间接的保持其对应key的强引用，因为这样会阻止key被回收。</p>\n<p>如果对于引用类型不熟悉的话，可以先阅读<a href=\"../reference/four-kinds-of-reference.html\">这篇文章</a>。</p>\n<p>下面来从源码角度看看具体是如何实现这个特性的。</p>\n<h2 id=\"继承结构\"><a href=\"#继承结构\" class=\"headerlink\" title=\"继承结构\"></a>继承结构</h2><img src=\"/programming/java/collection/weakhashmap-code-detail/weakhashmap-1.png\" title=\"weakhashmap-1\">\n<p>WeakHashMap并不是继承自HashMap，而是继承自AbstractMap，跟HashMap的继承结构差不多。</p>\n<h2 id=\"存储结构\"><a href=\"#存储结构\" class=\"headerlink\" title=\"存储结构\"></a>存储结构</h2><p>WeakHashMap中的数据结构是数组+链表的形式，这一点跟HashMap也是一致的，但不同的是，在JDK8中，当发生较多key冲突的时候，HashMap中会由链表转为红黑树，而WeakHashMap则一直使用链表进行存储。</p>\n<img src=\"/programming/java/collection/weakhashmap-code-detail/weakhashmap-4.png\" title=\"weakhashmap-4\">\n<h2 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认初始容量，必须是2的幂</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 最大容量</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 默认装载因子</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Entry数组，长度必须为2的幂</span></span><br><span class=\"line\">Entry&lt;K,V&gt;[] table;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 元素个数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 阈值 </span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> threshold;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 装载因子</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用队列</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReferenceQueue&lt;Object&gt; queue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 修改次数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> modCount;</span><br></pre></td></tr></table></figure>\n<p>跟HashMap的成员变量几乎一致，这里多了一个ReferenceQueue，用来存放那些已经被回收了的弱引用对象。如果想知道ReferenceQueue是如何工作的，可以参考<a href=\"../reference/reference-queue-code-detail.html\">这篇文章</a>。</p>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>WeakHashMap中也有四个构造函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WeakHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WeakHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WeakHashMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WeakHashMap</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(Math.max((<span class=\"keyword\">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class=\"number\">1</span>,</span><br><span class=\"line\">                  DEFAULT_INITIAL_CAPACITY),</span><br><span class=\"line\">         DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\">    putAll(m);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到后三个，都是调用的第一个构造函数，下面再来看一下第一个构造函数的内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 校验initialCapacity</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Initial Capacity: \"</span>+</span><br><span class=\"line\">                                       initialCapacity);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">    initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 校验loadFactor</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Load factor: \"</span>+</span><br><span class=\"line\">                                       loadFactor);</span><br><span class=\"line\"><span class=\"keyword\">int</span> capacity = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// 将容量设置为大于initialCapacity的最小2的幂</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (capacity &lt; initialCapacity)</span><br><span class=\"line\">    capacity &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">table = newTable(capacity);</span><br><span class=\"line\"><span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">threshold = (<span class=\"keyword\">int</span>)(capacity * loadFactor);</span><br></pre></td></tr></table></figure>\n<p>再看看newTable函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Entry&lt;K,V&gt;[] newTable(<span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Entry&lt;K,V&gt;[]) <span class=\"keyword\">new</span> Entry&lt;?,?&gt;[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里其实只是简单的创建一个Entry数组。</p>\n<h2 id=\"Entry剖析\"><a href=\"#Entry剖析\" class=\"headerlink\" title=\"Entry剖析\"></a>Entry剖析</h2><p>接下来看看WeakHashMap中的核心角色——Entry。上面已经看到了，WeakHashMap中的table是一个Entry数组：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Entry&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>\n<p>来看看Entry长什么样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">Object</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">\t...   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Entry继承自WeakReference，继承关系图如下：</p>\n<img src=\"/programming/java/collection/weakhashmap-code-detail/weakhashmap-2.png\" title=\"weakhashmap-2\">\n<p>再来看看Entry中的内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 成员变量</span></span><br><span class=\"line\">V value;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;</span><br><span class=\"line\">Entry&lt;K,V&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">Entry(Object key, V value,</span><br><span class=\"line\">      ReferenceQueue&lt;Object&gt; queue,</span><br><span class=\"line\">      <span class=\"keyword\">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(key, queue);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.hash  = hash;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next  = next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>细心的你可能会发现，哎？key哪里去了，成员变量里没有key。别着急，看看构造函数就可以发现，它调用了父类的构造函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">super</span>(key, queue);</span><br></pre></td></tr></table></figure>\n<p>这里调用的WeakReference的构造函数，将key传入Reference中，保存在referent成员变量中。对Reference和WeakReference不熟悉的话可以参考<a href=\"../reference/reference-code-detail.html\">这篇文章</a>和<a href=\"../reference/weak-reference-code-detail.html\">这篇文章</a>。</p>\n<p>再看看其它几个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> K <span class=\"title\">getKey</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里调用了Reference的get方法，从中取出referent对象</span></span><br><span class=\"line\">    <span class=\"comment\">// WeakHashMap中，key如果为null会使用NULL_KEY来替代</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (K) WeakHashMap.unmaskNull(get());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">setValue</span><span class=\"params\">(V newValue)</span> </span>&#123;</span><br><span class=\"line\">    V oldValue = value;</span><br><span class=\"line\">    value = newValue;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(o <span class=\"keyword\">instanceof</span> Map.Entry))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class=\"line\">    K k1 = getKey();</span><br><span class=\"line\">    Object k2 = e.getKey();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k1 == k2 || (k1 != <span class=\"keyword\">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class=\"line\">        V v1 = getValue();</span><br><span class=\"line\">        Object v2 = e.getValue();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v1 == v2 || (v1 != <span class=\"keyword\">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    K k = getKey();</span><br><span class=\"line\">    V v = getValue();</span><br><span class=\"line\">    <span class=\"comment\">// 这里只是简单的把key和value的hashcode做一个异或处理</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Objects.hashCode(k) ^ Objects.hashCode(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getKey() + <span class=\"string\">\"=\"</span> + getValue();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里稍微说一下getKey方法，调用了WeakHashMap.unmaskNull，之所以要调用这个方法，其实是因为WeakHashMap中对key为null时的特殊处理，会将其指向一个特殊的内部变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object NULL_KEY = <span class=\"keyword\">new</span> Object();</span><br></pre></td></tr></table></figure>\n<p>与其对应的两个方法便是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Object <span class=\"title\">maskNull</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? NULL_KEY : key;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> Object <span class=\"title\">unmaskNull</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == NULL_KEY) ? <span class=\"keyword\">null</span> : key;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，其他WeakHashMap中的Entry最大的不同就是继承自WeakReference，并把key保存在了WeakReference中。可以说WeakHashMap的特性绝大部分都是WeakReference的功劳。</p>\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><p>主要的方法有这些：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>                   <span class=\"title\">clear</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">Object                 <span class=\"title\">clone</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span>                <span class=\"title\">containsKey</span><span class=\"params\">(Object key)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span>                <span class=\"title\">containsValue</span><span class=\"params\">(Object value)</span></span></span><br><span class=\"line\"><span class=\"function\">Set&lt;Entry&lt;K, V&gt;&gt;       <span class=\"title\">entrySet</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">V                      <span class=\"title\">get</span><span class=\"params\">(Object key)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span>                <span class=\"title\">isEmpty</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">Set&lt;K&gt;                 <span class=\"title\">keySet</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">V                      <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>                   <span class=\"title\">putAll</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; map)</span></span></span><br><span class=\"line\"><span class=\"function\">V                      <span class=\"title\">remove</span><span class=\"params\">(Object key)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>                    <span class=\"title\">size</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">Collection&lt;V&gt;          <span class=\"title\">values</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n<p>这里选其中的三个最常用的方法进行解析：</p>\n<h3 id=\"put方法\"><a href=\"#put方法\" class=\"headerlink\" title=\"put方法\"></a>put方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理null值</span></span><br><span class=\"line\">    Object k = maskNull(key);</span><br><span class=\"line\">    <span class=\"comment\">// 计算hash</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = hash(k);</span><br><span class=\"line\">    <span class=\"comment\">// 获取table</span></span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    <span class=\"comment\">// 计算下标</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(h, tab.length);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 查找Entry</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = tab[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (value != oldValue)</span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    Entry&lt;K,V&gt; e = tab[i];</span><br><span class=\"line\">    tab[i] = <span class=\"keyword\">new</span> Entry&lt;&gt;(k, value, queue, h, e);</span><br><span class=\"line\">    <span class=\"comment\">// 如果元素个数超过阈值，则进行扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt;= threshold)</span><br><span class=\"line\">        resize(tab.length * <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里涉及到的方法比较多，不慌不慌，一个一个来。</p>\n<p>先来看看hash方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = k.hashCode();</span><br><span class=\"line\">    <span class=\"comment\">// 这里做了二次散列，来扩大低位的影响</span></span><br><span class=\"line\">    h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>hash方法对key的hashcode进行了二次散列，主要是为了扩大低位的影响。因为Entry数组的大小是2的幂，在进行查找的时候，进行掩码处理，如果不进行二次散列，那么低位对index就完全没有影响了，如果不清楚也没有关系，之后在get方法里会有说明。</p>\n<p>至于为什么要选20,12,7,4。emmm，大概是效果奇佳吧（一本正经的胡说八道，有兴趣的话可以自行研究）。</p>\n<p>再看看indexFor函数，这里就是将数组长度减1后与hashcode做一个位与操作，因为length必定是2的幂，所以减1后就变成了掩码，再进行与操作就能直接得到hashcode mod length的结果了，但是这样操作效率会更高。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再来看看getTable方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Entry&lt;K,V&gt;[] getTable() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 清除被回收的Entry对象</span></span><br><span class=\"line\">    expungeStaleEntries();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> table;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">expungeStaleEntries</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Object x; (x = queue.poll()) != <span class=\"keyword\">null</span>; ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 循环获取引用队列中的对象</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (queue) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class=\"line\">            <span class=\"comment\">// 查找对应的位置</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = indexFor(e.hash, table.length);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 找到之前的Entry</span></span><br><span class=\"line\">            Entry&lt;K,V&gt; prev = table[i];</span><br><span class=\"line\">            Entry&lt;K,V&gt; p = prev;</span><br><span class=\"line\">            <span class=\"comment\">// 在链表中寻找</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                Entry&lt;K,V&gt; next = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == e) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prev == e)</span><br><span class=\"line\">                        table[i] = next;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                        prev.next = next;</span><br><span class=\"line\">                    <span class=\"comment\">// 将对应的value置为null，帮助GC回收</span></span><br><span class=\"line\">                    e.value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    size--;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以每次调用getTable的时候，都会将table中key已经被回收掉的Entry移除掉。</p>\n<p>resize方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">(<span class=\"keyword\">int</span> newCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前table</span></span><br><span class=\"line\">    Entry&lt;K,V&gt;[] oldTable = getTable();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = oldTable.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">        threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 新建一个table</span></span><br><span class=\"line\">    Entry&lt;K,V&gt;[] newTable = newTable(newCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// 将旧table中的内容复制到新table中</span></span><br><span class=\"line\">    transfer(oldTable, newTable);</span><br><span class=\"line\">    table = newTable;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size &gt;= threshold / <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        threshold = (<span class=\"keyword\">int</span>)(newCapacity * loadFactor);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        expungeStaleEntries();</span><br><span class=\"line\">        transfer(newTable, oldTable);</span><br><span class=\"line\">        table = oldTable;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 新建Entry数组</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Entry&lt;K,V&gt;[] newTable(<span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Entry&lt;K,V&gt;[]) <span class=\"keyword\">new</span> Entry&lt;?,?&gt;[n];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">(Entry&lt;K,V&gt;[] src, Entry&lt;K,V&gt;[] dest)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; src.length; ++j) &#123;</span><br><span class=\"line\">        Entry&lt;K,V&gt; e = src[j];</span><br><span class=\"line\">        src[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Entry&lt;K,V&gt; next = e.next;</span><br><span class=\"line\">            Object key = e.get();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                e.next = <span class=\"keyword\">null</span>; </span><br><span class=\"line\">                e.value = <span class=\"keyword\">null</span>; </span><br><span class=\"line\">                size--;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> i = indexFor(e.hash, dest.length);</span><br><span class=\"line\">                e.next = dest[i];</span><br><span class=\"line\">                dest[i] = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            e = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"get方法\"><a href=\"#get方法\" class=\"headerlink\" title=\"get方法\"></a>get方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 对null值特殊处理</span></span><br><span class=\"line\">    Object k = maskNull(key);</span><br><span class=\"line\">    <span class=\"comment\">// 取key的hash值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = hash(k);</span><br><span class=\"line\">    <span class=\"comment\">// 取当前table</span></span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    <span class=\"comment\">// 获取下标</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = indexFor(h, tab.length);</span><br><span class=\"line\">    Entry&lt;K,V&gt; e = tab[index];</span><br><span class=\"line\">    <span class=\"comment\">// 链表中查找元素</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == h &amp;&amp; eq(k, e.get()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">        e = e.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在查找元素的时候调用了一个eq方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">eq</span><span class=\"params\">(Object x, Object y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x == y || x.equals(y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"remove方法\"><a href=\"#remove方法\" class=\"headerlink\" title=\"remove方法\"></a>remove方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 对null值特殊处理</span></span><br><span class=\"line\">    Object k = maskNull(key);</span><br><span class=\"line\">    <span class=\"comment\">// 取key的hash</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = hash(k);</span><br><span class=\"line\">    <span class=\"comment\">// 取当前table</span></span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    <span class=\"comment\">// 计算下标</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(h, tab.length);</span><br><span class=\"line\">    Entry&lt;K,V&gt; prev = tab[i];</span><br><span class=\"line\">    Entry&lt;K,V&gt; e = prev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Entry&lt;K,V&gt; next = e.next;</span><br><span class=\"line\">        <span class=\"comment\">// 查找对应Entry</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class=\"line\">            modCount++;</span><br><span class=\"line\">            size--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev == e)</span><br><span class=\"line\">                tab[i] = next;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                prev.next = next;</span><br><span class=\"line\">            <span class=\"comment\">// 如果找到，返回对应Entry的value</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        prev = e;</span><br><span class=\"line\">        e = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用栗子\"><a href=\"#使用栗子\" class=\"headerlink\" title=\"使用栗子\"></a>使用栗子</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WeakHashMapTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        testWeakHashMap();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testWeakHashMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建3个String对象用来做key</span></span><br><span class=\"line\">        String w1 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"key1\"</span>);</span><br><span class=\"line\">        String w2 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"key2\"</span>);</span><br><span class=\"line\">        String w3 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"key3\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 新建WeakHashMap</span></span><br><span class=\"line\">        Map weakHashMap = <span class=\"keyword\">new</span> WeakHashMap();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加键值对</span></span><br><span class=\"line\">        weakHashMap.put(w1, <span class=\"string\">\"v1\"</span>);</span><br><span class=\"line\">        weakHashMap.put(w2, <span class=\"string\">\"v2\"</span>);</span><br><span class=\"line\">        weakHashMap.put(w3, <span class=\"string\">\"v3\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 打印出weakHashMap</span></span><br><span class=\"line\">        System.out.printf(<span class=\"string\">\"weakHashMap:%s\\n\"</span>, weakHashMap);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// containsKey(Object key) :是否包含键key</span></span><br><span class=\"line\">        System.out.printf(<span class=\"string\">\"contains key key1 : %s\\n\"</span>,weakHashMap.containsKey(<span class=\"string\">\"key1\"</span>));</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">\"contains key key4 : %s\\n\"</span>,weakHashMap.containsKey(<span class=\"string\">\"key4\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// containsValue(Object value) :是否包含值value</span></span><br><span class=\"line\">        System.out.printf(<span class=\"string\">\"contains value v1 : %s\\n\"</span>,weakHashMap.containsValue(<span class=\"string\">\"v1\"</span>));</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">\"contains value 0 : %s\\n\"</span>,weakHashMap.containsValue(<span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// remove(Object key) ： 删除键key对应的键值对</span></span><br><span class=\"line\">        weakHashMap.remove(<span class=\"string\">\"three\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.printf(<span class=\"string\">\"weakHashMap: %s\\n\"</span>, weakHashMap);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ---- 测试 WeakHashMap 的自动回收特性 ----</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将w1设置null。</span></span><br><span class=\"line\">        <span class=\"comment\">// 这意味着“弱键”w1再没有被其它对象引用，调用gc时会回收WeakHashMap中与“w1”对应的键值对</span></span><br><span class=\"line\">        w1 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 内存回收。这里，会回收WeakHashMap中与“w1”对应的键值对</span></span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 遍历WeakHashMap</span></span><br><span class=\"line\">        Iterator iter = weakHashMap.entrySet().iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">            Map.Entry en = (Map.Entry)iter.next();</span><br><span class=\"line\">            System.out.printf(<span class=\"string\">\"next : %s - %s\\n\"</span>,en.getKey(),en.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 打印WeakHashMap的实际大小</span></span><br><span class=\"line\">        System.out.printf(<span class=\"string\">\"after gc WeakHashMap size:%s\\n\"</span>, weakHashMap.size());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">weakHashMap:&#123;key1=w1, key2=w2, key3=w3&#125;</span><br><span class=\"line\">contains key key1 : <span class=\"keyword\">true</span></span><br><span class=\"line\">contains key key4 : <span class=\"keyword\">false</span></span><br><span class=\"line\">contains value w1 : <span class=\"keyword\">true</span></span><br><span class=\"line\">contains value <span class=\"number\">0</span> : <span class=\"keyword\">false</span></span><br><span class=\"line\">weakHashMap: &#123;key1=w1, key2=w2, key3=w3&#125;</span><br><span class=\"line\">next : key2 - w2</span><br><span class=\"line\">next : key3 - w3</span><br><span class=\"line\">after gc WeakHashMap size:<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，w1对应的Entry被回收掉了，这就是WeakHashMap的最重要特性，当然，实际使用的时候一般不会这样使用，</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>由于WeakHashMap可以自动清除Entry，所以比较适合用于存储非必需对象，用作缓存非常合适。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcurrentCache</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;K,V&gt; eden;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;K,V&gt; longterm;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConcurrentCache</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.size = size;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.eden = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;(size);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.longterm = <span class=\"keyword\">new</span> WeakHashMap&lt;&gt;(size);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(K k)</span> </span>&#123;</span><br><span class=\"line\">        V v = <span class=\"keyword\">this</span>.eden.get(k);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (longterm) &#123;</span><br><span class=\"line\">                v = <span class=\"keyword\">this</span>.longterm.get(k);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (v != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.eden.put(k, v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(K k, V v)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.eden.size() &gt;= size) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (longterm) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.longterm.putAll(<span class=\"keyword\">this</span>.eden);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.eden.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.eden.put(k, v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在put方法里，在插入一个键值对时，先检查eden缓存的容量是不是超过了阈值，如果没有超就直接放入eden缓存，如果超了就将eden中所有的键值对都放入longterm（这里longterm类似于老年代，eden类似于年轻代），再将eden清空并插入相应键值对。</p>\n<p>在get方法中，也是优先从eden中找对应的value，如果没有则进入longterm缓存中查找，找到后就加入eden缓存并返回。</p>\n<p>这样设计的好处是，能将相对常用的对象都能在eden缓存中找到，不常用的则存入longterm缓存，并且由于WeakHashMap能自动清除Entry，所以不用担心longterm中键值对过多而导致OOM。</p>\n<p>WeakHashMap还有这样一个不错的应用场景，配合事务进行使用，存储事务过程中的各类信息。可以使用如下结构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WeakHashMap&lt;String,Map&lt;K,V&gt;&gt; transactionCache;</span><br></pre></td></tr></table></figure>\n<p>这里key为String类型，可以用来标志区分不同的事务，起到一个事务id的作用。value是一个map，可以是一个简单的HashMap或者LinkedHashMap，用来存放在事务中需要使用到的信息。</p>\n<p>在事务开始时创建一个事务id，并用它来作为key，事务结束后，将这个强引用消除掉，这样既能保证在事务中可以获取到所需要的信息，又能自动释放掉map中的所有信息。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>WeakHashMap是一个会自动清除Entry的Map</li>\n<li>WeakHashMap的操作与HashMap完全一致</li>\n<li>WeakHashMap内部数据结构是数组+链表</li>\n<li>WeakHashMap常被用作缓存</li>\n</ul>\n"},{"title":"【Java入门篇】小结","date":"2018-12-28T11:00:07.000Z","_content":"\n> 只要你在，我便无所不能。 -- 《进击的巨人》\n\n## 小结\n\n至此，Java入门篇就告一段落了，通过本篇的学习，希望你能掌握以下内容：\n\n1. Java有哪些用途\n2. 部署JDK\n3. 安装IDEA\n4. 使用IDEA创建一个类\n5. 使用IDEA开发一个简单的计算器\n\nJava入门篇的内容很简单，目的也只是为了让零基础的人能够快速上手Java并开发一个可以运行的程序，降低学习的门槛，增加学习的乐趣。\n\n如果你已经顺利完成了以上内容的学习，那么恭喜你，已经完成了新手的第一阶段试炼。后面的篇章就要真正开始Java中核心内容的介绍了，如果你学习的热情有幸还没有被浇灭，那么就拿着你的新手套装，在这场征程里继续前行吧。😆","source":"_posts/java/introduction/java-primer-conclusion.md","raw":"---\ntitle: 【Java入门篇】小结\ntags: \n - Java入门\n - Java\ncategories: 编程\ndate: 2018-12-28 19:00:07\n---\n\n> 只要你在，我便无所不能。 -- 《进击的巨人》\n\n## 小结\n\n至此，Java入门篇就告一段落了，通过本篇的学习，希望你能掌握以下内容：\n\n1. Java有哪些用途\n2. 部署JDK\n3. 安装IDEA\n4. 使用IDEA创建一个类\n5. 使用IDEA开发一个简单的计算器\n\nJava入门篇的内容很简单，目的也只是为了让零基础的人能够快速上手Java并开发一个可以运行的程序，降低学习的门槛，增加学习的乐趣。\n\n如果你已经顺利完成了以上内容的学习，那么恭喜你，已经完成了新手的第一阶段试炼。后面的篇章就要真正开始Java中核心内容的介绍了，如果你学习的热情有幸还没有被浇灭，那么就拿着你的新手套装，在这场征程里继续前行吧。😆","slug":"java/introduction/java-primer-conclusion","published":1,"updated":"2019-06-04T01:29:57.327Z","_id":"cjxze3gv6004e0cvwngbasiic","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>只要你在，我便无所不能。 – 《进击的巨人》</p>\n</blockquote>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>至此，Java入门篇就告一段落了，通过本篇的学习，希望你能掌握以下内容：</p>\n<ol>\n<li>Java有哪些用途</li>\n<li>部署JDK</li>\n<li>安装IDEA</li>\n<li>使用IDEA创建一个类</li>\n<li>使用IDEA开发一个简单的计算器</li>\n</ol>\n<p>Java入门篇的内容很简单，目的也只是为了让零基础的人能够快速上手Java并开发一个可以运行的程序，降低学习的门槛，增加学习的乐趣。</p>\n<p>如果你已经顺利完成了以上内容的学习，那么恭喜你，已经完成了新手的第一阶段试炼。后面的篇章就要真正开始Java中核心内容的介绍了，如果你学习的热情有幸还没有被浇灭，那么就拿着你的新手套装，在这场征程里继续前行吧。😆</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<blockquote>\n<p>只要你在，我便无所不能。 – 《进击的巨人》</p>\n</blockquote>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>至此，Java入门篇就告一段落了，通过本篇的学习，希望你能掌握以下内容：</p>\n<ol>\n<li>Java有哪些用途</li>\n<li>部署JDK</li>\n<li>安装IDEA</li>\n<li>使用IDEA创建一个类</li>\n<li>使用IDEA开发一个简单的计算器</li>\n</ol>\n<p>Java入门篇的内容很简单，目的也只是为了让零基础的人能够快速上手Java并开发一个可以运行的程序，降低学习的门槛，增加学习的乐趣。</p>\n<p>如果你已经顺利完成了以上内容的学习，那么恭喜你，已经完成了新手的第一阶段试炼。后面的篇章就要真正开始Java中核心内容的介绍了，如果你学习的热情有幸还没有被浇灭，那么就拿着你的新手套装，在这场征程里继续前行吧。😆</p>\n"},{"title":"Java中的垃圾回收","date":"2018-12-26T11:55:51.000Z","_content":"\n## 定义\n\nJava中的一个重要特性便是垃圾回收器，Java将程序员从无（dan）尽（teng）的内存管理中解放了出来，使用垃圾回收器自动收集程序中不再使用的对象，并释放其占用的内存空间。\n\n本篇主要从以下方面对垃圾回收进行介绍\n\n+ 垃圾收集的意义\n+ 垃圾收集的规则\n\n## 垃圾收集的意义\n\n在C++中，一个对象如果不显式进行释放，那么其占用的内存在程序运行期间将不会被释放；而在Java中，当没有对象引用指向内存中的某个对象时，其内存空间便成为垃圾。JVM的垃圾回收器线程变会自动释放该内存块。\n\n垃圾收集意味着程序员不再需要手动释放内存，不再需要的对象将会变成\"无用对象\"，这些对象将被自动清理和回收。当一个对象不再被引用的时候，将回收它占用的系统资源，如内存，句柄等等，以便这些资源继续分配给后来的新建的对象。\n\n事实上，除了释放没用的对象，垃圾收集也可以清理内存碎片。由于不断的创建对象，垃圾收集器不断进行内存回收和释放，内存会出现碎片。碎片是分配给对象的内存块之间的空闲内存洞。碎片整理将所占用的堆内存移到堆的一端，然后将整理出的内存分配给新的对象。\n\n垃圾收集能自动释放内存空间，减轻编程的负担。这使Java 虚拟机具有一些优点。首先，它能使编程效率提高。在没有垃圾收集机制的时候，可能要花许多时间来解决一个难懂的存储器问题。在用Java语言编程的时候，靠垃圾收集机制可大大缩短时间。其次是它保护程序的完整性， 垃圾收集是Java语言安全性策略的一个重要部份。\n\n垃圾收集的一个潜在的缺点是它的开销影响程序性能。Java虚拟机必须追踪运行程序中有用的对象，而且最终释放没用的对象。这一个过程需要花费处理器的时间。其次垃圾收集算法的不完备性，早先采用的某些垃圾收集算法就不能保证100%收集到所有的废弃内存。当然随着垃圾收集算法的不断改进以及软硬件运行效率的不断提升，这些问题都可以迎刃而解。\n\n## 垃圾收集规则\n\n虽然大部分JVM实现中都会有垃圾回收器，但事实上，JVM规范中并没有规定必须要有一个垃圾回收器。JVM规范在内存管理上给了虚拟机设计者很大设计自由度，甚至可以完全不使用垃圾回收器。\n\n当然，即使实现了垃圾回收器，你也总有办法把内存耗尽。<img src=\"../reference/0190.png\" width=\"40\"/>\n\n虚拟机规范中并没有描述需要给JVM留多大的内存空间，只规定了当JVM内存不足时，应该抛出一个OutOfMemoryError。\n\n此外，虚拟机规范中也并没有规定垃圾回收必须使用哪种算法，所以设计者们可以自由实现合适的垃圾回收算法。这也是众多JVM厂商竞争的领域。因为这对于程序而言十分重要。\n","source":"_posts/java/jvm/garbage-collection.md","raw":"---\ntitle: Java中的垃圾回收\ntags: \n - Java\n - 垃圾回收\ncategories: 编程\ndate: 2018-12-26 19:55:51\n---\n\n## 定义\n\nJava中的一个重要特性便是垃圾回收器，Java将程序员从无（dan）尽（teng）的内存管理中解放了出来，使用垃圾回收器自动收集程序中不再使用的对象，并释放其占用的内存空间。\n\n本篇主要从以下方面对垃圾回收进行介绍\n\n+ 垃圾收集的意义\n+ 垃圾收集的规则\n\n## 垃圾收集的意义\n\n在C++中，一个对象如果不显式进行释放，那么其占用的内存在程序运行期间将不会被释放；而在Java中，当没有对象引用指向内存中的某个对象时，其内存空间便成为垃圾。JVM的垃圾回收器线程变会自动释放该内存块。\n\n垃圾收集意味着程序员不再需要手动释放内存，不再需要的对象将会变成\"无用对象\"，这些对象将被自动清理和回收。当一个对象不再被引用的时候，将回收它占用的系统资源，如内存，句柄等等，以便这些资源继续分配给后来的新建的对象。\n\n事实上，除了释放没用的对象，垃圾收集也可以清理内存碎片。由于不断的创建对象，垃圾收集器不断进行内存回收和释放，内存会出现碎片。碎片是分配给对象的内存块之间的空闲内存洞。碎片整理将所占用的堆内存移到堆的一端，然后将整理出的内存分配给新的对象。\n\n垃圾收集能自动释放内存空间，减轻编程的负担。这使Java 虚拟机具有一些优点。首先，它能使编程效率提高。在没有垃圾收集机制的时候，可能要花许多时间来解决一个难懂的存储器问题。在用Java语言编程的时候，靠垃圾收集机制可大大缩短时间。其次是它保护程序的完整性， 垃圾收集是Java语言安全性策略的一个重要部份。\n\n垃圾收集的一个潜在的缺点是它的开销影响程序性能。Java虚拟机必须追踪运行程序中有用的对象，而且最终释放没用的对象。这一个过程需要花费处理器的时间。其次垃圾收集算法的不完备性，早先采用的某些垃圾收集算法就不能保证100%收集到所有的废弃内存。当然随着垃圾收集算法的不断改进以及软硬件运行效率的不断提升，这些问题都可以迎刃而解。\n\n## 垃圾收集规则\n\n虽然大部分JVM实现中都会有垃圾回收器，但事实上，JVM规范中并没有规定必须要有一个垃圾回收器。JVM规范在内存管理上给了虚拟机设计者很大设计自由度，甚至可以完全不使用垃圾回收器。\n\n当然，即使实现了垃圾回收器，你也总有办法把内存耗尽。<img src=\"../reference/0190.png\" width=\"40\"/>\n\n虚拟机规范中并没有描述需要给JVM留多大的内存空间，只规定了当JVM内存不足时，应该抛出一个OutOfMemoryError。\n\n此外，虚拟机规范中也并没有规定垃圾回收必须使用哪种算法，所以设计者们可以自由实现合适的垃圾回收算法。这也是众多JVM厂商竞争的领域。因为这对于程序而言十分重要。\n","slug":"java/jvm/garbage-collection","published":1,"updated":"2019-06-04T01:29:57.336Z","_id":"cjxze3gvg004h0cvwzl1jzq7d","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>Java中的一个重要特性便是垃圾回收器，Java将程序员从无（dan）尽（teng）的内存管理中解放了出来，使用垃圾回收器自动收集程序中不再使用的对象，并释放其占用的内存空间。</p>\n<p>本篇主要从以下方面对垃圾回收进行介绍</p>\n<ul>\n<li>垃圾收集的意义</li>\n<li>垃圾收集的规则</li>\n</ul>\n<h2 id=\"垃圾收集的意义\"><a href=\"#垃圾收集的意义\" class=\"headerlink\" title=\"垃圾收集的意义\"></a>垃圾收集的意义</h2><p>在C++中，一个对象如果不显式进行释放，那么其占用的内存在程序运行期间将不会被释放；而在Java中，当没有对象引用指向内存中的某个对象时，其内存空间便成为垃圾。JVM的垃圾回收器线程变会自动释放该内存块。</p>\n<p>垃圾收集意味着程序员不再需要手动释放内存，不再需要的对象将会变成”无用对象”，这些对象将被自动清理和回收。当一个对象不再被引用的时候，将回收它占用的系统资源，如内存，句柄等等，以便这些资源继续分配给后来的新建的对象。</p>\n<p>事实上，除了释放没用的对象，垃圾收集也可以清理内存碎片。由于不断的创建对象，垃圾收集器不断进行内存回收和释放，内存会出现碎片。碎片是分配给对象的内存块之间的空闲内存洞。碎片整理将所占用的堆内存移到堆的一端，然后将整理出的内存分配给新的对象。</p>\n<p>垃圾收集能自动释放内存空间，减轻编程的负担。这使Java 虚拟机具有一些优点。首先，它能使编程效率提高。在没有垃圾收集机制的时候，可能要花许多时间来解决一个难懂的存储器问题。在用Java语言编程的时候，靠垃圾收集机制可大大缩短时间。其次是它保护程序的完整性， 垃圾收集是Java语言安全性策略的一个重要部份。</p>\n<p>垃圾收集的一个潜在的缺点是它的开销影响程序性能。Java虚拟机必须追踪运行程序中有用的对象，而且最终释放没用的对象。这一个过程需要花费处理器的时间。其次垃圾收集算法的不完备性，早先采用的某些垃圾收集算法就不能保证100%收集到所有的废弃内存。当然随着垃圾收集算法的不断改进以及软硬件运行效率的不断提升，这些问题都可以迎刃而解。</p>\n<h2 id=\"垃圾收集规则\"><a href=\"#垃圾收集规则\" class=\"headerlink\" title=\"垃圾收集规则\"></a>垃圾收集规则</h2><p>虽然大部分JVM实现中都会有垃圾回收器，但事实上，JVM规范中并没有规定必须要有一个垃圾回收器。JVM规范在内存管理上给了虚拟机设计者很大设计自由度，甚至可以完全不使用垃圾回收器。</p>\n<p>当然，即使实现了垃圾回收器，你也总有办法把内存耗尽。<img src=\"../reference/0190.png\" width=\"40\"></p>\n<p>虚拟机规范中并没有描述需要给JVM留多大的内存空间，只规定了当JVM内存不足时，应该抛出一个OutOfMemoryError。</p>\n<p>此外，虚拟机规范中也并没有规定垃圾回收必须使用哪种算法，所以设计者们可以自由实现合适的垃圾回收算法。这也是众多JVM厂商竞争的领域。因为这对于程序而言十分重要。</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>Java中的一个重要特性便是垃圾回收器，Java将程序员从无（dan）尽（teng）的内存管理中解放了出来，使用垃圾回收器自动收集程序中不再使用的对象，并释放其占用的内存空间。</p>\n<p>本篇主要从以下方面对垃圾回收进行介绍</p>\n<ul>\n<li>垃圾收集的意义</li>\n<li>垃圾收集的规则</li>\n</ul>\n<h2 id=\"垃圾收集的意义\"><a href=\"#垃圾收集的意义\" class=\"headerlink\" title=\"垃圾收集的意义\"></a>垃圾收集的意义</h2><p>在C++中，一个对象如果不显式进行释放，那么其占用的内存在程序运行期间将不会被释放；而在Java中，当没有对象引用指向内存中的某个对象时，其内存空间便成为垃圾。JVM的垃圾回收器线程变会自动释放该内存块。</p>\n<p>垃圾收集意味着程序员不再需要手动释放内存，不再需要的对象将会变成”无用对象”，这些对象将被自动清理和回收。当一个对象不再被引用的时候，将回收它占用的系统资源，如内存，句柄等等，以便这些资源继续分配给后来的新建的对象。</p>\n<p>事实上，除了释放没用的对象，垃圾收集也可以清理内存碎片。由于不断的创建对象，垃圾收集器不断进行内存回收和释放，内存会出现碎片。碎片是分配给对象的内存块之间的空闲内存洞。碎片整理将所占用的堆内存移到堆的一端，然后将整理出的内存分配给新的对象。</p>\n<p>垃圾收集能自动释放内存空间，减轻编程的负担。这使Java 虚拟机具有一些优点。首先，它能使编程效率提高。在没有垃圾收集机制的时候，可能要花许多时间来解决一个难懂的存储器问题。在用Java语言编程的时候，靠垃圾收集机制可大大缩短时间。其次是它保护程序的完整性， 垃圾收集是Java语言安全性策略的一个重要部份。</p>\n<p>垃圾收集的一个潜在的缺点是它的开销影响程序性能。Java虚拟机必须追踪运行程序中有用的对象，而且最终释放没用的对象。这一个过程需要花费处理器的时间。其次垃圾收集算法的不完备性，早先采用的某些垃圾收集算法就不能保证100%收集到所有的废弃内存。当然随着垃圾收集算法的不断改进以及软硬件运行效率的不断提升，这些问题都可以迎刃而解。</p>\n<h2 id=\"垃圾收集规则\"><a href=\"#垃圾收集规则\" class=\"headerlink\" title=\"垃圾收集规则\"></a>垃圾收集规则</h2><p>虽然大部分JVM实现中都会有垃圾回收器，但事实上，JVM规范中并没有规定必须要有一个垃圾回收器。JVM规范在内存管理上给了虚拟机设计者很大设计自由度，甚至可以完全不使用垃圾回收器。</p>\n<p>当然，即使实现了垃圾回收器，你也总有办法把内存耗尽。<img src=\"../reference/0190.png\" width=\"40\"></p>\n<p>虚拟机规范中并没有描述需要给JVM留多大的内存空间，只规定了当JVM内存不足时，应该抛出一个OutOfMemoryError。</p>\n<p>此外，虚拟机规范中也并没有规定垃圾回收必须使用哪种算法，所以设计者们可以自由实现合适的垃圾回收算法。这也是众多JVM厂商竞争的领域。因为这对于程序而言十分重要。</p>\n"},{"title":"【Java入门篇】四、Java开发环境搭建——IDE","date":"2018-12-28T11:00:04.000Z","_content":"\n> 不相信自己的人 连努力的价值都没有。 --《火影忍者》\n\n## 前言\n\n前面我们已经安装好了JDK，现在Java这个大型游戏已经安装在我们的电脑里了，接下来我们就要准备学习如何玩这个游戏了。\n\n在入门阶段，我建议选择简单模式来进行，那么一个好的IDE是必不可少的。\n\n## 什么是IDE\n\nIDE（integrated development enviroment）就是集成开发环境，是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。所有具备这一特性的软件或者软件套（组）都可以叫集成开发环境。\n\n简单来说，IDE就是将一系列工具集成到了一个应用里，让你的开发之旅变得更加容易。\n\n## 为什么需要IDE\n\n很多老玩家在指导刚入坑的新手时，都喜欢循循善诱，教导新手使用文本编辑器而非IDE，这样可以提高对整个编译流程的理解。讲道理，确实是这样的，但是却将开发的复杂度增加了许多，对于新手而言，每增加一个步骤，就是增加了无数种失败的姿势，很多人的学习热情就消耗在了这种无关痛痒的小问题上，觉得这个游戏怎么这么难。\n\n所以我个人认为，开局一条狗，砍到99的打法并不适合每一个人，对于新手而言，先给一个新手套装，再来做任务会更加轻松。\n\n## 安装IDE\n\n接下来，我们去官网下载IDEA：http://www.jetbrains.com/idea/\n\n{% asset_img java-ide-1.png jdk-ide %}\n\n{% asset_img java-ide-2.png jdk-ide %}\n\n根据自己的系统进行选择安装即可，这里就不分系统进行介绍了，下载的时候，可以选ultimate版，也可以选community版，建议选择ultimate版。\n\n下载好以后安装，要激活码的时候可以看一看这个地址：http://idea.lanyus.com/ 使用前请将“0.0.0.0 account.jetbrains.com”添加到hosts文件中，然后输入激活码就能成功激活了。当然，此方法仅供学习研究使用，有经济能力的盆友还是自觉购买正版产品吧，反正我是没有经济能力的。\n\n安装的时候，所有的都按默认选项进行安装即可。\n\n## 新建项目\n\n然后开始我们的第一个新手任务——HelloWorld。\n\n{% asset_img java-ide-3.png jdk-ide %}\n\n{% asset_img java-ide-4.png jdk-ide %}\n\n{% asset_img java-ide-5.png jdk-ide %}\n\n创建好以后，右键src文件夹，添加package，名字叫hello，然后在package里添加HelloWorld类\n\n{% asset_img java-ide-6.png jdk-ide %}\n\n{% asset_img java-ide-7.png jdk-ide %}\n\n{% asset_img java-ide-8.png jdk-ide %}\n\n然后在文件里放上代码：\n\n```java\npackage hello;\nimport java.lang.System;\n\npublic class HelloWorld {\n    public static void main(String[] args){\n        System.out.println(\"Hello World!\");\n    }\n}\n```\n\n点击Run，运行程序，选择HelloWorld，代码就跑起来了。\n\n{% asset_img java-ide-9.png jdk-ide %}\n\n至此，IDE设置完成，我们的第一个项目也完工。\n\n如果在这个过程中遇到了任何问题，可以将关键词在百度中进行搜索，如果实在解决不了，可以加群【529253292】在群里提问，热心的群主自然会为你提供解决方案。","source":"_posts/java/introduction/java-ide.md","raw":"---\ntitle: 【Java入门篇】四、Java开发环境搭建——IDE\ntags: \n - Java入门\n - Java\n - 环境搭建\ncategories: 编程\ndate: 2018-12-28 19:00:04\n---\n\n> 不相信自己的人 连努力的价值都没有。 --《火影忍者》\n\n## 前言\n\n前面我们已经安装好了JDK，现在Java这个大型游戏已经安装在我们的电脑里了，接下来我们就要准备学习如何玩这个游戏了。\n\n在入门阶段，我建议选择简单模式来进行，那么一个好的IDE是必不可少的。\n\n## 什么是IDE\n\nIDE（integrated development enviroment）就是集成开发环境，是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。所有具备这一特性的软件或者软件套（组）都可以叫集成开发环境。\n\n简单来说，IDE就是将一系列工具集成到了一个应用里，让你的开发之旅变得更加容易。\n\n## 为什么需要IDE\n\n很多老玩家在指导刚入坑的新手时，都喜欢循循善诱，教导新手使用文本编辑器而非IDE，这样可以提高对整个编译流程的理解。讲道理，确实是这样的，但是却将开发的复杂度增加了许多，对于新手而言，每增加一个步骤，就是增加了无数种失败的姿势，很多人的学习热情就消耗在了这种无关痛痒的小问题上，觉得这个游戏怎么这么难。\n\n所以我个人认为，开局一条狗，砍到99的打法并不适合每一个人，对于新手而言，先给一个新手套装，再来做任务会更加轻松。\n\n## 安装IDE\n\n接下来，我们去官网下载IDEA：http://www.jetbrains.com/idea/\n\n{% asset_img java-ide-1.png jdk-ide %}\n\n{% asset_img java-ide-2.png jdk-ide %}\n\n根据自己的系统进行选择安装即可，这里就不分系统进行介绍了，下载的时候，可以选ultimate版，也可以选community版，建议选择ultimate版。\n\n下载好以后安装，要激活码的时候可以看一看这个地址：http://idea.lanyus.com/ 使用前请将“0.0.0.0 account.jetbrains.com”添加到hosts文件中，然后输入激活码就能成功激活了。当然，此方法仅供学习研究使用，有经济能力的盆友还是自觉购买正版产品吧，反正我是没有经济能力的。\n\n安装的时候，所有的都按默认选项进行安装即可。\n\n## 新建项目\n\n然后开始我们的第一个新手任务——HelloWorld。\n\n{% asset_img java-ide-3.png jdk-ide %}\n\n{% asset_img java-ide-4.png jdk-ide %}\n\n{% asset_img java-ide-5.png jdk-ide %}\n\n创建好以后，右键src文件夹，添加package，名字叫hello，然后在package里添加HelloWorld类\n\n{% asset_img java-ide-6.png jdk-ide %}\n\n{% asset_img java-ide-7.png jdk-ide %}\n\n{% asset_img java-ide-8.png jdk-ide %}\n\n然后在文件里放上代码：\n\n```java\npackage hello;\nimport java.lang.System;\n\npublic class HelloWorld {\n    public static void main(String[] args){\n        System.out.println(\"Hello World!\");\n    }\n}\n```\n\n点击Run，运行程序，选择HelloWorld，代码就跑起来了。\n\n{% asset_img java-ide-9.png jdk-ide %}\n\n至此，IDE设置完成，我们的第一个项目也完工。\n\n如果在这个过程中遇到了任何问题，可以将关键词在百度中进行搜索，如果实在解决不了，可以加群【529253292】在群里提问，热心的群主自然会为你提供解决方案。","slug":"java/introduction/java-ide","published":1,"updated":"2019-06-04T01:29:57.319Z","_id":"cjxze3gvg004l0cvwekducab4","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>不相信自己的人 连努力的价值都没有。 –《火影忍者》</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前面我们已经安装好了JDK，现在Java这个大型游戏已经安装在我们的电脑里了，接下来我们就要准备学习如何玩这个游戏了。</p>\n<p>在入门阶段，我建议选择简单模式来进行，那么一个好的IDE是必不可少的。</p>\n<h2 id=\"什么是IDE\"><a href=\"#什么是IDE\" class=\"headerlink\" title=\"什么是IDE\"></a>什么是IDE</h2><p>IDE（integrated development enviroment）就是集成开发环境，是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。所有具备这一特性的软件或者软件套（组）都可以叫集成开发环境。</p>\n<p>简单来说，IDE就是将一系列工具集成到了一个应用里，让你的开发之旅变得更加容易。</p>\n<h2 id=\"为什么需要IDE\"><a href=\"#为什么需要IDE\" class=\"headerlink\" title=\"为什么需要IDE\"></a>为什么需要IDE</h2><p>很多老玩家在指导刚入坑的新手时，都喜欢循循善诱，教导新手使用文本编辑器而非IDE，这样可以提高对整个编译流程的理解。讲道理，确实是这样的，但是却将开发的复杂度增加了许多，对于新手而言，每增加一个步骤，就是增加了无数种失败的姿势，很多人的学习热情就消耗在了这种无关痛痒的小问题上，觉得这个游戏怎么这么难。</p>\n<p>所以我个人认为，开局一条狗，砍到99的打法并不适合每一个人，对于新手而言，先给一个新手套装，再来做任务会更加轻松。</p>\n<h2 id=\"安装IDE\"><a href=\"#安装IDE\" class=\"headerlink\" title=\"安装IDE\"></a>安装IDE</h2><p>接下来，我们去官网下载IDEA：<a href=\"http://www.jetbrains.com/idea/\" target=\"_blank\" rel=\"noopener\">http://www.jetbrains.com/idea/</a></p>\n<img src=\"/programming/java/introduction/java-ide/java-ide-1.png\" title=\"jdk-ide\">\n<img src=\"/programming/java/introduction/java-ide/java-ide-2.png\" title=\"jdk-ide\">\n<p>根据自己的系统进行选择安装即可，这里就不分系统进行介绍了，下载的时候，可以选ultimate版，也可以选community版，建议选择ultimate版。</p>\n<p>下载好以后安装，要激活码的时候可以看一看这个地址：<a href=\"http://idea.lanyus.com/\" target=\"_blank\" rel=\"noopener\">http://idea.lanyus.com/</a> 使用前请将“0.0.0.0 account.jetbrains.com”添加到hosts文件中，然后输入激活码就能成功激活了。当然，此方法仅供学习研究使用，有经济能力的盆友还是自觉购买正版产品吧，反正我是没有经济能力的。</p>\n<p>安装的时候，所有的都按默认选项进行安装即可。</p>\n<h2 id=\"新建项目\"><a href=\"#新建项目\" class=\"headerlink\" title=\"新建项目\"></a>新建项目</h2><p>然后开始我们的第一个新手任务——HelloWorld。</p>\n<img src=\"/programming/java/introduction/java-ide/java-ide-3.png\" title=\"jdk-ide\">\n<img src=\"/programming/java/introduction/java-ide/java-ide-4.png\" title=\"jdk-ide\">\n<img src=\"/programming/java/introduction/java-ide/java-ide-5.png\" title=\"jdk-ide\">\n<p>创建好以后，右键src文件夹，添加package，名字叫hello，然后在package里添加HelloWorld类</p>\n<img src=\"/programming/java/introduction/java-ide/java-ide-6.png\" title=\"jdk-ide\">\n<img src=\"/programming/java/introduction/java-ide/java-ide-7.png\" title=\"jdk-ide\">\n<img src=\"/programming/java/introduction/java-ide/java-ide-8.png\" title=\"jdk-ide\">\n<p>然后在文件里放上代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> hello;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.System;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Hello World!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>点击Run，运行程序，选择HelloWorld，代码就跑起来了。</p>\n<img src=\"/programming/java/introduction/java-ide/java-ide-9.png\" title=\"jdk-ide\">\n<p>至此，IDE设置完成，我们的第一个项目也完工。</p>\n<p>如果在这个过程中遇到了任何问题，可以将关键词在百度中进行搜索，如果实在解决不了，可以加群【529253292】在群里提问，热心的群主自然会为你提供解决方案。</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<blockquote>\n<p>不相信自己的人 连努力的价值都没有。 –《火影忍者》</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前面我们已经安装好了JDK，现在Java这个大型游戏已经安装在我们的电脑里了，接下来我们就要准备学习如何玩这个游戏了。</p>\n<p>在入门阶段，我建议选择简单模式来进行，那么一个好的IDE是必不可少的。</p>\n<h2 id=\"什么是IDE\"><a href=\"#什么是IDE\" class=\"headerlink\" title=\"什么是IDE\"></a>什么是IDE</h2><p>IDE（integrated development enviroment）就是集成开发环境，是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。所有具备这一特性的软件或者软件套（组）都可以叫集成开发环境。</p>\n<p>简单来说，IDE就是将一系列工具集成到了一个应用里，让你的开发之旅变得更加容易。</p>\n<h2 id=\"为什么需要IDE\"><a href=\"#为什么需要IDE\" class=\"headerlink\" title=\"为什么需要IDE\"></a>为什么需要IDE</h2><p>很多老玩家在指导刚入坑的新手时，都喜欢循循善诱，教导新手使用文本编辑器而非IDE，这样可以提高对整个编译流程的理解。讲道理，确实是这样的，但是却将开发的复杂度增加了许多，对于新手而言，每增加一个步骤，就是增加了无数种失败的姿势，很多人的学习热情就消耗在了这种无关痛痒的小问题上，觉得这个游戏怎么这么难。</p>\n<p>所以我个人认为，开局一条狗，砍到99的打法并不适合每一个人，对于新手而言，先给一个新手套装，再来做任务会更加轻松。</p>\n<h2 id=\"安装IDE\"><a href=\"#安装IDE\" class=\"headerlink\" title=\"安装IDE\"></a>安装IDE</h2><p>接下来，我们去官网下载IDEA：<a href=\"http://www.jetbrains.com/idea/\" target=\"_blank\" rel=\"noopener\">http://www.jetbrains.com/idea/</a></p>\n<img src=\"/programming/java/introduction/java-ide/java-ide-1.png\" title=\"jdk-ide\">\n<img src=\"/programming/java/introduction/java-ide/java-ide-2.png\" title=\"jdk-ide\">\n<p>根据自己的系统进行选择安装即可，这里就不分系统进行介绍了，下载的时候，可以选ultimate版，也可以选community版，建议选择ultimate版。</p>\n<p>下载好以后安装，要激活码的时候可以看一看这个地址：<a href=\"http://idea.lanyus.com/\" target=\"_blank\" rel=\"noopener\">http://idea.lanyus.com/</a> 使用前请将“0.0.0.0 account.jetbrains.com”添加到hosts文件中，然后输入激活码就能成功激活了。当然，此方法仅供学习研究使用，有经济能力的盆友还是自觉购买正版产品吧，反正我是没有经济能力的。</p>\n<p>安装的时候，所有的都按默认选项进行安装即可。</p>\n<h2 id=\"新建项目\"><a href=\"#新建项目\" class=\"headerlink\" title=\"新建项目\"></a>新建项目</h2><p>然后开始我们的第一个新手任务——HelloWorld。</p>\n<img src=\"/programming/java/introduction/java-ide/java-ide-3.png\" title=\"jdk-ide\">\n<img src=\"/programming/java/introduction/java-ide/java-ide-4.png\" title=\"jdk-ide\">\n<img src=\"/programming/java/introduction/java-ide/java-ide-5.png\" title=\"jdk-ide\">\n<p>创建好以后，右键src文件夹，添加package，名字叫hello，然后在package里添加HelloWorld类</p>\n<img src=\"/programming/java/introduction/java-ide/java-ide-6.png\" title=\"jdk-ide\">\n<img src=\"/programming/java/introduction/java-ide/java-ide-7.png\" title=\"jdk-ide\">\n<img src=\"/programming/java/introduction/java-ide/java-ide-8.png\" title=\"jdk-ide\">\n<p>然后在文件里放上代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> hello;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.System;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Hello World!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>点击Run，运行程序，选择HelloWorld，代码就跑起来了。</p>\n<img src=\"/programming/java/introduction/java-ide/java-ide-9.png\" title=\"jdk-ide\">\n<p>至此，IDE设置完成，我们的第一个项目也完工。</p>\n<p>如果在这个过程中遇到了任何问题，可以将关键词在百度中进行搜索，如果实在解决不了，可以加群【529253292】在群里提问，热心的群主自然会为你提供解决方案。</p>\n"},{"title":"Java中的内存泄漏","date":"2018-12-26T11:55:51.000Z","_content":"\n## 定义\n\n内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费。\n\n## 说明\n\n长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。\n\n一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，会导致占用的内存空间不断增加，最终发生OOM。\n\n是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出！比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。\n\n## 造成内存泄漏的几种情况\n\n1、静态集合类引起内存泄漏\n\n像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。\n\n2、当集合里面的对象属性被修改后，再调用remove()方法时不起作用。\n\n3、监听器\n\n在释放对象的时候却没有去删除这些监听器，增加了内存泄漏的机会。\n\n4、各种连接\n\n比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。\n\n5、内部类和外部模块的引用\n\n内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如： public void registerMsg(Object b); 这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。\n\n6、单例模式\n\n不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏。","source":"_posts/java/jvm/memory-leak.md","raw":"---\ntitle: Java中的内存泄漏\ntags: \n - Java\n - 内存泄漏\ncategories: 编程\ndate: 2018-12-26 19:55:51\n---\n\n## 定义\n\n内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费。\n\n## 说明\n\n长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。\n\n一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，会导致占用的内存空间不断增加，最终发生OOM。\n\n是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出！比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。\n\n## 造成内存泄漏的几种情况\n\n1、静态集合类引起内存泄漏\n\n像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。\n\n2、当集合里面的对象属性被修改后，再调用remove()方法时不起作用。\n\n3、监听器\n\n在释放对象的时候却没有去删除这些监听器，增加了内存泄漏的机会。\n\n4、各种连接\n\n比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。\n\n5、内部类和外部模块的引用\n\n内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如： public void registerMsg(Object b); 这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。\n\n6、单例模式\n\n不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏。","slug":"java/jvm/memory-leak","published":1,"updated":"2019-06-04T01:29:57.337Z","_id":"cjxze3gvq004o0cvw41jihbeh","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费。</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。</p>\n<p>一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，会导致占用的内存空间不断增加，最终发生OOM。</p>\n<p>是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出！比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。</p>\n<h2 id=\"造成内存泄漏的几种情况\"><a href=\"#造成内存泄漏的几种情况\" class=\"headerlink\" title=\"造成内存泄漏的几种情况\"></a>造成内存泄漏的几种情况</h2><p>1、静态集合类引起内存泄漏</p>\n<p>像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。</p>\n<p>2、当集合里面的对象属性被修改后，再调用remove()方法时不起作用。</p>\n<p>3、监听器</p>\n<p>在释放对象的时候却没有去删除这些监听器，增加了内存泄漏的机会。</p>\n<p>4、各种连接</p>\n<p>比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。</p>\n<p>5、内部类和外部模块的引用</p>\n<p>内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如： public void registerMsg(Object b); 这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。</p>\n<p>6、单例模式</p>\n<p>不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏。</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费。</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。</p>\n<p>一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，会导致占用的内存空间不断增加，最终发生OOM。</p>\n<p>是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出！比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。</p>\n<h2 id=\"造成内存泄漏的几种情况\"><a href=\"#造成内存泄漏的几种情况\" class=\"headerlink\" title=\"造成内存泄漏的几种情况\"></a>造成内存泄漏的几种情况</h2><p>1、静态集合类引起内存泄漏</p>\n<p>像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。</p>\n<p>2、当集合里面的对象属性被修改后，再调用remove()方法时不起作用。</p>\n<p>3、监听器</p>\n<p>在释放对象的时候却没有去删除这些监听器，增加了内存泄漏的机会。</p>\n<p>4、各种连接</p>\n<p>比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。</p>\n<p>5、内部类和外部模块的引用</p>\n<p>内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如： public void registerMsg(Object b); 这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。</p>\n<p>6、单例模式</p>\n<p>不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏。</p>\n"},{"title":"【Java入门篇】六、Java简单示例","date":"2018-12-28T11:00:06.000Z","_content":"\n> 人都有两面，一面天使，一面恶魔。\n\n## 前言\n\n为了统一风格，也为了增加趣味性，以后的文章都会以关卡的形式进行展示，这样也能让大家明确每一篇的目标，带着目的来阅读会更有方向感。\n\n之前已经写过了Hello World，所以这次就换一个吧，这次的小目标便是——Java简易版计算器。\n\n## 功能说明\n\n第一版的Java计算器仅需要支持加法运算，用户输入两个数字，然后输出它们的和。\n\n## 方法预习\n\n如果是刚开始接触编程，也许你会毫无头绪，莫方，这是很正常的现象，因为你对于如何与计算机尤其是命令行进行交互毫无头绪。\n\n所以在开始编码前，需要先预习一些必要的知识。\n\n### 输出信息\n\n先来认识一个方法 `System.out.println()`，这个方法会将你传入的信息输出到控制台中，emmm，什么是控制台？你运行程序后出现的那个黑不拉几的东西就叫做控制台，它是我们与计算机交互的一个最简单原始的方式。\n\n来试验一下，还记得如何用idea创建一个类吗？不记得的话翻看一下[这里](java-ide.md)。\n\n这次我们继续在hello包下面创建一个类叫做PrintTest，然后添加以下方法：\n\n```java\npackage hello;\n\npublic class PrintTest {\n    public static void main(String[] args){\n        System.out.println(\"输出测试\");\n    }\n}\n```\n\n然后我们点击运行，或者按键（`ctrl+shift+R`），就能看到下面的输出了：\n\n{% asset_img java-simple-example-1.png java-example %}\n\n先不要问这个System是个什么东西，只要知道这样可以输出一行信息就行了，需要注意的是这个方法默认会在末尾加一个换行符，如果想要不换行，可以试试 `System.out.print() `。\n\n### 输入信息\n\n上面已经说过如何输出信息了，现在来看看如何输入信息并进行读取。\n\n先来认识一下Scanner类，Scanner类是用来从各种输入源读取信息的，它可以从各种输入源中读取信息，最常用的当然就是控制台输入。那如何用Scanner读取控制台的输入呢？这就要用到System.in了，来看栗子，我们再新建一个InputTest类：\n\n```java\npackage hello;\n\nimport java.util.Scanner;\n\npublic class InputTest {\n    public static void main(String[] args){\n        Scanner in = new Scanner(System.in);\n        System.out.print(\"请输入一个整数:\");\n        int a = in.nextInt();\n        System.out.println(\"刚才输入的整数为：\" + a);\n    }\n}\n```\n\n然后再运行一下，并且输入一个数字然后按回车键，这里我输入的是20：\n\n{% asset_img java-simple-example-2.png java-example %}\n\n如果对于具体的细节还不清楚，没有关系，先照做就好了。\n\n## 代码编写\n\n那么接下来就开始设计这个最简单的计算器了，首先我们要提示用户输入一个整数，就像上面那样：\n\n```java\nSystem.out.print(\"请输入一个整数:\");\n```\n\n然后用一个int变量来存储，什么？不知道变量是干嘛的？没事，你可以先把它当做一个盒子，用来把用户输入的信息存放进去。\n\n```java\nScanner in = new Scanner(System.in);\nint a = in.nextInt();\n```\n\n然后提示用户再输入一个整数：\n\n```java\nSystem.out.print(\"请输入另一个整数:\");\n```\n\n然后再用一个int变量来存储。\n\n```java\nint b = in.nextInt();\n```\n\n接下来计算两者的和，并存到第三个变量中：\n\n```java\nint sum = a + b;\n```\n\n最后输出这个和：\n\n```java\nSystem.out.print(\"这两个数的和为:\" + sum);\n```\n\n所以整体代码如下：\n\n```java\npackage hello;\n\nimport java.util.Scanner;\n\npublic class SimpleCalculator {\n    public static void main(String[] args){\n        System.out.print(\"请输入一个整数:\");\n        Scanner in = new Scanner(System.in);\n        int a = in.nextInt();\n        System.out.print(\"请再输入一个整数:\");\n        int b = in.nextInt();\n        int sum = a + b;\n        System.out.print(\"这两个数的和为:\" + sum);\n    }\n}\n```\n\n输出如下：\n\n{% asset_img java-simple-example-3.png java-example %}\n\n这样，我们的简易版计算器就完成了。虽然简单，但还是建议你在自己电脑上实现一次，看代码和写代码是完全不一样的两种体验。\n\n回顾一下本篇，我们设计了一个类`SimpleCalculator`，并编写了一个main方法，并在里面完成了简易版计算器的逻辑设计。也许你对于自己写的东西还有很多疑问，对象是什么？类又是什么含义？Scanner还可以做什么？前面的package有什么作用，import又是在干嘛？别着急，接着看后面的文章，相信你的疑问会一点一点消失。\n","source":"_posts/java/introduction/java-simple-example.md","raw":"---\ntitle: 【Java入门篇】六、Java简单示例\ntags: \n - Java入门\n - Java\ncategories: 编程\ndate: 2018-12-28 19:00:06\n---\n\n> 人都有两面，一面天使，一面恶魔。\n\n## 前言\n\n为了统一风格，也为了增加趣味性，以后的文章都会以关卡的形式进行展示，这样也能让大家明确每一篇的目标，带着目的来阅读会更有方向感。\n\n之前已经写过了Hello World，所以这次就换一个吧，这次的小目标便是——Java简易版计算器。\n\n## 功能说明\n\n第一版的Java计算器仅需要支持加法运算，用户输入两个数字，然后输出它们的和。\n\n## 方法预习\n\n如果是刚开始接触编程，也许你会毫无头绪，莫方，这是很正常的现象，因为你对于如何与计算机尤其是命令行进行交互毫无头绪。\n\n所以在开始编码前，需要先预习一些必要的知识。\n\n### 输出信息\n\n先来认识一个方法 `System.out.println()`，这个方法会将你传入的信息输出到控制台中，emmm，什么是控制台？你运行程序后出现的那个黑不拉几的东西就叫做控制台，它是我们与计算机交互的一个最简单原始的方式。\n\n来试验一下，还记得如何用idea创建一个类吗？不记得的话翻看一下[这里](java-ide.md)。\n\n这次我们继续在hello包下面创建一个类叫做PrintTest，然后添加以下方法：\n\n```java\npackage hello;\n\npublic class PrintTest {\n    public static void main(String[] args){\n        System.out.println(\"输出测试\");\n    }\n}\n```\n\n然后我们点击运行，或者按键（`ctrl+shift+R`），就能看到下面的输出了：\n\n{% asset_img java-simple-example-1.png java-example %}\n\n先不要问这个System是个什么东西，只要知道这样可以输出一行信息就行了，需要注意的是这个方法默认会在末尾加一个换行符，如果想要不换行，可以试试 `System.out.print() `。\n\n### 输入信息\n\n上面已经说过如何输出信息了，现在来看看如何输入信息并进行读取。\n\n先来认识一下Scanner类，Scanner类是用来从各种输入源读取信息的，它可以从各种输入源中读取信息，最常用的当然就是控制台输入。那如何用Scanner读取控制台的输入呢？这就要用到System.in了，来看栗子，我们再新建一个InputTest类：\n\n```java\npackage hello;\n\nimport java.util.Scanner;\n\npublic class InputTest {\n    public static void main(String[] args){\n        Scanner in = new Scanner(System.in);\n        System.out.print(\"请输入一个整数:\");\n        int a = in.nextInt();\n        System.out.println(\"刚才输入的整数为：\" + a);\n    }\n}\n```\n\n然后再运行一下，并且输入一个数字然后按回车键，这里我输入的是20：\n\n{% asset_img java-simple-example-2.png java-example %}\n\n如果对于具体的细节还不清楚，没有关系，先照做就好了。\n\n## 代码编写\n\n那么接下来就开始设计这个最简单的计算器了，首先我们要提示用户输入一个整数，就像上面那样：\n\n```java\nSystem.out.print(\"请输入一个整数:\");\n```\n\n然后用一个int变量来存储，什么？不知道变量是干嘛的？没事，你可以先把它当做一个盒子，用来把用户输入的信息存放进去。\n\n```java\nScanner in = new Scanner(System.in);\nint a = in.nextInt();\n```\n\n然后提示用户再输入一个整数：\n\n```java\nSystem.out.print(\"请输入另一个整数:\");\n```\n\n然后再用一个int变量来存储。\n\n```java\nint b = in.nextInt();\n```\n\n接下来计算两者的和，并存到第三个变量中：\n\n```java\nint sum = a + b;\n```\n\n最后输出这个和：\n\n```java\nSystem.out.print(\"这两个数的和为:\" + sum);\n```\n\n所以整体代码如下：\n\n```java\npackage hello;\n\nimport java.util.Scanner;\n\npublic class SimpleCalculator {\n    public static void main(String[] args){\n        System.out.print(\"请输入一个整数:\");\n        Scanner in = new Scanner(System.in);\n        int a = in.nextInt();\n        System.out.print(\"请再输入一个整数:\");\n        int b = in.nextInt();\n        int sum = a + b;\n        System.out.print(\"这两个数的和为:\" + sum);\n    }\n}\n```\n\n输出如下：\n\n{% asset_img java-simple-example-3.png java-example %}\n\n这样，我们的简易版计算器就完成了。虽然简单，但还是建议你在自己电脑上实现一次，看代码和写代码是完全不一样的两种体验。\n\n回顾一下本篇，我们设计了一个类`SimpleCalculator`，并编写了一个main方法，并在里面完成了简易版计算器的逻辑设计。也许你对于自己写的东西还有很多疑问，对象是什么？类又是什么含义？Scanner还可以做什么？前面的package有什么作用，import又是在干嘛？别着急，接着看后面的文章，相信你的疑问会一点一点消失。\n","slug":"java/introduction/java-simple-example","published":1,"updated":"2019-06-04T01:29:57.328Z","_id":"cjxze3gw0004r0cvwam3xiz7c","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>人都有两面，一面天使，一面恶魔。</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>为了统一风格，也为了增加趣味性，以后的文章都会以关卡的形式进行展示，这样也能让大家明确每一篇的目标，带着目的来阅读会更有方向感。</p>\n<p>之前已经写过了Hello World，所以这次就换一个吧，这次的小目标便是——Java简易版计算器。</p>\n<h2 id=\"功能说明\"><a href=\"#功能说明\" class=\"headerlink\" title=\"功能说明\"></a>功能说明</h2><p>第一版的Java计算器仅需要支持加法运算，用户输入两个数字，然后输出它们的和。</p>\n<h2 id=\"方法预习\"><a href=\"#方法预习\" class=\"headerlink\" title=\"方法预习\"></a>方法预习</h2><p>如果是刚开始接触编程，也许你会毫无头绪，莫方，这是很正常的现象，因为你对于如何与计算机尤其是命令行进行交互毫无头绪。</p>\n<p>所以在开始编码前，需要先预习一些必要的知识。</p>\n<h3 id=\"输出信息\"><a href=\"#输出信息\" class=\"headerlink\" title=\"输出信息\"></a>输出信息</h3><p>先来认识一个方法 <code>System.out.println()</code>，这个方法会将你传入的信息输出到控制台中，emmm，什么是控制台？你运行程序后出现的那个黑不拉几的东西就叫做控制台，它是我们与计算机交互的一个最简单原始的方式。</p>\n<p>来试验一下，还记得如何用idea创建一个类吗？不记得的话翻看一下<a href=\"java-ide.md\">这里</a>。</p>\n<p>这次我们继续在hello包下面创建一个类叫做PrintTest，然后添加以下方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> hello;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PrintTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"输出测试\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们点击运行，或者按键（<code>ctrl+shift+R</code>），就能看到下面的输出了：</p>\n<img src=\"/programming/java/introduction/java-simple-example/java-simple-example-1.png\" title=\"java-example\">\n<p>先不要问这个System是个什么东西，只要知道这样可以输出一行信息就行了，需要注意的是这个方法默认会在末尾加一个换行符，如果想要不换行，可以试试 <code>System.out.print()</code>。</p>\n<h3 id=\"输入信息\"><a href=\"#输入信息\" class=\"headerlink\" title=\"输入信息\"></a>输入信息</h3><p>上面已经说过如何输出信息了，现在来看看如何输入信息并进行读取。</p>\n<p>先来认识一下Scanner类，Scanner类是用来从各种输入源读取信息的，它可以从各种输入源中读取信息，最常用的当然就是控制台输入。那如何用Scanner读取控制台的输入呢？这就要用到System.in了，来看栗子，我们再新建一个InputTest类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> hello;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Scanner in = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        System.out.print(<span class=\"string\">\"请输入一个整数:\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = in.nextInt();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"刚才输入的整数为：\"</span> + a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后再运行一下，并且输入一个数字然后按回车键，这里我输入的是20：</p>\n<img src=\"/programming/java/introduction/java-simple-example/java-simple-example-2.png\" title=\"java-example\">\n<p>如果对于具体的细节还不清楚，没有关系，先照做就好了。</p>\n<h2 id=\"代码编写\"><a href=\"#代码编写\" class=\"headerlink\" title=\"代码编写\"></a>代码编写</h2><p>那么接下来就开始设计这个最简单的计算器了，首先我们要提示用户输入一个整数，就像上面那样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.print(<span class=\"string\">\"请输入一个整数:\"</span>);</span><br></pre></td></tr></table></figure>\n<p>然后用一个int变量来存储，什么？不知道变量是干嘛的？没事，你可以先把它当做一个盒子，用来把用户输入的信息存放进去。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scanner in = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\"><span class=\"keyword\">int</span> a = in.nextInt();</span><br></pre></td></tr></table></figure>\n<p>然后提示用户再输入一个整数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.print(<span class=\"string\">\"请输入另一个整数:\"</span>);</span><br></pre></td></tr></table></figure>\n<p>然后再用一个int变量来存储。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> b = in.nextInt();</span><br></pre></td></tr></table></figure>\n<p>接下来计算两者的和，并存到第三个变量中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> sum = a + b;</span><br></pre></td></tr></table></figure>\n<p>最后输出这个和：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.print(<span class=\"string\">\"这两个数的和为:\"</span> + sum);</span><br></pre></td></tr></table></figure>\n<p>所以整体代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> hello;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleCalculator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        System.out.print(<span class=\"string\">\"请输入一个整数:\"</span>);</span><br><span class=\"line\">        Scanner in = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = in.nextInt();</span><br><span class=\"line\">        System.out.print(<span class=\"string\">\"请再输入一个整数:\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b = in.nextInt();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = a + b;</span><br><span class=\"line\">        System.out.print(<span class=\"string\">\"这两个数的和为:\"</span> + sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<img src=\"/programming/java/introduction/java-simple-example/java-simple-example-3.png\" title=\"java-example\">\n<p>这样，我们的简易版计算器就完成了。虽然简单，但还是建议你在自己电脑上实现一次，看代码和写代码是完全不一样的两种体验。</p>\n<p>回顾一下本篇，我们设计了一个类<code>SimpleCalculator</code>，并编写了一个main方法，并在里面完成了简易版计算器的逻辑设计。也许你对于自己写的东西还有很多疑问，对象是什么？类又是什么含义？Scanner还可以做什么？前面的package有什么作用，import又是在干嘛？别着急，接着看后面的文章，相信你的疑问会一点一点消失。</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<blockquote>\n<p>人都有两面，一面天使，一面恶魔。</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>为了统一风格，也为了增加趣味性，以后的文章都会以关卡的形式进行展示，这样也能让大家明确每一篇的目标，带着目的来阅读会更有方向感。</p>\n<p>之前已经写过了Hello World，所以这次就换一个吧，这次的小目标便是——Java简易版计算器。</p>\n<h2 id=\"功能说明\"><a href=\"#功能说明\" class=\"headerlink\" title=\"功能说明\"></a>功能说明</h2><p>第一版的Java计算器仅需要支持加法运算，用户输入两个数字，然后输出它们的和。</p>\n<h2 id=\"方法预习\"><a href=\"#方法预习\" class=\"headerlink\" title=\"方法预习\"></a>方法预习</h2><p>如果是刚开始接触编程，也许你会毫无头绪，莫方，这是很正常的现象，因为你对于如何与计算机尤其是命令行进行交互毫无头绪。</p>\n<p>所以在开始编码前，需要先预习一些必要的知识。</p>\n<h3 id=\"输出信息\"><a href=\"#输出信息\" class=\"headerlink\" title=\"输出信息\"></a>输出信息</h3><p>先来认识一个方法 <code>System.out.println()</code>，这个方法会将你传入的信息输出到控制台中，emmm，什么是控制台？你运行程序后出现的那个黑不拉几的东西就叫做控制台，它是我们与计算机交互的一个最简单原始的方式。</p>\n<p>来试验一下，还记得如何用idea创建一个类吗？不记得的话翻看一下<a href=\"java-ide.md\">这里</a>。</p>\n<p>这次我们继续在hello包下面创建一个类叫做PrintTest，然后添加以下方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> hello;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PrintTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"输出测试\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们点击运行，或者按键（<code>ctrl+shift+R</code>），就能看到下面的输出了：</p>\n<img src=\"/programming/java/introduction/java-simple-example/java-simple-example-1.png\" title=\"java-example\">\n<p>先不要问这个System是个什么东西，只要知道这样可以输出一行信息就行了，需要注意的是这个方法默认会在末尾加一个换行符，如果想要不换行，可以试试 <code>System.out.print()</code>。</p>\n<h3 id=\"输入信息\"><a href=\"#输入信息\" class=\"headerlink\" title=\"输入信息\"></a>输入信息</h3><p>上面已经说过如何输出信息了，现在来看看如何输入信息并进行读取。</p>\n<p>先来认识一下Scanner类，Scanner类是用来从各种输入源读取信息的，它可以从各种输入源中读取信息，最常用的当然就是控制台输入。那如何用Scanner读取控制台的输入呢？这就要用到System.in了，来看栗子，我们再新建一个InputTest类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> hello;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Scanner in = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        System.out.print(<span class=\"string\">\"请输入一个整数:\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = in.nextInt();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"刚才输入的整数为：\"</span> + a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后再运行一下，并且输入一个数字然后按回车键，这里我输入的是20：</p>\n<img src=\"/programming/java/introduction/java-simple-example/java-simple-example-2.png\" title=\"java-example\">\n<p>如果对于具体的细节还不清楚，没有关系，先照做就好了。</p>\n<h2 id=\"代码编写\"><a href=\"#代码编写\" class=\"headerlink\" title=\"代码编写\"></a>代码编写</h2><p>那么接下来就开始设计这个最简单的计算器了，首先我们要提示用户输入一个整数，就像上面那样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.print(<span class=\"string\">\"请输入一个整数:\"</span>);</span><br></pre></td></tr></table></figure>\n<p>然后用一个int变量来存储，什么？不知道变量是干嘛的？没事，你可以先把它当做一个盒子，用来把用户输入的信息存放进去。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scanner in = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\"><span class=\"keyword\">int</span> a = in.nextInt();</span><br></pre></td></tr></table></figure>\n<p>然后提示用户再输入一个整数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.print(<span class=\"string\">\"请输入另一个整数:\"</span>);</span><br></pre></td></tr></table></figure>\n<p>然后再用一个int变量来存储。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> b = in.nextInt();</span><br></pre></td></tr></table></figure>\n<p>接下来计算两者的和，并存到第三个变量中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> sum = a + b;</span><br></pre></td></tr></table></figure>\n<p>最后输出这个和：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.print(<span class=\"string\">\"这两个数的和为:\"</span> + sum);</span><br></pre></td></tr></table></figure>\n<p>所以整体代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> hello;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleCalculator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        System.out.print(<span class=\"string\">\"请输入一个整数:\"</span>);</span><br><span class=\"line\">        Scanner in = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = in.nextInt();</span><br><span class=\"line\">        System.out.print(<span class=\"string\">\"请再输入一个整数:\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b = in.nextInt();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = a + b;</span><br><span class=\"line\">        System.out.print(<span class=\"string\">\"这两个数的和为:\"</span> + sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<img src=\"/programming/java/introduction/java-simple-example/java-simple-example-3.png\" title=\"java-example\">\n<p>这样，我们的简易版计算器就完成了。虽然简单，但还是建议你在自己电脑上实现一次，看代码和写代码是完全不一样的两种体验。</p>\n<p>回顾一下本篇，我们设计了一个类<code>SimpleCalculator</code>，并编写了一个main方法，并在里面完成了简易版计算器的逻辑设计。也许你对于自己写的东西还有很多疑问，对象是什么？类又是什么含义？Scanner还可以做什么？前面的package有什么作用，import又是在干嘛？别着急，接着看后面的文章，相信你的疑问会一点一点消失。</p>\n"},{"title":"对象的自我拯救","date":"2018-12-26T11:55:51.000Z","_content":"\n# 对象的自我拯救\n\n占个坑。。。。\n","source":"_posts/java/jvm/object-self-rescue.md","raw":"---\ntitle: 对象的自我拯救\ntags: \n - Java\ncategories: 编程\ndate: 2018-12-26 19:55:51\n---\n\n# 对象的自我拯救\n\n占个坑。。。。\n","slug":"java/jvm/object-self-rescue","published":1,"updated":"2019-06-04T01:29:57.337Z","_id":"cjxze3gw0004v0cvwlyvez3vo","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"对象的自我拯救\"><a href=\"#对象的自我拯救\" class=\"headerlink\" title=\"对象的自我拯救\"></a>对象的自我拯救</h1><p>占个坑。。。。</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h1 id=\"对象的自我拯救\"><a href=\"#对象的自我拯救\" class=\"headerlink\" title=\"对象的自我拯救\"></a>对象的自我拯救</h1><p>占个坑。。。。</p>\n"},{"title":"HotSpot虚拟机如何实现可达性算法","date":"2018-12-27T11:55:51.000Z","_content":"\n## 前言\n\nJava中的主流虚拟机HotSpot采用可达性分析算法来确定一个对象的状态，那么HotSpot是如何实现该算法的呢？\n\n## 使用OopMap记录并枚举根节点\n\n在从GC ROOT向下查找引用链时，可作为GC ROOT的节点主要有全局性引用（常量、静态变量）和执行上下文（栈帧中的本地变量表），通常方法区就有好几百兆，遍历一次需要比较长的时间。\n\n另外，在查找引用链过程中，需要保证引用链的一致性，即在分析过程中对象的引用关系不再变化，否则分析准确性则无法得到保证。因此通常GC执行时会stop the world，停止所有执行线程，即使几乎不发生停顿的CMS收集器中，枚举根节点也是需要停顿的。如果这个停顿的时间过长，肯定是难以接受的。\n\n那么HotSpot是如何在最短的时间内进行这个耗时的搜索工作的呢？\n\n答案就在这个神奇的数据结构中——OopMap。\n\n在遍历堆栈时，虚拟机关心的就是“这块数据是不是指针”。为了让JVM能够判断出所有位置上的数据是不是指向GC堆里的引用，包括活动记录（栈+寄存器）里的数据。HotSpot选择从外部记录下类型信息，存成映射表，也就是OopMap。\n\nOopMap在类加载完成时把对象内的偏移量是什么类型计算出，并且存放下在相应的位置，当需要遍历根结点时访问所有OopMap即可。在JIT编译过程中，也会在特定位置记录下栈和寄存器中的那些位置和引用的，这样GC在扫描时就可以直接获得这些信息。 \n\n## 用安全点Safepoint约束根节点\n\n如果将每个符合GC Roots条件的对象都存放进入OopMap中，那么OopMap也会变得很大，而且其中很多对象很可能会发生一些变化，这些变化使得维护这个映射表很困难。\n\n实际上，HotSpot并没有为每一个对象都创建OopMap，只在特定的位置上创建了这些信息，这些位置称为安全点（Safepoints）。\n\n为了保证虚拟机中安全点的个数不算太多也不是太少，主要决定安全点是否被建立的因素是时间。当进行了耗时的操作时，比如方法调用、循环跳转等时会产生安全点。\n\n在GC发生时需要让线程停顿下来，让线程停顿下来的方案有两种，**抢先式中断**和**主动式中断** \n\n- 抢先式中断：在GC发生时先中断所有线程，如果线程不在安全点上，则启动该线程使其执行到安全点后挂起。\n\n- 主动式中断：不需要直接对线程进行操作，在线程执行时主动轮询这个标识，若中断标识为真，在线程自己中断挂起这个标识和安全点是重合的\n\n## 安全区域（safe region）\n\n上面的安全点检查仿佛完全解决了如何进入GC的问题，但只有安全点还是不够的，安全点只解决了那些在运行的程序，保证了他们可以运行到安全点并挂起，但如果有些线程此时并未执行，例如处于sleep或blocked状态的线程，就无法响应JVM的中断请求，这时就需要使用安全区域了。\n\n**安全区域是指在此区域内，对象的引用关系不会发生变化（即不会影响枚举根节点) **\n\n当线程运行到安全区域时会将自己标识，在JVM准备进行GC时将视这些线程为安全的，不影响GC，当线程运行完毕要离开安全区域时，线程会检查JVM是否在枚举根节点，若是，则等待完成后再离开安全区域继续执行。","source":"_posts/java/jvm/reachable-in-hotspot.md","raw":"---\ntitle: HotSpot虚拟机如何实现可达性算法\ntags: \n - Java\n - 虚拟机\ncategories: 编程\ndate: 2018-12-27 19:55:51\n---\n\n## 前言\n\nJava中的主流虚拟机HotSpot采用可达性分析算法来确定一个对象的状态，那么HotSpot是如何实现该算法的呢？\n\n## 使用OopMap记录并枚举根节点\n\n在从GC ROOT向下查找引用链时，可作为GC ROOT的节点主要有全局性引用（常量、静态变量）和执行上下文（栈帧中的本地变量表），通常方法区就有好几百兆，遍历一次需要比较长的时间。\n\n另外，在查找引用链过程中，需要保证引用链的一致性，即在分析过程中对象的引用关系不再变化，否则分析准确性则无法得到保证。因此通常GC执行时会stop the world，停止所有执行线程，即使几乎不发生停顿的CMS收集器中，枚举根节点也是需要停顿的。如果这个停顿的时间过长，肯定是难以接受的。\n\n那么HotSpot是如何在最短的时间内进行这个耗时的搜索工作的呢？\n\n答案就在这个神奇的数据结构中——OopMap。\n\n在遍历堆栈时，虚拟机关心的就是“这块数据是不是指针”。为了让JVM能够判断出所有位置上的数据是不是指向GC堆里的引用，包括活动记录（栈+寄存器）里的数据。HotSpot选择从外部记录下类型信息，存成映射表，也就是OopMap。\n\nOopMap在类加载完成时把对象内的偏移量是什么类型计算出，并且存放下在相应的位置，当需要遍历根结点时访问所有OopMap即可。在JIT编译过程中，也会在特定位置记录下栈和寄存器中的那些位置和引用的，这样GC在扫描时就可以直接获得这些信息。 \n\n## 用安全点Safepoint约束根节点\n\n如果将每个符合GC Roots条件的对象都存放进入OopMap中，那么OopMap也会变得很大，而且其中很多对象很可能会发生一些变化，这些变化使得维护这个映射表很困难。\n\n实际上，HotSpot并没有为每一个对象都创建OopMap，只在特定的位置上创建了这些信息，这些位置称为安全点（Safepoints）。\n\n为了保证虚拟机中安全点的个数不算太多也不是太少，主要决定安全点是否被建立的因素是时间。当进行了耗时的操作时，比如方法调用、循环跳转等时会产生安全点。\n\n在GC发生时需要让线程停顿下来，让线程停顿下来的方案有两种，**抢先式中断**和**主动式中断** \n\n- 抢先式中断：在GC发生时先中断所有线程，如果线程不在安全点上，则启动该线程使其执行到安全点后挂起。\n\n- 主动式中断：不需要直接对线程进行操作，在线程执行时主动轮询这个标识，若中断标识为真，在线程自己中断挂起这个标识和安全点是重合的\n\n## 安全区域（safe region）\n\n上面的安全点检查仿佛完全解决了如何进入GC的问题，但只有安全点还是不够的，安全点只解决了那些在运行的程序，保证了他们可以运行到安全点并挂起，但如果有些线程此时并未执行，例如处于sleep或blocked状态的线程，就无法响应JVM的中断请求，这时就需要使用安全区域了。\n\n**安全区域是指在此区域内，对象的引用关系不会发生变化（即不会影响枚举根节点) **\n\n当线程运行到安全区域时会将自己标识，在JVM准备进行GC时将视这些线程为安全的，不影响GC，当线程运行完毕要离开安全区域时，线程会检查JVM是否在枚举根节点，若是，则等待完成后再离开安全区域继续执行。","slug":"java/jvm/reachable-in-hotspot","published":1,"updated":"2019-06-04T01:29:57.337Z","_id":"cjxze3gw0004y0cvwi4cslmm4","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Java中的主流虚拟机HotSpot采用可达性分析算法来确定一个对象的状态，那么HotSpot是如何实现该算法的呢？</p>\n<h2 id=\"使用OopMap记录并枚举根节点\"><a href=\"#使用OopMap记录并枚举根节点\" class=\"headerlink\" title=\"使用OopMap记录并枚举根节点\"></a>使用OopMap记录并枚举根节点</h2><p>在从GC ROOT向下查找引用链时，可作为GC ROOT的节点主要有全局性引用（常量、静态变量）和执行上下文（栈帧中的本地变量表），通常方法区就有好几百兆，遍历一次需要比较长的时间。</p>\n<p>另外，在查找引用链过程中，需要保证引用链的一致性，即在分析过程中对象的引用关系不再变化，否则分析准确性则无法得到保证。因此通常GC执行时会stop the world，停止所有执行线程，即使几乎不发生停顿的CMS收集器中，枚举根节点也是需要停顿的。如果这个停顿的时间过长，肯定是难以接受的。</p>\n<p>那么HotSpot是如何在最短的时间内进行这个耗时的搜索工作的呢？</p>\n<p>答案就在这个神奇的数据结构中——OopMap。</p>\n<p>在遍历堆栈时，虚拟机关心的就是“这块数据是不是指针”。为了让JVM能够判断出所有位置上的数据是不是指向GC堆里的引用，包括活动记录（栈+寄存器）里的数据。HotSpot选择从外部记录下类型信息，存成映射表，也就是OopMap。</p>\n<p>OopMap在类加载完成时把对象内的偏移量是什么类型计算出，并且存放下在相应的位置，当需要遍历根结点时访问所有OopMap即可。在JIT编译过程中，也会在特定位置记录下栈和寄存器中的那些位置和引用的，这样GC在扫描时就可以直接获得这些信息。 </p>\n<h2 id=\"用安全点Safepoint约束根节点\"><a href=\"#用安全点Safepoint约束根节点\" class=\"headerlink\" title=\"用安全点Safepoint约束根节点\"></a>用安全点Safepoint约束根节点</h2><p>如果将每个符合GC Roots条件的对象都存放进入OopMap中，那么OopMap也会变得很大，而且其中很多对象很可能会发生一些变化，这些变化使得维护这个映射表很困难。</p>\n<p>实际上，HotSpot并没有为每一个对象都创建OopMap，只在特定的位置上创建了这些信息，这些位置称为安全点（Safepoints）。</p>\n<p>为了保证虚拟机中安全点的个数不算太多也不是太少，主要决定安全点是否被建立的因素是时间。当进行了耗时的操作时，比如方法调用、循环跳转等时会产生安全点。</p>\n<p>在GC发生时需要让线程停顿下来，让线程停顿下来的方案有两种，<strong>抢先式中断</strong>和<strong>主动式中断</strong> </p>\n<ul>\n<li><p>抢先式中断：在GC发生时先中断所有线程，如果线程不在安全点上，则启动该线程使其执行到安全点后挂起。</p>\n</li>\n<li><p>主动式中断：不需要直接对线程进行操作，在线程执行时主动轮询这个标识，若中断标识为真，在线程自己中断挂起这个标识和安全点是重合的</p>\n</li>\n</ul>\n<h2 id=\"安全区域（safe-region）\"><a href=\"#安全区域（safe-region）\" class=\"headerlink\" title=\"安全区域（safe region）\"></a>安全区域（safe region）</h2><p>上面的安全点检查仿佛完全解决了如何进入GC的问题，但只有安全点还是不够的，安全点只解决了那些在运行的程序，保证了他们可以运行到安全点并挂起，但如果有些线程此时并未执行，例如处于sleep或blocked状态的线程，就无法响应JVM的中断请求，这时就需要使用安全区域了。</p>\n<p><strong>安全区域是指在此区域内，对象的引用关系不会发生变化（即不会影响枚举根节点) </strong></p>\n<p>当线程运行到安全区域时会将自己标识，在JVM准备进行GC时将视这些线程为安全的，不影响GC，当线程运行完毕要离开安全区域时，线程会检查JVM是否在枚举根节点，若是，则等待完成后再离开安全区域继续执行。</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Java中的主流虚拟机HotSpot采用可达性分析算法来确定一个对象的状态，那么HotSpot是如何实现该算法的呢？</p>\n<h2 id=\"使用OopMap记录并枚举根节点\"><a href=\"#使用OopMap记录并枚举根节点\" class=\"headerlink\" title=\"使用OopMap记录并枚举根节点\"></a>使用OopMap记录并枚举根节点</h2><p>在从GC ROOT向下查找引用链时，可作为GC ROOT的节点主要有全局性引用（常量、静态变量）和执行上下文（栈帧中的本地变量表），通常方法区就有好几百兆，遍历一次需要比较长的时间。</p>\n<p>另外，在查找引用链过程中，需要保证引用链的一致性，即在分析过程中对象的引用关系不再变化，否则分析准确性则无法得到保证。因此通常GC执行时会stop the world，停止所有执行线程，即使几乎不发生停顿的CMS收集器中，枚举根节点也是需要停顿的。如果这个停顿的时间过长，肯定是难以接受的。</p>\n<p>那么HotSpot是如何在最短的时间内进行这个耗时的搜索工作的呢？</p>\n<p>答案就在这个神奇的数据结构中——OopMap。</p>\n<p>在遍历堆栈时，虚拟机关心的就是“这块数据是不是指针”。为了让JVM能够判断出所有位置上的数据是不是指向GC堆里的引用，包括活动记录（栈+寄存器）里的数据。HotSpot选择从外部记录下类型信息，存成映射表，也就是OopMap。</p>\n<p>OopMap在类加载完成时把对象内的偏移量是什么类型计算出，并且存放下在相应的位置，当需要遍历根结点时访问所有OopMap即可。在JIT编译过程中，也会在特定位置记录下栈和寄存器中的那些位置和引用的，这样GC在扫描时就可以直接获得这些信息。 </p>\n<h2 id=\"用安全点Safepoint约束根节点\"><a href=\"#用安全点Safepoint约束根节点\" class=\"headerlink\" title=\"用安全点Safepoint约束根节点\"></a>用安全点Safepoint约束根节点</h2><p>如果将每个符合GC Roots条件的对象都存放进入OopMap中，那么OopMap也会变得很大，而且其中很多对象很可能会发生一些变化，这些变化使得维护这个映射表很困难。</p>\n<p>实际上，HotSpot并没有为每一个对象都创建OopMap，只在特定的位置上创建了这些信息，这些位置称为安全点（Safepoints）。</p>\n<p>为了保证虚拟机中安全点的个数不算太多也不是太少，主要决定安全点是否被建立的因素是时间。当进行了耗时的操作时，比如方法调用、循环跳转等时会产生安全点。</p>\n<p>在GC发生时需要让线程停顿下来，让线程停顿下来的方案有两种，<strong>抢先式中断</strong>和<strong>主动式中断</strong> </p>\n<ul>\n<li><p>抢先式中断：在GC发生时先中断所有线程，如果线程不在安全点上，则启动该线程使其执行到安全点后挂起。</p>\n</li>\n<li><p>主动式中断：不需要直接对线程进行操作，在线程执行时主动轮询这个标识，若中断标识为真，在线程自己中断挂起这个标识和安全点是重合的</p>\n</li>\n</ul>\n<h2 id=\"安全区域（safe-region）\"><a href=\"#安全区域（safe-region）\" class=\"headerlink\" title=\"安全区域（safe region）\"></a>安全区域（safe region）</h2><p>上面的安全点检查仿佛完全解决了如何进入GC的问题，但只有安全点还是不够的，安全点只解决了那些在运行的程序，保证了他们可以运行到安全点并挂起，但如果有些线程此时并未执行，例如处于sleep或blocked状态的线程，就无法响应JVM的中断请求，这时就需要使用安全区域了。</p>\n<p><strong>安全区域是指在此区域内，对象的引用关系不会发生变化（即不会影响枚举根节点) </strong></p>\n<p>当线程运行到安全区域时会将自己标识，在JVM准备进行GC时将视这些线程为安全的，不影响GC，当线程运行完毕要离开安全区域时，线程会检查JVM是否在枚举根节点，若是，则等待完成后再离开安全区域继续执行。</p>\n"},{"title":"Java 多线程篇","date":"2018-12-29T11:55:51.000Z","_content":"\n## 前言\n","source":"_posts/java/multithread/multithread-start.md","raw":"---\ntitle: Java 多线程篇\ntags: \n - Java\n - 多线程\ncategories: 编程\ndate: 2018-12-29 19:55:51\n---\n\n## 前言\n","slug":"java/multithread/multithread-start","published":1,"updated":"2019-06-04T01:29:57.371Z","_id":"cjxze3gwa00520cvwciw7wbfl","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2>","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2>"},{"title":"【问题总结】万万没想到，竟然栽在了List手里","date":"2019-05-18T01:00:02.000Z","_content":"\n## 说明\n\n昨天同事开发的时候遇到了一个奇怪的问题。\n\n![](https://i.loli.net/2019/05/18/5cdf7e9f2047e23793.png)\n\n使用Guava做缓存，往里面存一个List，为了方便描述，称它为列表A，在另一个地方取出来，再跟列表B中的元素进行差集处理，简单来说，就像是下面这样：\n\n```java\npublic class ArrayListTest {\n    // 方便起见，这里用HashMap来做缓存\n    private Map<String, List<Long>> cache = new HashMap<>();\n    \n    private void save(){\n        List<Long> listA = createListA();\n        cache.put(\"listA\", listA);\n    }\n    \n    private void get(){\n        List<Long> listB = createListB();\n        List<Long> listA = cache.get(\"listA\");\n        listA.removeAll(listB);\n    }\n    \n    private List<Long> createListA(){\n        ···\n    }\n\n    private List<Long> createListB(){\n        ···\n    }\n\n    public static void main(String[] args){\n        ArrayListTest test = new ArrayListTest();\n        test.save();\n        test.get();\n    }\n}\n```\n\n先调用save方法，然后调用get方法，然后就抛出了异常：\n\n![](https://i.loli.net/2019/05/18/5cdf7ec98fddd17705.png)\n\n```shell\nException in thread \"main\" java.lang.UnsupportedOperationException\n\tat java.util.AbstractList.remove(AbstractList.java:161)\n\tat java.util.AbstractList$Itr.remove(AbstractList.java:374)\n\tat java.util.AbstractCollection.removeAll(AbstractCollection.java:376)\n    ...\n```\n\n![](https://i.loli.net/2019/05/18/5cdf6539270f631562.jpg)\n\n## 问题探索\n\n究竟是人性的泯灭还是道德的沦丧，一个小小的List竟然也玩不转了，面对突如其来的打击，我跟同事都开始反思，复制粘贴一时爽，debug火葬场。\n\n但作为一名优秀的程序猿，怎么能被这点困难所难倒呢？于是开始了问题排查之旅。\n\n先来验证一下自己对ArrayList是否有什么误解：\n\n```java\n@Test\npublic void testArrayList() {\n    List<Long> listA = new ArrayList<>();\n    listA.add(1L);\n    listA.add(2L);\n    List<Long> listB = new ArrayList<>();\n    listB.add(2L);\n    listB.add(3L);\n    listA.removeAll(listB);\n    System.out.println(JSON.toJSONString(listA));\n}\n```\n\n输出如下：\n\n```\n[1]\n```\n\n嗯，看来并没有。\n\n![](https://i.loli.net/2019/05/18/5cdf7f0e86fbc84596.png)\n\n再回过头看看，抛出的异常是 `UnsupportedOperationException` 异常，而且是在 `AbstractList` 里抛出的，于是打开了 `AbstractList`的源码。\n\n```java\npublic E remove(int index) {\n    throw new UnsupportedOperationException();\n}\n```\n\n`AbstractList` 类对remove方法的默认实现就是直接抛出一个异常，所以如果子类并没有覆盖该方法，就会出现上面的问题。\n\n那么问题应该就出在列表A的创建方式上。\n\n结果一找，发现列表A是通过 `Arrays.asList()` 创建的，再跟进代码：\n\n```java\npublic static <T> List<T> asList(T... a) {\n    return new ArrayList<>(a);\n}\n```\n\n感觉好像也没哪里不对，这里也是创建一个 `ArrayList` ，讲道理的话，应该没问题才对，不过等等，`ArrayList` 好像没有能传入可变长参数的构造函数吧，于是朝着这个`ArrayList`小手一点，终于发现了问题所在。\n\n原来通过 `Arrays.asList()` 创建的 `List` 对象是通过实例化 `Arrays` 内部类 `ArrayList` 来创建的，所以这个 `ArrayList` 并不是我们常用的那个 `ArrayList`。\n\n![20190518101356.png](https://i.loli.net/2019/05/18/5cdf6a655276187010.png)\n\n![20190518101255.png](https://i.loli.net/2019/05/18/5cdf6a292b1d070453.png)\n\n这个内部类并没有覆盖父类 `AbstractList` 的 `remove` 方法，所以调用的时候就会直接调用父类的 `remove` 方法，于是便发生了上面的异常。\n\n## Arrays.asList的正确打开方式\n\n为了更好的使用这里方法，我们先来看看它的注释说明：\n\n```\n /**\n* Returns a fixed-size list backed by the specified array.  (Changes to\n* the returned list \"write through\" to the array.)  This method acts\n* as bridge between array-based and collection-based APIs, in\n* combination with {@link Collection#toArray}.  The returned list is\n* serializable and implements {@link RandomAccess}.\n*\n* <p>This method also provides a convenient way to create a fixed-size\n* list initialized to contain several elements:\n* <pre>\n*     List&lt;String&gt; stooges = Arrays.asList(\"Larry\", \"Moe\", \"Curly\");\n* </pre>\n*\n* @param <T> the class of the objects in the array\n* @param a the array by which the list will be backed\n* @return a list view of the specified array\n*/\n```\n\n从说明可以发现，有这么几点需要注意：\n\n1、该方法返回的是一个固定长度的列表\n\n所以它的长度是不能被改变的，也就不能对它进行添加和删除元素的操作，从它的内部类ArrayList的方法列表也可以看出，并没有覆盖add和remove方法，因此对这两个方法的调用都会导致抛出异常。\n\n虽然不能改变列表的长度，但是可以改变列表中的元素，以及元素的位置。比如通过set方法来重新设值，通过replaceAll方法来批量替换，通过sort方法来排序等等。\n\n2、任何对列表的改动都会回写到原来是数组\n\n也就是说对返回的列表进行的任何修改操作，都会导致原数组的改变。可以通过一个Test来测试一下：\n\n```java\n@Test\npublic void testArrays() {\n    Long[] longs = {1L,2L,4L,3L};\n    List<Long> longList = Arrays.asList(longs);\n    System.out.println(\"longList:\" + JSON.toJSONString(longList) + \"longs:\" + JSON.toJSONString(longs));\n\n    longList.set(1, 5L);\n    System.out.println(\"longList:\" + JSON.toJSONString(longList) + \"longs:\" + JSON.toJSONString(longs));\n\n    longList.replaceAll(a -> a + 1L);\n    System.out.println(\"longList:\" + JSON.toJSONString(longList) + \"longs:\" + JSON.toJSONString(longs));\n\n    longList.sort(Long::compareTo);\n    System.out.println(\"longList:\" + JSON.toJSONString(longList) + \"longs:\" + JSON.toJSONString(longs));\n\n    longs[2] = 7L;\n    System.out.println(\"longList:\" + JSON.toJSONString(longList) + \"longs:\" + JSON.toJSONString(longs));\n}\n```\n\n输出如下：\n\n```\nlongList:[1,2,4,3]longs:[1,2,4,3]\nlongList:[1,5,4,3]longs:[1,5,4,3]\nlongList:[2,6,5,4]longs:[2,6,5,4]\nlongList:[2,4,5,6]longs:[2,4,5,6]\nlongList:[2,4,7,6]longs:[2,4,7,6]\n```\n\n注意最后一个输出，我们修改原数组的元素，也会导致列表元素的改变，究其原因，当然是因为列表只是将数组封装了起来而已，最终指向的都是同一个内存地址，因此修改自然也是同步的。\n\n3、不能使用基本数据类型数组来作为参数\n\n举个栗子：\n\n```java\n@Test\npublic void testArrays2() {\n    int[] ints = { 1, 2, 3 };\n    List list = Arrays.asList(ints);\n    System.out.println(list.size());\n}\n```\n\n这里并不会报错，而是会输出`1`。为什么呢？\n\n再回过头去看下说明：\n\n```java\n@param <T> the class of the objects in the array\n```\n\n参数的类型T指的是数组中的元素类型，如果数组中元素类型是基本类型，就会把整个数组当成一个元素，我们把上面的栗子稍微修改一下就清楚了。\n\n```java\n@Test\npublic void testArrays2() {\n    int[] ints = { 1, 2, 3 };\n    System.out.println(ints.getClass());\n    List list = Arrays.asList(ints);\n    System.out.println(JSON.toJSONString(list));\n}\n```\n\n输出如下：\n\n```\nclass [I\n[[1,2,3]]\n```\n\n注意第二行的输出是一个二维数组。变长参数本质上就是一个对象数组，所以如果传入一个Integer数组，就能正常接收：\n\n```java\n@Test\npublic void testArrays2() {\n    Integer[] ints = { 1, 2, 3 };\n    System.out.println(ints.getClass());\n    List list = Arrays.asList(ints);\n    System.out.println(list.size());\n}\n```\n\n```\nclass [Ljava.lang.Integer;\n3\n```\n\n## 总结\n\n至此，关于 `Arrays.asList()` 的探索之旅就结束了，遇到问题一般跟一跟源码就差不多能解决了，但对于常用的类，如果对其内部的运行机制不熟悉的话，代码就会容易出现一些不符合预期的行为，报错的异常并不可怕，因为可以根据异常很快定位，最怕的就是不报错，能正常运行，但是数据处理却是错误的，等到真正发现的时候，可能已经造成了难以挽回的损失。\n\n![](https://i.loli.net/2019/05/18/5cdf7f4a7282234332.png)\n\n看来主动阅读源码还是相当有必要的，其实`Arrays.asList()`并不难使用，推而广之，就像Guava、fastjson这些模块，或者spring、redis、dubbo之类，学习使用并不难，但如果不熟悉内部运行机制，仅仅当成一个黑盒的话，无法探索内部的精妙设计，遇到问题也比较难处理，如果只是把功能框定在其设定的能力范围之内，就没有办法进行定制化的改造。\n\n嗯，看来我的历练路程还很长啊。最后用荀子的一句话来共勉吧。\n\n“路虽弥，不行不至，\n\n事虽小，不做不成。”\n\n![](https://i.loli.net/2019/05/18/5cdf7daf74e9241031.png)","source":"_posts/java/problem/the-correct-operation-of-arrays.md","raw":"---\ntitle: 【问题总结】万万没想到，竟然栽在了List手里\ndate: 2019-05-18 09:00:02\ntags: \n - Java\n - 常见问题\ncategories: 编程\n---\n\n## 说明\n\n昨天同事开发的时候遇到了一个奇怪的问题。\n\n![](https://i.loli.net/2019/05/18/5cdf7e9f2047e23793.png)\n\n使用Guava做缓存，往里面存一个List，为了方便描述，称它为列表A，在另一个地方取出来，再跟列表B中的元素进行差集处理，简单来说，就像是下面这样：\n\n```java\npublic class ArrayListTest {\n    // 方便起见，这里用HashMap来做缓存\n    private Map<String, List<Long>> cache = new HashMap<>();\n    \n    private void save(){\n        List<Long> listA = createListA();\n        cache.put(\"listA\", listA);\n    }\n    \n    private void get(){\n        List<Long> listB = createListB();\n        List<Long> listA = cache.get(\"listA\");\n        listA.removeAll(listB);\n    }\n    \n    private List<Long> createListA(){\n        ···\n    }\n\n    private List<Long> createListB(){\n        ···\n    }\n\n    public static void main(String[] args){\n        ArrayListTest test = new ArrayListTest();\n        test.save();\n        test.get();\n    }\n}\n```\n\n先调用save方法，然后调用get方法，然后就抛出了异常：\n\n![](https://i.loli.net/2019/05/18/5cdf7ec98fddd17705.png)\n\n```shell\nException in thread \"main\" java.lang.UnsupportedOperationException\n\tat java.util.AbstractList.remove(AbstractList.java:161)\n\tat java.util.AbstractList$Itr.remove(AbstractList.java:374)\n\tat java.util.AbstractCollection.removeAll(AbstractCollection.java:376)\n    ...\n```\n\n![](https://i.loli.net/2019/05/18/5cdf6539270f631562.jpg)\n\n## 问题探索\n\n究竟是人性的泯灭还是道德的沦丧，一个小小的List竟然也玩不转了，面对突如其来的打击，我跟同事都开始反思，复制粘贴一时爽，debug火葬场。\n\n但作为一名优秀的程序猿，怎么能被这点困难所难倒呢？于是开始了问题排查之旅。\n\n先来验证一下自己对ArrayList是否有什么误解：\n\n```java\n@Test\npublic void testArrayList() {\n    List<Long> listA = new ArrayList<>();\n    listA.add(1L);\n    listA.add(2L);\n    List<Long> listB = new ArrayList<>();\n    listB.add(2L);\n    listB.add(3L);\n    listA.removeAll(listB);\n    System.out.println(JSON.toJSONString(listA));\n}\n```\n\n输出如下：\n\n```\n[1]\n```\n\n嗯，看来并没有。\n\n![](https://i.loli.net/2019/05/18/5cdf7f0e86fbc84596.png)\n\n再回过头看看，抛出的异常是 `UnsupportedOperationException` 异常，而且是在 `AbstractList` 里抛出的，于是打开了 `AbstractList`的源码。\n\n```java\npublic E remove(int index) {\n    throw new UnsupportedOperationException();\n}\n```\n\n`AbstractList` 类对remove方法的默认实现就是直接抛出一个异常，所以如果子类并没有覆盖该方法，就会出现上面的问题。\n\n那么问题应该就出在列表A的创建方式上。\n\n结果一找，发现列表A是通过 `Arrays.asList()` 创建的，再跟进代码：\n\n```java\npublic static <T> List<T> asList(T... a) {\n    return new ArrayList<>(a);\n}\n```\n\n感觉好像也没哪里不对，这里也是创建一个 `ArrayList` ，讲道理的话，应该没问题才对，不过等等，`ArrayList` 好像没有能传入可变长参数的构造函数吧，于是朝着这个`ArrayList`小手一点，终于发现了问题所在。\n\n原来通过 `Arrays.asList()` 创建的 `List` 对象是通过实例化 `Arrays` 内部类 `ArrayList` 来创建的，所以这个 `ArrayList` 并不是我们常用的那个 `ArrayList`。\n\n![20190518101356.png](https://i.loli.net/2019/05/18/5cdf6a655276187010.png)\n\n![20190518101255.png](https://i.loli.net/2019/05/18/5cdf6a292b1d070453.png)\n\n这个内部类并没有覆盖父类 `AbstractList` 的 `remove` 方法，所以调用的时候就会直接调用父类的 `remove` 方法，于是便发生了上面的异常。\n\n## Arrays.asList的正确打开方式\n\n为了更好的使用这里方法，我们先来看看它的注释说明：\n\n```\n /**\n* Returns a fixed-size list backed by the specified array.  (Changes to\n* the returned list \"write through\" to the array.)  This method acts\n* as bridge between array-based and collection-based APIs, in\n* combination with {@link Collection#toArray}.  The returned list is\n* serializable and implements {@link RandomAccess}.\n*\n* <p>This method also provides a convenient way to create a fixed-size\n* list initialized to contain several elements:\n* <pre>\n*     List&lt;String&gt; stooges = Arrays.asList(\"Larry\", \"Moe\", \"Curly\");\n* </pre>\n*\n* @param <T> the class of the objects in the array\n* @param a the array by which the list will be backed\n* @return a list view of the specified array\n*/\n```\n\n从说明可以发现，有这么几点需要注意：\n\n1、该方法返回的是一个固定长度的列表\n\n所以它的长度是不能被改变的，也就不能对它进行添加和删除元素的操作，从它的内部类ArrayList的方法列表也可以看出，并没有覆盖add和remove方法，因此对这两个方法的调用都会导致抛出异常。\n\n虽然不能改变列表的长度，但是可以改变列表中的元素，以及元素的位置。比如通过set方法来重新设值，通过replaceAll方法来批量替换，通过sort方法来排序等等。\n\n2、任何对列表的改动都会回写到原来是数组\n\n也就是说对返回的列表进行的任何修改操作，都会导致原数组的改变。可以通过一个Test来测试一下：\n\n```java\n@Test\npublic void testArrays() {\n    Long[] longs = {1L,2L,4L,3L};\n    List<Long> longList = Arrays.asList(longs);\n    System.out.println(\"longList:\" + JSON.toJSONString(longList) + \"longs:\" + JSON.toJSONString(longs));\n\n    longList.set(1, 5L);\n    System.out.println(\"longList:\" + JSON.toJSONString(longList) + \"longs:\" + JSON.toJSONString(longs));\n\n    longList.replaceAll(a -> a + 1L);\n    System.out.println(\"longList:\" + JSON.toJSONString(longList) + \"longs:\" + JSON.toJSONString(longs));\n\n    longList.sort(Long::compareTo);\n    System.out.println(\"longList:\" + JSON.toJSONString(longList) + \"longs:\" + JSON.toJSONString(longs));\n\n    longs[2] = 7L;\n    System.out.println(\"longList:\" + JSON.toJSONString(longList) + \"longs:\" + JSON.toJSONString(longs));\n}\n```\n\n输出如下：\n\n```\nlongList:[1,2,4,3]longs:[1,2,4,3]\nlongList:[1,5,4,3]longs:[1,5,4,3]\nlongList:[2,6,5,4]longs:[2,6,5,4]\nlongList:[2,4,5,6]longs:[2,4,5,6]\nlongList:[2,4,7,6]longs:[2,4,7,6]\n```\n\n注意最后一个输出，我们修改原数组的元素，也会导致列表元素的改变，究其原因，当然是因为列表只是将数组封装了起来而已，最终指向的都是同一个内存地址，因此修改自然也是同步的。\n\n3、不能使用基本数据类型数组来作为参数\n\n举个栗子：\n\n```java\n@Test\npublic void testArrays2() {\n    int[] ints = { 1, 2, 3 };\n    List list = Arrays.asList(ints);\n    System.out.println(list.size());\n}\n```\n\n这里并不会报错，而是会输出`1`。为什么呢？\n\n再回过头去看下说明：\n\n```java\n@param <T> the class of the objects in the array\n```\n\n参数的类型T指的是数组中的元素类型，如果数组中元素类型是基本类型，就会把整个数组当成一个元素，我们把上面的栗子稍微修改一下就清楚了。\n\n```java\n@Test\npublic void testArrays2() {\n    int[] ints = { 1, 2, 3 };\n    System.out.println(ints.getClass());\n    List list = Arrays.asList(ints);\n    System.out.println(JSON.toJSONString(list));\n}\n```\n\n输出如下：\n\n```\nclass [I\n[[1,2,3]]\n```\n\n注意第二行的输出是一个二维数组。变长参数本质上就是一个对象数组，所以如果传入一个Integer数组，就能正常接收：\n\n```java\n@Test\npublic void testArrays2() {\n    Integer[] ints = { 1, 2, 3 };\n    System.out.println(ints.getClass());\n    List list = Arrays.asList(ints);\n    System.out.println(list.size());\n}\n```\n\n```\nclass [Ljava.lang.Integer;\n3\n```\n\n## 总结\n\n至此，关于 `Arrays.asList()` 的探索之旅就结束了，遇到问题一般跟一跟源码就差不多能解决了，但对于常用的类，如果对其内部的运行机制不熟悉的话，代码就会容易出现一些不符合预期的行为，报错的异常并不可怕，因为可以根据异常很快定位，最怕的就是不报错，能正常运行，但是数据处理却是错误的，等到真正发现的时候，可能已经造成了难以挽回的损失。\n\n![](https://i.loli.net/2019/05/18/5cdf7f4a7282234332.png)\n\n看来主动阅读源码还是相当有必要的，其实`Arrays.asList()`并不难使用，推而广之，就像Guava、fastjson这些模块，或者spring、redis、dubbo之类，学习使用并不难，但如果不熟悉内部运行机制，仅仅当成一个黑盒的话，无法探索内部的精妙设计，遇到问题也比较难处理，如果只是把功能框定在其设定的能力范围之内，就没有办法进行定制化的改造。\n\n嗯，看来我的历练路程还很长啊。最后用荀子的一句话来共勉吧。\n\n“路虽弥，不行不至，\n\n事虽小，不做不成。”\n\n![](https://i.loli.net/2019/05/18/5cdf7daf74e9241031.png)","slug":"java/problem/the-correct-operation-of-arrays","published":1,"updated":"2019-06-04T01:29:57.373Z","_id":"cjxze3gwa00550cvwlu8qcz9r","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>昨天同事开发的时候遇到了一个奇怪的问题。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/18/5cdf7e9f2047e23793.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>使用Guava做缓存，往里面存一个List，为了方便描述，称它为列表A，在另一个地方取出来，再跟列表B中的元素进行差集处理，简单来说，就像是下面这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayListTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 方便起见，这里用HashMap来做缓存</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, List&lt;Long&gt;&gt; cache = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">save</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        List&lt;Long&gt; listA = createListA();</span><br><span class=\"line\">        cache.put(<span class=\"string\">\"listA\"</span>, listA);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">get</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        List&lt;Long&gt; listB = createListB();</span><br><span class=\"line\">        List&lt;Long&gt; listA = cache.get(<span class=\"string\">\"listA\"</span>);</span><br><span class=\"line\">        listA.removeAll(listB);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> List&lt;Long&gt; <span class=\"title\">createListA</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        ···</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> List&lt;Long&gt; <span class=\"title\">createListB</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        ···</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        ArrayListTest test = <span class=\"keyword\">new</span> ArrayListTest();</span><br><span class=\"line\">        test.save();</span><br><span class=\"line\">        test.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先调用save方法，然后调用get方法，然后就抛出了异常：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/18/5cdf7ec98fddd17705.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread \"main\" java.lang.UnsupportedOperationException</span><br><span class=\"line\">\tat java.util.AbstractList.remove(AbstractList.java:161)</span><br><span class=\"line\">\tat java.util.AbstractList$Itr.remove(AbstractList.java:374)</span><br><span class=\"line\">\tat java.util.AbstractCollection.removeAll(AbstractCollection.java:376)</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/18/5cdf6539270f631562.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h2 id=\"问题探索\"><a href=\"#问题探索\" class=\"headerlink\" title=\"问题探索\"></a>问题探索</h2><p>究竟是人性的泯灭还是道德的沦丧，一个小小的List竟然也玩不转了，面对突如其来的打击，我跟同事都开始反思，复制粘贴一时爽，debug火葬场。</p>\n<p>但作为一名优秀的程序猿，怎么能被这点困难所难倒呢？于是开始了问题排查之旅。</p>\n<p>先来验证一下自己对ArrayList是否有什么误解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testArrayList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Long&gt; listA = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    listA.add(<span class=\"number\">1L</span>);</span><br><span class=\"line\">    listA.add(<span class=\"number\">2L</span>);</span><br><span class=\"line\">    List&lt;Long&gt; listB = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    listB.add(<span class=\"number\">2L</span>);</span><br><span class=\"line\">    listB.add(<span class=\"number\">3L</span>);</span><br><span class=\"line\">    listA.removeAll(listB);</span><br><span class=\"line\">    System.out.println(JSON.toJSONString(listA));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1]</span><br></pre></td></tr></table></figure>\n<p>嗯，看来并没有。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/18/5cdf7f0e86fbc84596.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>再回过头看看，抛出的异常是 <code>UnsupportedOperationException</code> 异常，而且是在 <code>AbstractList</code> 里抛出的，于是打开了 <code>AbstractList</code>的源码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>AbstractList</code> 类对remove方法的默认实现就是直接抛出一个异常，所以如果子类并没有覆盖该方法，就会出现上面的问题。</p>\n<p>那么问题应该就出在列表A的创建方式上。</p>\n<p>结果一找，发现列表A是通过 <code>Arrays.asList()</code> 创建的，再跟进代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">asList</span><span class=\"params\">(T... a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;&gt;(a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>感觉好像也没哪里不对，这里也是创建一个 <code>ArrayList</code> ，讲道理的话，应该没问题才对，不过等等，<code>ArrayList</code> 好像没有能传入可变长参数的构造函数吧，于是朝着这个<code>ArrayList</code>小手一点，终于发现了问题所在。</p>\n<p>原来通过 <code>Arrays.asList()</code> 创建的 <code>List</code> 对象是通过实例化 <code>Arrays</code> 内部类 <code>ArrayList</code> 来创建的，所以这个 <code>ArrayList</code> 并不是我们常用的那个 <code>ArrayList</code>。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/18/5cdf6a655276187010.png\" alt=\"20190518101356.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190518101356.png</div>\n            </figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/18/5cdf6a292b1d070453.png\" alt=\"20190518101255.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190518101255.png</div>\n            </figure>\n<p>这个内部类并没有覆盖父类 <code>AbstractList</code> 的 <code>remove</code> 方法，所以调用的时候就会直接调用父类的 <code>remove</code> 方法，于是便发生了上面的异常。</p>\n<h2 id=\"Arrays-asList的正确打开方式\"><a href=\"#Arrays-asList的正确打开方式\" class=\"headerlink\" title=\"Arrays.asList的正确打开方式\"></a>Arrays.asList的正确打开方式</h2><p>为了更好的使用这里方法，我们先来看看它的注释说明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> /**</span><br><span class=\"line\">* Returns a fixed-size list backed by the specified array.  (Changes to</span><br><span class=\"line\">* the returned list &quot;write through&quot; to the array.)  This method acts</span><br><span class=\"line\">* as bridge between array-based and collection-based APIs, in</span><br><span class=\"line\">* combination with &#123;@link Collection#toArray&#125;.  The returned list is</span><br><span class=\"line\">* serializable and implements &#123;@link RandomAccess&#125;.</span><br><span class=\"line\">*</span><br><span class=\"line\">* &lt;p&gt;This method also provides a convenient way to create a fixed-size</span><br><span class=\"line\">* list initialized to contain several elements:</span><br><span class=\"line\">* &lt;pre&gt;</span><br><span class=\"line\">*     List&amp;lt;String&amp;gt; stooges = Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;);</span><br><span class=\"line\">* &lt;/pre&gt;</span><br><span class=\"line\">*</span><br><span class=\"line\">* @param &lt;T&gt; the class of the objects in the array</span><br><span class=\"line\">* @param a the array by which the list will be backed</span><br><span class=\"line\">* @return a list view of the specified array</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n<p>从说明可以发现，有这么几点需要注意：</p>\n<p>1、该方法返回的是一个固定长度的列表</p>\n<p>所以它的长度是不能被改变的，也就不能对它进行添加和删除元素的操作，从它的内部类ArrayList的方法列表也可以看出，并没有覆盖add和remove方法，因此对这两个方法的调用都会导致抛出异常。</p>\n<p>虽然不能改变列表的长度，但是可以改变列表中的元素，以及元素的位置。比如通过set方法来重新设值，通过replaceAll方法来批量替换，通过sort方法来排序等等。</p>\n<p>2、任何对列表的改动都会回写到原来是数组</p>\n<p>也就是说对返回的列表进行的任何修改操作，都会导致原数组的改变。可以通过一个Test来测试一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testArrays</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Long[] longs = &#123;<span class=\"number\">1L</span>,<span class=\"number\">2L</span>,<span class=\"number\">4L</span>,<span class=\"number\">3L</span>&#125;;</span><br><span class=\"line\">    List&lt;Long&gt; longList = Arrays.asList(longs);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"longList:\"</span> + JSON.toJSONString(longList) + <span class=\"string\">\"longs:\"</span> + JSON.toJSONString(longs));</span><br><span class=\"line\"></span><br><span class=\"line\">    longList.set(<span class=\"number\">1</span>, <span class=\"number\">5L</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"longList:\"</span> + JSON.toJSONString(longList) + <span class=\"string\">\"longs:\"</span> + JSON.toJSONString(longs));</span><br><span class=\"line\"></span><br><span class=\"line\">    longList.replaceAll(a -&gt; a + <span class=\"number\">1L</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"longList:\"</span> + JSON.toJSONString(longList) + <span class=\"string\">\"longs:\"</span> + JSON.toJSONString(longs));</span><br><span class=\"line\"></span><br><span class=\"line\">    longList.sort(Long::compareTo);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"longList:\"</span> + JSON.toJSONString(longList) + <span class=\"string\">\"longs:\"</span> + JSON.toJSONString(longs));</span><br><span class=\"line\"></span><br><span class=\"line\">    longs[<span class=\"number\">2</span>] = <span class=\"number\">7L</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"longList:\"</span> + JSON.toJSONString(longList) + <span class=\"string\">\"longs:\"</span> + JSON.toJSONString(longs));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">longList:[1,2,4,3]longs:[1,2,4,3]</span><br><span class=\"line\">longList:[1,5,4,3]longs:[1,5,4,3]</span><br><span class=\"line\">longList:[2,6,5,4]longs:[2,6,5,4]</span><br><span class=\"line\">longList:[2,4,5,6]longs:[2,4,5,6]</span><br><span class=\"line\">longList:[2,4,7,6]longs:[2,4,7,6]</span><br></pre></td></tr></table></figure>\n<p>注意最后一个输出，我们修改原数组的元素，也会导致列表元素的改变，究其原因，当然是因为列表只是将数组封装了起来而已，最终指向的都是同一个内存地址，因此修改自然也是同步的。</p>\n<p>3、不能使用基本数据类型数组来作为参数</p>\n<p>举个栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testArrays2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] ints = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\">    List list = Arrays.asList(ints);</span><br><span class=\"line\">    System.out.println(list.size());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里并不会报错，而是会输出<code>1</code>。为什么呢？</p>\n<p>再回过头去看下说明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@param</span> &lt;T&gt; the <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">of</span> <span class=\"title\">the</span> <span class=\"title\">objects</span> <span class=\"title\">in</span> <span class=\"title\">the</span> <span class=\"title\">array</span></span></span><br></pre></td></tr></table></figure>\n<p>参数的类型T指的是数组中的元素类型，如果数组中元素类型是基本类型，就会把整个数组当成一个元素，我们把上面的栗子稍微修改一下就清楚了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testArrays2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] ints = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\">    System.out.println(ints.getClass());</span><br><span class=\"line\">    List list = Arrays.asList(ints);</span><br><span class=\"line\">    System.out.println(JSON.toJSONString(list));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class [I</span><br><span class=\"line\">[[1,2,3]]</span><br></pre></td></tr></table></figure>\n<p>注意第二行的输出是一个二维数组。变长参数本质上就是一个对象数组，所以如果传入一个Integer数组，就能正常接收：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testArrays2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Integer[] ints = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\">    System.out.println(ints.getClass());</span><br><span class=\"line\">    List list = Arrays.asList(ints);</span><br><span class=\"line\">    System.out.println(list.size());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class [Ljava.lang.Integer;</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>至此，关于 <code>Arrays.asList()</code> 的探索之旅就结束了，遇到问题一般跟一跟源码就差不多能解决了，但对于常用的类，如果对其内部的运行机制不熟悉的话，代码就会容易出现一些不符合预期的行为，报错的异常并不可怕，因为可以根据异常很快定位，最怕的就是不报错，能正常运行，但是数据处理却是错误的，等到真正发现的时候，可能已经造成了难以挽回的损失。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/18/5cdf7f4a7282234332.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>看来主动阅读源码还是相当有必要的，其实<code>Arrays.asList()</code>并不难使用，推而广之，就像Guava、fastjson这些模块，或者spring、redis、dubbo之类，学习使用并不难，但如果不熟悉内部运行机制，仅仅当成一个黑盒的话，无法探索内部的精妙设计，遇到问题也比较难处理，如果只是把功能框定在其设定的能力范围之内，就没有办法进行定制化的改造。</p>\n<p>嗯，看来我的历练路程还很长啊。最后用荀子的一句话来共勉吧。</p>\n<p>“路虽弥，不行不至，</p>\n<p>事虽小，不做不成。”</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/18/5cdf7daf74e9241031.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>昨天同事开发的时候遇到了一个奇怪的问题。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/18/5cdf7e9f2047e23793.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>使用Guava做缓存，往里面存一个List，为了方便描述，称它为列表A，在另一个地方取出来，再跟列表B中的元素进行差集处理，简单来说，就像是下面这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayListTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 方便起见，这里用HashMap来做缓存</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, List&lt;Long&gt;&gt; cache = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">save</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        List&lt;Long&gt; listA = createListA();</span><br><span class=\"line\">        cache.put(<span class=\"string\">\"listA\"</span>, listA);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">get</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        List&lt;Long&gt; listB = createListB();</span><br><span class=\"line\">        List&lt;Long&gt; listA = cache.get(<span class=\"string\">\"listA\"</span>);</span><br><span class=\"line\">        listA.removeAll(listB);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> List&lt;Long&gt; <span class=\"title\">createListA</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        ···</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> List&lt;Long&gt; <span class=\"title\">createListB</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        ···</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        ArrayListTest test = <span class=\"keyword\">new</span> ArrayListTest();</span><br><span class=\"line\">        test.save();</span><br><span class=\"line\">        test.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先调用save方法，然后调用get方法，然后就抛出了异常：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/18/5cdf7ec98fddd17705.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread \"main\" java.lang.UnsupportedOperationException</span><br><span class=\"line\">\tat java.util.AbstractList.remove(AbstractList.java:161)</span><br><span class=\"line\">\tat java.util.AbstractList$Itr.remove(AbstractList.java:374)</span><br><span class=\"line\">\tat java.util.AbstractCollection.removeAll(AbstractCollection.java:376)</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/18/5cdf6539270f631562.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h2 id=\"问题探索\"><a href=\"#问题探索\" class=\"headerlink\" title=\"问题探索\"></a>问题探索</h2><p>究竟是人性的泯灭还是道德的沦丧，一个小小的List竟然也玩不转了，面对突如其来的打击，我跟同事都开始反思，复制粘贴一时爽，debug火葬场。</p>\n<p>但作为一名优秀的程序猿，怎么能被这点困难所难倒呢？于是开始了问题排查之旅。</p>\n<p>先来验证一下自己对ArrayList是否有什么误解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testArrayList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Long&gt; listA = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    listA.add(<span class=\"number\">1L</span>);</span><br><span class=\"line\">    listA.add(<span class=\"number\">2L</span>);</span><br><span class=\"line\">    List&lt;Long&gt; listB = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    listB.add(<span class=\"number\">2L</span>);</span><br><span class=\"line\">    listB.add(<span class=\"number\">3L</span>);</span><br><span class=\"line\">    listA.removeAll(listB);</span><br><span class=\"line\">    System.out.println(JSON.toJSONString(listA));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1]</span><br></pre></td></tr></table></figure>\n<p>嗯，看来并没有。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/18/5cdf7f0e86fbc84596.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>再回过头看看，抛出的异常是 <code>UnsupportedOperationException</code> 异常，而且是在 <code>AbstractList</code> 里抛出的，于是打开了 <code>AbstractList</code>的源码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>AbstractList</code> 类对remove方法的默认实现就是直接抛出一个异常，所以如果子类并没有覆盖该方法，就会出现上面的问题。</p>\n<p>那么问题应该就出在列表A的创建方式上。</p>\n<p>结果一找，发现列表A是通过 <code>Arrays.asList()</code> 创建的，再跟进代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">asList</span><span class=\"params\">(T... a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;&gt;(a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>感觉好像也没哪里不对，这里也是创建一个 <code>ArrayList</code> ，讲道理的话，应该没问题才对，不过等等，<code>ArrayList</code> 好像没有能传入可变长参数的构造函数吧，于是朝着这个<code>ArrayList</code>小手一点，终于发现了问题所在。</p>\n<p>原来通过 <code>Arrays.asList()</code> 创建的 <code>List</code> 对象是通过实例化 <code>Arrays</code> 内部类 <code>ArrayList</code> 来创建的，所以这个 <code>ArrayList</code> 并不是我们常用的那个 <code>ArrayList</code>。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/18/5cdf6a655276187010.png\" alt=\"20190518101356.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190518101356.png</div>\n            </figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/18/5cdf6a292b1d070453.png\" alt=\"20190518101255.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190518101255.png</div>\n            </figure>\n<p>这个内部类并没有覆盖父类 <code>AbstractList</code> 的 <code>remove</code> 方法，所以调用的时候就会直接调用父类的 <code>remove</code> 方法，于是便发生了上面的异常。</p>\n<h2 id=\"Arrays-asList的正确打开方式\"><a href=\"#Arrays-asList的正确打开方式\" class=\"headerlink\" title=\"Arrays.asList的正确打开方式\"></a>Arrays.asList的正确打开方式</h2><p>为了更好的使用这里方法，我们先来看看它的注释说明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> /**</span><br><span class=\"line\">* Returns a fixed-size list backed by the specified array.  (Changes to</span><br><span class=\"line\">* the returned list &quot;write through&quot; to the array.)  This method acts</span><br><span class=\"line\">* as bridge between array-based and collection-based APIs, in</span><br><span class=\"line\">* combination with &#123;@link Collection#toArray&#125;.  The returned list is</span><br><span class=\"line\">* serializable and implements &#123;@link RandomAccess&#125;.</span><br><span class=\"line\">*</span><br><span class=\"line\">* &lt;p&gt;This method also provides a convenient way to create a fixed-size</span><br><span class=\"line\">* list initialized to contain several elements:</span><br><span class=\"line\">* &lt;pre&gt;</span><br><span class=\"line\">*     List&amp;lt;String&amp;gt; stooges = Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;);</span><br><span class=\"line\">* &lt;/pre&gt;</span><br><span class=\"line\">*</span><br><span class=\"line\">* @param &lt;T&gt; the class of the objects in the array</span><br><span class=\"line\">* @param a the array by which the list will be backed</span><br><span class=\"line\">* @return a list view of the specified array</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n<p>从说明可以发现，有这么几点需要注意：</p>\n<p>1、该方法返回的是一个固定长度的列表</p>\n<p>所以它的长度是不能被改变的，也就不能对它进行添加和删除元素的操作，从它的内部类ArrayList的方法列表也可以看出，并没有覆盖add和remove方法，因此对这两个方法的调用都会导致抛出异常。</p>\n<p>虽然不能改变列表的长度，但是可以改变列表中的元素，以及元素的位置。比如通过set方法来重新设值，通过replaceAll方法来批量替换，通过sort方法来排序等等。</p>\n<p>2、任何对列表的改动都会回写到原来是数组</p>\n<p>也就是说对返回的列表进行的任何修改操作，都会导致原数组的改变。可以通过一个Test来测试一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testArrays</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Long[] longs = &#123;<span class=\"number\">1L</span>,<span class=\"number\">2L</span>,<span class=\"number\">4L</span>,<span class=\"number\">3L</span>&#125;;</span><br><span class=\"line\">    List&lt;Long&gt; longList = Arrays.asList(longs);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"longList:\"</span> + JSON.toJSONString(longList) + <span class=\"string\">\"longs:\"</span> + JSON.toJSONString(longs));</span><br><span class=\"line\"></span><br><span class=\"line\">    longList.set(<span class=\"number\">1</span>, <span class=\"number\">5L</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"longList:\"</span> + JSON.toJSONString(longList) + <span class=\"string\">\"longs:\"</span> + JSON.toJSONString(longs));</span><br><span class=\"line\"></span><br><span class=\"line\">    longList.replaceAll(a -&gt; a + <span class=\"number\">1L</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"longList:\"</span> + JSON.toJSONString(longList) + <span class=\"string\">\"longs:\"</span> + JSON.toJSONString(longs));</span><br><span class=\"line\"></span><br><span class=\"line\">    longList.sort(Long::compareTo);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"longList:\"</span> + JSON.toJSONString(longList) + <span class=\"string\">\"longs:\"</span> + JSON.toJSONString(longs));</span><br><span class=\"line\"></span><br><span class=\"line\">    longs[<span class=\"number\">2</span>] = <span class=\"number\">7L</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"longList:\"</span> + JSON.toJSONString(longList) + <span class=\"string\">\"longs:\"</span> + JSON.toJSONString(longs));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">longList:[1,2,4,3]longs:[1,2,4,3]</span><br><span class=\"line\">longList:[1,5,4,3]longs:[1,5,4,3]</span><br><span class=\"line\">longList:[2,6,5,4]longs:[2,6,5,4]</span><br><span class=\"line\">longList:[2,4,5,6]longs:[2,4,5,6]</span><br><span class=\"line\">longList:[2,4,7,6]longs:[2,4,7,6]</span><br></pre></td></tr></table></figure>\n<p>注意最后一个输出，我们修改原数组的元素，也会导致列表元素的改变，究其原因，当然是因为列表只是将数组封装了起来而已，最终指向的都是同一个内存地址，因此修改自然也是同步的。</p>\n<p>3、不能使用基本数据类型数组来作为参数</p>\n<p>举个栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testArrays2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] ints = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\">    List list = Arrays.asList(ints);</span><br><span class=\"line\">    System.out.println(list.size());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里并不会报错，而是会输出<code>1</code>。为什么呢？</p>\n<p>再回过头去看下说明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@param</span> &lt;T&gt; the <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">of</span> <span class=\"title\">the</span> <span class=\"title\">objects</span> <span class=\"title\">in</span> <span class=\"title\">the</span> <span class=\"title\">array</span></span></span><br></pre></td></tr></table></figure>\n<p>参数的类型T指的是数组中的元素类型，如果数组中元素类型是基本类型，就会把整个数组当成一个元素，我们把上面的栗子稍微修改一下就清楚了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testArrays2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] ints = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\">    System.out.println(ints.getClass());</span><br><span class=\"line\">    List list = Arrays.asList(ints);</span><br><span class=\"line\">    System.out.println(JSON.toJSONString(list));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class [I</span><br><span class=\"line\">[[1,2,3]]</span><br></pre></td></tr></table></figure>\n<p>注意第二行的输出是一个二维数组。变长参数本质上就是一个对象数组，所以如果传入一个Integer数组，就能正常接收：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testArrays2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Integer[] ints = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\">    System.out.println(ints.getClass());</span><br><span class=\"line\">    List list = Arrays.asList(ints);</span><br><span class=\"line\">    System.out.println(list.size());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class [Ljava.lang.Integer;</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>至此，关于 <code>Arrays.asList()</code> 的探索之旅就结束了，遇到问题一般跟一跟源码就差不多能解决了，但对于常用的类，如果对其内部的运行机制不熟悉的话，代码就会容易出现一些不符合预期的行为，报错的异常并不可怕，因为可以根据异常很快定位，最怕的就是不报错，能正常运行，但是数据处理却是错误的，等到真正发现的时候，可能已经造成了难以挽回的损失。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/18/5cdf7f4a7282234332.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>看来主动阅读源码还是相当有必要的，其实<code>Arrays.asList()</code>并不难使用，推而广之，就像Guava、fastjson这些模块，或者spring、redis、dubbo之类，学习使用并不难，但如果不熟悉内部运行机制，仅仅当成一个黑盒的话，无法探索内部的精妙设计，遇到问题也比较难处理，如果只是把功能框定在其设定的能力范围之内，就没有办法进行定制化的改造。</p>\n<p>嗯，看来我的历练路程还很长啊。最后用荀子的一句话来共勉吧。</p>\n<p>“路虽弥，不行不至，</p>\n<p>事虽小，不做不成。”</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/18/5cdf7daf74e9241031.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>"},{"title":"可达性","date":"2018-12-28T11:55:51.000Z","_content":"\n## 定义\n\nJava中，一个对象的可达性（Reachable）是指从一系列GC Roots的对象出发，从这些节点往下搜索，搜索时走过的路径称为引用链（Reference Chain），当一个对象不在任何GC Roots的引用链中时，则表示此对象是不可到达的，将会被判定为可回收对象。\n\n## 说明\n\n可达性，主要是用来作为垃圾回收器回收的标准，表示一个对象可被访问的难易程度。\n\n可达性按强弱程度依次为强可达（strongly reachable）、软可达（softly reachable）、弱可达（weakly reachable）、虚可达（phantom reachable）和不可达（unreachable）。\n\n``` bash\n当一个对象有其它对象或变量持有其强引用时，该对象就处于强可达状态。\n当一个对象没有任何对象或变量持有其强引用，但有对象或变量持有其软引用，则该变量处于软可达状态。\n当一个对象既没有强引用，也没有软引用指向它，但有弱引用与其关联，则该变量处于弱可达状态。\n当一个对象仅存在虚引用与其关联时，该变量处于虚可达状态。\n当一个对象不存在任何引用与其关联时，该变量处于不可达状态。\n```\n\n垃圾回收，回收的自然是“垃圾”，那么“垃圾”的判断标准是什么？在Java中，使用的是可达性分析算法，也就是根据对象的可达性来判断它是否该被回收。当内存足够时，如果一个对象是弱可达、虚可达或者不可达的，那么它就会判定为可回收对象。如果内存不足时，那么软可达对象也会纳入回收范围之内。\n\n{% asset_img accessibility1.png accessibility %}\n\n## GC Roots\n\n那么什么样的对象可以作为GC Roots呢？一般来说，如下情况的对象可以作为GC Roots：\n\n```bash\n1. 虚拟机栈(栈桢中的本地变量表)中引用的对象\n2. 方法区中的类静态属性引用的对象\n3. 方法区中的常量引用的对象\n4. 本地方法栈中JNI（Native方法）引用的对象\n```\n\n## 可达性判断\n\nJVM在进行GC时，判断一个对象是否存在引用，是从根引用GC Roots开始去标识，到达同一个对象的路径有时可能会有多条，如下图所示： \n\n{% asset_img accessibility2.png accessibility %}\n\n此时，JVM判断的标准是：\n\n1. 如果只存在一条路径，则以该路径上最弱的引用为准。\n2. 如果存在不同路径，则以最强的路径引用为准。\n\n例如Obj4的引用，存在3个路径:1->6、2->5、3->4, 那么从根对象到Obj4最强的引用是2->5，因为它们都是强引用，此时Obj4为强可达（strong reachable）对象。\n\n如果仅仅存在一个路径对Obj4有引用时，比如现在只剩1->6,那么根对象到Obj4的引用就是以最弱的为准，就是SoftReference引用,Obj4就是软可达（softly-reachable）对象。\n\n如果还想了解在HotSpot虚拟机中是如何实现可达性分析算法的话，可以点[这里](./reachable-in-hotspot.md)。\n","source":"_posts/java/jvm/reachable.md","raw":"---\ntitle: 可达性\ntags: \n - Java\ncategories: 编程\ndate: 2018-12-28 19:55:51\n---\n\n## 定义\n\nJava中，一个对象的可达性（Reachable）是指从一系列GC Roots的对象出发，从这些节点往下搜索，搜索时走过的路径称为引用链（Reference Chain），当一个对象不在任何GC Roots的引用链中时，则表示此对象是不可到达的，将会被判定为可回收对象。\n\n## 说明\n\n可达性，主要是用来作为垃圾回收器回收的标准，表示一个对象可被访问的难易程度。\n\n可达性按强弱程度依次为强可达（strongly reachable）、软可达（softly reachable）、弱可达（weakly reachable）、虚可达（phantom reachable）和不可达（unreachable）。\n\n``` bash\n当一个对象有其它对象或变量持有其强引用时，该对象就处于强可达状态。\n当一个对象没有任何对象或变量持有其强引用，但有对象或变量持有其软引用，则该变量处于软可达状态。\n当一个对象既没有强引用，也没有软引用指向它，但有弱引用与其关联，则该变量处于弱可达状态。\n当一个对象仅存在虚引用与其关联时，该变量处于虚可达状态。\n当一个对象不存在任何引用与其关联时，该变量处于不可达状态。\n```\n\n垃圾回收，回收的自然是“垃圾”，那么“垃圾”的判断标准是什么？在Java中，使用的是可达性分析算法，也就是根据对象的可达性来判断它是否该被回收。当内存足够时，如果一个对象是弱可达、虚可达或者不可达的，那么它就会判定为可回收对象。如果内存不足时，那么软可达对象也会纳入回收范围之内。\n\n{% asset_img accessibility1.png accessibility %}\n\n## GC Roots\n\n那么什么样的对象可以作为GC Roots呢？一般来说，如下情况的对象可以作为GC Roots：\n\n```bash\n1. 虚拟机栈(栈桢中的本地变量表)中引用的对象\n2. 方法区中的类静态属性引用的对象\n3. 方法区中的常量引用的对象\n4. 本地方法栈中JNI（Native方法）引用的对象\n```\n\n## 可达性判断\n\nJVM在进行GC时，判断一个对象是否存在引用，是从根引用GC Roots开始去标识，到达同一个对象的路径有时可能会有多条，如下图所示： \n\n{% asset_img accessibility2.png accessibility %}\n\n此时，JVM判断的标准是：\n\n1. 如果只存在一条路径，则以该路径上最弱的引用为准。\n2. 如果存在不同路径，则以最强的路径引用为准。\n\n例如Obj4的引用，存在3个路径:1->6、2->5、3->4, 那么从根对象到Obj4最强的引用是2->5，因为它们都是强引用，此时Obj4为强可达（strong reachable）对象。\n\n如果仅仅存在一个路径对Obj4有引用时，比如现在只剩1->6,那么根对象到Obj4的引用就是以最弱的为准，就是SoftReference引用,Obj4就是软可达（softly-reachable）对象。\n\n如果还想了解在HotSpot虚拟机中是如何实现可达性分析算法的话，可以点[这里](./reachable-in-hotspot.md)。\n","slug":"java/jvm/reachable","published":1,"updated":"2019-06-04T01:29:57.338Z","_id":"cjxze3gwk00590cvwnvqe92ba","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>Java中，一个对象的可达性（Reachable）是指从一系列GC Roots的对象出发，从这些节点往下搜索，搜索时走过的路径称为引用链（Reference Chain），当一个对象不在任何GC Roots的引用链中时，则表示此对象是不可到达的，将会被判定为可回收对象。</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>可达性，主要是用来作为垃圾回收器回收的标准，表示一个对象可被访问的难易程度。</p>\n<p>可达性按强弱程度依次为强可达（strongly reachable）、软可达（softly reachable）、弱可达（weakly reachable）、虚可达（phantom reachable）和不可达（unreachable）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当一个对象有其它对象或变量持有其强引用时，该对象就处于强可达状态。</span><br><span class=\"line\">当一个对象没有任何对象或变量持有其强引用，但有对象或变量持有其软引用，则该变量处于软可达状态。</span><br><span class=\"line\">当一个对象既没有强引用，也没有软引用指向它，但有弱引用与其关联，则该变量处于弱可达状态。</span><br><span class=\"line\">当一个对象仅存在虚引用与其关联时，该变量处于虚可达状态。</span><br><span class=\"line\">当一个对象不存在任何引用与其关联时，该变量处于不可达状态。</span><br></pre></td></tr></table></figure>\n<p>垃圾回收，回收的自然是“垃圾”，那么“垃圾”的判断标准是什么？在Java中，使用的是可达性分析算法，也就是根据对象的可达性来判断它是否该被回收。当内存足够时，如果一个对象是弱可达、虚可达或者不可达的，那么它就会判定为可回收对象。如果内存不足时，那么软可达对象也会纳入回收范围之内。</p>\n\n<h2 id=\"GC-Roots\"><a href=\"#GC-Roots\" class=\"headerlink\" title=\"GC Roots\"></a>GC Roots</h2><p>那么什么样的对象可以作为GC Roots呢？一般来说，如下情况的对象可以作为GC Roots：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 虚拟机栈(栈桢中的本地变量表)中引用的对象</span><br><span class=\"line\">2. 方法区中的类静态属性引用的对象</span><br><span class=\"line\">3. 方法区中的常量引用的对象</span><br><span class=\"line\">4. 本地方法栈中JNI（Native方法）引用的对象</span><br></pre></td></tr></table></figure>\n<h2 id=\"可达性判断\"><a href=\"#可达性判断\" class=\"headerlink\" title=\"可达性判断\"></a>可达性判断</h2><p>JVM在进行GC时，判断一个对象是否存在引用，是从根引用GC Roots开始去标识，到达同一个对象的路径有时可能会有多条，如下图所示： </p>\n<img src=\"/programming/java/jvm/reachable/accessibility2.png\" title=\"accessibility\">\n<p>此时，JVM判断的标准是：</p>\n<ol>\n<li>如果只存在一条路径，则以该路径上最弱的引用为准。</li>\n<li>如果存在不同路径，则以最强的路径引用为准。</li>\n</ol>\n<p>例如Obj4的引用，存在3个路径:1-&gt;6、2-&gt;5、3-&gt;4, 那么从根对象到Obj4最强的引用是2-&gt;5，因为它们都是强引用，此时Obj4为强可达（strong reachable）对象。</p>\n<p>如果仅仅存在一个路径对Obj4有引用时，比如现在只剩1-&gt;6,那么根对象到Obj4的引用就是以最弱的为准，就是SoftReference引用,Obj4就是软可达（softly-reachable）对象。</p>\n<p>如果还想了解在HotSpot虚拟机中是如何实现可达性分析算法的话，可以点<a href=\"./reachable-in-hotspot.md\">这里</a>。</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>Java中，一个对象的可达性（Reachable）是指从一系列GC Roots的对象出发，从这些节点往下搜索，搜索时走过的路径称为引用链（Reference Chain），当一个对象不在任何GC Roots的引用链中时，则表示此对象是不可到达的，将会被判定为可回收对象。</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>可达性，主要是用来作为垃圾回收器回收的标准，表示一个对象可被访问的难易程度。</p>\n<p>可达性按强弱程度依次为强可达（strongly reachable）、软可达（softly reachable）、弱可达（weakly reachable）、虚可达（phantom reachable）和不可达（unreachable）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当一个对象有其它对象或变量持有其强引用时，该对象就处于强可达状态。</span><br><span class=\"line\">当一个对象没有任何对象或变量持有其强引用，但有对象或变量持有其软引用，则该变量处于软可达状态。</span><br><span class=\"line\">当一个对象既没有强引用，也没有软引用指向它，但有弱引用与其关联，则该变量处于弱可达状态。</span><br><span class=\"line\">当一个对象仅存在虚引用与其关联时，该变量处于虚可达状态。</span><br><span class=\"line\">当一个对象不存在任何引用与其关联时，该变量处于不可达状态。</span><br></pre></td></tr></table></figure>\n<p>垃圾回收，回收的自然是“垃圾”，那么“垃圾”的判断标准是什么？在Java中，使用的是可达性分析算法，也就是根据对象的可达性来判断它是否该被回收。当内存足够时，如果一个对象是弱可达、虚可达或者不可达的，那么它就会判定为可回收对象。如果内存不足时，那么软可达对象也会纳入回收范围之内。</p>\n\n<h2 id=\"GC-Roots\"><a href=\"#GC-Roots\" class=\"headerlink\" title=\"GC Roots\"></a>GC Roots</h2><p>那么什么样的对象可以作为GC Roots呢？一般来说，如下情况的对象可以作为GC Roots：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 虚拟机栈(栈桢中的本地变量表)中引用的对象</span><br><span class=\"line\">2. 方法区中的类静态属性引用的对象</span><br><span class=\"line\">3. 方法区中的常量引用的对象</span><br><span class=\"line\">4. 本地方法栈中JNI（Native方法）引用的对象</span><br></pre></td></tr></table></figure>\n<h2 id=\"可达性判断\"><a href=\"#可达性判断\" class=\"headerlink\" title=\"可达性判断\"></a>可达性判断</h2><p>JVM在进行GC时，判断一个对象是否存在引用，是从根引用GC Roots开始去标识，到达同一个对象的路径有时可能会有多条，如下图所示： </p>\n<img src=\"/programming/java/jvm/reachable/accessibility2.png\" title=\"accessibility\">\n<p>此时，JVM判断的标准是：</p>\n<ol>\n<li>如果只存在一条路径，则以该路径上最弱的引用为准。</li>\n<li>如果存在不同路径，则以最强的路径引用为准。</li>\n</ol>\n<p>例如Obj4的引用，存在3个路径:1-&gt;6、2-&gt;5、3-&gt;4, 那么从根对象到Obj4最强的引用是2-&gt;5，因为它们都是强引用，此时Obj4为强可达（strong reachable）对象。</p>\n<p>如果仅仅存在一个路径对Obj4有引用时，比如现在只剩1-&gt;6,那么根对象到Obj4的引用就是以最弱的为准，就是SoftReference引用,Obj4就是软可达（softly-reachable）对象。</p>\n<p>如果还想了解在HotSpot虚拟机中是如何实现可达性分析算法的话，可以点<a href=\"./reachable-in-hotspot.md\">这里</a>。</p>\n"},{"title":"PhantomReference源码详解","date":"2018-12-29T12:20:51.000Z","_content":"\n## 定义\n\nPhantomReference是虚引用，该引用不会影响不会影响对象的生命周期，也无法从虚引用中获取对象实例。\n\n## 说明\n\n源码介绍部分其实也没多大内容，主要内容都在前面介绍中说完了。PhantomReference类的源码和WeakReference类一样简单：\n\n```java\npublic class PhantomReference<T> extends Reference<T> {\n    public T get() {\n        return null;\n    }\n\n    /**\n     * 这里传入的引用队列也可以为null，但是这样的引用没有任何意义，因为永远不会入队\n     */\n    public PhantomReference(T referent, ReferenceQueue<? super T> q) {\n        super(referent, q);\n    }\n}\n```\n\n可以看到，get方法直接返回null，有一个两个参数的构造方法，传入被引用的对象和引用队列。\n\n<img src=\"/images/06.png\" width=\"40\"/>那么，这篇也先告一段落吧。","source":"_posts/java/reference/phantom-reference-code-detail.md","raw":"---\ntitle: PhantomReference源码详解\ntags: \n - Java\n - 引用类型\ncategories: 编程\ndate: 2018-12-29 20:20:51\n---\n\n## 定义\n\nPhantomReference是虚引用，该引用不会影响不会影响对象的生命周期，也无法从虚引用中获取对象实例。\n\n## 说明\n\n源码介绍部分其实也没多大内容，主要内容都在前面介绍中说完了。PhantomReference类的源码和WeakReference类一样简单：\n\n```java\npublic class PhantomReference<T> extends Reference<T> {\n    public T get() {\n        return null;\n    }\n\n    /**\n     * 这里传入的引用队列也可以为null，但是这样的引用没有任何意义，因为永远不会入队\n     */\n    public PhantomReference(T referent, ReferenceQueue<? super T> q) {\n        super(referent, q);\n    }\n}\n```\n\n可以看到，get方法直接返回null，有一个两个参数的构造方法，传入被引用的对象和引用队列。\n\n<img src=\"/images/06.png\" width=\"40\"/>那么，这篇也先告一段落吧。","slug":"java/reference/phantom-reference-code-detail","published":1,"updated":"2019-06-04T01:29:57.400Z","_id":"cjxze3gwk005c0cvwle6qbx0f","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>PhantomReference是虚引用，该引用不会影响不会影响对象的生命周期，也无法从虚引用中获取对象实例。</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>源码介绍部分其实也没多大内容，主要内容都在前面介绍中说完了。PhantomReference类的源码和WeakReference类一样简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhantomReference</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Reference</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 这里传入的引用队列也可以为null，但是这样的引用没有任何意义，因为永远不会入队</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PhantomReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"keyword\">super</span> T&gt; q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(referent, q);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，get方法直接返回null，有一个两个参数的构造方法，传入被引用的对象和引用队列。</p>\n<p><img src=\"/images/06.png\" width=\"40\">那么，这篇也先告一段落吧。</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>PhantomReference是虚引用，该引用不会影响不会影响对象的生命周期，也无法从虚引用中获取对象实例。</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>源码介绍部分其实也没多大内容，主要内容都在前面介绍中说完了。PhantomReference类的源码和WeakReference类一样简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhantomReference</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Reference</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 这里传入的引用队列也可以为null，但是这样的引用没有任何意义，因为永远不会入队</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PhantomReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"keyword\">super</span> T&gt; q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(referent, q);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，get方法直接返回null，有一个两个参数的构造方法，传入被引用的对象和引用队列。</p>\n<p><img src=\"/images/06.png\" width=\"40\">那么，这篇也先告一段落吧。</p>\n"},{"title":"FinalReference 与 Finalizer 详解","date":"2018-12-29T11:55:51.000Z","_content":"\n# FinalReference 与 Finalizer 详解\n\n## 说明\n\n？？？说好只有四种引用呢，怎么又跑出来一个FinalReference？还有一个奇奇怪怪的Finalizer？\n\n<img src=\"/images/0012.png\"/>\n\n别别别，把枪放下，事情不是你想的那样。<img src=\"/images/0190.png\" width=\"40\"/>\n\nFinalReference虽然也是继承自Reference类，但是并不能直接使用它，因为它是包可见的。\n\n```java\nclass FinalReference<T> extends Reference<T> {\n    public FinalReference(T referent, ReferenceQueue<? super T> q) {\n        super(referent, q);\n    }\n}\n```\n\n也很简单明了，就这一个构造函数。既然是包可见，自然是为了来继承的，不直接提供给外部使用。\n\nFinalReference由JVM来实例化，JVM会对那些实现了Object中finalize()方法的类对象实例化一个对应的FinalReference。 而事实上，JVM实际操作的是其子类——Finalizer，那么Finalizer是如何工作的呢？\n\n## Finalizer标记\n\n类其实除了语法层面的显示标记（如final，abstract，public等等）之外，在JVM中其实还会给类标记其他一些符号，比如finalizer类，如果一个类覆盖了Object类的finalize方法，并且方法体非空，则这个类就是finalizer类，JVM会给它做一个标记，以下简称“f类”，GC在处理这种类的对象的时候会做一些特殊的处理，如在这个对象被回收之前会先调用其finalize方法。\n\n## Finalizer源码解析\n\n在java.lang.ref包下，还有最后一个没有说到类，也就是FinalReference的子类——Finalizer，一听就是个专门给人善后的家伙。来看看它长什么样。<img src=\"/images/06.png\" width=\"40\"/>\n\n```java\nfinal class Finalizer extends FinalReference<Object> {\n    ...\n}\n```\n\nemm….Finalizer看起来比FinalReference更高冷，不仅仅是包访问权限，而且是final修饰的，表示其不能再被继承。\n\n这个类是专门留给JVM去使用的，所以可以才如此设计，防止被篡改。\n\n当加载一个类时，如果该类覆盖了finalize方法，并且方法体非空，那么这个类就会被JVM做上标记，每次实例化该类对象时，就会为其生成一个Finalizer对象，JVM会调用Finalizer.register()将这个对象注册到Finalizer的内部队列中。\n\n### 成员变量\n\n接下来看看Finalizer的成员变量：\n\n```java\nprivate Finalizer\n        next = null,\n        prev = null;\n```\n\nFinalizer是类似双链表的结构，next指向其后一个节点，prev指向其前一个节点。\n\n```java\nprivate static final Object lock = new Object();\n```\n\n这里也有一个lock对象用来做锁。\n\n```java\nprivate static Finalizer unfinalized = null;\n```\n\nunfinalized用来链接所有f类对象，以下称其为“f类对象链表”。这是一个静态变量，目的是防止f类对象在执行finalize方法之前被GC回收掉。\n\n```java\nprivate static ReferenceQueue<Object> queue = new ReferenceQueue<>();\n```\n\nqueue是静态队列（单链表结构），JVM在回收对象时，如果发现它是F类对象，则将其从f类对象链表中取出，将它放入引用队列queue中，并通知FinalizerThread去消费。也就是说，发生GC时并不会直接回收该对象占用的内存，而是将其移入队列中，等到之后的一次或者几次GC时才真正回收其占用的内存。\n\n### 构造函数\n\n```java\nprivate Finalizer(Object finalizee) {\n    super(finalizee, queue);\n    add();\n}\n```\n\n构造函数也是私有的，意味着无法在该类之外构建这类对象，在构造函数中调用add方法，将当前Finalizer插入到f类对象链表中。\n\n### 内部方法\n\n虽然我们无法创建Finalizer对象，但是在Finalizer中有一个register方法，在里面会创建一个Finalizer对象。\n\n```java\nstatic void register(Object finalizee) {\n    new Finalizer(finalizee);\n}\n```\n\n没错，它也是给JVM调用的，那么问题来了，虚拟机会在什么时候调用这个函数呢？\n\n也许你已经猜到了，在创建对象的时候，JVM会将当前对象传递给Finalizer.register方法，给它创建一个Finalizer并且添加到f类对象链表中。\n\n另外，如果我们是通过clone的方式来复制对象时，如果被复制的对象是一个f类对象，那么在clone完成的时候也会调用Finalizer.register方法进行注册。\n\n```java\nprivate void add() {\n    synchronized (lock) {\n        if (unfinalized != null) {\n            this.next = unfinalized;\n            unfinalized.prev = this;\n        }\n        unfinalized = this;\n    }\n}\n```\n\nadd方法中，使用lock对象锁进行加锁操作，然后将当前对象注册到f类对象链表的头部节点。\n\n```java\nprivate void remove() {\n    synchronized (lock) {\n        if (unfinalized == this) {\n            if (this.next != null) {\n                unfinalized = this.next;\n            } else {\n                unfinalized = this.prev;\n            }\n        }\n        if (this.next != null) {\n            this.next.prev = this.prev;\n        }\n        if (this.prev != null) {\n            this.prev.next = this.next;\n        }\n        this.next = this; \n        this.prev = this;\n    }\n}\n```\n\nremove方法中则同样以lock对象锁进行加锁后，将当前对象从f类对象链表中移除。并将next和prev均指向自身，这也用来判断f类对象是否已经被执行过finalize方法。\n\n```java\nprivate boolean hasBeenFinalized() {\n    return (next == this);\n}\n```\n\nhasBeenFinalized方法，正如其名，便是用来判断一个f类对象是否已经被执行过finalize方法，而判断时使用的条件便是next == this。\n\n### FinalizerThread线程\n\n在Finalizer类的最后，有一段静态代码块，用来初始化FinalizerThread线程。\n\n```java\nstatic {\n    ThreadGroup tg = Thread.currentThread().getThreadGroup();\n    for (ThreadGroup tgn = tg;\n         tgn != null;\n         tg = tgn, tgn = tg.getParent());\n    Thread finalizer = new FinalizerThread(tg);\n    finalizer.setPriority(Thread.MAX_PRIORITY - 2);\n    finalizer.setDaemon(true);\n    finalizer.start();\n}\n```\n\n这跟之前说过的ReferenceHandler线程十分相似，但是很重要的一点区别是，这里设置的线程优先级并不是最高优先级，而是：\n\n```java\nfinalizer.setPriority(Thread.MAX_PRIORITY - 2);\n```\n\n所以，这意味着在CPU比较紧张的情况下，这条线程被调度的优先级可能会受到影响。\n\n```java\nprivate static class FinalizerThread extends Thread {\n    // 用来判断该线程是否已经启动的标志\n    private volatile boolean running;\n    FinalizerThread(ThreadGroup g) {\n        super(g, \"Finalizer\");\n    }\n    public void run() {\n        // 如果发生了递归调用则直接返回\n        if (running)\n            return;\n\n        // Finalizer线程在 System.initializeSystemClass 被调用前启动\n        // 需要等到JVM已经初始化完成才能执行\n        while (!VM.isBooted()) {\n            try {\n                VM.awaitBooted();\n            } catch (InterruptedException x) {\n            }\n        }\n        final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n        running = true;\n        for (;;) {\n            try {\n                // 将节点从队列中移除\n                Finalizer f = (Finalizer)queue.remove();\n                // 调用其runFinalizer方法\n                f.runFinalizer(jla);\n            } catch (InterruptedException x) {\n                // 出错直接忽略\n            }\n        }\n    }\n}\n```\n\n这个线程的逻辑并不复杂，等待JVM初始化完成后，便开启死循环模式，从引用队列中阻塞式获取元素，并执行其runFinalizer方法。注意这里的try…catch语句，捕获到异常都是忽略处理，所以**如果在类的finalize方法中如果抛出异常，你是得不到任何错误信息的**。\n\n```java\nprivate void runFinalizer(JavaLangAccess jla) {\n    synchronized (this) {\n        // 先判断其是否已经被执行过finalize方法\n        if (hasBeenFinalized()) return;\n        remove();\n    }\n    try {\n        // 取出其引用的对象\n        Object finalizee = this.get();\n        // 如果不为null且不是Enum对象\n        if (finalizee != null && !(finalizee instanceof java.lang.Enum)) {\n            // 执行其finalize方法\n            jla.invokeFinalize(finalizee);\n\n            // 清空包含该变量的堆栈，以减少被保守型GC保留的可能性\n            finalizee = null;\n        }\n    } catch (Throwable x) { }\n    // 调用Reference的clear方法\n    super.clear();\n}\n```\n\n这里的同步代码块只有最前面的一小段，先判断是否已经执行过finalize方法，如果已经执行过，则直接返回。所以**一个对象finalize方法最多只会被执行一次**。所以如果在f类对象的finalize方法中，重新使用全局变量给它关联一个强引用，使其变成一个强可达对象，当这个对象再次变成不可达的对象的时候，就不会再执行它的finalize方法了。这一点在《深入理解JVM虚拟机》一书中有讲到。\n\n该方法在判断完之后，取出Finalizer的内部引用对象，执行其finalize方法，并将其置为null。\n\n### SecondaryFinalizer线程\n\nemmm….除了上面那条线程之外，还有两条辅助线程，在runFinalization方法和runAllFinalizers方法中调用。前一个方法将依次取出queue中的Finalizer并执行其runFinalizer方法，后一个方法则会依次对f类对象链表中的对象执行runFinalizer方法。\n\n```java\nstatic void runFinalization() {\n    if (!VM.isBooted()) {\n        return;\n    }\n\n    forkSecondaryFinalizer(new Runnable() {\n        private volatile boolean running;\n        public void run() {\n            // 如果是递归调用，则直接返回\n            if (running)\n                return;\n            final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n            running = true;\n            for (;;) {\n                Finalizer f = (Finalizer)queue.poll();\n                if (f == null) break;\n                f.runFinalizer(jla);\n            }\n        }\n    });\n}\n```\n\nrunFinalization方法对比一下上面的FinalizerThread的run方法便发现其实几乎一样。这是提供给其他类调用的，但Finalizer是包访问权限，所以其他类（如Runtime、Shutdown）并不是直接调用，而是通过JVM间接调用。\n\n例如，调用System.runFinalization方法时，便会调用Runtime.runFinalization方法，最终通过虚拟机，调用Finalizer.runFinalization方法。\n\n再来看看runAllFinalizers方法。\n\n```java\nstatic void runAllFinalizers() {\n    if (!VM.isBooted()) {\n        return;\n    }\n\n    forkSecondaryFinalizer(new Runnable() {\n        private volatile boolean running;\n        public void run() {\n            // 如果是递归调用，则直接返回\n            if (running)\n                return;\n            final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n            running = true;\n            for (;;) {\n                Finalizer f;\n                synchronized (lock) {\n                    f = unfinalized;\n                    if (f == null) break;\n                    unfinalized = f.next;\n                }\n                f.runFinalizer(jla);\n            }}});\n}\n```\n\n这里的处理与上面也很相似，只是将queue换成了unfinalized链表。\n\n在java.lang.ShutDown类中的sequence方法中，会调用runAllFinalizer方法：\n\n```java\nif (rfoe) runAllFinalizers();\n```\n\n而这个方法其实是一个本地方法，由JVM间接调用Finalizer的runAllFinalizer方法。\n\n```java\n/* Wormhole for invoking java.lang.ref.Finalizer.runAllFinalizers */\nprivate static native void runAllFinalizers();\n```\n\n这两个方法中都用到了同一个模板方法——forkSecondaryFinalizer：\n\n```java\nprivate static void forkSecondaryFinalizer(final Runnable proc) {\n    AccessController.doPrivileged(\n        new PrivilegedAction<Void>() {\n            public Void run() {\n                ThreadGroup tg = Thread.currentThread().getThreadGroup();\n                for (ThreadGroup tgn = tg;\n                     tgn != null;\n                     tg = tgn, tgn = tg.getParent());\n                Thread sft = new Thread(tg, proc, \"Secondary finalizer\");\n                sft.start();\n                try {\n                    sft.join();\n                } catch (InterruptedException x) {\n                    Thread.currentThread().interrupt();\n                }\n                return null;\n            }});\n}\n```\n\n这里调用了AccessController.doPrivileged方法，这个方法的作用是使其内部的代码段获得更大的权限，可以在里面访问更多的资源。这个涉及到另一个话题，如果想要了解的话可以参考这篇文章——[Java安全模型](https://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/)。\n\n这里你只需要关注run方法即可，run方法里只是启动一个线程的模板代码。\n\n### Finalizer与内存泄漏\n\n利用finalize来释放资源，听起来好像挺不错的，但是事实上却并没有想象中那么好，很容易会导致内存泄漏。\n\n通常而言，你不会知道垃圾回收器何时进行垃圾回收，也不知道何时回收某个特定的对象。但你可能会关心对象的finalize方法是否被执行。Java规范中对于Finalizer有以下规定;\n\n> 在回收一个有Finalizer关联的对象的内存之前，垃圾回收器会先调用其finalizer中的方法（即执行对象的finalize方法）。\n\n但是由于你并不知道对象何时被垃圾回收器收集，你只知道对象的finalize方法最终会被执行。所以必须清楚的一点是，你不会知道一个对象的finalize方法何时被执行。所以不要设计一个需要依赖程序finalize及时执行的程序。\n\n使用finalize一个经典的用法便是在构造器中打开文件，然后在finalize方法中关闭文件。这个设计看似很整洁完美，实际上隐藏一个隐秘的bug，Java中文件句柄数量是有限的，如果所有的句柄都用完了，那么程序将会无法打开任何文件。\n\n这样使用finalize方法，在某些经常执行finalization以确保有足够多可用句柄的JVM中可能工作良好，但是在另一些JVM中可能无法正常工作，因为那些垃圾回收器并不会经常执行finalization来确保有足够的句柄可用。\n\n此外FinalizeThread线程的优先级并不是最高的，所有当CPU资源紧张时，可能会有相当长一段时间不会执行Finalizer队列中的f对象的finalize方法，从而导致内存泄漏的发生。\n\n对于这些即将被回收掉的f对象，并不会在最近的一次GC中马上被回收释放掉，而是会延迟到下一个或几个GC时才会被真正回收。finalize方法无法在GC过程中执行，第一次GC只会讲其放入队列中去，由FinalizerThread去轮询执行。\n\n所以，不要在运行期间不断创建f对象，否则内存泄漏将常伴你左右。<img src=\"/images/0190.png\" width=\"40\"/>\n\n而且不同f对象的Finalizer的执行顺序并不是确定的，取决于它们被加入f对象链表的时间，而且从上面的源码分析中应该能知道，unfinalized链表更像是一个栈，不像链表那样先进先出，当既有对象进入，又有对象移出时，你无法知道这些Finalizer对象的具体执行顺序，所以不要设计依赖Finalizer执行顺序的程序。\n\n当然，如果你不得不使用finalize方法，并且需要确保其被执行，可以在代码中显式调用System.runFinalization方法。\n\n### Finalizer 应用场景\n\n好嘛，叽叽歪歪介绍了这么一大堆，结果都在说Finalizer怎么怎么不好，怎么怎么会出错。那要它何用？<img src=\"/images/0012.png\" width=\"50\"/>\n\n嗯，自有妙用。Finalizer一个比较适合的场景便是释放nativa方法中申请的内存，如果一个对象调用了本地方法，并且申请了内存（例如C中的malloc方法），那么可以在这个对象的finalize方法中调用native方法进行内存释放（如free方法），因为在这种情况下，本地方法申请的内存不会被垃圾回收器自动回收。\n\n另一个更常见的用法是为释放非内存资源（如：文件句柄、sockets）提供一个反馈机制。之前提到，你不应该依赖Finalizer来释放这些有限的资源。你应该提供一个释放这些资源的方法。但是你仍希望有一个Finalizer来检查这些资源是否已经被释放，如果没有则将其释放。相当于做一个防护措施，因为当你的代码被其他程序员调用时，也许他会粗心大意的忘记调用释放资源的方法。\n\n## 小结\n\n终于讲完了，现在来小结一下。\n\n+ FinalReference是为处理对象的finalize方法而设计的\n+ 如果一个类或者其父类覆盖了Object类的finalize方法，那么这个类就叫做f类，会被JVM特殊标记\n+ f类对象在创建时会顺便注册一个与其关联的Finalizer对象\n+ f类对象在其不可达时会在GC中被放入引用队列\n+ f类对象的finalize方法执行时间并不确定，f对象至少要经历两次GC才能被回收，有可能执行finalize期间已经经历了多次GC\n+ Finalizer对象的处理是在GC时进行的，如果没有触发GC就不会触发对Finalizer对象的处理，unfinalized队列中的对象也就不会被放入队列，其finalize方法也不会被执行\n+ 依赖f类对象的finalize执行顺序和执行时间的程序很可能会出现内存泄漏\n+ 因为f对象的finalize方法迟迟没有执行，有可能会导致大部分f对象进入到old分代，此时容易导致老年代的GC，甚至Full GC，会使GC暂停时间明显变长\n","source":"_posts/java/reference/final-reference-code-detail.md","raw":"---\ntitle: FinalReference 与 Finalizer 详解\ntags: \n - Java\n - 引用类型\ncategories: 编程\ndate: 2018-12-29 19:55:51\n---\n\n# FinalReference 与 Finalizer 详解\n\n## 说明\n\n？？？说好只有四种引用呢，怎么又跑出来一个FinalReference？还有一个奇奇怪怪的Finalizer？\n\n<img src=\"/images/0012.png\"/>\n\n别别别，把枪放下，事情不是你想的那样。<img src=\"/images/0190.png\" width=\"40\"/>\n\nFinalReference虽然也是继承自Reference类，但是并不能直接使用它，因为它是包可见的。\n\n```java\nclass FinalReference<T> extends Reference<T> {\n    public FinalReference(T referent, ReferenceQueue<? super T> q) {\n        super(referent, q);\n    }\n}\n```\n\n也很简单明了，就这一个构造函数。既然是包可见，自然是为了来继承的，不直接提供给外部使用。\n\nFinalReference由JVM来实例化，JVM会对那些实现了Object中finalize()方法的类对象实例化一个对应的FinalReference。 而事实上，JVM实际操作的是其子类——Finalizer，那么Finalizer是如何工作的呢？\n\n## Finalizer标记\n\n类其实除了语法层面的显示标记（如final，abstract，public等等）之外，在JVM中其实还会给类标记其他一些符号，比如finalizer类，如果一个类覆盖了Object类的finalize方法，并且方法体非空，则这个类就是finalizer类，JVM会给它做一个标记，以下简称“f类”，GC在处理这种类的对象的时候会做一些特殊的处理，如在这个对象被回收之前会先调用其finalize方法。\n\n## Finalizer源码解析\n\n在java.lang.ref包下，还有最后一个没有说到类，也就是FinalReference的子类——Finalizer，一听就是个专门给人善后的家伙。来看看它长什么样。<img src=\"/images/06.png\" width=\"40\"/>\n\n```java\nfinal class Finalizer extends FinalReference<Object> {\n    ...\n}\n```\n\nemm….Finalizer看起来比FinalReference更高冷，不仅仅是包访问权限，而且是final修饰的，表示其不能再被继承。\n\n这个类是专门留给JVM去使用的，所以可以才如此设计，防止被篡改。\n\n当加载一个类时，如果该类覆盖了finalize方法，并且方法体非空，那么这个类就会被JVM做上标记，每次实例化该类对象时，就会为其生成一个Finalizer对象，JVM会调用Finalizer.register()将这个对象注册到Finalizer的内部队列中。\n\n### 成员变量\n\n接下来看看Finalizer的成员变量：\n\n```java\nprivate Finalizer\n        next = null,\n        prev = null;\n```\n\nFinalizer是类似双链表的结构，next指向其后一个节点，prev指向其前一个节点。\n\n```java\nprivate static final Object lock = new Object();\n```\n\n这里也有一个lock对象用来做锁。\n\n```java\nprivate static Finalizer unfinalized = null;\n```\n\nunfinalized用来链接所有f类对象，以下称其为“f类对象链表”。这是一个静态变量，目的是防止f类对象在执行finalize方法之前被GC回收掉。\n\n```java\nprivate static ReferenceQueue<Object> queue = new ReferenceQueue<>();\n```\n\nqueue是静态队列（单链表结构），JVM在回收对象时，如果发现它是F类对象，则将其从f类对象链表中取出，将它放入引用队列queue中，并通知FinalizerThread去消费。也就是说，发生GC时并不会直接回收该对象占用的内存，而是将其移入队列中，等到之后的一次或者几次GC时才真正回收其占用的内存。\n\n### 构造函数\n\n```java\nprivate Finalizer(Object finalizee) {\n    super(finalizee, queue);\n    add();\n}\n```\n\n构造函数也是私有的，意味着无法在该类之外构建这类对象，在构造函数中调用add方法，将当前Finalizer插入到f类对象链表中。\n\n### 内部方法\n\n虽然我们无法创建Finalizer对象，但是在Finalizer中有一个register方法，在里面会创建一个Finalizer对象。\n\n```java\nstatic void register(Object finalizee) {\n    new Finalizer(finalizee);\n}\n```\n\n没错，它也是给JVM调用的，那么问题来了，虚拟机会在什么时候调用这个函数呢？\n\n也许你已经猜到了，在创建对象的时候，JVM会将当前对象传递给Finalizer.register方法，给它创建一个Finalizer并且添加到f类对象链表中。\n\n另外，如果我们是通过clone的方式来复制对象时，如果被复制的对象是一个f类对象，那么在clone完成的时候也会调用Finalizer.register方法进行注册。\n\n```java\nprivate void add() {\n    synchronized (lock) {\n        if (unfinalized != null) {\n            this.next = unfinalized;\n            unfinalized.prev = this;\n        }\n        unfinalized = this;\n    }\n}\n```\n\nadd方法中，使用lock对象锁进行加锁操作，然后将当前对象注册到f类对象链表的头部节点。\n\n```java\nprivate void remove() {\n    synchronized (lock) {\n        if (unfinalized == this) {\n            if (this.next != null) {\n                unfinalized = this.next;\n            } else {\n                unfinalized = this.prev;\n            }\n        }\n        if (this.next != null) {\n            this.next.prev = this.prev;\n        }\n        if (this.prev != null) {\n            this.prev.next = this.next;\n        }\n        this.next = this; \n        this.prev = this;\n    }\n}\n```\n\nremove方法中则同样以lock对象锁进行加锁后，将当前对象从f类对象链表中移除。并将next和prev均指向自身，这也用来判断f类对象是否已经被执行过finalize方法。\n\n```java\nprivate boolean hasBeenFinalized() {\n    return (next == this);\n}\n```\n\nhasBeenFinalized方法，正如其名，便是用来判断一个f类对象是否已经被执行过finalize方法，而判断时使用的条件便是next == this。\n\n### FinalizerThread线程\n\n在Finalizer类的最后，有一段静态代码块，用来初始化FinalizerThread线程。\n\n```java\nstatic {\n    ThreadGroup tg = Thread.currentThread().getThreadGroup();\n    for (ThreadGroup tgn = tg;\n         tgn != null;\n         tg = tgn, tgn = tg.getParent());\n    Thread finalizer = new FinalizerThread(tg);\n    finalizer.setPriority(Thread.MAX_PRIORITY - 2);\n    finalizer.setDaemon(true);\n    finalizer.start();\n}\n```\n\n这跟之前说过的ReferenceHandler线程十分相似，但是很重要的一点区别是，这里设置的线程优先级并不是最高优先级，而是：\n\n```java\nfinalizer.setPriority(Thread.MAX_PRIORITY - 2);\n```\n\n所以，这意味着在CPU比较紧张的情况下，这条线程被调度的优先级可能会受到影响。\n\n```java\nprivate static class FinalizerThread extends Thread {\n    // 用来判断该线程是否已经启动的标志\n    private volatile boolean running;\n    FinalizerThread(ThreadGroup g) {\n        super(g, \"Finalizer\");\n    }\n    public void run() {\n        // 如果发生了递归调用则直接返回\n        if (running)\n            return;\n\n        // Finalizer线程在 System.initializeSystemClass 被调用前启动\n        // 需要等到JVM已经初始化完成才能执行\n        while (!VM.isBooted()) {\n            try {\n                VM.awaitBooted();\n            } catch (InterruptedException x) {\n            }\n        }\n        final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n        running = true;\n        for (;;) {\n            try {\n                // 将节点从队列中移除\n                Finalizer f = (Finalizer)queue.remove();\n                // 调用其runFinalizer方法\n                f.runFinalizer(jla);\n            } catch (InterruptedException x) {\n                // 出错直接忽略\n            }\n        }\n    }\n}\n```\n\n这个线程的逻辑并不复杂，等待JVM初始化完成后，便开启死循环模式，从引用队列中阻塞式获取元素，并执行其runFinalizer方法。注意这里的try…catch语句，捕获到异常都是忽略处理，所以**如果在类的finalize方法中如果抛出异常，你是得不到任何错误信息的**。\n\n```java\nprivate void runFinalizer(JavaLangAccess jla) {\n    synchronized (this) {\n        // 先判断其是否已经被执行过finalize方法\n        if (hasBeenFinalized()) return;\n        remove();\n    }\n    try {\n        // 取出其引用的对象\n        Object finalizee = this.get();\n        // 如果不为null且不是Enum对象\n        if (finalizee != null && !(finalizee instanceof java.lang.Enum)) {\n            // 执行其finalize方法\n            jla.invokeFinalize(finalizee);\n\n            // 清空包含该变量的堆栈，以减少被保守型GC保留的可能性\n            finalizee = null;\n        }\n    } catch (Throwable x) { }\n    // 调用Reference的clear方法\n    super.clear();\n}\n```\n\n这里的同步代码块只有最前面的一小段，先判断是否已经执行过finalize方法，如果已经执行过，则直接返回。所以**一个对象finalize方法最多只会被执行一次**。所以如果在f类对象的finalize方法中，重新使用全局变量给它关联一个强引用，使其变成一个强可达对象，当这个对象再次变成不可达的对象的时候，就不会再执行它的finalize方法了。这一点在《深入理解JVM虚拟机》一书中有讲到。\n\n该方法在判断完之后，取出Finalizer的内部引用对象，执行其finalize方法，并将其置为null。\n\n### SecondaryFinalizer线程\n\nemmm….除了上面那条线程之外，还有两条辅助线程，在runFinalization方法和runAllFinalizers方法中调用。前一个方法将依次取出queue中的Finalizer并执行其runFinalizer方法，后一个方法则会依次对f类对象链表中的对象执行runFinalizer方法。\n\n```java\nstatic void runFinalization() {\n    if (!VM.isBooted()) {\n        return;\n    }\n\n    forkSecondaryFinalizer(new Runnable() {\n        private volatile boolean running;\n        public void run() {\n            // 如果是递归调用，则直接返回\n            if (running)\n                return;\n            final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n            running = true;\n            for (;;) {\n                Finalizer f = (Finalizer)queue.poll();\n                if (f == null) break;\n                f.runFinalizer(jla);\n            }\n        }\n    });\n}\n```\n\nrunFinalization方法对比一下上面的FinalizerThread的run方法便发现其实几乎一样。这是提供给其他类调用的，但Finalizer是包访问权限，所以其他类（如Runtime、Shutdown）并不是直接调用，而是通过JVM间接调用。\n\n例如，调用System.runFinalization方法时，便会调用Runtime.runFinalization方法，最终通过虚拟机，调用Finalizer.runFinalization方法。\n\n再来看看runAllFinalizers方法。\n\n```java\nstatic void runAllFinalizers() {\n    if (!VM.isBooted()) {\n        return;\n    }\n\n    forkSecondaryFinalizer(new Runnable() {\n        private volatile boolean running;\n        public void run() {\n            // 如果是递归调用，则直接返回\n            if (running)\n                return;\n            final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n            running = true;\n            for (;;) {\n                Finalizer f;\n                synchronized (lock) {\n                    f = unfinalized;\n                    if (f == null) break;\n                    unfinalized = f.next;\n                }\n                f.runFinalizer(jla);\n            }}});\n}\n```\n\n这里的处理与上面也很相似，只是将queue换成了unfinalized链表。\n\n在java.lang.ShutDown类中的sequence方法中，会调用runAllFinalizer方法：\n\n```java\nif (rfoe) runAllFinalizers();\n```\n\n而这个方法其实是一个本地方法，由JVM间接调用Finalizer的runAllFinalizer方法。\n\n```java\n/* Wormhole for invoking java.lang.ref.Finalizer.runAllFinalizers */\nprivate static native void runAllFinalizers();\n```\n\n这两个方法中都用到了同一个模板方法——forkSecondaryFinalizer：\n\n```java\nprivate static void forkSecondaryFinalizer(final Runnable proc) {\n    AccessController.doPrivileged(\n        new PrivilegedAction<Void>() {\n            public Void run() {\n                ThreadGroup tg = Thread.currentThread().getThreadGroup();\n                for (ThreadGroup tgn = tg;\n                     tgn != null;\n                     tg = tgn, tgn = tg.getParent());\n                Thread sft = new Thread(tg, proc, \"Secondary finalizer\");\n                sft.start();\n                try {\n                    sft.join();\n                } catch (InterruptedException x) {\n                    Thread.currentThread().interrupt();\n                }\n                return null;\n            }});\n}\n```\n\n这里调用了AccessController.doPrivileged方法，这个方法的作用是使其内部的代码段获得更大的权限，可以在里面访问更多的资源。这个涉及到另一个话题，如果想要了解的话可以参考这篇文章——[Java安全模型](https://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/)。\n\n这里你只需要关注run方法即可，run方法里只是启动一个线程的模板代码。\n\n### Finalizer与内存泄漏\n\n利用finalize来释放资源，听起来好像挺不错的，但是事实上却并没有想象中那么好，很容易会导致内存泄漏。\n\n通常而言，你不会知道垃圾回收器何时进行垃圾回收，也不知道何时回收某个特定的对象。但你可能会关心对象的finalize方法是否被执行。Java规范中对于Finalizer有以下规定;\n\n> 在回收一个有Finalizer关联的对象的内存之前，垃圾回收器会先调用其finalizer中的方法（即执行对象的finalize方法）。\n\n但是由于你并不知道对象何时被垃圾回收器收集，你只知道对象的finalize方法最终会被执行。所以必须清楚的一点是，你不会知道一个对象的finalize方法何时被执行。所以不要设计一个需要依赖程序finalize及时执行的程序。\n\n使用finalize一个经典的用法便是在构造器中打开文件，然后在finalize方法中关闭文件。这个设计看似很整洁完美，实际上隐藏一个隐秘的bug，Java中文件句柄数量是有限的，如果所有的句柄都用完了，那么程序将会无法打开任何文件。\n\n这样使用finalize方法，在某些经常执行finalization以确保有足够多可用句柄的JVM中可能工作良好，但是在另一些JVM中可能无法正常工作，因为那些垃圾回收器并不会经常执行finalization来确保有足够的句柄可用。\n\n此外FinalizeThread线程的优先级并不是最高的，所有当CPU资源紧张时，可能会有相当长一段时间不会执行Finalizer队列中的f对象的finalize方法，从而导致内存泄漏的发生。\n\n对于这些即将被回收掉的f对象，并不会在最近的一次GC中马上被回收释放掉，而是会延迟到下一个或几个GC时才会被真正回收。finalize方法无法在GC过程中执行，第一次GC只会讲其放入队列中去，由FinalizerThread去轮询执行。\n\n所以，不要在运行期间不断创建f对象，否则内存泄漏将常伴你左右。<img src=\"/images/0190.png\" width=\"40\"/>\n\n而且不同f对象的Finalizer的执行顺序并不是确定的，取决于它们被加入f对象链表的时间，而且从上面的源码分析中应该能知道，unfinalized链表更像是一个栈，不像链表那样先进先出，当既有对象进入，又有对象移出时，你无法知道这些Finalizer对象的具体执行顺序，所以不要设计依赖Finalizer执行顺序的程序。\n\n当然，如果你不得不使用finalize方法，并且需要确保其被执行，可以在代码中显式调用System.runFinalization方法。\n\n### Finalizer 应用场景\n\n好嘛，叽叽歪歪介绍了这么一大堆，结果都在说Finalizer怎么怎么不好，怎么怎么会出错。那要它何用？<img src=\"/images/0012.png\" width=\"50\"/>\n\n嗯，自有妙用。Finalizer一个比较适合的场景便是释放nativa方法中申请的内存，如果一个对象调用了本地方法，并且申请了内存（例如C中的malloc方法），那么可以在这个对象的finalize方法中调用native方法进行内存释放（如free方法），因为在这种情况下，本地方法申请的内存不会被垃圾回收器自动回收。\n\n另一个更常见的用法是为释放非内存资源（如：文件句柄、sockets）提供一个反馈机制。之前提到，你不应该依赖Finalizer来释放这些有限的资源。你应该提供一个释放这些资源的方法。但是你仍希望有一个Finalizer来检查这些资源是否已经被释放，如果没有则将其释放。相当于做一个防护措施，因为当你的代码被其他程序员调用时，也许他会粗心大意的忘记调用释放资源的方法。\n\n## 小结\n\n终于讲完了，现在来小结一下。\n\n+ FinalReference是为处理对象的finalize方法而设计的\n+ 如果一个类或者其父类覆盖了Object类的finalize方法，那么这个类就叫做f类，会被JVM特殊标记\n+ f类对象在创建时会顺便注册一个与其关联的Finalizer对象\n+ f类对象在其不可达时会在GC中被放入引用队列\n+ f类对象的finalize方法执行时间并不确定，f对象至少要经历两次GC才能被回收，有可能执行finalize期间已经经历了多次GC\n+ Finalizer对象的处理是在GC时进行的，如果没有触发GC就不会触发对Finalizer对象的处理，unfinalized队列中的对象也就不会被放入队列，其finalize方法也不会被执行\n+ 依赖f类对象的finalize执行顺序和执行时间的程序很可能会出现内存泄漏\n+ 因为f对象的finalize方法迟迟没有执行，有可能会导致大部分f对象进入到old分代，此时容易导致老年代的GC，甚至Full GC，会使GC暂停时间明显变长\n","slug":"java/reference/final-reference-code-detail","published":1,"updated":"2019-06-04T01:29:57.399Z","_id":"cjxze3gwk005g0cvwp414mbt1","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"FinalReference-与-Finalizer-详解\"><a href=\"#FinalReference-与-Finalizer-详解\" class=\"headerlink\" title=\"FinalReference 与 Finalizer 详解\"></a>FinalReference 与 Finalizer 详解</h1><h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>？？？说好只有四种引用呢，怎么又跑出来一个FinalReference？还有一个奇奇怪怪的Finalizer？</p>\n<p><img src=\"/images/0012.png\"></p>\n<p>别别别，把枪放下，事情不是你想的那样。<img src=\"/images/0190.png\" width=\"40\"></p>\n<p>FinalReference虽然也是继承自Reference类，但是并不能直接使用它，因为它是包可见的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FinalReference</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Reference</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FinalReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"keyword\">super</span> T&gt; q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(referent, q);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也很简单明了，就这一个构造函数。既然是包可见，自然是为了来继承的，不直接提供给外部使用。</p>\n<p>FinalReference由JVM来实例化，JVM会对那些实现了Object中finalize()方法的类对象实例化一个对应的FinalReference。 而事实上，JVM实际操作的是其子类——Finalizer，那么Finalizer是如何工作的呢？</p>\n<h2 id=\"Finalizer标记\"><a href=\"#Finalizer标记\" class=\"headerlink\" title=\"Finalizer标记\"></a>Finalizer标记</h2><p>类其实除了语法层面的显示标记（如final，abstract，public等等）之外，在JVM中其实还会给类标记其他一些符号，比如finalizer类，如果一个类覆盖了Object类的finalize方法，并且方法体非空，则这个类就是finalizer类，JVM会给它做一个标记，以下简称“f类”，GC在处理这种类的对象的时候会做一些特殊的处理，如在这个对象被回收之前会先调用其finalize方法。</p>\n<h2 id=\"Finalizer源码解析\"><a href=\"#Finalizer源码解析\" class=\"headerlink\" title=\"Finalizer源码解析\"></a>Finalizer源码解析</h2><p>在java.lang.ref包下，还有最后一个没有说到类，也就是FinalReference的子类——Finalizer，一听就是个专门给人善后的家伙。来看看它长什么样。<img src=\"/images/06.png\" width=\"40\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Finalizer</span> <span class=\"keyword\">extends</span> <span class=\"title\">FinalReference</span>&lt;<span class=\"title\">Object</span>&gt; </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>emm….Finalizer看起来比FinalReference更高冷，不仅仅是包访问权限，而且是final修饰的，表示其不能再被继承。</p>\n<p>这个类是专门留给JVM去使用的，所以可以才如此设计，防止被篡改。</p>\n<p>当加载一个类时，如果该类覆盖了finalize方法，并且方法体非空，那么这个类就会被JVM做上标记，每次实例化该类对象时，就会为其生成一个Finalizer对象，JVM会调用Finalizer.register()将这个对象注册到Finalizer的内部队列中。</p>\n<h3 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h3><p>接下来看看Finalizer的成员变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Finalizer</span><br><span class=\"line\">        next = <span class=\"keyword\">null</span>,</span><br><span class=\"line\">        prev = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>Finalizer是类似双链表的结构，next指向其后一个节点，prev指向其前一个节点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object lock = <span class=\"keyword\">new</span> Object();</span><br></pre></td></tr></table></figure>\n<p>这里也有一个lock对象用来做锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Finalizer unfinalized = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>unfinalized用来链接所有f类对象，以下称其为“f类对象链表”。这是一个静态变量，目的是防止f类对象在执行finalize方法之前被GC回收掉。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ReferenceQueue&lt;Object&gt; queue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<p>queue是静态队列（单链表结构），JVM在回收对象时，如果发现它是F类对象，则将其从f类对象链表中取出，将它放入引用队列queue中，并通知FinalizerThread去消费。也就是说，发生GC时并不会直接回收该对象占用的内存，而是将其移入队列中，等到之后的一次或者几次GC时才真正回收其占用的内存。</p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Finalizer</span><span class=\"params\">(Object finalizee)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(finalizee, queue);</span><br><span class=\"line\">    add();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>构造函数也是私有的，意味着无法在该类之外构建这类对象，在构造函数中调用add方法，将当前Finalizer插入到f类对象链表中。</p>\n<h3 id=\"内部方法\"><a href=\"#内部方法\" class=\"headerlink\" title=\"内部方法\"></a>内部方法</h3><p>虽然我们无法创建Finalizer对象，但是在Finalizer中有一个register方法，在里面会创建一个Finalizer对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(Object finalizee)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Finalizer(finalizee);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>没错，它也是给JVM调用的，那么问题来了，虚拟机会在什么时候调用这个函数呢？</p>\n<p>也许你已经猜到了，在创建对象的时候，JVM会将当前对象传递给Finalizer.register方法，给它创建一个Finalizer并且添加到f类对象链表中。</p>\n<p>另外，如果我们是通过clone的方式来复制对象时，如果被复制的对象是一个f类对象，那么在clone完成的时候也会调用Finalizer.register方法进行注册。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (unfinalized != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.next = unfinalized;</span><br><span class=\"line\">            unfinalized.prev = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        unfinalized = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>add方法中，使用lock对象锁进行加锁操作，然后将当前对象注册到f类对象链表的头部节点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (unfinalized == <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                unfinalized = <span class=\"keyword\">this</span>.next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                unfinalized = <span class=\"keyword\">this</span>.prev;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.next.prev = <span class=\"keyword\">this</span>.prev;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.prev != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.prev.next = <span class=\"keyword\">this</span>.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = <span class=\"keyword\">this</span>; </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.prev = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>remove方法中则同样以lock对象锁进行加锁后，将当前对象从f类对象链表中移除。并将next和prev均指向自身，这也用来判断f类对象是否已经被执行过finalize方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasBeenFinalized</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (next == <span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>hasBeenFinalized方法，正如其名，便是用来判断一个f类对象是否已经被执行过finalize方法，而判断时使用的条件便是next == this。</p>\n<h3 id=\"FinalizerThread线程\"><a href=\"#FinalizerThread线程\" class=\"headerlink\" title=\"FinalizerThread线程\"></a>FinalizerThread线程</h3><p>在Finalizer类的最后，有一段静态代码块，用来初始化FinalizerThread线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ThreadGroup tgn = tg;</span><br><span class=\"line\">         tgn != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         tg = tgn, tgn = tg.getParent());</span><br><span class=\"line\">    Thread finalizer = <span class=\"keyword\">new</span> FinalizerThread(tg);</span><br><span class=\"line\">    finalizer.setPriority(Thread.MAX_PRIORITY - <span class=\"number\">2</span>);</span><br><span class=\"line\">    finalizer.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    finalizer.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这跟之前说过的ReferenceHandler线程十分相似，但是很重要的一点区别是，这里设置的线程优先级并不是最高优先级，而是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">finalizer.setPriority(Thread.MAX_PRIORITY - <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<p>所以，这意味着在CPU比较紧张的情况下，这条线程被调度的优先级可能会受到影响。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FinalizerThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用来判断该线程是否已经启动的标志</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> running;</span><br><span class=\"line\">    FinalizerThread(ThreadGroup g) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(g, <span class=\"string\">\"Finalizer\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果发生了递归调用则直接返回</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (running)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Finalizer线程在 System.initializeSystemClass 被调用前启动</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要等到JVM已经初始化完成才能执行</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!VM.isBooted()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                VM.awaitBooted();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException x) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> JavaLangAccess jla = SharedSecrets.getJavaLangAccess();</span><br><span class=\"line\">        running = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 将节点从队列中移除</span></span><br><span class=\"line\">                Finalizer f = (Finalizer)queue.remove();</span><br><span class=\"line\">                <span class=\"comment\">// 调用其runFinalizer方法</span></span><br><span class=\"line\">                f.runFinalizer(jla);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException x) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 出错直接忽略</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个线程的逻辑并不复杂，等待JVM初始化完成后，便开启死循环模式，从引用队列中阻塞式获取元素，并执行其runFinalizer方法。注意这里的try…catch语句，捕获到异常都是忽略处理，所以<strong>如果在类的finalize方法中如果抛出异常，你是得不到任何错误信息的</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">runFinalizer</span><span class=\"params\">(JavaLangAccess jla)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先判断其是否已经被执行过finalize方法</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hasBeenFinalized()) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 取出其引用的对象</span></span><br><span class=\"line\">        Object finalizee = <span class=\"keyword\">this</span>.get();</span><br><span class=\"line\">        <span class=\"comment\">// 如果不为null且不是Enum对象</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (finalizee != <span class=\"keyword\">null</span> &amp;&amp; !(finalizee <span class=\"keyword\">instanceof</span> java.lang.Enum)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 执行其finalize方法</span></span><br><span class=\"line\">            jla.invokeFinalize(finalizee);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 清空包含该变量的堆栈，以减少被保守型GC保留的可能性</span></span><br><span class=\"line\">            finalizee = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable x) &#123; &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 调用Reference的clear方法</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.clear();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的同步代码块只有最前面的一小段，先判断是否已经执行过finalize方法，如果已经执行过，则直接返回。所以<strong>一个对象finalize方法最多只会被执行一次</strong>。所以如果在f类对象的finalize方法中，重新使用全局变量给它关联一个强引用，使其变成一个强可达对象，当这个对象再次变成不可达的对象的时候，就不会再执行它的finalize方法了。这一点在《深入理解JVM虚拟机》一书中有讲到。</p>\n<p>该方法在判断完之后，取出Finalizer的内部引用对象，执行其finalize方法，并将其置为null。</p>\n<h3 id=\"SecondaryFinalizer线程\"><a href=\"#SecondaryFinalizer线程\" class=\"headerlink\" title=\"SecondaryFinalizer线程\"></a>SecondaryFinalizer线程</h3><p>emmm….除了上面那条线程之外，还有两条辅助线程，在runFinalization方法和runAllFinalizers方法中调用。前一个方法将依次取出queue中的Finalizer并执行其runFinalizer方法，后一个方法则会依次对f类对象链表中的对象执行runFinalizer方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">runFinalization</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!VM.isBooted()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    forkSecondaryFinalizer(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> running;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果是递归调用，则直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (running)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> JavaLangAccess jla = SharedSecrets.getJavaLangAccess();</span><br><span class=\"line\">            running = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                Finalizer f = (Finalizer)queue.poll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                f.runFinalizer(jla);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>runFinalization方法对比一下上面的FinalizerThread的run方法便发现其实几乎一样。这是提供给其他类调用的，但Finalizer是包访问权限，所以其他类（如Runtime、Shutdown）并不是直接调用，而是通过JVM间接调用。</p>\n<p>例如，调用System.runFinalization方法时，便会调用Runtime.runFinalization方法，最终通过虚拟机，调用Finalizer.runFinalization方法。</p>\n<p>再来看看runAllFinalizers方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">runAllFinalizers</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!VM.isBooted()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    forkSecondaryFinalizer(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> running;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果是递归调用，则直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (running)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> JavaLangAccess jla = SharedSecrets.getJavaLangAccess();</span><br><span class=\"line\">            running = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                Finalizer f;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                    f = unfinalized;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    unfinalized = f.next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                f.runFinalizer(jla);</span><br><span class=\"line\">            &#125;&#125;&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的处理与上面也很相似，只是将queue换成了unfinalized链表。</p>\n<p>在java.lang.ShutDown类中的sequence方法中，会调用runAllFinalizer方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (rfoe) runAllFinalizers();</span><br></pre></td></tr></table></figure>\n<p>而这个方法其实是一个本地方法，由JVM间接调用Finalizer的runAllFinalizer方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Wormhole for invoking java.lang.ref.Finalizer.runAllFinalizers */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">runAllFinalizers</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<p>这两个方法中都用到了同一个模板方法——forkSecondaryFinalizer：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">forkSecondaryFinalizer</span><span class=\"params\">(<span class=\"keyword\">final</span> Runnable proc)</span> </span>&#123;</span><br><span class=\"line\">    AccessController.doPrivileged(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Void <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (ThreadGroup tgn = tg;</span><br><span class=\"line\">                     tgn != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                     tg = tgn, tgn = tg.getParent());</span><br><span class=\"line\">                Thread sft = <span class=\"keyword\">new</span> Thread(tg, proc, <span class=\"string\">\"Secondary finalizer\"</span>);</span><br><span class=\"line\">                sft.start();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    sft.join();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException x) &#123;</span><br><span class=\"line\">                    Thread.currentThread().interrupt();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里调用了AccessController.doPrivileged方法，这个方法的作用是使其内部的代码段获得更大的权限，可以在里面访问更多的资源。这个涉及到另一个话题，如果想要了解的话可以参考这篇文章——<a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/\" target=\"_blank\" rel=\"noopener\">Java安全模型</a>。</p>\n<p>这里你只需要关注run方法即可，run方法里只是启动一个线程的模板代码。</p>\n<h3 id=\"Finalizer与内存泄漏\"><a href=\"#Finalizer与内存泄漏\" class=\"headerlink\" title=\"Finalizer与内存泄漏\"></a>Finalizer与内存泄漏</h3><p>利用finalize来释放资源，听起来好像挺不错的，但是事实上却并没有想象中那么好，很容易会导致内存泄漏。</p>\n<p>通常而言，你不会知道垃圾回收器何时进行垃圾回收，也不知道何时回收某个特定的对象。但你可能会关心对象的finalize方法是否被执行。Java规范中对于Finalizer有以下规定;</p>\n<blockquote>\n<p>在回收一个有Finalizer关联的对象的内存之前，垃圾回收器会先调用其finalizer中的方法（即执行对象的finalize方法）。</p>\n</blockquote>\n<p>但是由于你并不知道对象何时被垃圾回收器收集，你只知道对象的finalize方法最终会被执行。所以必须清楚的一点是，你不会知道一个对象的finalize方法何时被执行。所以不要设计一个需要依赖程序finalize及时执行的程序。</p>\n<p>使用finalize一个经典的用法便是在构造器中打开文件，然后在finalize方法中关闭文件。这个设计看似很整洁完美，实际上隐藏一个隐秘的bug，Java中文件句柄数量是有限的，如果所有的句柄都用完了，那么程序将会无法打开任何文件。</p>\n<p>这样使用finalize方法，在某些经常执行finalization以确保有足够多可用句柄的JVM中可能工作良好，但是在另一些JVM中可能无法正常工作，因为那些垃圾回收器并不会经常执行finalization来确保有足够的句柄可用。</p>\n<p>此外FinalizeThread线程的优先级并不是最高的，所有当CPU资源紧张时，可能会有相当长一段时间不会执行Finalizer队列中的f对象的finalize方法，从而导致内存泄漏的发生。</p>\n<p>对于这些即将被回收掉的f对象，并不会在最近的一次GC中马上被回收释放掉，而是会延迟到下一个或几个GC时才会被真正回收。finalize方法无法在GC过程中执行，第一次GC只会讲其放入队列中去，由FinalizerThread去轮询执行。</p>\n<p>所以，不要在运行期间不断创建f对象，否则内存泄漏将常伴你左右。<img src=\"/images/0190.png\" width=\"40\"></p>\n<p>而且不同f对象的Finalizer的执行顺序并不是确定的，取决于它们被加入f对象链表的时间，而且从上面的源码分析中应该能知道，unfinalized链表更像是一个栈，不像链表那样先进先出，当既有对象进入，又有对象移出时，你无法知道这些Finalizer对象的具体执行顺序，所以不要设计依赖Finalizer执行顺序的程序。</p>\n<p>当然，如果你不得不使用finalize方法，并且需要确保其被执行，可以在代码中显式调用System.runFinalization方法。</p>\n<h3 id=\"Finalizer-应用场景\"><a href=\"#Finalizer-应用场景\" class=\"headerlink\" title=\"Finalizer 应用场景\"></a>Finalizer 应用场景</h3><p>好嘛，叽叽歪歪介绍了这么一大堆，结果都在说Finalizer怎么怎么不好，怎么怎么会出错。那要它何用？<img src=\"/images/0012.png\" width=\"50\"></p>\n<p>嗯，自有妙用。Finalizer一个比较适合的场景便是释放nativa方法中申请的内存，如果一个对象调用了本地方法，并且申请了内存（例如C中的malloc方法），那么可以在这个对象的finalize方法中调用native方法进行内存释放（如free方法），因为在这种情况下，本地方法申请的内存不会被垃圾回收器自动回收。</p>\n<p>另一个更常见的用法是为释放非内存资源（如：文件句柄、sockets）提供一个反馈机制。之前提到，你不应该依赖Finalizer来释放这些有限的资源。你应该提供一个释放这些资源的方法。但是你仍希望有一个Finalizer来检查这些资源是否已经被释放，如果没有则将其释放。相当于做一个防护措施，因为当你的代码被其他程序员调用时，也许他会粗心大意的忘记调用释放资源的方法。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>终于讲完了，现在来小结一下。</p>\n<ul>\n<li>FinalReference是为处理对象的finalize方法而设计的</li>\n<li>如果一个类或者其父类覆盖了Object类的finalize方法，那么这个类就叫做f类，会被JVM特殊标记</li>\n<li>f类对象在创建时会顺便注册一个与其关联的Finalizer对象</li>\n<li>f类对象在其不可达时会在GC中被放入引用队列</li>\n<li>f类对象的finalize方法执行时间并不确定，f对象至少要经历两次GC才能被回收，有可能执行finalize期间已经经历了多次GC</li>\n<li>Finalizer对象的处理是在GC时进行的，如果没有触发GC就不会触发对Finalizer对象的处理，unfinalized队列中的对象也就不会被放入队列，其finalize方法也不会被执行</li>\n<li>依赖f类对象的finalize执行顺序和执行时间的程序很可能会出现内存泄漏</li>\n<li>因为f对象的finalize方法迟迟没有执行，有可能会导致大部分f对象进入到old分代，此时容易导致老年代的GC，甚至Full GC，会使GC暂停时间明显变长</li>\n</ul>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h1 id=\"FinalReference-与-Finalizer-详解\"><a href=\"#FinalReference-与-Finalizer-详解\" class=\"headerlink\" title=\"FinalReference 与 Finalizer 详解\"></a>FinalReference 与 Finalizer 详解</h1><h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>？？？说好只有四种引用呢，怎么又跑出来一个FinalReference？还有一个奇奇怪怪的Finalizer？</p>\n<p><img src=\"/images/0012.png\"></p>\n<p>别别别，把枪放下，事情不是你想的那样。<img src=\"/images/0190.png\" width=\"40\"></p>\n<p>FinalReference虽然也是继承自Reference类，但是并不能直接使用它，因为它是包可见的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FinalReference</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Reference</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FinalReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"keyword\">super</span> T&gt; q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(referent, q);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也很简单明了，就这一个构造函数。既然是包可见，自然是为了来继承的，不直接提供给外部使用。</p>\n<p>FinalReference由JVM来实例化，JVM会对那些实现了Object中finalize()方法的类对象实例化一个对应的FinalReference。 而事实上，JVM实际操作的是其子类——Finalizer，那么Finalizer是如何工作的呢？</p>\n<h2 id=\"Finalizer标记\"><a href=\"#Finalizer标记\" class=\"headerlink\" title=\"Finalizer标记\"></a>Finalizer标记</h2><p>类其实除了语法层面的显示标记（如final，abstract，public等等）之外，在JVM中其实还会给类标记其他一些符号，比如finalizer类，如果一个类覆盖了Object类的finalize方法，并且方法体非空，则这个类就是finalizer类，JVM会给它做一个标记，以下简称“f类”，GC在处理这种类的对象的时候会做一些特殊的处理，如在这个对象被回收之前会先调用其finalize方法。</p>\n<h2 id=\"Finalizer源码解析\"><a href=\"#Finalizer源码解析\" class=\"headerlink\" title=\"Finalizer源码解析\"></a>Finalizer源码解析</h2><p>在java.lang.ref包下，还有最后一个没有说到类，也就是FinalReference的子类——Finalizer，一听就是个专门给人善后的家伙。来看看它长什么样。<img src=\"/images/06.png\" width=\"40\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Finalizer</span> <span class=\"keyword\">extends</span> <span class=\"title\">FinalReference</span>&lt;<span class=\"title\">Object</span>&gt; </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>emm….Finalizer看起来比FinalReference更高冷，不仅仅是包访问权限，而且是final修饰的，表示其不能再被继承。</p>\n<p>这个类是专门留给JVM去使用的，所以可以才如此设计，防止被篡改。</p>\n<p>当加载一个类时，如果该类覆盖了finalize方法，并且方法体非空，那么这个类就会被JVM做上标记，每次实例化该类对象时，就会为其生成一个Finalizer对象，JVM会调用Finalizer.register()将这个对象注册到Finalizer的内部队列中。</p>\n<h3 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h3><p>接下来看看Finalizer的成员变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Finalizer</span><br><span class=\"line\">        next = <span class=\"keyword\">null</span>,</span><br><span class=\"line\">        prev = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>Finalizer是类似双链表的结构，next指向其后一个节点，prev指向其前一个节点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object lock = <span class=\"keyword\">new</span> Object();</span><br></pre></td></tr></table></figure>\n<p>这里也有一个lock对象用来做锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Finalizer unfinalized = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>unfinalized用来链接所有f类对象，以下称其为“f类对象链表”。这是一个静态变量，目的是防止f类对象在执行finalize方法之前被GC回收掉。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ReferenceQueue&lt;Object&gt; queue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<p>queue是静态队列（单链表结构），JVM在回收对象时，如果发现它是F类对象，则将其从f类对象链表中取出，将它放入引用队列queue中，并通知FinalizerThread去消费。也就是说，发生GC时并不会直接回收该对象占用的内存，而是将其移入队列中，等到之后的一次或者几次GC时才真正回收其占用的内存。</p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Finalizer</span><span class=\"params\">(Object finalizee)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(finalizee, queue);</span><br><span class=\"line\">    add();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>构造函数也是私有的，意味着无法在该类之外构建这类对象，在构造函数中调用add方法，将当前Finalizer插入到f类对象链表中。</p>\n<h3 id=\"内部方法\"><a href=\"#内部方法\" class=\"headerlink\" title=\"内部方法\"></a>内部方法</h3><p>虽然我们无法创建Finalizer对象，但是在Finalizer中有一个register方法，在里面会创建一个Finalizer对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(Object finalizee)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Finalizer(finalizee);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>没错，它也是给JVM调用的，那么问题来了，虚拟机会在什么时候调用这个函数呢？</p>\n<p>也许你已经猜到了，在创建对象的时候，JVM会将当前对象传递给Finalizer.register方法，给它创建一个Finalizer并且添加到f类对象链表中。</p>\n<p>另外，如果我们是通过clone的方式来复制对象时，如果被复制的对象是一个f类对象，那么在clone完成的时候也会调用Finalizer.register方法进行注册。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (unfinalized != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.next = unfinalized;</span><br><span class=\"line\">            unfinalized.prev = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        unfinalized = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>add方法中，使用lock对象锁进行加锁操作，然后将当前对象注册到f类对象链表的头部节点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (unfinalized == <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                unfinalized = <span class=\"keyword\">this</span>.next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                unfinalized = <span class=\"keyword\">this</span>.prev;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.next.prev = <span class=\"keyword\">this</span>.prev;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.prev != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.prev.next = <span class=\"keyword\">this</span>.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = <span class=\"keyword\">this</span>; </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.prev = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>remove方法中则同样以lock对象锁进行加锁后，将当前对象从f类对象链表中移除。并将next和prev均指向自身，这也用来判断f类对象是否已经被执行过finalize方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasBeenFinalized</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (next == <span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>hasBeenFinalized方法，正如其名，便是用来判断一个f类对象是否已经被执行过finalize方法，而判断时使用的条件便是next == this。</p>\n<h3 id=\"FinalizerThread线程\"><a href=\"#FinalizerThread线程\" class=\"headerlink\" title=\"FinalizerThread线程\"></a>FinalizerThread线程</h3><p>在Finalizer类的最后，有一段静态代码块，用来初始化FinalizerThread线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ThreadGroup tgn = tg;</span><br><span class=\"line\">         tgn != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         tg = tgn, tgn = tg.getParent());</span><br><span class=\"line\">    Thread finalizer = <span class=\"keyword\">new</span> FinalizerThread(tg);</span><br><span class=\"line\">    finalizer.setPriority(Thread.MAX_PRIORITY - <span class=\"number\">2</span>);</span><br><span class=\"line\">    finalizer.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    finalizer.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这跟之前说过的ReferenceHandler线程十分相似，但是很重要的一点区别是，这里设置的线程优先级并不是最高优先级，而是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">finalizer.setPriority(Thread.MAX_PRIORITY - <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<p>所以，这意味着在CPU比较紧张的情况下，这条线程被调度的优先级可能会受到影响。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FinalizerThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用来判断该线程是否已经启动的标志</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> running;</span><br><span class=\"line\">    FinalizerThread(ThreadGroup g) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(g, <span class=\"string\">\"Finalizer\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果发生了递归调用则直接返回</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (running)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Finalizer线程在 System.initializeSystemClass 被调用前启动</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要等到JVM已经初始化完成才能执行</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!VM.isBooted()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                VM.awaitBooted();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException x) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> JavaLangAccess jla = SharedSecrets.getJavaLangAccess();</span><br><span class=\"line\">        running = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 将节点从队列中移除</span></span><br><span class=\"line\">                Finalizer f = (Finalizer)queue.remove();</span><br><span class=\"line\">                <span class=\"comment\">// 调用其runFinalizer方法</span></span><br><span class=\"line\">                f.runFinalizer(jla);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException x) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 出错直接忽略</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个线程的逻辑并不复杂，等待JVM初始化完成后，便开启死循环模式，从引用队列中阻塞式获取元素，并执行其runFinalizer方法。注意这里的try…catch语句，捕获到异常都是忽略处理，所以<strong>如果在类的finalize方法中如果抛出异常，你是得不到任何错误信息的</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">runFinalizer</span><span class=\"params\">(JavaLangAccess jla)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先判断其是否已经被执行过finalize方法</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hasBeenFinalized()) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 取出其引用的对象</span></span><br><span class=\"line\">        Object finalizee = <span class=\"keyword\">this</span>.get();</span><br><span class=\"line\">        <span class=\"comment\">// 如果不为null且不是Enum对象</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (finalizee != <span class=\"keyword\">null</span> &amp;&amp; !(finalizee <span class=\"keyword\">instanceof</span> java.lang.Enum)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 执行其finalize方法</span></span><br><span class=\"line\">            jla.invokeFinalize(finalizee);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 清空包含该变量的堆栈，以减少被保守型GC保留的可能性</span></span><br><span class=\"line\">            finalizee = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable x) &#123; &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 调用Reference的clear方法</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.clear();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的同步代码块只有最前面的一小段，先判断是否已经执行过finalize方法，如果已经执行过，则直接返回。所以<strong>一个对象finalize方法最多只会被执行一次</strong>。所以如果在f类对象的finalize方法中，重新使用全局变量给它关联一个强引用，使其变成一个强可达对象，当这个对象再次变成不可达的对象的时候，就不会再执行它的finalize方法了。这一点在《深入理解JVM虚拟机》一书中有讲到。</p>\n<p>该方法在判断完之后，取出Finalizer的内部引用对象，执行其finalize方法，并将其置为null。</p>\n<h3 id=\"SecondaryFinalizer线程\"><a href=\"#SecondaryFinalizer线程\" class=\"headerlink\" title=\"SecondaryFinalizer线程\"></a>SecondaryFinalizer线程</h3><p>emmm….除了上面那条线程之外，还有两条辅助线程，在runFinalization方法和runAllFinalizers方法中调用。前一个方法将依次取出queue中的Finalizer并执行其runFinalizer方法，后一个方法则会依次对f类对象链表中的对象执行runFinalizer方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">runFinalization</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!VM.isBooted()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    forkSecondaryFinalizer(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> running;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果是递归调用，则直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (running)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> JavaLangAccess jla = SharedSecrets.getJavaLangAccess();</span><br><span class=\"line\">            running = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                Finalizer f = (Finalizer)queue.poll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                f.runFinalizer(jla);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>runFinalization方法对比一下上面的FinalizerThread的run方法便发现其实几乎一样。这是提供给其他类调用的，但Finalizer是包访问权限，所以其他类（如Runtime、Shutdown）并不是直接调用，而是通过JVM间接调用。</p>\n<p>例如，调用System.runFinalization方法时，便会调用Runtime.runFinalization方法，最终通过虚拟机，调用Finalizer.runFinalization方法。</p>\n<p>再来看看runAllFinalizers方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">runAllFinalizers</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!VM.isBooted()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    forkSecondaryFinalizer(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> running;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果是递归调用，则直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (running)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> JavaLangAccess jla = SharedSecrets.getJavaLangAccess();</span><br><span class=\"line\">            running = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                Finalizer f;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                    f = unfinalized;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    unfinalized = f.next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                f.runFinalizer(jla);</span><br><span class=\"line\">            &#125;&#125;&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的处理与上面也很相似，只是将queue换成了unfinalized链表。</p>\n<p>在java.lang.ShutDown类中的sequence方法中，会调用runAllFinalizer方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (rfoe) runAllFinalizers();</span><br></pre></td></tr></table></figure>\n<p>而这个方法其实是一个本地方法，由JVM间接调用Finalizer的runAllFinalizer方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Wormhole for invoking java.lang.ref.Finalizer.runAllFinalizers */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">runAllFinalizers</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<p>这两个方法中都用到了同一个模板方法——forkSecondaryFinalizer：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">forkSecondaryFinalizer</span><span class=\"params\">(<span class=\"keyword\">final</span> Runnable proc)</span> </span>&#123;</span><br><span class=\"line\">    AccessController.doPrivileged(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Void <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (ThreadGroup tgn = tg;</span><br><span class=\"line\">                     tgn != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                     tg = tgn, tgn = tg.getParent());</span><br><span class=\"line\">                Thread sft = <span class=\"keyword\">new</span> Thread(tg, proc, <span class=\"string\">\"Secondary finalizer\"</span>);</span><br><span class=\"line\">                sft.start();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    sft.join();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException x) &#123;</span><br><span class=\"line\">                    Thread.currentThread().interrupt();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里调用了AccessController.doPrivileged方法，这个方法的作用是使其内部的代码段获得更大的权限，可以在里面访问更多的资源。这个涉及到另一个话题，如果想要了解的话可以参考这篇文章——<a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/\" target=\"_blank\" rel=\"noopener\">Java安全模型</a>。</p>\n<p>这里你只需要关注run方法即可，run方法里只是启动一个线程的模板代码。</p>\n<h3 id=\"Finalizer与内存泄漏\"><a href=\"#Finalizer与内存泄漏\" class=\"headerlink\" title=\"Finalizer与内存泄漏\"></a>Finalizer与内存泄漏</h3><p>利用finalize来释放资源，听起来好像挺不错的，但是事实上却并没有想象中那么好，很容易会导致内存泄漏。</p>\n<p>通常而言，你不会知道垃圾回收器何时进行垃圾回收，也不知道何时回收某个特定的对象。但你可能会关心对象的finalize方法是否被执行。Java规范中对于Finalizer有以下规定;</p>\n<blockquote>\n<p>在回收一个有Finalizer关联的对象的内存之前，垃圾回收器会先调用其finalizer中的方法（即执行对象的finalize方法）。</p>\n</blockquote>\n<p>但是由于你并不知道对象何时被垃圾回收器收集，你只知道对象的finalize方法最终会被执行。所以必须清楚的一点是，你不会知道一个对象的finalize方法何时被执行。所以不要设计一个需要依赖程序finalize及时执行的程序。</p>\n<p>使用finalize一个经典的用法便是在构造器中打开文件，然后在finalize方法中关闭文件。这个设计看似很整洁完美，实际上隐藏一个隐秘的bug，Java中文件句柄数量是有限的，如果所有的句柄都用完了，那么程序将会无法打开任何文件。</p>\n<p>这样使用finalize方法，在某些经常执行finalization以确保有足够多可用句柄的JVM中可能工作良好，但是在另一些JVM中可能无法正常工作，因为那些垃圾回收器并不会经常执行finalization来确保有足够的句柄可用。</p>\n<p>此外FinalizeThread线程的优先级并不是最高的，所有当CPU资源紧张时，可能会有相当长一段时间不会执行Finalizer队列中的f对象的finalize方法，从而导致内存泄漏的发生。</p>\n<p>对于这些即将被回收掉的f对象，并不会在最近的一次GC中马上被回收释放掉，而是会延迟到下一个或几个GC时才会被真正回收。finalize方法无法在GC过程中执行，第一次GC只会讲其放入队列中去，由FinalizerThread去轮询执行。</p>\n<p>所以，不要在运行期间不断创建f对象，否则内存泄漏将常伴你左右。<img src=\"/images/0190.png\" width=\"40\"></p>\n<p>而且不同f对象的Finalizer的执行顺序并不是确定的，取决于它们被加入f对象链表的时间，而且从上面的源码分析中应该能知道，unfinalized链表更像是一个栈，不像链表那样先进先出，当既有对象进入，又有对象移出时，你无法知道这些Finalizer对象的具体执行顺序，所以不要设计依赖Finalizer执行顺序的程序。</p>\n<p>当然，如果你不得不使用finalize方法，并且需要确保其被执行，可以在代码中显式调用System.runFinalization方法。</p>\n<h3 id=\"Finalizer-应用场景\"><a href=\"#Finalizer-应用场景\" class=\"headerlink\" title=\"Finalizer 应用场景\"></a>Finalizer 应用场景</h3><p>好嘛，叽叽歪歪介绍了这么一大堆，结果都在说Finalizer怎么怎么不好，怎么怎么会出错。那要它何用？<img src=\"/images/0012.png\" width=\"50\"></p>\n<p>嗯，自有妙用。Finalizer一个比较适合的场景便是释放nativa方法中申请的内存，如果一个对象调用了本地方法，并且申请了内存（例如C中的malloc方法），那么可以在这个对象的finalize方法中调用native方法进行内存释放（如free方法），因为在这种情况下，本地方法申请的内存不会被垃圾回收器自动回收。</p>\n<p>另一个更常见的用法是为释放非内存资源（如：文件句柄、sockets）提供一个反馈机制。之前提到，你不应该依赖Finalizer来释放这些有限的资源。你应该提供一个释放这些资源的方法。但是你仍希望有一个Finalizer来检查这些资源是否已经被释放，如果没有则将其释放。相当于做一个防护措施，因为当你的代码被其他程序员调用时，也许他会粗心大意的忘记调用释放资源的方法。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>终于讲完了，现在来小结一下。</p>\n<ul>\n<li>FinalReference是为处理对象的finalize方法而设计的</li>\n<li>如果一个类或者其父类覆盖了Object类的finalize方法，那么这个类就叫做f类，会被JVM特殊标记</li>\n<li>f类对象在创建时会顺便注册一个与其关联的Finalizer对象</li>\n<li>f类对象在其不可达时会在GC中被放入引用队列</li>\n<li>f类对象的finalize方法执行时间并不确定，f对象至少要经历两次GC才能被回收，有可能执行finalize期间已经经历了多次GC</li>\n<li>Finalizer对象的处理是在GC时进行的，如果没有触发GC就不会触发对Finalizer对象的处理，unfinalized队列中的对象也就不会被放入队列，其finalize方法也不会被执行</li>\n<li>依赖f类对象的finalize执行顺序和执行时间的程序很可能会出现内存泄漏</li>\n<li>因为f对象的finalize方法迟迟没有执行，有可能会导致大部分f对象进入到old分代，此时容易导致老年代的GC，甚至Full GC，会使GC暂停时间明显变长</li>\n</ul>\n"},{"title":"虚引用","date":"2018-12-29T11:57:51.000Z","_content":"\n## 定义\n\n虚引用是使用PhantomReference创建的引用，虚引用也称为幽灵引用或者幻影引用，是所有引用类型中最弱的一个。一个对象是否有虚引用的存在，完全不会对其生命周期构成影响，也无法通过虚引用获得一个对象实例。\n\n## 说明\n\n虚引用，正如其名，对一个对象而言，这个引用形同虚设，有和没有一样。\n\n> 虚可达\n> 如果一个对象与GC Roots之间仅存在虚引用，则称这个对象为`虚可达（phantom reachable）`对象。\n\n当试图通过虚引用的get()方法取得强引用时，总是会返回null，并且，虚引用必须和引用队列一起使用。既然这么虚，那么它出现的意义何在？？\n\n别慌别慌，自然有它的用处。它的作用在于跟踪垃圾回收过程，在对象被收集器回收时收到一个系统通知。 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，将这个虚引用加入引用队列，在其关联的虚引用出队前，不会彻底销毁该对象。 所以可以通过检查引用队列中是否有相应的虚引用来判断对象是否已经被回收了。\n\n如果一个对象没有强引用和软引用，对于垃圾回收器而言便是可以被清除的，在清除之前，会调用其finalize方法，如果一个对象已经被调用过finalize方法但是还没有被释放，它就变成了一个虚可达对象。\n\n与软引用和弱引用不同，显式使用虚引用可以阻止对象被清除，只有在程序中显式或者隐式移除这个虚引用时，这个已经执行过finalize方法的对象才会被清除。想要显式的移除虚引用的话，只需要将其从引用队列中取出然后扔掉（置为null）即可。\n\n同样来看一个栗子：\n\n```java\npublic class PhantomReferenceTest {\n    private static final List<Object> TEST_DATA = new LinkedList<>();\n    private static final ReferenceQueue<TestClass> QUEUE = new ReferenceQueue<>();\n\n    public static void main(String[] args) {\n        TestClass obj = new TestClass(\"Test\");\n        PhantomReference<TestClass> phantomReference = new PhantomReference<>(obj, QUEUE);\n\n        // 该线程不断读取这个虚引用，并不断往列表里插入数据，以促使系统早点进行GC\n        new Thread(() -> {\n            while (true) {\n                TEST_DATA.add(new byte[1024 * 100]);\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    Thread.currentThread().interrupt();\n                }\n                System.out.println(phantomReference.get());\n            }\n        }).start();\n\n        // 这个线程不断读取引用队列，当弱引用指向的对象呗回收时，该引用就会被加入到引用队列中\n        new Thread(() -> {\n            while (true) {\n                Reference<? extends TestClass> poll = QUEUE.poll();\n                if (poll != null) {\n                    System.out.println(\"--- 虚引用对象被jvm回收了 ---- \" + poll);\n                    System.out.println(\"--- 回收对象 ---- \" + poll.get());\n                }\n            }\n        }).start();\n\n        obj = null;\n\n        try {\n            Thread.currentThread().join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    static class TestClass {\n        private String name;\n\n        public TestClass(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public String toString() {\n            return \"TestClass - \" + name;\n        }\n    }\n}\n```\n\n使用的虚拟机设置如下：\n\n```bash\n-verbose:gc -Xms4m -Xmx4m -Xmn2m\n```\n\n运行结果如下：\n\n```bash\n[GC (Allocation Failure)  1024K->432K(3584K), 0.0113386 secs]\n[GC (Allocation Failure)  1455K->520K(3584K), 0.0133610 secs]\n[GC (Allocation Failure)  1544K->648K(3584K), 0.0008654 secs]\nnull\nnull\nnull\n[GC (Allocation Failure)  1655K->973K(3584K), 0.0008111 secs]\nnull\n...省略几个null的输出\n[GC (Allocation Failure)  1980K->1997K(3584K), 0.0009289 secs]\n[Full GC (Ergonomics)  1997K->1870K(3584K), 0.0048483 secs]\n--- 弱引用对象被jvm回收了 ---- java.lang.ref.PhantomReference@74cbe23d\n--- 回收对象 ---- null\nnull\n...省略几个null和几次Full GC的输出\n[Full GC (Ergonomics)  2971K->2971K(3584K), 0.0024850 secs]\n[Full GC (Allocation Failure)  2971K->2971K(3584K), 0.0022460 secs]\nException in thread \"Thread-0\" java.lang.OutOfMemoryError: Java heap space\n\tat weakhashmap.PhantomReferenceTest.lambda$main$0(PhantomReferenceTest.java:20)\n\tat weakhashmap.PhantomReferenceTest$$Lambda$1/2065951873.run(Unknown Source)\n\tat java.lang.Thread.run(Thread.java:748)\n```\n\n因为设置的虚拟机堆大小比较小，所以创建一个100k的对象时直接进入了老年代，等到发生Full GC时才会被扫描然后回收。\n\n## 适用场景\n\n使用虚引用的目的就是为了得知对象被GC的时机，所以可以利用虚引用来进行销毁前的一些操作，比如说资源释放等。这个虚引用对于对象而言完全是无感知的，有没有完全一样，但是对于虚引用的使用者而言，就像是待观察的对象的把脉线，可以通过它来观察对象是否已经被回收，从而进行相应的处理。\n\n事实上，虚引用有一个很重要的用途就是用来做堆外内存的释放，DirectByteBuffer就是通过虚引用来实现堆外内存的释放的。 \n\n## 小结\n\n+ 虚引用是最弱的引用\n+ 虚引用对对象而言是无感知的，对象有虚引用跟没有是完全一样的\n+ 虚引用不会影响对象的生命周期\n+ 虚引用可以用来做为对象是否存活的监控","source":"_posts/java/reference/phantom-reference.md","raw":"---\ntitle: 虚引用\ntags: \n - Java\n - 引用类型\ncategories: 编程\ndate: 2018-12-29 19:57:51\n---\n\n## 定义\n\n虚引用是使用PhantomReference创建的引用，虚引用也称为幽灵引用或者幻影引用，是所有引用类型中最弱的一个。一个对象是否有虚引用的存在，完全不会对其生命周期构成影响，也无法通过虚引用获得一个对象实例。\n\n## 说明\n\n虚引用，正如其名，对一个对象而言，这个引用形同虚设，有和没有一样。\n\n> 虚可达\n> 如果一个对象与GC Roots之间仅存在虚引用，则称这个对象为`虚可达（phantom reachable）`对象。\n\n当试图通过虚引用的get()方法取得强引用时，总是会返回null，并且，虚引用必须和引用队列一起使用。既然这么虚，那么它出现的意义何在？？\n\n别慌别慌，自然有它的用处。它的作用在于跟踪垃圾回收过程，在对象被收集器回收时收到一个系统通知。 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，将这个虚引用加入引用队列，在其关联的虚引用出队前，不会彻底销毁该对象。 所以可以通过检查引用队列中是否有相应的虚引用来判断对象是否已经被回收了。\n\n如果一个对象没有强引用和软引用，对于垃圾回收器而言便是可以被清除的，在清除之前，会调用其finalize方法，如果一个对象已经被调用过finalize方法但是还没有被释放，它就变成了一个虚可达对象。\n\n与软引用和弱引用不同，显式使用虚引用可以阻止对象被清除，只有在程序中显式或者隐式移除这个虚引用时，这个已经执行过finalize方法的对象才会被清除。想要显式的移除虚引用的话，只需要将其从引用队列中取出然后扔掉（置为null）即可。\n\n同样来看一个栗子：\n\n```java\npublic class PhantomReferenceTest {\n    private static final List<Object> TEST_DATA = new LinkedList<>();\n    private static final ReferenceQueue<TestClass> QUEUE = new ReferenceQueue<>();\n\n    public static void main(String[] args) {\n        TestClass obj = new TestClass(\"Test\");\n        PhantomReference<TestClass> phantomReference = new PhantomReference<>(obj, QUEUE);\n\n        // 该线程不断读取这个虚引用，并不断往列表里插入数据，以促使系统早点进行GC\n        new Thread(() -> {\n            while (true) {\n                TEST_DATA.add(new byte[1024 * 100]);\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    Thread.currentThread().interrupt();\n                }\n                System.out.println(phantomReference.get());\n            }\n        }).start();\n\n        // 这个线程不断读取引用队列，当弱引用指向的对象呗回收时，该引用就会被加入到引用队列中\n        new Thread(() -> {\n            while (true) {\n                Reference<? extends TestClass> poll = QUEUE.poll();\n                if (poll != null) {\n                    System.out.println(\"--- 虚引用对象被jvm回收了 ---- \" + poll);\n                    System.out.println(\"--- 回收对象 ---- \" + poll.get());\n                }\n            }\n        }).start();\n\n        obj = null;\n\n        try {\n            Thread.currentThread().join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    static class TestClass {\n        private String name;\n\n        public TestClass(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public String toString() {\n            return \"TestClass - \" + name;\n        }\n    }\n}\n```\n\n使用的虚拟机设置如下：\n\n```bash\n-verbose:gc -Xms4m -Xmx4m -Xmn2m\n```\n\n运行结果如下：\n\n```bash\n[GC (Allocation Failure)  1024K->432K(3584K), 0.0113386 secs]\n[GC (Allocation Failure)  1455K->520K(3584K), 0.0133610 secs]\n[GC (Allocation Failure)  1544K->648K(3584K), 0.0008654 secs]\nnull\nnull\nnull\n[GC (Allocation Failure)  1655K->973K(3584K), 0.0008111 secs]\nnull\n...省略几个null的输出\n[GC (Allocation Failure)  1980K->1997K(3584K), 0.0009289 secs]\n[Full GC (Ergonomics)  1997K->1870K(3584K), 0.0048483 secs]\n--- 弱引用对象被jvm回收了 ---- java.lang.ref.PhantomReference@74cbe23d\n--- 回收对象 ---- null\nnull\n...省略几个null和几次Full GC的输出\n[Full GC (Ergonomics)  2971K->2971K(3584K), 0.0024850 secs]\n[Full GC (Allocation Failure)  2971K->2971K(3584K), 0.0022460 secs]\nException in thread \"Thread-0\" java.lang.OutOfMemoryError: Java heap space\n\tat weakhashmap.PhantomReferenceTest.lambda$main$0(PhantomReferenceTest.java:20)\n\tat weakhashmap.PhantomReferenceTest$$Lambda$1/2065951873.run(Unknown Source)\n\tat java.lang.Thread.run(Thread.java:748)\n```\n\n因为设置的虚拟机堆大小比较小，所以创建一个100k的对象时直接进入了老年代，等到发生Full GC时才会被扫描然后回收。\n\n## 适用场景\n\n使用虚引用的目的就是为了得知对象被GC的时机，所以可以利用虚引用来进行销毁前的一些操作，比如说资源释放等。这个虚引用对于对象而言完全是无感知的，有没有完全一样，但是对于虚引用的使用者而言，就像是待观察的对象的把脉线，可以通过它来观察对象是否已经被回收，从而进行相应的处理。\n\n事实上，虚引用有一个很重要的用途就是用来做堆外内存的释放，DirectByteBuffer就是通过虚引用来实现堆外内存的释放的。 \n\n## 小结\n\n+ 虚引用是最弱的引用\n+ 虚引用对对象而言是无感知的，对象有虚引用跟没有是完全一样的\n+ 虚引用不会影响对象的生命周期\n+ 虚引用可以用来做为对象是否存活的监控","slug":"java/reference/phantom-reference","published":1,"updated":"2019-06-04T01:29:57.400Z","_id":"cjxze3gwu005j0cvw0opodqas","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>虚引用是使用PhantomReference创建的引用，虚引用也称为幽灵引用或者幻影引用，是所有引用类型中最弱的一个。一个对象是否有虚引用的存在，完全不会对其生命周期构成影响，也无法通过虚引用获得一个对象实例。</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>虚引用，正如其名，对一个对象而言，这个引用形同虚设，有和没有一样。</p>\n<blockquote>\n<p>虚可达<br>如果一个对象与GC Roots之间仅存在虚引用，则称这个对象为<code>虚可达（phantom reachable）</code>对象。</p>\n</blockquote>\n<p>当试图通过虚引用的get()方法取得强引用时，总是会返回null，并且，虚引用必须和引用队列一起使用。既然这么虚，那么它出现的意义何在？？</p>\n<p>别慌别慌，自然有它的用处。它的作用在于跟踪垃圾回收过程，在对象被收集器回收时收到一个系统通知。 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，将这个虚引用加入引用队列，在其关联的虚引用出队前，不会彻底销毁该对象。 所以可以通过检查引用队列中是否有相应的虚引用来判断对象是否已经被回收了。</p>\n<p>如果一个对象没有强引用和软引用，对于垃圾回收器而言便是可以被清除的，在清除之前，会调用其finalize方法，如果一个对象已经被调用过finalize方法但是还没有被释放，它就变成了一个虚可达对象。</p>\n<p>与软引用和弱引用不同，显式使用虚引用可以阻止对象被清除，只有在程序中显式或者隐式移除这个虚引用时，这个已经执行过finalize方法的对象才会被清除。想要显式的移除虚引用的话，只需要将其从引用队列中取出然后扔掉（置为null）即可。</p>\n<p>同样来看一个栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhantomReferenceTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> List&lt;Object&gt; TEST_DATA = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ReferenceQueue&lt;TestClass&gt; QUEUE = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        TestClass obj = <span class=\"keyword\">new</span> TestClass(<span class=\"string\">\"Test\"</span>);</span><br><span class=\"line\">        PhantomReference&lt;TestClass&gt; phantomReference = <span class=\"keyword\">new</span> PhantomReference&lt;&gt;(obj, QUEUE);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 该线程不断读取这个虚引用，并不断往列表里插入数据，以促使系统早点进行GC</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                TEST_DATA.add(<span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span> * <span class=\"number\">100</span>]);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                    Thread.currentThread().interrupt();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(phantomReference.get());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 这个线程不断读取引用队列，当弱引用指向的对象呗回收时，该引用就会被加入到引用队列中</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                Reference&lt;? extends TestClass&gt; poll = QUEUE.poll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (poll != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"--- 虚引用对象被jvm回收了 ---- \"</span> + poll);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"--- 回收对象 ---- \"</span> + poll.get());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        obj = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.currentThread().join();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestClass</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TestClass</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"TestClass - \"</span> + name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用的虚拟机设置如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-verbose:gc -Xms4m -Xmx4m -Xmn2m</span><br></pre></td></tr></table></figure>\n<p>运行结果如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure)  1024K-&gt;432K(3584K), 0.0113386 secs]</span><br><span class=\"line\">[GC (Allocation Failure)  1455K-&gt;520K(3584K), 0.0133610 secs]</span><br><span class=\"line\">[GC (Allocation Failure)  1544K-&gt;648K(3584K), 0.0008654 secs]</span><br><span class=\"line\">null</span><br><span class=\"line\">null</span><br><span class=\"line\">null</span><br><span class=\"line\">[GC (Allocation Failure)  1655K-&gt;973K(3584K), 0.0008111 secs]</span><br><span class=\"line\">null</span><br><span class=\"line\">...省略几个null的输出</span><br><span class=\"line\">[GC (Allocation Failure)  1980K-&gt;1997K(3584K), 0.0009289 secs]</span><br><span class=\"line\">[Full GC (Ergonomics)  1997K-&gt;1870K(3584K), 0.0048483 secs]</span><br><span class=\"line\">--- 弱引用对象被jvm回收了 ---- java.lang.ref.PhantomReference@74cbe23d</span><br><span class=\"line\">--- 回收对象 ---- null</span><br><span class=\"line\">null</span><br><span class=\"line\">...省略几个null和几次Full GC的输出</span><br><span class=\"line\">[Full GC (Ergonomics)  2971K-&gt;2971K(3584K), 0.0024850 secs]</span><br><span class=\"line\">[Full GC (Allocation Failure)  2971K-&gt;2971K(3584K), 0.0022460 secs]</span><br><span class=\"line\">Exception <span class=\"keyword\">in</span> thread <span class=\"string\">\"Thread-0\"</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">\tat weakhashmap.PhantomReferenceTest.lambda<span class=\"variable\">$main</span><span class=\"variable\">$0</span>(PhantomReferenceTest.java:20)</span><br><span class=\"line\">\tat weakhashmap.PhantomReferenceTest$<span class=\"variable\">$Lambda</span><span class=\"variable\">$1</span>/2065951873.run(Unknown Source)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>\n<p>因为设置的虚拟机堆大小比较小，所以创建一个100k的对象时直接进入了老年代，等到发生Full GC时才会被扫描然后回收。</p>\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><p>使用虚引用的目的就是为了得知对象被GC的时机，所以可以利用虚引用来进行销毁前的一些操作，比如说资源释放等。这个虚引用对于对象而言完全是无感知的，有没有完全一样，但是对于虚引用的使用者而言，就像是待观察的对象的把脉线，可以通过它来观察对象是否已经被回收，从而进行相应的处理。</p>\n<p>事实上，虚引用有一个很重要的用途就是用来做堆外内存的释放，DirectByteBuffer就是通过虚引用来实现堆外内存的释放的。 </p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>虚引用是最弱的引用</li>\n<li>虚引用对对象而言是无感知的，对象有虚引用跟没有是完全一样的</li>\n<li>虚引用不会影响对象的生命周期</li>\n<li>虚引用可以用来做为对象是否存活的监控</li>\n</ul>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>虚引用是使用PhantomReference创建的引用，虚引用也称为幽灵引用或者幻影引用，是所有引用类型中最弱的一个。一个对象是否有虚引用的存在，完全不会对其生命周期构成影响，也无法通过虚引用获得一个对象实例。</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>虚引用，正如其名，对一个对象而言，这个引用形同虚设，有和没有一样。</p>\n<blockquote>\n<p>虚可达<br>如果一个对象与GC Roots之间仅存在虚引用，则称这个对象为<code>虚可达（phantom reachable）</code>对象。</p>\n</blockquote>\n<p>当试图通过虚引用的get()方法取得强引用时，总是会返回null，并且，虚引用必须和引用队列一起使用。既然这么虚，那么它出现的意义何在？？</p>\n<p>别慌别慌，自然有它的用处。它的作用在于跟踪垃圾回收过程，在对象被收集器回收时收到一个系统通知。 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，将这个虚引用加入引用队列，在其关联的虚引用出队前，不会彻底销毁该对象。 所以可以通过检查引用队列中是否有相应的虚引用来判断对象是否已经被回收了。</p>\n<p>如果一个对象没有强引用和软引用，对于垃圾回收器而言便是可以被清除的，在清除之前，会调用其finalize方法，如果一个对象已经被调用过finalize方法但是还没有被释放，它就变成了一个虚可达对象。</p>\n<p>与软引用和弱引用不同，显式使用虚引用可以阻止对象被清除，只有在程序中显式或者隐式移除这个虚引用时，这个已经执行过finalize方法的对象才会被清除。想要显式的移除虚引用的话，只需要将其从引用队列中取出然后扔掉（置为null）即可。</p>\n<p>同样来看一个栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhantomReferenceTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> List&lt;Object&gt; TEST_DATA = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ReferenceQueue&lt;TestClass&gt; QUEUE = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        TestClass obj = <span class=\"keyword\">new</span> TestClass(<span class=\"string\">\"Test\"</span>);</span><br><span class=\"line\">        PhantomReference&lt;TestClass&gt; phantomReference = <span class=\"keyword\">new</span> PhantomReference&lt;&gt;(obj, QUEUE);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 该线程不断读取这个虚引用，并不断往列表里插入数据，以促使系统早点进行GC</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                TEST_DATA.add(<span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span> * <span class=\"number\">100</span>]);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                    Thread.currentThread().interrupt();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(phantomReference.get());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 这个线程不断读取引用队列，当弱引用指向的对象呗回收时，该引用就会被加入到引用队列中</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                Reference&lt;? extends TestClass&gt; poll = QUEUE.poll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (poll != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"--- 虚引用对象被jvm回收了 ---- \"</span> + poll);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"--- 回收对象 ---- \"</span> + poll.get());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        obj = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.currentThread().join();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestClass</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TestClass</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"TestClass - \"</span> + name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用的虚拟机设置如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-verbose:gc -Xms4m -Xmx4m -Xmn2m</span><br></pre></td></tr></table></figure>\n<p>运行结果如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure)  1024K-&gt;432K(3584K), 0.0113386 secs]</span><br><span class=\"line\">[GC (Allocation Failure)  1455K-&gt;520K(3584K), 0.0133610 secs]</span><br><span class=\"line\">[GC (Allocation Failure)  1544K-&gt;648K(3584K), 0.0008654 secs]</span><br><span class=\"line\">null</span><br><span class=\"line\">null</span><br><span class=\"line\">null</span><br><span class=\"line\">[GC (Allocation Failure)  1655K-&gt;973K(3584K), 0.0008111 secs]</span><br><span class=\"line\">null</span><br><span class=\"line\">...省略几个null的输出</span><br><span class=\"line\">[GC (Allocation Failure)  1980K-&gt;1997K(3584K), 0.0009289 secs]</span><br><span class=\"line\">[Full GC (Ergonomics)  1997K-&gt;1870K(3584K), 0.0048483 secs]</span><br><span class=\"line\">--- 弱引用对象被jvm回收了 ---- java.lang.ref.PhantomReference@74cbe23d</span><br><span class=\"line\">--- 回收对象 ---- null</span><br><span class=\"line\">null</span><br><span class=\"line\">...省略几个null和几次Full GC的输出</span><br><span class=\"line\">[Full GC (Ergonomics)  2971K-&gt;2971K(3584K), 0.0024850 secs]</span><br><span class=\"line\">[Full GC (Allocation Failure)  2971K-&gt;2971K(3584K), 0.0022460 secs]</span><br><span class=\"line\">Exception <span class=\"keyword\">in</span> thread <span class=\"string\">\"Thread-0\"</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">\tat weakhashmap.PhantomReferenceTest.lambda<span class=\"variable\">$main</span><span class=\"variable\">$0</span>(PhantomReferenceTest.java:20)</span><br><span class=\"line\">\tat weakhashmap.PhantomReferenceTest$<span class=\"variable\">$Lambda</span><span class=\"variable\">$1</span>/2065951873.run(Unknown Source)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>\n<p>因为设置的虚拟机堆大小比较小，所以创建一个100k的对象时直接进入了老年代，等到发生Full GC时才会被扫描然后回收。</p>\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><p>使用虚引用的目的就是为了得知对象被GC的时机，所以可以利用虚引用来进行销毁前的一些操作，比如说资源释放等。这个虚引用对于对象而言完全是无感知的，有没有完全一样，但是对于虚引用的使用者而言，就像是待观察的对象的把脉线，可以通过它来观察对象是否已经被回收，从而进行相应的处理。</p>\n<p>事实上，虚引用有一个很重要的用途就是用来做堆外内存的释放，DirectByteBuffer就是通过虚引用来实现堆外内存的释放的。 </p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>虚引用是最弱的引用</li>\n<li>虚引用对对象而言是无感知的，对象有虚引用跟没有是完全一样的</li>\n<li>虚引用不会影响对象的生命周期</li>\n<li>虚引用可以用来做为对象是否存活的监控</li>\n</ul>\n"},{"title":"强引用、软引用、弱引用和虚引用深入探讨","date":"2018-12-29T11:55:51.000Z","_content":"\n## 前言\n\n为了更灵活的控制对象的生命周期，在JDK1.2之后，引用被划分为强引用、软引用、弱引用、虚引用四种类型。\n\n引用类型在日常开发中并不常关注，也很少注意到，因此很多人忽略了它们的存在，而事实上，引用类型在Java体系中扮演着十分重要的角色，如果要想对Java体系有一个更深层次的理解，那么了解和掌握这些引用的用法是十分必要的。\n\n在正式开始前，我们先来上两道开胃菜。<img src=\"/images/0046.png\" width=\"50\"/>\n\n## 为什么需要回收\n\n每一个Java程序中的对象都会占用一定的计算机资源，最常见的，如：每个对象都会在堆空间上申请一定的内存空间。但是除了内存之外，对象还会占用其它资源，如文件句柄，端口，socket等等。当你创建一个对象的时候，必须保证它在销毁的时候会释放它占用的资源。否则程序将会在OOM中结束它的使命。<img src=\"/images/0005.png\" width=\"50\"/>\n\n在Java中，程序员不需要关心对象的内存具体如何分配和如何释放，不需要了解其中回收的细节，也不需要担心会将同一个对象释放两次而导致内存损坏。JVM有自动进行内存管理的神器——垃圾回收器，垃圾回收器会自动回收那些不再使用的对象，并释放掉它们的内存，你只需要保证那些不再被使用的对象的所有强引用都已经被释放掉了。  \n\n虽然垃圾回收器确实让Java中的内存管理比C、C++中的内存管理容易许多，但是你不能对于内存完全不关心。如果你不清楚JVM到底会在什么条件下才会对对象进行回收，那么就有可能会不小心在代码中留下内存泄漏的bug。\n\n因此，关注对象的回收时机，理解JVM中垃圾收集的机制，可以提高对于这个问题的敏感度，也能在发生内存泄漏问题时更快的定位问题所在。想了解更多关于垃圾回收相关的细节，可以参考[这篇文章](../jvm/garbage-collection.html)。\n\n## 为什么需要引用类型\n\n在JDK 1.2以前的版本中，如果一个对象没有被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有当对象处于可达（reachable）状态时，程序才能使用它。只有在对象没有任何其他对象引用它时，垃圾回收器才会对它进行回收。对象只有被引用和没有被引用两种状态。这种方式无法描述一些“食之无味，弃之可惜”的对象。 而很多时候，\n\n我们希望存在这样一些对象：当内存空间足够时，可以将它们保存在内存中，不进行回收；当内存空间变得紧张时，允许JVM回收这些对象。大部分缓存都符合这样的场景。\n\n从JDK 1.2版本开始，Java对引用的概念进行了扩充，对象的引用分成了4种级别，从而使程序开发者能更加灵活地控制对象的生命周期，更好的控制创建的对象何时被释放和回收。\n\n引用类型是与JVM密切合作的类型，有些引用类型甚至允许其引用对象在程序中仍需要的时候被JVM释放。\n\n这4种引用类型的强度由高到低依次为：**强引用**、**软引用**、**弱引用**和**虚引用**。\n\n有了这些引用类型之后，可以一定程度上增加对垃圾回收的粒度把控，可以让垃圾回收器在更合适的时机回收掉那些可以被回收掉的对象，而并不仅仅是只回收不再使用的对象。\n\n这些引用类型各有特点，各有各的适用场景，清楚的了解和掌握它们的用法可以帮助你写出更加健壮的代码。<img src=\"/images/148.png\" width=\"50\"/>\n\n## 实力翻车\n\n下面欢迎来到大型翻车现场，接下来将实力演示一波因为强引用过多导致的翻车例子。\n\n如果你需要在整个程序运行期间保存一些对象（因为它们的初始化很耗费时间和资源），你可能会使用静态集合对象来存储并且在代码中随处使用它们。\n\n```java\npublic static Map<K, V> storedObjs = new HashMap<>();\n```\n\n但是这样，你就能成功阻止垃圾回收器对集合中的对象进行回收和销毁。从而顺利引发OOM。例如：\n\n```java\npublic class OOMTest {\n    public static List<Integer> cachedObjs = new ArrayList<>();\n \n    public static void main(String[] args) {\n        for (int i = 0; i < 100_000_000; i++) {\n            cachedObjs.add(i);\n        }\n    }\n}\n```\n\n输出如下：\n\n```bash\nException in thread “main” java.lang.OutOfMemoryError: Java heap space\n```\n\n<img src=\"/images/0005.png\" width=\"50\"/>这样就符合预期的翻车了。但你也许会说，谁会这么无聊，创建这么多变量。\n\n嗯，确实是的，但是别忘了，一个程序可能会运行很长时间，几个月，甚至几年（如果你的代码和公司足够健壮的话），如果期间不断的创建变量而不清理的话（像上面那样把HashMap当缓存使用，不断往里面添加内容但是却不做删除），是有可能会导致这种情况发生的。\n\n## 内容编排\n\n 接下来的文章将从以下几方面对这四种引用进行介绍：\n\n+ <LabelBlock>简要介绍    </LabelBlock>\n  + [强引用](./strong-reference.html)\n  + [软引用](./soft-reference.html)\n  + [弱引用](./weak-referecen.html)\n  + [虚引用](./phantom-reference.html)\n+ <LabelBlock>源码剖析    </LabelBlock>\n  + [Reference源码详解](./reference-code-detail.html)\n  + [ReferenceQueue源码详解](./reference-queue-code-detail.html)\n  + [SoftReference源码详解](./soft-reference-code-detail.html)\n  + [WeakReference源码详解](./weak-reference-code-detail.html)\n  + [PhantomReference源码详解](./phantom-reference-code-detail.html)\n  + [FinalReference与Finalizer详解](./final-reference-code-detail.html)\n+ <LabelBlock>总结    </LabelBlock>\n  + [四种引用类型总结](./reference-summary.html)\n\n> 注意\n> 本系列文章都是以`JDK1.8` 版本的代码进行分析，不同版本中代码会略有差异。 \n\n如果只是想要对这些引用进行简单了解，那么看完简要介绍部分即可，如果想要有更深入的研究，可以继续查阅源码剖析部分。<img src=\"/images/0003.png\" width=\"50\"/>","source":"_posts/java/reference/four-kinds-of-reference.md","raw":"---\ntitle: 强引用、软引用、弱引用和虚引用深入探讨\ntags: \n - Java\n - 引用类型\ncategories: 编程\ndate: 2018-12-29 19:55:51\n---\n\n## 前言\n\n为了更灵活的控制对象的生命周期，在JDK1.2之后，引用被划分为强引用、软引用、弱引用、虚引用四种类型。\n\n引用类型在日常开发中并不常关注，也很少注意到，因此很多人忽略了它们的存在，而事实上，引用类型在Java体系中扮演着十分重要的角色，如果要想对Java体系有一个更深层次的理解，那么了解和掌握这些引用的用法是十分必要的。\n\n在正式开始前，我们先来上两道开胃菜。<img src=\"/images/0046.png\" width=\"50\"/>\n\n## 为什么需要回收\n\n每一个Java程序中的对象都会占用一定的计算机资源，最常见的，如：每个对象都会在堆空间上申请一定的内存空间。但是除了内存之外，对象还会占用其它资源，如文件句柄，端口，socket等等。当你创建一个对象的时候，必须保证它在销毁的时候会释放它占用的资源。否则程序将会在OOM中结束它的使命。<img src=\"/images/0005.png\" width=\"50\"/>\n\n在Java中，程序员不需要关心对象的内存具体如何分配和如何释放，不需要了解其中回收的细节，也不需要担心会将同一个对象释放两次而导致内存损坏。JVM有自动进行内存管理的神器——垃圾回收器，垃圾回收器会自动回收那些不再使用的对象，并释放掉它们的内存，你只需要保证那些不再被使用的对象的所有强引用都已经被释放掉了。  \n\n虽然垃圾回收器确实让Java中的内存管理比C、C++中的内存管理容易许多，但是你不能对于内存完全不关心。如果你不清楚JVM到底会在什么条件下才会对对象进行回收，那么就有可能会不小心在代码中留下内存泄漏的bug。\n\n因此，关注对象的回收时机，理解JVM中垃圾收集的机制，可以提高对于这个问题的敏感度，也能在发生内存泄漏问题时更快的定位问题所在。想了解更多关于垃圾回收相关的细节，可以参考[这篇文章](../jvm/garbage-collection.html)。\n\n## 为什么需要引用类型\n\n在JDK 1.2以前的版本中，如果一个对象没有被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有当对象处于可达（reachable）状态时，程序才能使用它。只有在对象没有任何其他对象引用它时，垃圾回收器才会对它进行回收。对象只有被引用和没有被引用两种状态。这种方式无法描述一些“食之无味，弃之可惜”的对象。 而很多时候，\n\n我们希望存在这样一些对象：当内存空间足够时，可以将它们保存在内存中，不进行回收；当内存空间变得紧张时，允许JVM回收这些对象。大部分缓存都符合这样的场景。\n\n从JDK 1.2版本开始，Java对引用的概念进行了扩充，对象的引用分成了4种级别，从而使程序开发者能更加灵活地控制对象的生命周期，更好的控制创建的对象何时被释放和回收。\n\n引用类型是与JVM密切合作的类型，有些引用类型甚至允许其引用对象在程序中仍需要的时候被JVM释放。\n\n这4种引用类型的强度由高到低依次为：**强引用**、**软引用**、**弱引用**和**虚引用**。\n\n有了这些引用类型之后，可以一定程度上增加对垃圾回收的粒度把控，可以让垃圾回收器在更合适的时机回收掉那些可以被回收掉的对象，而并不仅仅是只回收不再使用的对象。\n\n这些引用类型各有特点，各有各的适用场景，清楚的了解和掌握它们的用法可以帮助你写出更加健壮的代码。<img src=\"/images/148.png\" width=\"50\"/>\n\n## 实力翻车\n\n下面欢迎来到大型翻车现场，接下来将实力演示一波因为强引用过多导致的翻车例子。\n\n如果你需要在整个程序运行期间保存一些对象（因为它们的初始化很耗费时间和资源），你可能会使用静态集合对象来存储并且在代码中随处使用它们。\n\n```java\npublic static Map<K, V> storedObjs = new HashMap<>();\n```\n\n但是这样，你就能成功阻止垃圾回收器对集合中的对象进行回收和销毁。从而顺利引发OOM。例如：\n\n```java\npublic class OOMTest {\n    public static List<Integer> cachedObjs = new ArrayList<>();\n \n    public static void main(String[] args) {\n        for (int i = 0; i < 100_000_000; i++) {\n            cachedObjs.add(i);\n        }\n    }\n}\n```\n\n输出如下：\n\n```bash\nException in thread “main” java.lang.OutOfMemoryError: Java heap space\n```\n\n<img src=\"/images/0005.png\" width=\"50\"/>这样就符合预期的翻车了。但你也许会说，谁会这么无聊，创建这么多变量。\n\n嗯，确实是的，但是别忘了，一个程序可能会运行很长时间，几个月，甚至几年（如果你的代码和公司足够健壮的话），如果期间不断的创建变量而不清理的话（像上面那样把HashMap当缓存使用，不断往里面添加内容但是却不做删除），是有可能会导致这种情况发生的。\n\n## 内容编排\n\n 接下来的文章将从以下几方面对这四种引用进行介绍：\n\n+ <LabelBlock>简要介绍    </LabelBlock>\n  + [强引用](./strong-reference.html)\n  + [软引用](./soft-reference.html)\n  + [弱引用](./weak-referecen.html)\n  + [虚引用](./phantom-reference.html)\n+ <LabelBlock>源码剖析    </LabelBlock>\n  + [Reference源码详解](./reference-code-detail.html)\n  + [ReferenceQueue源码详解](./reference-queue-code-detail.html)\n  + [SoftReference源码详解](./soft-reference-code-detail.html)\n  + [WeakReference源码详解](./weak-reference-code-detail.html)\n  + [PhantomReference源码详解](./phantom-reference-code-detail.html)\n  + [FinalReference与Finalizer详解](./final-reference-code-detail.html)\n+ <LabelBlock>总结    </LabelBlock>\n  + [四种引用类型总结](./reference-summary.html)\n\n> 注意\n> 本系列文章都是以`JDK1.8` 版本的代码进行分析，不同版本中代码会略有差异。 \n\n如果只是想要对这些引用进行简单了解，那么看完简要介绍部分即可，如果想要有更深入的研究，可以继续查阅源码剖析部分。<img src=\"/images/0003.png\" width=\"50\"/>","slug":"java/reference/four-kinds-of-reference","published":1,"updated":"2019-06-04T01:29:57.400Z","_id":"cjxze3gwu005m0cvwpr9rtcrz","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>为了更灵活的控制对象的生命周期，在JDK1.2之后，引用被划分为强引用、软引用、弱引用、虚引用四种类型。</p>\n<p>引用类型在日常开发中并不常关注，也很少注意到，因此很多人忽略了它们的存在，而事实上，引用类型在Java体系中扮演着十分重要的角色，如果要想对Java体系有一个更深层次的理解，那么了解和掌握这些引用的用法是十分必要的。</p>\n<p>在正式开始前，我们先来上两道开胃菜。<img src=\"/images/0046.png\" width=\"50\"></p>\n<h2 id=\"为什么需要回收\"><a href=\"#为什么需要回收\" class=\"headerlink\" title=\"为什么需要回收\"></a>为什么需要回收</h2><p>每一个Java程序中的对象都会占用一定的计算机资源，最常见的，如：每个对象都会在堆空间上申请一定的内存空间。但是除了内存之外，对象还会占用其它资源，如文件句柄，端口，socket等等。当你创建一个对象的时候，必须保证它在销毁的时候会释放它占用的资源。否则程序将会在OOM中结束它的使命。<img src=\"/images/0005.png\" width=\"50\"></p>\n<p>在Java中，程序员不需要关心对象的内存具体如何分配和如何释放，不需要了解其中回收的细节，也不需要担心会将同一个对象释放两次而导致内存损坏。JVM有自动进行内存管理的神器——垃圾回收器，垃圾回收器会自动回收那些不再使用的对象，并释放掉它们的内存，你只需要保证那些不再被使用的对象的所有强引用都已经被释放掉了。  </p>\n<p>虽然垃圾回收器确实让Java中的内存管理比C、C++中的内存管理容易许多，但是你不能对于内存完全不关心。如果你不清楚JVM到底会在什么条件下才会对对象进行回收，那么就有可能会不小心在代码中留下内存泄漏的bug。</p>\n<p>因此，关注对象的回收时机，理解JVM中垃圾收集的机制，可以提高对于这个问题的敏感度，也能在发生内存泄漏问题时更快的定位问题所在。想了解更多关于垃圾回收相关的细节，可以参考<a href=\"../jvm/garbage-collection.html\">这篇文章</a>。</p>\n<h2 id=\"为什么需要引用类型\"><a href=\"#为什么需要引用类型\" class=\"headerlink\" title=\"为什么需要引用类型\"></a>为什么需要引用类型</h2><p>在JDK 1.2以前的版本中，如果一个对象没有被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有当对象处于可达（reachable）状态时，程序才能使用它。只有在对象没有任何其他对象引用它时，垃圾回收器才会对它进行回收。对象只有被引用和没有被引用两种状态。这种方式无法描述一些“食之无味，弃之可惜”的对象。 而很多时候，</p>\n<p>我们希望存在这样一些对象：当内存空间足够时，可以将它们保存在内存中，不进行回收；当内存空间变得紧张时，允许JVM回收这些对象。大部分缓存都符合这样的场景。</p>\n<p>从JDK 1.2版本开始，Java对引用的概念进行了扩充，对象的引用分成了4种级别，从而使程序开发者能更加灵活地控制对象的生命周期，更好的控制创建的对象何时被释放和回收。</p>\n<p>引用类型是与JVM密切合作的类型，有些引用类型甚至允许其引用对象在程序中仍需要的时候被JVM释放。</p>\n<p>这4种引用类型的强度由高到低依次为：<strong>强引用</strong>、<strong>软引用</strong>、<strong>弱引用</strong>和<strong>虚引用</strong>。</p>\n<p>有了这些引用类型之后，可以一定程度上增加对垃圾回收的粒度把控，可以让垃圾回收器在更合适的时机回收掉那些可以被回收掉的对象，而并不仅仅是只回收不再使用的对象。</p>\n<p>这些引用类型各有特点，各有各的适用场景，清楚的了解和掌握它们的用法可以帮助你写出更加健壮的代码。<img src=\"/images/148.png\" width=\"50\"></p>\n<h2 id=\"实力翻车\"><a href=\"#实力翻车\" class=\"headerlink\" title=\"实力翻车\"></a>实力翻车</h2><p>下面欢迎来到大型翻车现场，接下来将实力演示一波因为强引用过多导致的翻车例子。</p>\n<p>如果你需要在整个程序运行期间保存一些对象（因为它们的初始化很耗费时间和资源），你可能会使用静态集合对象来存储并且在代码中随处使用它们。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Map&lt;K, V&gt; storedObjs = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<p>但是这样，你就能成功阻止垃圾回收器对集合中的对象进行回收和销毁。从而顺利引发OOM。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OOMTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Integer&gt; cachedObjs = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100_000_000</span>; i++) &#123;</span><br><span class=\"line\">            cachedObjs.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception <span class=\"keyword\">in</span> thread “main” java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/0005.png\" width=\"50\">这样就符合预期的翻车了。但你也许会说，谁会这么无聊，创建这么多变量。</p>\n<p>嗯，确实是的，但是别忘了，一个程序可能会运行很长时间，几个月，甚至几年（如果你的代码和公司足够健壮的话），如果期间不断的创建变量而不清理的话（像上面那样把HashMap当缓存使用，不断往里面添加内容但是却不做删除），是有可能会导致这种情况发生的。</p>\n<h2 id=\"内容编排\"><a href=\"#内容编排\" class=\"headerlink\" title=\"内容编排\"></a>内容编排</h2><p> 接下来的文章将从以下几方面对这四种引用进行介绍：</p>\n<ul>\n<li><labelblock>简要介绍    </labelblock><ul>\n<li><a href=\"./strong-reference.html\">强引用</a></li>\n<li><a href=\"./soft-reference.html\">软引用</a></li>\n<li><a href=\"./weak-referecen.html\">弱引用</a></li>\n<li><a href=\"./phantom-reference.html\">虚引用</a></li>\n</ul>\n</li>\n<li><labelblock>源码剖析    </labelblock><ul>\n<li><a href=\"./reference-code-detail.html\">Reference源码详解</a></li>\n<li><a href=\"./reference-queue-code-detail.html\">ReferenceQueue源码详解</a></li>\n<li><a href=\"./soft-reference-code-detail.html\">SoftReference源码详解</a></li>\n<li><a href=\"./weak-reference-code-detail.html\">WeakReference源码详解</a></li>\n<li><a href=\"./phantom-reference-code-detail.html\">PhantomReference源码详解</a></li>\n<li><a href=\"./final-reference-code-detail.html\">FinalReference与Finalizer详解</a></li>\n</ul>\n</li>\n<li><labelblock>总结    </labelblock><ul>\n<li><a href=\"./reference-summary.html\">四种引用类型总结</a></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>注意<br>本系列文章都是以<code>JDK1.8</code> 版本的代码进行分析，不同版本中代码会略有差异。 </p>\n</blockquote>\n<p>如果只是想要对这些引用进行简单了解，那么看完简要介绍部分即可，如果想要有更深入的研究，可以继续查阅源码剖析部分。<img src=\"/images/0003.png\" width=\"50\"></p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>为了更灵活的控制对象的生命周期，在JDK1.2之后，引用被划分为强引用、软引用、弱引用、虚引用四种类型。</p>\n<p>引用类型在日常开发中并不常关注，也很少注意到，因此很多人忽略了它们的存在，而事实上，引用类型在Java体系中扮演着十分重要的角色，如果要想对Java体系有一个更深层次的理解，那么了解和掌握这些引用的用法是十分必要的。</p>\n<p>在正式开始前，我们先来上两道开胃菜。<img src=\"/images/0046.png\" width=\"50\"></p>\n<h2 id=\"为什么需要回收\"><a href=\"#为什么需要回收\" class=\"headerlink\" title=\"为什么需要回收\"></a>为什么需要回收</h2><p>每一个Java程序中的对象都会占用一定的计算机资源，最常见的，如：每个对象都会在堆空间上申请一定的内存空间。但是除了内存之外，对象还会占用其它资源，如文件句柄，端口，socket等等。当你创建一个对象的时候，必须保证它在销毁的时候会释放它占用的资源。否则程序将会在OOM中结束它的使命。<img src=\"/images/0005.png\" width=\"50\"></p>\n<p>在Java中，程序员不需要关心对象的内存具体如何分配和如何释放，不需要了解其中回收的细节，也不需要担心会将同一个对象释放两次而导致内存损坏。JVM有自动进行内存管理的神器——垃圾回收器，垃圾回收器会自动回收那些不再使用的对象，并释放掉它们的内存，你只需要保证那些不再被使用的对象的所有强引用都已经被释放掉了。  </p>\n<p>虽然垃圾回收器确实让Java中的内存管理比C、C++中的内存管理容易许多，但是你不能对于内存完全不关心。如果你不清楚JVM到底会在什么条件下才会对对象进行回收，那么就有可能会不小心在代码中留下内存泄漏的bug。</p>\n<p>因此，关注对象的回收时机，理解JVM中垃圾收集的机制，可以提高对于这个问题的敏感度，也能在发生内存泄漏问题时更快的定位问题所在。想了解更多关于垃圾回收相关的细节，可以参考<a href=\"../jvm/garbage-collection.html\">这篇文章</a>。</p>\n<h2 id=\"为什么需要引用类型\"><a href=\"#为什么需要引用类型\" class=\"headerlink\" title=\"为什么需要引用类型\"></a>为什么需要引用类型</h2><p>在JDK 1.2以前的版本中，如果一个对象没有被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有当对象处于可达（reachable）状态时，程序才能使用它。只有在对象没有任何其他对象引用它时，垃圾回收器才会对它进行回收。对象只有被引用和没有被引用两种状态。这种方式无法描述一些“食之无味，弃之可惜”的对象。 而很多时候，</p>\n<p>我们希望存在这样一些对象：当内存空间足够时，可以将它们保存在内存中，不进行回收；当内存空间变得紧张时，允许JVM回收这些对象。大部分缓存都符合这样的场景。</p>\n<p>从JDK 1.2版本开始，Java对引用的概念进行了扩充，对象的引用分成了4种级别，从而使程序开发者能更加灵活地控制对象的生命周期，更好的控制创建的对象何时被释放和回收。</p>\n<p>引用类型是与JVM密切合作的类型，有些引用类型甚至允许其引用对象在程序中仍需要的时候被JVM释放。</p>\n<p>这4种引用类型的强度由高到低依次为：<strong>强引用</strong>、<strong>软引用</strong>、<strong>弱引用</strong>和<strong>虚引用</strong>。</p>\n<p>有了这些引用类型之后，可以一定程度上增加对垃圾回收的粒度把控，可以让垃圾回收器在更合适的时机回收掉那些可以被回收掉的对象，而并不仅仅是只回收不再使用的对象。</p>\n<p>这些引用类型各有特点，各有各的适用场景，清楚的了解和掌握它们的用法可以帮助你写出更加健壮的代码。<img src=\"/images/148.png\" width=\"50\"></p>\n<h2 id=\"实力翻车\"><a href=\"#实力翻车\" class=\"headerlink\" title=\"实力翻车\"></a>实力翻车</h2><p>下面欢迎来到大型翻车现场，接下来将实力演示一波因为强引用过多导致的翻车例子。</p>\n<p>如果你需要在整个程序运行期间保存一些对象（因为它们的初始化很耗费时间和资源），你可能会使用静态集合对象来存储并且在代码中随处使用它们。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Map&lt;K, V&gt; storedObjs = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<p>但是这样，你就能成功阻止垃圾回收器对集合中的对象进行回收和销毁。从而顺利引发OOM。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OOMTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Integer&gt; cachedObjs = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100_000_000</span>; i++) &#123;</span><br><span class=\"line\">            cachedObjs.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception <span class=\"keyword\">in</span> thread “main” java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/0005.png\" width=\"50\">这样就符合预期的翻车了。但你也许会说，谁会这么无聊，创建这么多变量。</p>\n<p>嗯，确实是的，但是别忘了，一个程序可能会运行很长时间，几个月，甚至几年（如果你的代码和公司足够健壮的话），如果期间不断的创建变量而不清理的话（像上面那样把HashMap当缓存使用，不断往里面添加内容但是却不做删除），是有可能会导致这种情况发生的。</p>\n<h2 id=\"内容编排\"><a href=\"#内容编排\" class=\"headerlink\" title=\"内容编排\"></a>内容编排</h2><p> 接下来的文章将从以下几方面对这四种引用进行介绍：</p>\n<ul>\n<li><labelblock>简要介绍    </labelblock><ul>\n<li><a href=\"./strong-reference.html\">强引用</a></li>\n<li><a href=\"./soft-reference.html\">软引用</a></li>\n<li><a href=\"./weak-referecen.html\">弱引用</a></li>\n<li><a href=\"./phantom-reference.html\">虚引用</a></li>\n</ul>\n</li>\n<li><labelblock>源码剖析    </labelblock><ul>\n<li><a href=\"./reference-code-detail.html\">Reference源码详解</a></li>\n<li><a href=\"./reference-queue-code-detail.html\">ReferenceQueue源码详解</a></li>\n<li><a href=\"./soft-reference-code-detail.html\">SoftReference源码详解</a></li>\n<li><a href=\"./weak-reference-code-detail.html\">WeakReference源码详解</a></li>\n<li><a href=\"./phantom-reference-code-detail.html\">PhantomReference源码详解</a></li>\n<li><a href=\"./final-reference-code-detail.html\">FinalReference与Finalizer详解</a></li>\n</ul>\n</li>\n<li><labelblock>总结    </labelblock><ul>\n<li><a href=\"./reference-summary.html\">四种引用类型总结</a></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>注意<br>本系列文章都是以<code>JDK1.8</code> 版本的代码进行分析，不同版本中代码会略有差异。 </p>\n</blockquote>\n<p>如果只是想要对这些引用进行简单了解，那么看完简要介绍部分即可，如果想要有更深入的研究，可以继续查阅源码剖析部分。<img src=\"/images/0003.png\" width=\"50\"></p>\n"},{"title":"【Java入门篇】二、Java开发环境搭建——Windows篇","date":"2018-12-28T11:00:02.000Z","_content":"\n> 你为了你的正义，我为了我的正义。 -- 《火影忍者》\n\n## 一、安装JDK\n\n官网下载链接：https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\n\n{% asset_img 1-jdk-windows.png jdk-windows %}\n\n## 二、配置环境变量\n\n需要配置以下几个环境变量：\n\nJAVA_HOME     配置JDK安装路径\n\nPATH                  配置JDK命令文件的位置\n\nCLASSPATH      配置类库文件的位置\n\n### 1、我的电脑（右键）-->属性-->高级系统设置\n\n{% asset_img 2-jdk-windows.png jdk-windows %}\n\n### 2、环境变量-->新建\n\n{% asset_img 3-jdk-windows.png jdk-windows %}\n\n{% asset_img 4-jdk-windows.png jdk-windows %}\n\n{% asset_img 5-jdk-windows.png jdk-windows %})\n\n(1)新建->变量名\"JAVA_HOME\"，变量值\"C:/Java/jdk1.8.0_144\"（即JDK的安装路径） \n\n(2)编辑->变量名\"Path\"，在原变量值的最后面加上“;%JAVA_HOME%/bin;%JAVA_HOME%/jre/bin” \n\n(3)新建->变量名“CLASSPATH”,变量值“.;%JAVA_HOME%/lib;%JAVA_HOME%/lib/dt.jar;%JAVA_HOME%/lib/tools.jar”\n\n### 3、确认环境配置是否正确\n\n在控制台分别输入java，javac，java -version 命令，出现如下所示的JDK的编译器信息，包括修改命令的语法和参数选项等信息。\n\njava命令：\n\n{% asset_img 6-jdk-windows.png jdk-windows %}\n\njavac命令：\n\n{% asset_img 7-jdk-windows.png jdk-windows %}\n\njava -version命令：\n\n{% asset_img 8-jdk-windows.png jdk-windows %}\n\n### 4、在控制台下验证第一个java程序：\n\n右键--》新建--》文本文档\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n    System.out.println(\"Hello World!\");\n    }\n}\n```\n\n用记事本编写好，点击“保存”，并保存在桌面后，先在控制台中进入桌面的目录。\n\n```bash\nC:\ncd /Users/[用户名]/Desktop\n```\n\n上面的[用户名]改成你的计算机用户名即可，不清楚的话打开我的电脑，进C盘目录：C:/Users 找一下。\n\n输入javac Test.java和java Test命令，即可运行程序（打印出结果“Hello Java”）。\n\n{% asset_img 9-jdk-windows.png jdk-windows %}\n\n至此，Java开发环境搭建成功。","source":"_posts/java/introduction/java-environment-windows.md","raw":"---\ntitle: 【Java入门篇】二、Java开发环境搭建——Windows篇\ntags: \n - Java入门\n - Java\n - 环境搭建\ncategories: 编程\ndate: 2018-12-28 19:00:02\n---\n\n> 你为了你的正义，我为了我的正义。 -- 《火影忍者》\n\n## 一、安装JDK\n\n官网下载链接：https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\n\n{% asset_img 1-jdk-windows.png jdk-windows %}\n\n## 二、配置环境变量\n\n需要配置以下几个环境变量：\n\nJAVA_HOME     配置JDK安装路径\n\nPATH                  配置JDK命令文件的位置\n\nCLASSPATH      配置类库文件的位置\n\n### 1、我的电脑（右键）-->属性-->高级系统设置\n\n{% asset_img 2-jdk-windows.png jdk-windows %}\n\n### 2、环境变量-->新建\n\n{% asset_img 3-jdk-windows.png jdk-windows %}\n\n{% asset_img 4-jdk-windows.png jdk-windows %}\n\n{% asset_img 5-jdk-windows.png jdk-windows %})\n\n(1)新建->变量名\"JAVA_HOME\"，变量值\"C:/Java/jdk1.8.0_144\"（即JDK的安装路径） \n\n(2)编辑->变量名\"Path\"，在原变量值的最后面加上“;%JAVA_HOME%/bin;%JAVA_HOME%/jre/bin” \n\n(3)新建->变量名“CLASSPATH”,变量值“.;%JAVA_HOME%/lib;%JAVA_HOME%/lib/dt.jar;%JAVA_HOME%/lib/tools.jar”\n\n### 3、确认环境配置是否正确\n\n在控制台分别输入java，javac，java -version 命令，出现如下所示的JDK的编译器信息，包括修改命令的语法和参数选项等信息。\n\njava命令：\n\n{% asset_img 6-jdk-windows.png jdk-windows %}\n\njavac命令：\n\n{% asset_img 7-jdk-windows.png jdk-windows %}\n\njava -version命令：\n\n{% asset_img 8-jdk-windows.png jdk-windows %}\n\n### 4、在控制台下验证第一个java程序：\n\n右键--》新建--》文本文档\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n    System.out.println(\"Hello World!\");\n    }\n}\n```\n\n用记事本编写好，点击“保存”，并保存在桌面后，先在控制台中进入桌面的目录。\n\n```bash\nC:\ncd /Users/[用户名]/Desktop\n```\n\n上面的[用户名]改成你的计算机用户名即可，不清楚的话打开我的电脑，进C盘目录：C:/Users 找一下。\n\n输入javac Test.java和java Test命令，即可运行程序（打印出结果“Hello Java”）。\n\n{% asset_img 9-jdk-windows.png jdk-windows %}\n\n至此，Java开发环境搭建成功。","slug":"java/introduction/java-environment-windows","published":1,"updated":"2019-06-04T01:29:57.315Z","_id":"cjxze3gwu005q0cvwu5jx6eyy","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>你为了你的正义，我为了我的正义。 – 《火影忍者》</p>\n</blockquote>\n<h2 id=\"一、安装JDK\"><a href=\"#一、安装JDK\" class=\"headerlink\" title=\"一、安装JDK\"></a>一、安装JDK</h2><p>官网下载链接：<a href=\"https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\" target=\"_blank\" rel=\"noopener\">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>\n<img src=\"/programming/java/introduction/java-environment-windows/1-jdk-windows.png\" title=\"jdk-windows\">\n<h2 id=\"二、配置环境变量\"><a href=\"#二、配置环境变量\" class=\"headerlink\" title=\"二、配置环境变量\"></a>二、配置环境变量</h2><p>需要配置以下几个环境变量：</p>\n<p>JAVA_HOME     配置JDK安装路径</p>\n<p>PATH                  配置JDK命令文件的位置</p>\n<p>CLASSPATH      配置类库文件的位置</p>\n<h3 id=\"1、我的电脑（右键）–-gt-属性–-gt-高级系统设置\"><a href=\"#1、我的电脑（右键）–-gt-属性–-gt-高级系统设置\" class=\"headerlink\" title=\"1、我的电脑（右键）–&gt;属性–&gt;高级系统设置\"></a>1、我的电脑（右键）–&gt;属性–&gt;高级系统设置</h3><img src=\"/programming/java/introduction/java-environment-windows/2-jdk-windows.png\" title=\"jdk-windows\">\n<h3 id=\"2、环境变量–-gt-新建\"><a href=\"#2、环境变量–-gt-新建\" class=\"headerlink\" title=\"2、环境变量–&gt;新建\"></a>2、环境变量–&gt;新建</h3><img src=\"/programming/java/introduction/java-environment-windows/3-jdk-windows.png\" title=\"jdk-windows\">\n<img src=\"/programming/java/introduction/java-environment-windows/4-jdk-windows.png\" title=\"jdk-windows\">\n<img src=\"/programming/java/introduction/java-environment-windows/5-jdk-windows.png\" title=\"jdk-windows\">)<br><br>(1)新建-&gt;变量名”JAVA_HOME”，变量值”C:/Java/jdk1.8.0_144”（即JDK的安装路径）<br><br>(2)编辑-&gt;变量名”Path”，在原变量值的最后面加上“;%JAVA_HOME%/bin;%JAVA_HOME%/jre/bin”<br><br>(3)新建-&gt;变量名“CLASSPATH”,变量值“.;%JAVA_HOME%/lib;%JAVA_HOME%/lib/dt.jar;%JAVA_HOME%/lib/tools.jar”<br><br>### 3、确认环境配置是否正确<br><br>在控制台分别输入java，javac，java -version 命令，出现如下所示的JDK的编译器信息，包括修改命令的语法和参数选项等信息。<br><br>java命令：<br><br><img src=\"/programming/java/introduction/java-environment-windows/6-jdk-windows.png\" title=\"jdk-windows\">\n<p>javac命令：</p>\n<img src=\"/programming/java/introduction/java-environment-windows/7-jdk-windows.png\" title=\"jdk-windows\">\n<p>java -version命令：</p>\n<img src=\"/programming/java/introduction/java-environment-windows/8-jdk-windows.png\" title=\"jdk-windows\">\n<h3 id=\"4、在控制台下验证第一个java程序：\"><a href=\"#4、在控制台下验证第一个java程序：\" class=\"headerlink\" title=\"4、在控制台下验证第一个java程序：\"></a>4、在控制台下验证第一个java程序：</h3><p>右键–》新建–》文本文档</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Hello World!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用记事本编写好，点击“保存”，并保存在桌面后，先在控制台中进入桌面的目录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /Users/[用户名]/Desktop</span><br></pre></td></tr></table></figure>\n<p>上面的[用户名]改成你的计算机用户名即可，不清楚的话打开我的电脑，进C盘目录：C:/Users 找一下。</p>\n<p>输入javac Test.java和java Test命令，即可运行程序（打印出结果“Hello Java”）。</p>\n<img src=\"/programming/java/introduction/java-environment-windows/9-jdk-windows.png\" title=\"jdk-windows\">\n<p>至此，Java开发环境搭建成功。</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<blockquote>\n<p>你为了你的正义，我为了我的正义。 – 《火影忍者》</p>\n</blockquote>\n<h2 id=\"一、安装JDK\"><a href=\"#一、安装JDK\" class=\"headerlink\" title=\"一、安装JDK\"></a>一、安装JDK</h2><p>官网下载链接：<a href=\"https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\" target=\"_blank\" rel=\"noopener\">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>\n<img src=\"/programming/java/introduction/java-environment-windows/1-jdk-windows.png\" title=\"jdk-windows\">\n<h2 id=\"二、配置环境变量\"><a href=\"#二、配置环境变量\" class=\"headerlink\" title=\"二、配置环境变量\"></a>二、配置环境变量</h2><p>需要配置以下几个环境变量：</p>\n<p>JAVA_HOME     配置JDK安装路径</p>\n<p>PATH                  配置JDK命令文件的位置</p>\n<p>CLASSPATH      配置类库文件的位置</p>\n<h3 id=\"1、我的电脑（右键）–-gt-属性–-gt-高级系统设置\"><a href=\"#1、我的电脑（右键）–-gt-属性–-gt-高级系统设置\" class=\"headerlink\" title=\"1、我的电脑（右键）–&gt;属性–&gt;高级系统设置\"></a>1、我的电脑（右键）–&gt;属性–&gt;高级系统设置</h3><img src=\"/programming/java/introduction/java-environment-windows/2-jdk-windows.png\" title=\"jdk-windows\">\n<h3 id=\"2、环境变量–-gt-新建\"><a href=\"#2、环境变量–-gt-新建\" class=\"headerlink\" title=\"2、环境变量–&gt;新建\"></a>2、环境变量–&gt;新建</h3><img src=\"/programming/java/introduction/java-environment-windows/3-jdk-windows.png\" title=\"jdk-windows\">\n<img src=\"/programming/java/introduction/java-environment-windows/4-jdk-windows.png\" title=\"jdk-windows\">\n<img src=\"/programming/java/introduction/java-environment-windows/5-jdk-windows.png\" title=\"jdk-windows\">)<br><br>(1)新建-&gt;变量名”JAVA_HOME”，变量值”C:/Java/jdk1.8.0_144”（即JDK的安装路径）<br><br>(2)编辑-&gt;变量名”Path”，在原变量值的最后面加上“;%JAVA_HOME%/bin;%JAVA_HOME%/jre/bin”<br><br>(3)新建-&gt;变量名“CLASSPATH”,变量值“.;%JAVA_HOME%/lib;%JAVA_HOME%/lib/dt.jar;%JAVA_HOME%/lib/tools.jar”<br><br>### 3、确认环境配置是否正确<br><br>在控制台分别输入java，javac，java -version 命令，出现如下所示的JDK的编译器信息，包括修改命令的语法和参数选项等信息。<br><br>java命令：<br><br><img src=\"/programming/java/introduction/java-environment-windows/6-jdk-windows.png\" title=\"jdk-windows\">\n<p>javac命令：</p>\n<img src=\"/programming/java/introduction/java-environment-windows/7-jdk-windows.png\" title=\"jdk-windows\">\n<p>java -version命令：</p>\n<img src=\"/programming/java/introduction/java-environment-windows/8-jdk-windows.png\" title=\"jdk-windows\">\n<h3 id=\"4、在控制台下验证第一个java程序：\"><a href=\"#4、在控制台下验证第一个java程序：\" class=\"headerlink\" title=\"4、在控制台下验证第一个java程序：\"></a>4、在控制台下验证第一个java程序：</h3><p>右键–》新建–》文本文档</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Hello World!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用记事本编写好，点击“保存”，并保存在桌面后，先在控制台中进入桌面的目录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /Users/[用户名]/Desktop</span><br></pre></td></tr></table></figure>\n<p>上面的[用户名]改成你的计算机用户名即可，不清楚的话打开我的电脑，进C盘目录：C:/Users 找一下。</p>\n<p>输入javac Test.java和java Test命令，即可运行程序（打印出结果“Hello Java”）。</p>\n<img src=\"/programming/java/introduction/java-environment-windows/9-jdk-windows.png\" title=\"jdk-windows\">\n<p>至此，Java开发环境搭建成功。</p>\n"},{"title":"Reference源码详解","date":"2018-12-29T12:10:51.000Z","_content":"\n{% asset_img reference-1.png reference-1 %}\n\n## 定义\n\n> 说明\n> Reference是所有引用类型的父类，定义了引用的公共行为和操作。\n> reference指代引用对象本身，referent指代reference引用的对象，下文介绍会以reference，referent形式出现。\n\n## 说明\n\nReference类与垃圾回收是密切配合的，所以该类不能被直接子类化。简单来讲，Reference的继承类都是经过严格设计的，甚至连成员变量的先后顺序都不能改变，所以在代码中直接继承Reference类是没有任何意义的。但是可以继承Reference类的子类。\n\n> 例如\n> Finalizer 继承自 FinalReference，Cleaner 继承自 PhantomReference\n\n## 构造函数\n\nReference类中有两个构造函数，一个需要传入引用队列，另一个则不需要。\n\n这个队列的意义在于增加一种判断机制，可以在外部通过监控这个队列来判断对象是否被回收。如果一个对象即将被回收，那么引用这个对象的reference对象就会被放到这个队列中。通过监控这个队列，就可以取出这个reference后再进行一些善后处理。<img src=\"/images/0003.png\" width=\"50\"/>\n\n如果没有这个队列，就只能通过不断地轮询reference对象，通过get方法是否返回null( phantomReference对象不能这样做，其get方法始终返回null，因此它只有带queue的构造函数 )来判断对象是否被回收。\n\n这两种方法均有相应的使用场景，具体使用需要具体情况具体分析。比如在weakHashMap中，就通过查询queue的数据，来判定是否有对象将被回收。而ThreadLocalMap，则采用判断get()是否为null来进行处理。\n\n```java\n/* -- Constructors -- */\nReference(T referent) {\n    this(referent, null);\n}\n\nReference(T referent, ReferenceQueue<? super T> queue) {\n    this.referent = referent;\n    this.queue = (queue == null) ? ReferenceQueue.NULL : queue;\n}\n```\n\n## 内部成员\n\nReference类内部有这么几个成员变量：\n\nreferent：保存reference指向的对象。\n\n``` java\nprivate T referent;\n```\n\nqueue：引用对象关联的引用队列。是对象即将被回收时所要通知的队列。当对象将被回收时，reference对象( 而不是referent引用的对象 )会被放到queue里面，然后外部程序即可通过监控这个queue拿到相应的数据了。\n\n这里的queue( 即，ReferenceQueue对象 )名义上是一个队列，实际内部是使用单链表来表示的单向队列，可以理解为queue就是一个链表，其自身仅存储当前的head节点，后面的节点由每个reference节点通过next来保持即可。\n\n```java\nvolatile ReferenceQueue<? super T> queue;\n```\n\nnext：指向下一个引用，Reference是一个单链表的结构。\n\n```java\nReference next;\n```\ndiscovered：表示要处理的对象的下一个对象。\n\n```java\n/* 当处于active状态: discovered链表中下一个待处理对象\n * 当处于pending状态: pending列表中的下一个对象\n * 其它状态:   NULL\n */\ntransient private Reference<T> discovered;\n```\n\nlock：内部同步锁对象。用作在操作pending链表时的同步对象。注意这是一个静态对象，意味着所有Reference对象共用同一个锁。\n\n```java\nstatic private class Lock { }\nprivate static Lock lock = new Lock();\n```\n\npending：等待添加到queue中的元素链表。注意这是一个静态对象，意味着所有Reference对象共用同一个pending队列。\n\n```java\n/* 用来保存那些需要被放入队列中的reference，收集器会把引用添加到这个列表里来，\n * Reference-handler线程会从中移除它们。\n * 这个列表由上面的lock对象锁进行保护。列表使用discovered字段来链接它的元素。\n */\nprivate static Reference<Object> pending = null;\n```\n\n> 说明\n> queue队列使用next来查找下一个reference，pending队列使用discovered来查找下一个reference。\n\n## Reference状态\n\n在Reference类中，有一段很长的注释，来对内部对象referent的状态进行了说明。\n\n> Active: \n> reference如果处于此状态，会受到垃圾处理器的特殊处理。当垃圾回收器检测到referent已经更改为合适的状态后(没有任何强引用和软引用关联)，会在某个时间将实例的状态更改为Pending或者Inactive。具体取决于实例是否在创建时注册到一个引用队列中。\n> 在前一种情况下（将状态更改为Pending），他还会将实例添加到pending-Reference列表中。新创建的实例处于活动状态。\n>\n> Pending:\n> 实例如果处于此状态，表明它是pending-Reference列表中的一个元素，等待被Reference-handler线程做入队处理。未注册引用队列的实例永远不会处于该状态。\n>\n> Enqueued: \n> 实例如果处于此状态，表明它已经是它注册的引用队列中的一个元素，当它被从引用队列中移除时，它的状态将会变为Inactive，未注册引用队列的实例永远不会处于该状态。\n>\n> Inactive: \n> 实例如果处于此状态，那么它就是个废实例了(滑稽)，它的状态将永远不会再改变了。\n\n所以实例一共有四种状态，Active（活跃状态）、Pending（半死不活状态）、Enqueued（濒死状态）、Inactive（凉凉状态）。当然，Pending和Enqueued状态是引用实例在创建时注册了引用队列才会有。\n\n一个reference处于Active状态时，表示它是活跃正常的，垃圾回收器会监视这个引用的referent，如果扫描到它没有任何强引用关联时就会进行回收判定了。\n\n如果判定为需要进行回收，则判断其是否注册了引用队列，如果有的话将reference的状态置为pending。当reference处于pending状态时，表明已经准备将它放入引用队列中，在这个状态下要处理的对象将逐个放入queue中。在这个时间窗口期，相应的引用对象为pending状态。\n\n当它进入到Enqueued状态时，表明已经引用实例已经被放到queue当中了，准备由外部线程来轮询获取相应信息。此时引用指向的对即将被垃圾回收器回收掉了。\n\n当它变成Inactive状态时，表明它已经凉透了，它的生命已经到了尽头。不管你用什么方式，也救不了它了。\n\nJVM中并没有显示定义这样的状态，而是通过next和queue来进行判断。\n\n```bash\nActive：如果创建Reference对象时，没有传入ReferenceQueue，queue=ReferenceQueue.NULL。如果有传入，则queue指向传入的ReferenceQueue队列对象。next == null；\n\nPending：queue为初始化时传入ReferenceQueue对象；next == this；\n\nEnqueue：queue == ReferenceQueue.ENQUEUED；next为queue中下一个reference对象，或者若为最后一个了next == this；\n\nInactive：queue == ReferenceQueue.NULL; next == this.\n```\n\n如果next==null，则reference处于Active状态；\n\n如果next!=null，queue == ReferenceQueue.NULL，则reference处于Inactive状态；\n\n如果next!=null，queue == ReferenceQueue.ENQUEUED，则reference处于Enqueue状态；\n\n如果next != null，queue != ReferenceQueue.NULL && queu != ReferenceQueue.ENQUEUED ，则reference处于Pending状态。\n\n{% asset_img reference-2.png Reference-relastionship %}\n\n## ReferenceHandler线程\n\nReference类中有一个特殊的线程叫ReferenceHandler，专门处理那些pending链表中的引用对象。ReferenceHandler类是Reference类的一个静态内部类，继承自Thread，所以这条线程就叫它ReferenceHandler线程。<img src=\"/images/0019.png\" width=\"50\"/>\n\n```java\nprivate static class ReferenceHandler extends Thread {\n    // 确保类已经被初始化\n    private static void ensureClassInitialized(Class<?> clazz) {\n        try {\n            Class.forName(clazz.getName(), true, clazz.getClassLoader());\n        } catch (ClassNotFoundException e) {\n            throw (Error) new NoClassDefFoundError(e.getMessage()).initCause(e);\n        }\n    }\n\n    static {\n        // 预加载并初始化 InterruptedException 和 Cleaner 类\n        // 来避免出现在循环运行过程中时由于内存不足而无法加载它们\t\t \n        ensureClassInitialized(InterruptedException.class);\n        ensureClassInitialized(Cleaner.class);\n    }\n\n    ReferenceHandler(ThreadGroup g, String name) {\n        super(g, name);\n    }\n\n    public void run() {\n        // 死循环调用\n        while (true) {\n            tryHandlePending(true);\n        }\n    }\n}\n```\n\n这个类其实也很简单，就是先预加载了两个类，然后run方法中使用了while死循环运行tryHandlerPending方法。这个方法通过名字就能大概判断，应该是来处理pending链表的，让我们看看它的内部代码：\n\n```java\nstatic {\n    ThreadGroup tg = Thread.currentThread().getThreadGroup();\n    for (ThreadGroup tgn = tg;\n         tgn != null;\n         tg = tgn, tgn = tg.getParent());\n    // 将handler线程注册到根线程组中并设置最高优先级\n    Thread handler = new ReferenceHandler(tg, \"Reference Handler\");\n    handler.setPriority(Thread.MAX_PRIORITY);\n    handler.setDaemon(true);\n    handler.start();\n\n    // 覆盖jvm的默认处理方式\n    SharedSecrets.setJavaLangRefAccess(new JavaLangRefAccess() {\n        @Override\n        public boolean tryHandlePendingReference() {\n            return tryHandlePending(false);\n        }\n    });\n}\n```\n\n这里其实就是在静态代码段里在根线程组中启动了一条最高优先级的ReferenceHandler线程，并覆盖了JVM中对pending的默认处理方式。嗯，关键点就在 tryHandlePending(false) 这一句了。接下来再看看这里的实现：\n\n```java\nstatic boolean tryHandlePending(boolean waitForNotify) {\n    Reference<Object> r;\n    Cleaner c;\n    try {\n        synchronized (lock) {\n            // 如果pending链表不为null，则开始进行处理\n            if (pending != null) {\n                r = pending;\n                // 使用 'instanceof' 有时会导致OOM\n                // 所以在将r从链表中摘除时先进行这个操作\n                c = r instanceof Cleaner ? (Cleaner) r : null;\n                // 移除头结点，将pending指向其后一个节点\n                pending = r.discovered;\n                // 此时r为原来pending链表的头结点，已经从链表中脱离出来\n                r.discovered = null;\n            } else {\n                // 在锁上等待可能会造成OOM，因为它会试图分配exception对象\n                if (waitForNotify) {\n                    lock.wait();\n                }\n                // 重试\n                return waitForNotify;\n            }\n        }\n    } catch (OutOfMemoryError x) {\n        Thread.yield();\n        // 重试\n        return true;\n    } catch (InterruptedException x) {\n        // 重试\n        return true;\n    }\n\n    // 如果摘除的元素是Cleaner类型，则执行其clean方法\n    if (c != null) {\n        c.clean();\n        return true;\n    }\n\n    ReferenceQueue<? super Object> q = r.queue;\n    // 最后，如果其引用队列不为空，则将该元素入队\n    if (q != ReferenceQueue.NULL) q.enqueue(r);\n    return true;\n}\n```\n\n所以，这里整个过程就是摘取pending链表的头结点，如果是Cleaner，则执行clean操作，否则进行入队处理。\n\n## 常用方法\n\n```java\n/**\n  * 返回引用指向的对象，如果referent已经被程序或者垃圾回收器清理，则返回null。\n  */\npublic T get() {\n    return this.referent;\n}\n\n/**\n  * 清理referent对象，调用该方法不会使得这个对象进入Enqueued状态。\n  */\npublic void clear() {\n    this.referent = null;\n}\n\n/**\n  * 判断该reference是否已经入队。\n  */\npublic boolean isEnqueued() {\n    return (this.queue == ReferenceQueue.ENQUEUED);\n}\n\n/**\n  * 将该引用添加到其注册的引用队列中。\n  * 如果reference成功入队则返回true，如果它已经在队列中或者创建时没有注册队列则返回false\n  */\npublic boolean enqueue() {\n    return this.queue.enqueue(this);\n}\n```\n\nReference类就是用来包装对象的，通过跟JVM的一些密切配合，使得被包裹其中的对象能够被JVM特殊处理，所以使用Reference对象可以使得我们在更细粒度上控制对象的生命周期。\n\n## 小结\n\n+ Reference类是所有引用类的父类\n\n+ Reference中可以在创建时注册引用队列\n\n+ Reference有四种状态，如果创建时没有注册引用队列，则只有两种状态\n\n+ 可以通过get方法获取内部的对象，但如果对象已经被回收了，则会返回null \n\n\n\n\n\n\n\n\n\n","source":"_posts/java/reference/reference-code-detail.md","raw":"---\ntitle: Reference源码详解\ntags: \n - Java\n - 引用类型\ncategories: 编程\ndate: 2018-12-29 20:10:51\n---\n\n{% asset_img reference-1.png reference-1 %}\n\n## 定义\n\n> 说明\n> Reference是所有引用类型的父类，定义了引用的公共行为和操作。\n> reference指代引用对象本身，referent指代reference引用的对象，下文介绍会以reference，referent形式出现。\n\n## 说明\n\nReference类与垃圾回收是密切配合的，所以该类不能被直接子类化。简单来讲，Reference的继承类都是经过严格设计的，甚至连成员变量的先后顺序都不能改变，所以在代码中直接继承Reference类是没有任何意义的。但是可以继承Reference类的子类。\n\n> 例如\n> Finalizer 继承自 FinalReference，Cleaner 继承自 PhantomReference\n\n## 构造函数\n\nReference类中有两个构造函数，一个需要传入引用队列，另一个则不需要。\n\n这个队列的意义在于增加一种判断机制，可以在外部通过监控这个队列来判断对象是否被回收。如果一个对象即将被回收，那么引用这个对象的reference对象就会被放到这个队列中。通过监控这个队列，就可以取出这个reference后再进行一些善后处理。<img src=\"/images/0003.png\" width=\"50\"/>\n\n如果没有这个队列，就只能通过不断地轮询reference对象，通过get方法是否返回null( phantomReference对象不能这样做，其get方法始终返回null，因此它只有带queue的构造函数 )来判断对象是否被回收。\n\n这两种方法均有相应的使用场景，具体使用需要具体情况具体分析。比如在weakHashMap中，就通过查询queue的数据，来判定是否有对象将被回收。而ThreadLocalMap，则采用判断get()是否为null来进行处理。\n\n```java\n/* -- Constructors -- */\nReference(T referent) {\n    this(referent, null);\n}\n\nReference(T referent, ReferenceQueue<? super T> queue) {\n    this.referent = referent;\n    this.queue = (queue == null) ? ReferenceQueue.NULL : queue;\n}\n```\n\n## 内部成员\n\nReference类内部有这么几个成员变量：\n\nreferent：保存reference指向的对象。\n\n``` java\nprivate T referent;\n```\n\nqueue：引用对象关联的引用队列。是对象即将被回收时所要通知的队列。当对象将被回收时，reference对象( 而不是referent引用的对象 )会被放到queue里面，然后外部程序即可通过监控这个queue拿到相应的数据了。\n\n这里的queue( 即，ReferenceQueue对象 )名义上是一个队列，实际内部是使用单链表来表示的单向队列，可以理解为queue就是一个链表，其自身仅存储当前的head节点，后面的节点由每个reference节点通过next来保持即可。\n\n```java\nvolatile ReferenceQueue<? super T> queue;\n```\n\nnext：指向下一个引用，Reference是一个单链表的结构。\n\n```java\nReference next;\n```\ndiscovered：表示要处理的对象的下一个对象。\n\n```java\n/* 当处于active状态: discovered链表中下一个待处理对象\n * 当处于pending状态: pending列表中的下一个对象\n * 其它状态:   NULL\n */\ntransient private Reference<T> discovered;\n```\n\nlock：内部同步锁对象。用作在操作pending链表时的同步对象。注意这是一个静态对象，意味着所有Reference对象共用同一个锁。\n\n```java\nstatic private class Lock { }\nprivate static Lock lock = new Lock();\n```\n\npending：等待添加到queue中的元素链表。注意这是一个静态对象，意味着所有Reference对象共用同一个pending队列。\n\n```java\n/* 用来保存那些需要被放入队列中的reference，收集器会把引用添加到这个列表里来，\n * Reference-handler线程会从中移除它们。\n * 这个列表由上面的lock对象锁进行保护。列表使用discovered字段来链接它的元素。\n */\nprivate static Reference<Object> pending = null;\n```\n\n> 说明\n> queue队列使用next来查找下一个reference，pending队列使用discovered来查找下一个reference。\n\n## Reference状态\n\n在Reference类中，有一段很长的注释，来对内部对象referent的状态进行了说明。\n\n> Active: \n> reference如果处于此状态，会受到垃圾处理器的特殊处理。当垃圾回收器检测到referent已经更改为合适的状态后(没有任何强引用和软引用关联)，会在某个时间将实例的状态更改为Pending或者Inactive。具体取决于实例是否在创建时注册到一个引用队列中。\n> 在前一种情况下（将状态更改为Pending），他还会将实例添加到pending-Reference列表中。新创建的实例处于活动状态。\n>\n> Pending:\n> 实例如果处于此状态，表明它是pending-Reference列表中的一个元素，等待被Reference-handler线程做入队处理。未注册引用队列的实例永远不会处于该状态。\n>\n> Enqueued: \n> 实例如果处于此状态，表明它已经是它注册的引用队列中的一个元素，当它被从引用队列中移除时，它的状态将会变为Inactive，未注册引用队列的实例永远不会处于该状态。\n>\n> Inactive: \n> 实例如果处于此状态，那么它就是个废实例了(滑稽)，它的状态将永远不会再改变了。\n\n所以实例一共有四种状态，Active（活跃状态）、Pending（半死不活状态）、Enqueued（濒死状态）、Inactive（凉凉状态）。当然，Pending和Enqueued状态是引用实例在创建时注册了引用队列才会有。\n\n一个reference处于Active状态时，表示它是活跃正常的，垃圾回收器会监视这个引用的referent，如果扫描到它没有任何强引用关联时就会进行回收判定了。\n\n如果判定为需要进行回收，则判断其是否注册了引用队列，如果有的话将reference的状态置为pending。当reference处于pending状态时，表明已经准备将它放入引用队列中，在这个状态下要处理的对象将逐个放入queue中。在这个时间窗口期，相应的引用对象为pending状态。\n\n当它进入到Enqueued状态时，表明已经引用实例已经被放到queue当中了，准备由外部线程来轮询获取相应信息。此时引用指向的对即将被垃圾回收器回收掉了。\n\n当它变成Inactive状态时，表明它已经凉透了，它的生命已经到了尽头。不管你用什么方式，也救不了它了。\n\nJVM中并没有显示定义这样的状态，而是通过next和queue来进行判断。\n\n```bash\nActive：如果创建Reference对象时，没有传入ReferenceQueue，queue=ReferenceQueue.NULL。如果有传入，则queue指向传入的ReferenceQueue队列对象。next == null；\n\nPending：queue为初始化时传入ReferenceQueue对象；next == this；\n\nEnqueue：queue == ReferenceQueue.ENQUEUED；next为queue中下一个reference对象，或者若为最后一个了next == this；\n\nInactive：queue == ReferenceQueue.NULL; next == this.\n```\n\n如果next==null，则reference处于Active状态；\n\n如果next!=null，queue == ReferenceQueue.NULL，则reference处于Inactive状态；\n\n如果next!=null，queue == ReferenceQueue.ENQUEUED，则reference处于Enqueue状态；\n\n如果next != null，queue != ReferenceQueue.NULL && queu != ReferenceQueue.ENQUEUED ，则reference处于Pending状态。\n\n{% asset_img reference-2.png Reference-relastionship %}\n\n## ReferenceHandler线程\n\nReference类中有一个特殊的线程叫ReferenceHandler，专门处理那些pending链表中的引用对象。ReferenceHandler类是Reference类的一个静态内部类，继承自Thread，所以这条线程就叫它ReferenceHandler线程。<img src=\"/images/0019.png\" width=\"50\"/>\n\n```java\nprivate static class ReferenceHandler extends Thread {\n    // 确保类已经被初始化\n    private static void ensureClassInitialized(Class<?> clazz) {\n        try {\n            Class.forName(clazz.getName(), true, clazz.getClassLoader());\n        } catch (ClassNotFoundException e) {\n            throw (Error) new NoClassDefFoundError(e.getMessage()).initCause(e);\n        }\n    }\n\n    static {\n        // 预加载并初始化 InterruptedException 和 Cleaner 类\n        // 来避免出现在循环运行过程中时由于内存不足而无法加载它们\t\t \n        ensureClassInitialized(InterruptedException.class);\n        ensureClassInitialized(Cleaner.class);\n    }\n\n    ReferenceHandler(ThreadGroup g, String name) {\n        super(g, name);\n    }\n\n    public void run() {\n        // 死循环调用\n        while (true) {\n            tryHandlePending(true);\n        }\n    }\n}\n```\n\n这个类其实也很简单，就是先预加载了两个类，然后run方法中使用了while死循环运行tryHandlerPending方法。这个方法通过名字就能大概判断，应该是来处理pending链表的，让我们看看它的内部代码：\n\n```java\nstatic {\n    ThreadGroup tg = Thread.currentThread().getThreadGroup();\n    for (ThreadGroup tgn = tg;\n         tgn != null;\n         tg = tgn, tgn = tg.getParent());\n    // 将handler线程注册到根线程组中并设置最高优先级\n    Thread handler = new ReferenceHandler(tg, \"Reference Handler\");\n    handler.setPriority(Thread.MAX_PRIORITY);\n    handler.setDaemon(true);\n    handler.start();\n\n    // 覆盖jvm的默认处理方式\n    SharedSecrets.setJavaLangRefAccess(new JavaLangRefAccess() {\n        @Override\n        public boolean tryHandlePendingReference() {\n            return tryHandlePending(false);\n        }\n    });\n}\n```\n\n这里其实就是在静态代码段里在根线程组中启动了一条最高优先级的ReferenceHandler线程，并覆盖了JVM中对pending的默认处理方式。嗯，关键点就在 tryHandlePending(false) 这一句了。接下来再看看这里的实现：\n\n```java\nstatic boolean tryHandlePending(boolean waitForNotify) {\n    Reference<Object> r;\n    Cleaner c;\n    try {\n        synchronized (lock) {\n            // 如果pending链表不为null，则开始进行处理\n            if (pending != null) {\n                r = pending;\n                // 使用 'instanceof' 有时会导致OOM\n                // 所以在将r从链表中摘除时先进行这个操作\n                c = r instanceof Cleaner ? (Cleaner) r : null;\n                // 移除头结点，将pending指向其后一个节点\n                pending = r.discovered;\n                // 此时r为原来pending链表的头结点，已经从链表中脱离出来\n                r.discovered = null;\n            } else {\n                // 在锁上等待可能会造成OOM，因为它会试图分配exception对象\n                if (waitForNotify) {\n                    lock.wait();\n                }\n                // 重试\n                return waitForNotify;\n            }\n        }\n    } catch (OutOfMemoryError x) {\n        Thread.yield();\n        // 重试\n        return true;\n    } catch (InterruptedException x) {\n        // 重试\n        return true;\n    }\n\n    // 如果摘除的元素是Cleaner类型，则执行其clean方法\n    if (c != null) {\n        c.clean();\n        return true;\n    }\n\n    ReferenceQueue<? super Object> q = r.queue;\n    // 最后，如果其引用队列不为空，则将该元素入队\n    if (q != ReferenceQueue.NULL) q.enqueue(r);\n    return true;\n}\n```\n\n所以，这里整个过程就是摘取pending链表的头结点，如果是Cleaner，则执行clean操作，否则进行入队处理。\n\n## 常用方法\n\n```java\n/**\n  * 返回引用指向的对象，如果referent已经被程序或者垃圾回收器清理，则返回null。\n  */\npublic T get() {\n    return this.referent;\n}\n\n/**\n  * 清理referent对象，调用该方法不会使得这个对象进入Enqueued状态。\n  */\npublic void clear() {\n    this.referent = null;\n}\n\n/**\n  * 判断该reference是否已经入队。\n  */\npublic boolean isEnqueued() {\n    return (this.queue == ReferenceQueue.ENQUEUED);\n}\n\n/**\n  * 将该引用添加到其注册的引用队列中。\n  * 如果reference成功入队则返回true，如果它已经在队列中或者创建时没有注册队列则返回false\n  */\npublic boolean enqueue() {\n    return this.queue.enqueue(this);\n}\n```\n\nReference类就是用来包装对象的，通过跟JVM的一些密切配合，使得被包裹其中的对象能够被JVM特殊处理，所以使用Reference对象可以使得我们在更细粒度上控制对象的生命周期。\n\n## 小结\n\n+ Reference类是所有引用类的父类\n\n+ Reference中可以在创建时注册引用队列\n\n+ Reference有四种状态，如果创建时没有注册引用队列，则只有两种状态\n\n+ 可以通过get方法获取内部的对象，但如果对象已经被回收了，则会返回null \n\n\n\n\n\n\n\n\n\n","slug":"java/reference/reference-code-detail","published":1,"updated":"2019-06-04T01:29:57.401Z","_id":"cjxze3gwu005t0cvw8r0uapym","comments":1,"layout":"post","photos":[],"link":"","content":"<img src=\"/programming/java/reference/reference-code-detail/reference-1.png\" title=\"reference-1\">\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><blockquote>\n<p>说明<br>Reference是所有引用类型的父类，定义了引用的公共行为和操作。<br>reference指代引用对象本身，referent指代reference引用的对象，下文介绍会以reference，referent形式出现。</p>\n</blockquote>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>Reference类与垃圾回收是密切配合的，所以该类不能被直接子类化。简单来讲，Reference的继承类都是经过严格设计的，甚至连成员变量的先后顺序都不能改变，所以在代码中直接继承Reference类是没有任何意义的。但是可以继承Reference类的子类。</p>\n<blockquote>\n<p>例如<br>Finalizer 继承自 FinalReference，Cleaner 继承自 PhantomReference</p>\n</blockquote>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>Reference类中有两个构造函数，一个需要传入引用队列，另一个则不需要。</p>\n<p>这个队列的意义在于增加一种判断机制，可以在外部通过监控这个队列来判断对象是否被回收。如果一个对象即将被回收，那么引用这个对象的reference对象就会被放到这个队列中。通过监控这个队列，就可以取出这个reference后再进行一些善后处理。<img src=\"/images/0003.png\" width=\"50\"></p>\n<p>如果没有这个队列，就只能通过不断地轮询reference对象，通过get方法是否返回null( phantomReference对象不能这样做，其get方法始终返回null，因此它只有带queue的构造函数 )来判断对象是否被回收。</p>\n<p>这两种方法均有相应的使用场景，具体使用需要具体情况具体分析。比如在weakHashMap中，就通过查询queue的数据，来判定是否有对象将被回收。而ThreadLocalMap，则采用判断get()是否为null来进行处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* -- Constructors -- */</span></span><br><span class=\"line\">Reference(T referent) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(referent, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Reference(T referent, ReferenceQueue&lt;? <span class=\"keyword\">super</span> T&gt; queue) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.referent = referent;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.queue = (queue == <span class=\"keyword\">null</span>) ? ReferenceQueue.NULL : queue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"内部成员\"><a href=\"#内部成员\" class=\"headerlink\" title=\"内部成员\"></a>内部成员</h2><p>Reference类内部有这么几个成员变量：</p>\n<p>referent：保存reference指向的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> T referent;</span><br></pre></td></tr></table></figure>\n<p>queue：引用对象关联的引用队列。是对象即将被回收时所要通知的队列。当对象将被回收时，reference对象( 而不是referent引用的对象 )会被放到queue里面，然后外部程序即可通过监控这个queue拿到相应的数据了。</p>\n<p>这里的queue( 即，ReferenceQueue对象 )名义上是一个队列，实际内部是使用单链表来表示的单向队列，可以理解为queue就是一个链表，其自身仅存储当前的head节点，后面的节点由每个reference节点通过next来保持即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">volatile</span> ReferenceQueue&lt;? <span class=\"keyword\">super</span> T&gt; queue;</span><br></pre></td></tr></table></figure>\n<p>next：指向下一个引用，Reference是一个单链表的结构。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Reference next;</span><br></pre></td></tr></table></figure>\n<p>discovered：表示要处理的对象的下一个对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 当处于active状态: discovered链表中下一个待处理对象</span></span><br><span class=\"line\"><span class=\"comment\"> * 当处于pending状态: pending列表中的下一个对象</span></span><br><span class=\"line\"><span class=\"comment\"> * 其它状态:   NULL</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">private</span> Reference&lt;T&gt; discovered;</span><br></pre></td></tr></table></figure>\n<p>lock：内部同步锁对象。用作在操作pending链表时的同步对象。注意这是一个静态对象，意味着所有Reference对象共用同一个锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Lock</span> </span>&#123; &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Lock lock = <span class=\"keyword\">new</span> Lock();</span><br></pre></td></tr></table></figure>\n<p>pending：等待添加到queue中的元素链表。注意这是一个静态对象，意味着所有Reference对象共用同一个pending队列。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 用来保存那些需要被放入队列中的reference，收集器会把引用添加到这个列表里来，</span></span><br><span class=\"line\"><span class=\"comment\"> * Reference-handler线程会从中移除它们。</span></span><br><span class=\"line\"><span class=\"comment\"> * 这个列表由上面的lock对象锁进行保护。列表使用discovered字段来链接它的元素。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Reference&lt;Object&gt; pending = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>说明<br>queue队列使用next来查找下一个reference，pending队列使用discovered来查找下一个reference。</p>\n</blockquote>\n<h2 id=\"Reference状态\"><a href=\"#Reference状态\" class=\"headerlink\" title=\"Reference状态\"></a>Reference状态</h2><p>在Reference类中，有一段很长的注释，来对内部对象referent的状态进行了说明。</p>\n<blockquote>\n<p>Active:<br>reference如果处于此状态，会受到垃圾处理器的特殊处理。当垃圾回收器检测到referent已经更改为合适的状态后(没有任何强引用和软引用关联)，会在某个时间将实例的状态更改为Pending或者Inactive。具体取决于实例是否在创建时注册到一个引用队列中。<br>在前一种情况下（将状态更改为Pending），他还会将实例添加到pending-Reference列表中。新创建的实例处于活动状态。</p>\n<p>Pending:<br>实例如果处于此状态，表明它是pending-Reference列表中的一个元素，等待被Reference-handler线程做入队处理。未注册引用队列的实例永远不会处于该状态。</p>\n<p>Enqueued:<br>实例如果处于此状态，表明它已经是它注册的引用队列中的一个元素，当它被从引用队列中移除时，它的状态将会变为Inactive，未注册引用队列的实例永远不会处于该状态。</p>\n<p>Inactive:<br>实例如果处于此状态，那么它就是个废实例了(滑稽)，它的状态将永远不会再改变了。</p>\n</blockquote>\n<p>所以实例一共有四种状态，Active（活跃状态）、Pending（半死不活状态）、Enqueued（濒死状态）、Inactive（凉凉状态）。当然，Pending和Enqueued状态是引用实例在创建时注册了引用队列才会有。</p>\n<p>一个reference处于Active状态时，表示它是活跃正常的，垃圾回收器会监视这个引用的referent，如果扫描到它没有任何强引用关联时就会进行回收判定了。</p>\n<p>如果判定为需要进行回收，则判断其是否注册了引用队列，如果有的话将reference的状态置为pending。当reference处于pending状态时，表明已经准备将它放入引用队列中，在这个状态下要处理的对象将逐个放入queue中。在这个时间窗口期，相应的引用对象为pending状态。</p>\n<p>当它进入到Enqueued状态时，表明已经引用实例已经被放到queue当中了，准备由外部线程来轮询获取相应信息。此时引用指向的对即将被垃圾回收器回收掉了。</p>\n<p>当它变成Inactive状态时，表明它已经凉透了，它的生命已经到了尽头。不管你用什么方式，也救不了它了。</p>\n<p>JVM中并没有显示定义这样的状态，而是通过next和queue来进行判断。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Active：如果创建Reference对象时，没有传入ReferenceQueue，queue=ReferenceQueue.NULL。如果有传入，则queue指向传入的ReferenceQueue队列对象。next == null；</span><br><span class=\"line\"></span><br><span class=\"line\">Pending：queue为初始化时传入ReferenceQueue对象；next == this；</span><br><span class=\"line\"></span><br><span class=\"line\">Enqueue：queue == ReferenceQueue.ENQUEUED；next为queue中下一个reference对象，或者若为最后一个了next == this；</span><br><span class=\"line\"></span><br><span class=\"line\">Inactive：queue == ReferenceQueue.NULL; next == this.</span><br></pre></td></tr></table></figure>\n<p>如果next==null，则reference处于Active状态；</p>\n<p>如果next!=null，queue == ReferenceQueue.NULL，则reference处于Inactive状态；</p>\n<p>如果next!=null，queue == ReferenceQueue.ENQUEUED，则reference处于Enqueue状态；</p>\n<p>如果next != null，queue != ReferenceQueue.NULL &amp;&amp; queu != ReferenceQueue.ENQUEUED ，则reference处于Pending状态。</p>\n<img src=\"/programming/java/reference/reference-code-detail/reference-2.png\" title=\"Reference-relastionship\">\n<h2 id=\"ReferenceHandler线程\"><a href=\"#ReferenceHandler线程\" class=\"headerlink\" title=\"ReferenceHandler线程\"></a>ReferenceHandler线程</h2><p>Reference类中有一个特殊的线程叫ReferenceHandler，专门处理那些pending链表中的引用对象。ReferenceHandler类是Reference类的一个静态内部类，继承自Thread，所以这条线程就叫它ReferenceHandler线程。<img src=\"/images/0019.png\" width=\"50\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReferenceHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 确保类已经被初始化</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureClassInitialized</span><span class=\"params\">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Class.forName(clazz.getName(), <span class=\"keyword\">true</span>, clazz.getClassLoader());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> (Error) <span class=\"keyword\">new</span> NoClassDefFoundError(e.getMessage()).initCause(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 预加载并初始化 InterruptedException 和 Cleaner 类</span></span><br><span class=\"line\">        <span class=\"comment\">// 来避免出现在循环运行过程中时由于内存不足而无法加载它们\t\t </span></span><br><span class=\"line\">        ensureClassInitialized(InterruptedException.class);</span><br><span class=\"line\">        ensureClassInitialized(Cleaner.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(g, name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 死循环调用</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            tryHandlePending(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个类其实也很简单，就是先预加载了两个类，然后run方法中使用了while死循环运行tryHandlerPending方法。这个方法通过名字就能大概判断，应该是来处理pending链表的，让我们看看它的内部代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ThreadGroup tgn = tg;</span><br><span class=\"line\">         tgn != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         tg = tgn, tgn = tg.getParent());</span><br><span class=\"line\">    <span class=\"comment\">// 将handler线程注册到根线程组中并设置最高优先级</span></span><br><span class=\"line\">    Thread handler = <span class=\"keyword\">new</span> ReferenceHandler(tg, <span class=\"string\">\"Reference Handler\"</span>);</span><br><span class=\"line\">    handler.setPriority(Thread.MAX_PRIORITY);</span><br><span class=\"line\">    handler.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    handler.start();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 覆盖jvm的默认处理方式</span></span><br><span class=\"line\">    SharedSecrets.setJavaLangRefAccess(<span class=\"keyword\">new</span> JavaLangRefAccess() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryHandlePendingReference</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> tryHandlePending(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里其实就是在静态代码段里在根线程组中启动了一条最高优先级的ReferenceHandler线程，并覆盖了JVM中对pending的默认处理方式。嗯，关键点就在 tryHandlePending(false) 这一句了。接下来再看看这里的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryHandlePending</span><span class=\"params\">(<span class=\"keyword\">boolean</span> waitForNotify)</span> </span>&#123;</span><br><span class=\"line\">    Reference&lt;Object&gt; r;</span><br><span class=\"line\">    Cleaner c;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果pending链表不为null，则开始进行处理</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pending != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                r = pending;</span><br><span class=\"line\">                <span class=\"comment\">// 使用 'instanceof' 有时会导致OOM</span></span><br><span class=\"line\">                <span class=\"comment\">// 所以在将r从链表中摘除时先进行这个操作</span></span><br><span class=\"line\">                c = r <span class=\"keyword\">instanceof</span> Cleaner ? (Cleaner) r : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 移除头结点，将pending指向其后一个节点</span></span><br><span class=\"line\">                pending = r.discovered;</span><br><span class=\"line\">                <span class=\"comment\">// 此时r为原来pending链表的头结点，已经从链表中脱离出来</span></span><br><span class=\"line\">                r.discovered = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 在锁上等待可能会造成OOM，因为它会试图分配exception对象</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (waitForNotify) &#123;</span><br><span class=\"line\">                    lock.wait();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 重试</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> waitForNotify;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (OutOfMemoryError x) &#123;</span><br><span class=\"line\">        Thread.yield();</span><br><span class=\"line\">        <span class=\"comment\">// 重试</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException x) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 重试</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果摘除的元素是Cleaner类型，则执行其clean方法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        c.clean();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ReferenceQueue&lt;? <span class=\"keyword\">super</span> Object&gt; q = r.queue;</span><br><span class=\"line\">    <span class=\"comment\">// 最后，如果其引用队列不为空，则将该元素入队</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，这里整个过程就是摘取pending链表的头结点，如果是Cleaner，则执行clean操作，否则进行入队处理。</p>\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 返回引用指向的对象，如果referent已经被程序或者垃圾回收器清理，则返回null。</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.referent;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 清理referent对象，调用该方法不会使得这个对象进入Enqueued状态。</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.referent = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 判断该reference是否已经入队。</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEnqueued</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span>.queue == ReferenceQueue.ENQUEUED);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 将该引用添加到其注册的引用队列中。</span></span><br><span class=\"line\"><span class=\"comment\">  * 如果reference成功入队则返回true，如果它已经在队列中或者创建时没有注册队列则返回false</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">enqueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.queue.enqueue(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Reference类就是用来包装对象的，通过跟JVM的一些密切配合，使得被包裹其中的对象能够被JVM特殊处理，所以使用Reference对象可以使得我们在更细粒度上控制对象的生命周期。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li><p>Reference类是所有引用类的父类</p>\n</li>\n<li><p>Reference中可以在创建时注册引用队列</p>\n</li>\n<li><p>Reference有四种状态，如果创建时没有注册引用队列，则只有两种状态</p>\n</li>\n<li><p>可以通过get方法获取内部的对象，但如果对象已经被回收了，则会返回null </p>\n</li>\n</ul>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<img src=\"/programming/java/reference/reference-code-detail/reference-1.png\" title=\"reference-1\">\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><blockquote>\n<p>说明<br>Reference是所有引用类型的父类，定义了引用的公共行为和操作。<br>reference指代引用对象本身，referent指代reference引用的对象，下文介绍会以reference，referent形式出现。</p>\n</blockquote>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>Reference类与垃圾回收是密切配合的，所以该类不能被直接子类化。简单来讲，Reference的继承类都是经过严格设计的，甚至连成员变量的先后顺序都不能改变，所以在代码中直接继承Reference类是没有任何意义的。但是可以继承Reference类的子类。</p>\n<blockquote>\n<p>例如<br>Finalizer 继承自 FinalReference，Cleaner 继承自 PhantomReference</p>\n</blockquote>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>Reference类中有两个构造函数，一个需要传入引用队列，另一个则不需要。</p>\n<p>这个队列的意义在于增加一种判断机制，可以在外部通过监控这个队列来判断对象是否被回收。如果一个对象即将被回收，那么引用这个对象的reference对象就会被放到这个队列中。通过监控这个队列，就可以取出这个reference后再进行一些善后处理。<img src=\"/images/0003.png\" width=\"50\"></p>\n<p>如果没有这个队列，就只能通过不断地轮询reference对象，通过get方法是否返回null( phantomReference对象不能这样做，其get方法始终返回null，因此它只有带queue的构造函数 )来判断对象是否被回收。</p>\n<p>这两种方法均有相应的使用场景，具体使用需要具体情况具体分析。比如在weakHashMap中，就通过查询queue的数据，来判定是否有对象将被回收。而ThreadLocalMap，则采用判断get()是否为null来进行处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* -- Constructors -- */</span></span><br><span class=\"line\">Reference(T referent) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(referent, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Reference(T referent, ReferenceQueue&lt;? <span class=\"keyword\">super</span> T&gt; queue) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.referent = referent;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.queue = (queue == <span class=\"keyword\">null</span>) ? ReferenceQueue.NULL : queue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"内部成员\"><a href=\"#内部成员\" class=\"headerlink\" title=\"内部成员\"></a>内部成员</h2><p>Reference类内部有这么几个成员变量：</p>\n<p>referent：保存reference指向的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> T referent;</span><br></pre></td></tr></table></figure>\n<p>queue：引用对象关联的引用队列。是对象即将被回收时所要通知的队列。当对象将被回收时，reference对象( 而不是referent引用的对象 )会被放到queue里面，然后外部程序即可通过监控这个queue拿到相应的数据了。</p>\n<p>这里的queue( 即，ReferenceQueue对象 )名义上是一个队列，实际内部是使用单链表来表示的单向队列，可以理解为queue就是一个链表，其自身仅存储当前的head节点，后面的节点由每个reference节点通过next来保持即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">volatile</span> ReferenceQueue&lt;? <span class=\"keyword\">super</span> T&gt; queue;</span><br></pre></td></tr></table></figure>\n<p>next：指向下一个引用，Reference是一个单链表的结构。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Reference next;</span><br></pre></td></tr></table></figure>\n<p>discovered：表示要处理的对象的下一个对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 当处于active状态: discovered链表中下一个待处理对象</span></span><br><span class=\"line\"><span class=\"comment\"> * 当处于pending状态: pending列表中的下一个对象</span></span><br><span class=\"line\"><span class=\"comment\"> * 其它状态:   NULL</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">private</span> Reference&lt;T&gt; discovered;</span><br></pre></td></tr></table></figure>\n<p>lock：内部同步锁对象。用作在操作pending链表时的同步对象。注意这是一个静态对象，意味着所有Reference对象共用同一个锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Lock</span> </span>&#123; &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Lock lock = <span class=\"keyword\">new</span> Lock();</span><br></pre></td></tr></table></figure>\n<p>pending：等待添加到queue中的元素链表。注意这是一个静态对象，意味着所有Reference对象共用同一个pending队列。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 用来保存那些需要被放入队列中的reference，收集器会把引用添加到这个列表里来，</span></span><br><span class=\"line\"><span class=\"comment\"> * Reference-handler线程会从中移除它们。</span></span><br><span class=\"line\"><span class=\"comment\"> * 这个列表由上面的lock对象锁进行保护。列表使用discovered字段来链接它的元素。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Reference&lt;Object&gt; pending = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>说明<br>queue队列使用next来查找下一个reference，pending队列使用discovered来查找下一个reference。</p>\n</blockquote>\n<h2 id=\"Reference状态\"><a href=\"#Reference状态\" class=\"headerlink\" title=\"Reference状态\"></a>Reference状态</h2><p>在Reference类中，有一段很长的注释，来对内部对象referent的状态进行了说明。</p>\n<blockquote>\n<p>Active:<br>reference如果处于此状态，会受到垃圾处理器的特殊处理。当垃圾回收器检测到referent已经更改为合适的状态后(没有任何强引用和软引用关联)，会在某个时间将实例的状态更改为Pending或者Inactive。具体取决于实例是否在创建时注册到一个引用队列中。<br>在前一种情况下（将状态更改为Pending），他还会将实例添加到pending-Reference列表中。新创建的实例处于活动状态。</p>\n<p>Pending:<br>实例如果处于此状态，表明它是pending-Reference列表中的一个元素，等待被Reference-handler线程做入队处理。未注册引用队列的实例永远不会处于该状态。</p>\n<p>Enqueued:<br>实例如果处于此状态，表明它已经是它注册的引用队列中的一个元素，当它被从引用队列中移除时，它的状态将会变为Inactive，未注册引用队列的实例永远不会处于该状态。</p>\n<p>Inactive:<br>实例如果处于此状态，那么它就是个废实例了(滑稽)，它的状态将永远不会再改变了。</p>\n</blockquote>\n<p>所以实例一共有四种状态，Active（活跃状态）、Pending（半死不活状态）、Enqueued（濒死状态）、Inactive（凉凉状态）。当然，Pending和Enqueued状态是引用实例在创建时注册了引用队列才会有。</p>\n<p>一个reference处于Active状态时，表示它是活跃正常的，垃圾回收器会监视这个引用的referent，如果扫描到它没有任何强引用关联时就会进行回收判定了。</p>\n<p>如果判定为需要进行回收，则判断其是否注册了引用队列，如果有的话将reference的状态置为pending。当reference处于pending状态时，表明已经准备将它放入引用队列中，在这个状态下要处理的对象将逐个放入queue中。在这个时间窗口期，相应的引用对象为pending状态。</p>\n<p>当它进入到Enqueued状态时，表明已经引用实例已经被放到queue当中了，准备由外部线程来轮询获取相应信息。此时引用指向的对即将被垃圾回收器回收掉了。</p>\n<p>当它变成Inactive状态时，表明它已经凉透了，它的生命已经到了尽头。不管你用什么方式，也救不了它了。</p>\n<p>JVM中并没有显示定义这样的状态，而是通过next和queue来进行判断。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Active：如果创建Reference对象时，没有传入ReferenceQueue，queue=ReferenceQueue.NULL。如果有传入，则queue指向传入的ReferenceQueue队列对象。next == null；</span><br><span class=\"line\"></span><br><span class=\"line\">Pending：queue为初始化时传入ReferenceQueue对象；next == this；</span><br><span class=\"line\"></span><br><span class=\"line\">Enqueue：queue == ReferenceQueue.ENQUEUED；next为queue中下一个reference对象，或者若为最后一个了next == this；</span><br><span class=\"line\"></span><br><span class=\"line\">Inactive：queue == ReferenceQueue.NULL; next == this.</span><br></pre></td></tr></table></figure>\n<p>如果next==null，则reference处于Active状态；</p>\n<p>如果next!=null，queue == ReferenceQueue.NULL，则reference处于Inactive状态；</p>\n<p>如果next!=null，queue == ReferenceQueue.ENQUEUED，则reference处于Enqueue状态；</p>\n<p>如果next != null，queue != ReferenceQueue.NULL &amp;&amp; queu != ReferenceQueue.ENQUEUED ，则reference处于Pending状态。</p>\n<img src=\"/programming/java/reference/reference-code-detail/reference-2.png\" title=\"Reference-relastionship\">\n<h2 id=\"ReferenceHandler线程\"><a href=\"#ReferenceHandler线程\" class=\"headerlink\" title=\"ReferenceHandler线程\"></a>ReferenceHandler线程</h2><p>Reference类中有一个特殊的线程叫ReferenceHandler，专门处理那些pending链表中的引用对象。ReferenceHandler类是Reference类的一个静态内部类，继承自Thread，所以这条线程就叫它ReferenceHandler线程。<img src=\"/images/0019.png\" width=\"50\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReferenceHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 确保类已经被初始化</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureClassInitialized</span><span class=\"params\">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Class.forName(clazz.getName(), <span class=\"keyword\">true</span>, clazz.getClassLoader());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> (Error) <span class=\"keyword\">new</span> NoClassDefFoundError(e.getMessage()).initCause(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 预加载并初始化 InterruptedException 和 Cleaner 类</span></span><br><span class=\"line\">        <span class=\"comment\">// 来避免出现在循环运行过程中时由于内存不足而无法加载它们\t\t </span></span><br><span class=\"line\">        ensureClassInitialized(InterruptedException.class);</span><br><span class=\"line\">        ensureClassInitialized(Cleaner.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(g, name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 死循环调用</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            tryHandlePending(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个类其实也很简单，就是先预加载了两个类，然后run方法中使用了while死循环运行tryHandlerPending方法。这个方法通过名字就能大概判断，应该是来处理pending链表的，让我们看看它的内部代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ThreadGroup tgn = tg;</span><br><span class=\"line\">         tgn != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         tg = tgn, tgn = tg.getParent());</span><br><span class=\"line\">    <span class=\"comment\">// 将handler线程注册到根线程组中并设置最高优先级</span></span><br><span class=\"line\">    Thread handler = <span class=\"keyword\">new</span> ReferenceHandler(tg, <span class=\"string\">\"Reference Handler\"</span>);</span><br><span class=\"line\">    handler.setPriority(Thread.MAX_PRIORITY);</span><br><span class=\"line\">    handler.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    handler.start();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 覆盖jvm的默认处理方式</span></span><br><span class=\"line\">    SharedSecrets.setJavaLangRefAccess(<span class=\"keyword\">new</span> JavaLangRefAccess() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryHandlePendingReference</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> tryHandlePending(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里其实就是在静态代码段里在根线程组中启动了一条最高优先级的ReferenceHandler线程，并覆盖了JVM中对pending的默认处理方式。嗯，关键点就在 tryHandlePending(false) 这一句了。接下来再看看这里的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryHandlePending</span><span class=\"params\">(<span class=\"keyword\">boolean</span> waitForNotify)</span> </span>&#123;</span><br><span class=\"line\">    Reference&lt;Object&gt; r;</span><br><span class=\"line\">    Cleaner c;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果pending链表不为null，则开始进行处理</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pending != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                r = pending;</span><br><span class=\"line\">                <span class=\"comment\">// 使用 'instanceof' 有时会导致OOM</span></span><br><span class=\"line\">                <span class=\"comment\">// 所以在将r从链表中摘除时先进行这个操作</span></span><br><span class=\"line\">                c = r <span class=\"keyword\">instanceof</span> Cleaner ? (Cleaner) r : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 移除头结点，将pending指向其后一个节点</span></span><br><span class=\"line\">                pending = r.discovered;</span><br><span class=\"line\">                <span class=\"comment\">// 此时r为原来pending链表的头结点，已经从链表中脱离出来</span></span><br><span class=\"line\">                r.discovered = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 在锁上等待可能会造成OOM，因为它会试图分配exception对象</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (waitForNotify) &#123;</span><br><span class=\"line\">                    lock.wait();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 重试</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> waitForNotify;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (OutOfMemoryError x) &#123;</span><br><span class=\"line\">        Thread.yield();</span><br><span class=\"line\">        <span class=\"comment\">// 重试</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException x) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 重试</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果摘除的元素是Cleaner类型，则执行其clean方法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        c.clean();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ReferenceQueue&lt;? <span class=\"keyword\">super</span> Object&gt; q = r.queue;</span><br><span class=\"line\">    <span class=\"comment\">// 最后，如果其引用队列不为空，则将该元素入队</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，这里整个过程就是摘取pending链表的头结点，如果是Cleaner，则执行clean操作，否则进行入队处理。</p>\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 返回引用指向的对象，如果referent已经被程序或者垃圾回收器清理，则返回null。</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.referent;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 清理referent对象，调用该方法不会使得这个对象进入Enqueued状态。</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.referent = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 判断该reference是否已经入队。</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEnqueued</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span>.queue == ReferenceQueue.ENQUEUED);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 将该引用添加到其注册的引用队列中。</span></span><br><span class=\"line\"><span class=\"comment\">  * 如果reference成功入队则返回true，如果它已经在队列中或者创建时没有注册队列则返回false</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">enqueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.queue.enqueue(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Reference类就是用来包装对象的，通过跟JVM的一些密切配合，使得被包裹其中的对象能够被JVM特殊处理，所以使用Reference对象可以使得我们在更细粒度上控制对象的生命周期。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li><p>Reference类是所有引用类的父类</p>\n</li>\n<li><p>Reference中可以在创建时注册引用队列</p>\n</li>\n<li><p>Reference有四种状态，如果创建时没有注册引用队列，则只有两种状态</p>\n</li>\n<li><p>可以通过get方法获取内部的对象，但如果对象已经被回收了，则会返回null </p>\n</li>\n</ul>\n"},{"title":"软引用","date":"2018-12-29T12:20:51.000Z","_content":"\n## 定义\n\n软引用是使用SoftReference创建的引用，强度弱于强引用，被其引用的对象在内存不足的时候会被回收，不会产生内存溢出。\n\n## 说明\n\n软引用，顾名思义就是比较“软”一点的引用。<img src=\"/images/0003.png\" width=\"50\"/>\n\n当一个对象与GC Roots之间存在强引用时，无论何时都不会被GC回收掉。如果一个对象与GC Roots之间没有强引用与其关联而存在软引用关联时，那么垃圾回收器对它的态度就取决于内存的紧张程度了。如果内存空间足够，垃圾回收器就不会回收这个对象，但如果内存空间不足了，它就难逃被回收的厄运。<img src=\"/images/0005.png\" width=\"50\"/>\n\n> 软可达\n> 如果一个对象与GC Roots之间不存在强引用，但是存在软引用，则称这个对象为`软可达（soft reachable）`对象。\n\n在垃圾回收器没有回收它的时候，软可达对象就像强可达对象一样，可以被程序正常访问和使用，但是需要通过软引用对象间接访问，需要的话也能重新使用强引用将其关联。所以软引用适合用来做内存敏感的高速缓存。\n\n```java\nString s = new String(\"Frank\");    // 创建强引用与String对象关联，现在该String对象为强可达状态\nSoftReference<String> softRef = new SoftReference<String>(s);     // 再创建一个软引用关联该对象\ns = null;        // 消除强引用，现在只剩下软引用与其关联，该String对象为软可达状态\ns = softRef.get();  // 重新关联上强引用\n```\n\n这里变量s持有对字符串对象的强引用，而softRef持有对该对象的软引用，所以当执行s = null后，字符串对象就只剩下软引用了，这时如果因为内存不足发生Full GC，就会把这个字符串对象回收掉。\n\n> 注意\n> 在垃圾回收器回收一个对象前，SoftReference类所提供的get方法会返回Java对象的强引用，一旦垃圾线程回收该对象之后，get方法将返回null。所以在获取软引用对象的代码中，一定要先判断返回是否为null，以免出现NullPointerException异常而导致应用崩溃。<img src=\"/images/2030.png\" width=\"50\"/>\n\n下面的代码会让s再次持有对象的强引用：\n\n```java\ns = softRef.get();\n```\n\n如果在softRef指向的对象被回收前，用强引用指向该对象，那这个对象又会变成强可达。\n\n来看一个使用SoftReference的栗子：\n\n```java\npublic class TestA {\n    static class OOMClass{\n        private int[] oom = new int[1024 * 100];// 100KB\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        ReferenceQueue<OOMClass> queue = new ReferenceQueue<>();\n        List<SoftReference> list = new ArrayList<>();\n        while(true){\n            for (int i = 0; i < 100; i++) {\n                list.add(new SoftReference<OOMClass>(new OOMClass(), queue));\n            }\n            Thread.sleep(500);\n        }\n    }\n}\n```\n\n> 注意\n> ReferenceQueue中声明的类型为OOMClass，即与SoftReference引用的类型一致。\n\n设置一下虚拟机参数：\n\n```bash\n-verbose:gc -Xms4m -Xmx4m -Xmn2m\n```\n\n运行结果：\n\n```bash\n[GC (Allocation Failure)  1017K->432K(3584K), 0.0017239 secs]\n[GC (Allocation Failure)  1072K->472K(3584K), 0.0099237 secs]\n[GC (Allocation Failure)  1323K->1296K(3584K), 0.0009528 secs]\n[GC (Allocation Failure)  2114K->2136K(3584K), 0.0009951 secs]\n[Full GC (Ergonomics)  2136K->1992K(3584K), 0.0040658 secs]\n[Full GC (Ergonomics)  2807K->2791K(3584K), 0.0036280 secs]\n[Full GC (Allocation Failure)  2791K->373K(3584K), 0.0032477 secs]\n[Full GC (Ergonomics)  2786K->2773K(3584K), 0.0034554 secs]\n[Full GC (Allocation Failure)  2773K->373K(3584K), 0.0032667 secs]\n[Full GC (Ergonomics)  2798K->2775K(3584K), 0.0036231 secs]\n[Full GC (Allocation Failure)  2775K->375K(3584K), 0.0055482 secs]\n[Full GC (Ergonomics)  2799K->2776K(3584K), 0.0031358 secs]\n...省略n次GC信息\n```\n\n在TestA中，我们使用死循环不断的往list中添加新对象，如果是强引用，会很快因为内存不足而抛出OOM，因为这里的堆内存大小设置为了4M，而一个对象就有100KB，一个循环添加100个对象，也就是差不多10M，显然一个循环都跑不完就会内存不足，而这里，因为使用的是软引用，所以JVM会在内存不足的时候将软引用回收掉。\n\n```bash\n[Full GC (Allocation Failure)  2791K->373K(3584K), 0.0032477 secs]\n```\n\n从这一条可以看出，在内存不足发生Full GC时，回收掉了大部分的软引用指向的对象，释放了大量的内存。\n\n因为这里新生代只分配了2M，所以很快就会发生GC，如果你的程序运行没有看到这个结果，请先确认一下虚拟机参数是否设置正确，如果设置正确还是没有看到，那么将循环次数由1000改为10000或者100000在试试看。<img src=\"/images/141.png\" width=\"50\"/>\n\n## 应用场景\n\n软引用关联的对象，只有在内存不足的时候JVM才会回收该对象。这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。 \n\n现在考虑这样一个场景 ，在很多应用中，都会出现大量的默认图片，比如说QQ的默认头像，应用内的默认图标等等，这些图片很多地方会用到。\n\n如果每次都去读取图片，由于读取文件速度较慢，大量重复的读取会导致性能下降。所以可以考虑将图片缓存起来，需要的时候直接从内存中读取。但是，由于图片占用内存空间比较大，缓存的图片过多会占用比较多的内存，就可能比较容易发生OOM。这时候，软引用就派得上用场了。<img src=\"/images/0009.png\" width=\"50\"/>\n\n> 注意\n> SoftReference对象是用来保存软引用的，但它同时也是一个Java对象。所以，当软可及对象被回收之后，虽然这个SoftReference对象的get()方法返回null，但SoftReference对象本身并不是null，而此时这个SoftReference对象已经不再具有存在的价值，需要一个适当的清除机制，避免大量SoftReference对象带来的内存泄漏。\n\nReferenceQueue就是用来保存这些需要被清理的引用对象的。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。\n\n下面用SoftReference来实现一个简单的缓存类：\n\n```java\npublic class SoftCache<T> {\n    // 引用队列\n    private ReferenceQueue<T> referenceQueue = new ReferenceQueue<>();\n    // 保存软引用集合，在引用对象被回收后销毁\n    private List<Reference<T>> list = new ArrayList<>();\n\n    // 添加缓存对象\n    public synchronized void add(T obj){\n        // 构建软引用\n        Reference<T> reference = new SoftReference<T>(obj, referenceQueue);\n        // 加入列表中\n        list.add(reference);\n    }\n\n    // 获取缓存对象\n    public synchronized T get(int index){\n        // 先对无效引用进行清理\n        clear();\n        if (index < 0 || list.size() < index){\n            return null;\n        }\n        Reference<T> reference = list.get(index);\n        return reference == null ? null : reference.get();\n    }\n\n    public int size(){\n        return list.size();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void clear(){\n        Reference<T> reference;\n        while (null != (reference = (Reference<T>) referenceQueue.poll())){\n            list.remove(reference);\n        }\n    }\n}\n```\n\n然后测试一下这个缓存类：\n\n```java\npublic class SoftCacheTest {\n    private static int num = 0;\n\n    public static void main(String[] args){\n        SoftCache<OOMClass> softCache = new SoftCache<>();\n        for (int i = 0; i < 40; i++) {\n            softCache.add(new OOMClass(\"OOM Obj-\" + ++num));\n        }\n        System.out.println(softCache.size());\n        for (int i = 0; i < softCache.size(); i++) {\n            OOMClass obj = softCache.get(i);\n            System.out.println(obj == null ? \"null\" : obj.name);\n        }\n        System.out.println(softCache.size());\n    }\n\n    static class OOMClass{\n        private String name;\n        private int[] oom = new int[1024 * 100];// 100KB\n\n        public OOMClass(String name) {\n            this.name = name;\n        }\n    }\n}\n```\n\n仍使用之前的虚拟机参数：\n\n```bash\n-verbose:gc -Xms4m -Xmx4m -Xmn2m\n```\n\n运行结果：\n\n```java\n[GC (Allocation Failure)  1017K->432K(3584K), 0.0012236 secs]\n[GC (Allocation Failure)  1117K->496K(3584K), 0.0016875 secs]\n[GC (Allocation Failure)  1347K->1229K(3584K), 0.0015059 secs]\n[GC (Allocation Failure)  2047K->2125K(3584K), 0.0018090 secs]\n[Full GC (Ergonomics)  2125K->1994K(3584K), 0.0054759 secs]\n[Full GC (Ergonomics)  2822K->2794K(3584K), 0.0023167 secs]\n[Full GC (Allocation Failure)  2794K->376K(3584K), 0.0036056 secs]\n[Full GC (Ergonomics)  2795K->2776K(3584K), 0.0042365 secs]\n[Full GC (Allocation Failure)  2776K->376K(3584K), 0.0035122 secs]\n[Full GC (Ergonomics)  2795K->2776K(3584K), 0.0054760 secs]\n[Full GC (Allocation Failure)  2776K->376K(3584K), 0.0036965 secs]\n[Full GC (Ergonomics)  2802K->2777K(3584K), 0.0044513 secs]\n[Full GC (Allocation Failure)  2777K->376K(3584K), 0.0041400 secs]\n[Full GC (Ergonomics)  2796K->2777K(3584K), 0.0025255 secs]\n[Full GC (Allocation Failure)  2777K->376K(3584K), 0.0037690 secs]\n[Full GC (Ergonomics)  2817K->2777K(3584K), 0.0037759 secs]\n[Full GC (Allocation Failure)  2777K->377K(3584K), 0.0042416 secs]\n缓存列表大小：40\nOOM Obj-37\nOOM Obj-38\nOOM Obj-39\nOOM Obj-40\n缓存列表大小：4\n```\n\n可以看到，缓存40个软引用对象之后，如果一次性全部存储，显然内存大小无法满足，所以在不断创建软引用对象的过程中，不断发生GC来进行垃圾回收，最终只有4个软引用未被清理掉。\n\n## 强引用与软引用对比\n\n没有对比就没有伤害，来将强引用和软引用对比一下：\n\n```java\npublic class Test {\n\n    static class OOMClass{\n        private int[] oom = new int[1024];\n    }\n\n    public static void main(String[] args) {\n        testStrongReference();\n        //testSoftReference();\n    }\n\n    public static void testStrongReference(){\n        List<OOMClass> list = new ArrayList<>();\n        for (int i = 0; i < 1000; i++) {\n            list.add(new OOMClass());\n        }\n    }\n\n    public static void testSoftReference(){\n        ReferenceQueue<OOMClass> referenceQueue = new ReferenceQueue<>();\n        List<SoftReference> list = new ArrayList<>();\n        for (int i = 0; i < 1000; i++) {\n            OOMClass oomClass = new OOMClass();\n            list.add(new SoftReference(oomClass, referenceQueue));\n            oomClass = null;\n        }\n    }\n}\n```\n\n运行testStrongReference方法的结果如下：\n\n```java\n[GC (Allocation Failure)  1019K->384K(3584K), 0.0033595 secs]\n[GC (Allocation Failure)  1406K->856K(3584K), 0.0013098 secs]\n[GC (Allocation Failure)  1880K->1836K(3584K), 0.0014382 secs]\n[Full GC (Ergonomics)  1836K->1756K(3584K), 0.0039761 secs]\n[Full GC (Ergonomics)  2778K->2758K(3584K), 0.0021269 secs]\n[Full GC (Ergonomics)  2779K->2770K(3584K), 0.0016329 secs]\n[Full GC (Ergonomics)  2779K->2775K(3584K), 0.0023157 secs]\n[Full GC (Ergonomics)  2775K->2775K(3584K), 0.0015927 secs]\n[Full GC (Ergonomics)  3037K->3029K(3584K), 0.0025071 secs]\n[Full GC (Ergonomics)  3067K->3065K(3584K), 0.0017529 secs]\n[Full GC (Allocation Failure)  3065K->3047K(3584K), 0.0033445 secs]\n[Full GC (Ergonomics)  3068K->3059K(3584K), 0.0016623 secs]\n[Full GC (Ergonomics)  3070K->3068K(3584K), 0.0028357 secs]\n[Full GC (Allocation Failure)  3068K->3068K(3584K), 0.0017616 secs]\njava.lang.OutOfMemoryError: Java heap space\nDumping heap to java_pid3352.hprof ...\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\nHeap dump file created [3855956 bytes in 0.017 secs]\n[Full GC (Ergonomics)  3071K->376K(3584K), 0.0032068 secs]\n\tat reference.Test$OOMClass.<init>(Test.java:11)\n\tat reference.Test.testStrongReference(Test.java:22)\n\tat reference.Test.main(Test.java:15)\n\nProcess finished with exit code 1\n```\n\n可以看到，很快就抛出了OOM，原因是Java heap space，也就是堆内存不足。\n\n如果运行testSoftReference方法，将会得到如下结果：\n\n```java\n[GC (Allocation Failure)  1019K->464K(3584K), 0.0019850 secs]\n[GC (Allocation Failure)  1484K->844K(3584K), 0.0015920 secs]\n[GC (Allocation Failure)  1868K->1860K(3584K), 0.0043236 secs]\n[Full GC (Ergonomics)  1860K->1781K(3584K), 0.0044581 secs]\n[Full GC (Ergonomics)  2802K->2754K(3584K), 0.0041726 secs]\n[Full GC (Ergonomics)  2802K->2799K(3584K), 0.0031293 secs]\n[Full GC (Ergonomics)  3023K->3023K(3584K), 0.0024830 secs]\n[Full GC (Ergonomics)  3071K->3068K(3584K), 0.0035025 secs]\n[Full GC (Allocation Failure)  3068K->405K(3584K), 0.0040672 secs]\n[GC (Allocation Failure)  1512K->1567K(3584K), 0.0011170 secs]\n[Full GC (Ergonomics)  1567K->1496K(3584K), 0.0048438 secs]\n```\n\n可以看到，并没有抛出OOM，而是进行多次了GC，可以明显的看到这一条：\n\n```bash\n[Full GC (Allocation Failure)  3068K->405K(3584K), 0.0040672 secs]\n```\n\n当内存不足时进行了一次Full GC，回收了大部分内存空间，也就是将大部分软引用指向的对象回收掉了。\n\n## 小结\n\n+ 软引用弱于强引用\n+ 软引用指向的对象会在内存不足时被垃圾回收清理掉\n+ JVM会优先回收长时间闲置不用的软引用对象，对那些刚刚构建的或刚刚使用过的软引用对象会尽可能保留\n+ 软引用可以有效的解决OOM问题\n+ 软引用适合用作非必须大对象的缓存\n\n至此，本篇就告一段落了，这里只简单的介绍了软引用的作用以及用法。其实软引用并没有这么好，它的使用有一些可能是致命的缺点，如果想要更深入的了解软引用的运行原理以及软引用到底是在何时进行回收，又是如何进行回收的话，可以查看翻阅后续的章节。 \n\n\n\n","source":"_posts/java/reference/soft-reference.md","raw":"---\ntitle: 软引用\ntags: \n - Java\n - 引用类型\ncategories: 编程\ndate: 2018-12-29 20:20:51\n---\n\n## 定义\n\n软引用是使用SoftReference创建的引用，强度弱于强引用，被其引用的对象在内存不足的时候会被回收，不会产生内存溢出。\n\n## 说明\n\n软引用，顾名思义就是比较“软”一点的引用。<img src=\"/images/0003.png\" width=\"50\"/>\n\n当一个对象与GC Roots之间存在强引用时，无论何时都不会被GC回收掉。如果一个对象与GC Roots之间没有强引用与其关联而存在软引用关联时，那么垃圾回收器对它的态度就取决于内存的紧张程度了。如果内存空间足够，垃圾回收器就不会回收这个对象，但如果内存空间不足了，它就难逃被回收的厄运。<img src=\"/images/0005.png\" width=\"50\"/>\n\n> 软可达\n> 如果一个对象与GC Roots之间不存在强引用，但是存在软引用，则称这个对象为`软可达（soft reachable）`对象。\n\n在垃圾回收器没有回收它的时候，软可达对象就像强可达对象一样，可以被程序正常访问和使用，但是需要通过软引用对象间接访问，需要的话也能重新使用强引用将其关联。所以软引用适合用来做内存敏感的高速缓存。\n\n```java\nString s = new String(\"Frank\");    // 创建强引用与String对象关联，现在该String对象为强可达状态\nSoftReference<String> softRef = new SoftReference<String>(s);     // 再创建一个软引用关联该对象\ns = null;        // 消除强引用，现在只剩下软引用与其关联，该String对象为软可达状态\ns = softRef.get();  // 重新关联上强引用\n```\n\n这里变量s持有对字符串对象的强引用，而softRef持有对该对象的软引用，所以当执行s = null后，字符串对象就只剩下软引用了，这时如果因为内存不足发生Full GC，就会把这个字符串对象回收掉。\n\n> 注意\n> 在垃圾回收器回收一个对象前，SoftReference类所提供的get方法会返回Java对象的强引用，一旦垃圾线程回收该对象之后，get方法将返回null。所以在获取软引用对象的代码中，一定要先判断返回是否为null，以免出现NullPointerException异常而导致应用崩溃。<img src=\"/images/2030.png\" width=\"50\"/>\n\n下面的代码会让s再次持有对象的强引用：\n\n```java\ns = softRef.get();\n```\n\n如果在softRef指向的对象被回收前，用强引用指向该对象，那这个对象又会变成强可达。\n\n来看一个使用SoftReference的栗子：\n\n```java\npublic class TestA {\n    static class OOMClass{\n        private int[] oom = new int[1024 * 100];// 100KB\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        ReferenceQueue<OOMClass> queue = new ReferenceQueue<>();\n        List<SoftReference> list = new ArrayList<>();\n        while(true){\n            for (int i = 0; i < 100; i++) {\n                list.add(new SoftReference<OOMClass>(new OOMClass(), queue));\n            }\n            Thread.sleep(500);\n        }\n    }\n}\n```\n\n> 注意\n> ReferenceQueue中声明的类型为OOMClass，即与SoftReference引用的类型一致。\n\n设置一下虚拟机参数：\n\n```bash\n-verbose:gc -Xms4m -Xmx4m -Xmn2m\n```\n\n运行结果：\n\n```bash\n[GC (Allocation Failure)  1017K->432K(3584K), 0.0017239 secs]\n[GC (Allocation Failure)  1072K->472K(3584K), 0.0099237 secs]\n[GC (Allocation Failure)  1323K->1296K(3584K), 0.0009528 secs]\n[GC (Allocation Failure)  2114K->2136K(3584K), 0.0009951 secs]\n[Full GC (Ergonomics)  2136K->1992K(3584K), 0.0040658 secs]\n[Full GC (Ergonomics)  2807K->2791K(3584K), 0.0036280 secs]\n[Full GC (Allocation Failure)  2791K->373K(3584K), 0.0032477 secs]\n[Full GC (Ergonomics)  2786K->2773K(3584K), 0.0034554 secs]\n[Full GC (Allocation Failure)  2773K->373K(3584K), 0.0032667 secs]\n[Full GC (Ergonomics)  2798K->2775K(3584K), 0.0036231 secs]\n[Full GC (Allocation Failure)  2775K->375K(3584K), 0.0055482 secs]\n[Full GC (Ergonomics)  2799K->2776K(3584K), 0.0031358 secs]\n...省略n次GC信息\n```\n\n在TestA中，我们使用死循环不断的往list中添加新对象，如果是强引用，会很快因为内存不足而抛出OOM，因为这里的堆内存大小设置为了4M，而一个对象就有100KB，一个循环添加100个对象，也就是差不多10M，显然一个循环都跑不完就会内存不足，而这里，因为使用的是软引用，所以JVM会在内存不足的时候将软引用回收掉。\n\n```bash\n[Full GC (Allocation Failure)  2791K->373K(3584K), 0.0032477 secs]\n```\n\n从这一条可以看出，在内存不足发生Full GC时，回收掉了大部分的软引用指向的对象，释放了大量的内存。\n\n因为这里新生代只分配了2M，所以很快就会发生GC，如果你的程序运行没有看到这个结果，请先确认一下虚拟机参数是否设置正确，如果设置正确还是没有看到，那么将循环次数由1000改为10000或者100000在试试看。<img src=\"/images/141.png\" width=\"50\"/>\n\n## 应用场景\n\n软引用关联的对象，只有在内存不足的时候JVM才会回收该对象。这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。 \n\n现在考虑这样一个场景 ，在很多应用中，都会出现大量的默认图片，比如说QQ的默认头像，应用内的默认图标等等，这些图片很多地方会用到。\n\n如果每次都去读取图片，由于读取文件速度较慢，大量重复的读取会导致性能下降。所以可以考虑将图片缓存起来，需要的时候直接从内存中读取。但是，由于图片占用内存空间比较大，缓存的图片过多会占用比较多的内存，就可能比较容易发生OOM。这时候，软引用就派得上用场了。<img src=\"/images/0009.png\" width=\"50\"/>\n\n> 注意\n> SoftReference对象是用来保存软引用的，但它同时也是一个Java对象。所以，当软可及对象被回收之后，虽然这个SoftReference对象的get()方法返回null，但SoftReference对象本身并不是null，而此时这个SoftReference对象已经不再具有存在的价值，需要一个适当的清除机制，避免大量SoftReference对象带来的内存泄漏。\n\nReferenceQueue就是用来保存这些需要被清理的引用对象的。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。\n\n下面用SoftReference来实现一个简单的缓存类：\n\n```java\npublic class SoftCache<T> {\n    // 引用队列\n    private ReferenceQueue<T> referenceQueue = new ReferenceQueue<>();\n    // 保存软引用集合，在引用对象被回收后销毁\n    private List<Reference<T>> list = new ArrayList<>();\n\n    // 添加缓存对象\n    public synchronized void add(T obj){\n        // 构建软引用\n        Reference<T> reference = new SoftReference<T>(obj, referenceQueue);\n        // 加入列表中\n        list.add(reference);\n    }\n\n    // 获取缓存对象\n    public synchronized T get(int index){\n        // 先对无效引用进行清理\n        clear();\n        if (index < 0 || list.size() < index){\n            return null;\n        }\n        Reference<T> reference = list.get(index);\n        return reference == null ? null : reference.get();\n    }\n\n    public int size(){\n        return list.size();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void clear(){\n        Reference<T> reference;\n        while (null != (reference = (Reference<T>) referenceQueue.poll())){\n            list.remove(reference);\n        }\n    }\n}\n```\n\n然后测试一下这个缓存类：\n\n```java\npublic class SoftCacheTest {\n    private static int num = 0;\n\n    public static void main(String[] args){\n        SoftCache<OOMClass> softCache = new SoftCache<>();\n        for (int i = 0; i < 40; i++) {\n            softCache.add(new OOMClass(\"OOM Obj-\" + ++num));\n        }\n        System.out.println(softCache.size());\n        for (int i = 0; i < softCache.size(); i++) {\n            OOMClass obj = softCache.get(i);\n            System.out.println(obj == null ? \"null\" : obj.name);\n        }\n        System.out.println(softCache.size());\n    }\n\n    static class OOMClass{\n        private String name;\n        private int[] oom = new int[1024 * 100];// 100KB\n\n        public OOMClass(String name) {\n            this.name = name;\n        }\n    }\n}\n```\n\n仍使用之前的虚拟机参数：\n\n```bash\n-verbose:gc -Xms4m -Xmx4m -Xmn2m\n```\n\n运行结果：\n\n```java\n[GC (Allocation Failure)  1017K->432K(3584K), 0.0012236 secs]\n[GC (Allocation Failure)  1117K->496K(3584K), 0.0016875 secs]\n[GC (Allocation Failure)  1347K->1229K(3584K), 0.0015059 secs]\n[GC (Allocation Failure)  2047K->2125K(3584K), 0.0018090 secs]\n[Full GC (Ergonomics)  2125K->1994K(3584K), 0.0054759 secs]\n[Full GC (Ergonomics)  2822K->2794K(3584K), 0.0023167 secs]\n[Full GC (Allocation Failure)  2794K->376K(3584K), 0.0036056 secs]\n[Full GC (Ergonomics)  2795K->2776K(3584K), 0.0042365 secs]\n[Full GC (Allocation Failure)  2776K->376K(3584K), 0.0035122 secs]\n[Full GC (Ergonomics)  2795K->2776K(3584K), 0.0054760 secs]\n[Full GC (Allocation Failure)  2776K->376K(3584K), 0.0036965 secs]\n[Full GC (Ergonomics)  2802K->2777K(3584K), 0.0044513 secs]\n[Full GC (Allocation Failure)  2777K->376K(3584K), 0.0041400 secs]\n[Full GC (Ergonomics)  2796K->2777K(3584K), 0.0025255 secs]\n[Full GC (Allocation Failure)  2777K->376K(3584K), 0.0037690 secs]\n[Full GC (Ergonomics)  2817K->2777K(3584K), 0.0037759 secs]\n[Full GC (Allocation Failure)  2777K->377K(3584K), 0.0042416 secs]\n缓存列表大小：40\nOOM Obj-37\nOOM Obj-38\nOOM Obj-39\nOOM Obj-40\n缓存列表大小：4\n```\n\n可以看到，缓存40个软引用对象之后，如果一次性全部存储，显然内存大小无法满足，所以在不断创建软引用对象的过程中，不断发生GC来进行垃圾回收，最终只有4个软引用未被清理掉。\n\n## 强引用与软引用对比\n\n没有对比就没有伤害，来将强引用和软引用对比一下：\n\n```java\npublic class Test {\n\n    static class OOMClass{\n        private int[] oom = new int[1024];\n    }\n\n    public static void main(String[] args) {\n        testStrongReference();\n        //testSoftReference();\n    }\n\n    public static void testStrongReference(){\n        List<OOMClass> list = new ArrayList<>();\n        for (int i = 0; i < 1000; i++) {\n            list.add(new OOMClass());\n        }\n    }\n\n    public static void testSoftReference(){\n        ReferenceQueue<OOMClass> referenceQueue = new ReferenceQueue<>();\n        List<SoftReference> list = new ArrayList<>();\n        for (int i = 0; i < 1000; i++) {\n            OOMClass oomClass = new OOMClass();\n            list.add(new SoftReference(oomClass, referenceQueue));\n            oomClass = null;\n        }\n    }\n}\n```\n\n运行testStrongReference方法的结果如下：\n\n```java\n[GC (Allocation Failure)  1019K->384K(3584K), 0.0033595 secs]\n[GC (Allocation Failure)  1406K->856K(3584K), 0.0013098 secs]\n[GC (Allocation Failure)  1880K->1836K(3584K), 0.0014382 secs]\n[Full GC (Ergonomics)  1836K->1756K(3584K), 0.0039761 secs]\n[Full GC (Ergonomics)  2778K->2758K(3584K), 0.0021269 secs]\n[Full GC (Ergonomics)  2779K->2770K(3584K), 0.0016329 secs]\n[Full GC (Ergonomics)  2779K->2775K(3584K), 0.0023157 secs]\n[Full GC (Ergonomics)  2775K->2775K(3584K), 0.0015927 secs]\n[Full GC (Ergonomics)  3037K->3029K(3584K), 0.0025071 secs]\n[Full GC (Ergonomics)  3067K->3065K(3584K), 0.0017529 secs]\n[Full GC (Allocation Failure)  3065K->3047K(3584K), 0.0033445 secs]\n[Full GC (Ergonomics)  3068K->3059K(3584K), 0.0016623 secs]\n[Full GC (Ergonomics)  3070K->3068K(3584K), 0.0028357 secs]\n[Full GC (Allocation Failure)  3068K->3068K(3584K), 0.0017616 secs]\njava.lang.OutOfMemoryError: Java heap space\nDumping heap to java_pid3352.hprof ...\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\nHeap dump file created [3855956 bytes in 0.017 secs]\n[Full GC (Ergonomics)  3071K->376K(3584K), 0.0032068 secs]\n\tat reference.Test$OOMClass.<init>(Test.java:11)\n\tat reference.Test.testStrongReference(Test.java:22)\n\tat reference.Test.main(Test.java:15)\n\nProcess finished with exit code 1\n```\n\n可以看到，很快就抛出了OOM，原因是Java heap space，也就是堆内存不足。\n\n如果运行testSoftReference方法，将会得到如下结果：\n\n```java\n[GC (Allocation Failure)  1019K->464K(3584K), 0.0019850 secs]\n[GC (Allocation Failure)  1484K->844K(3584K), 0.0015920 secs]\n[GC (Allocation Failure)  1868K->1860K(3584K), 0.0043236 secs]\n[Full GC (Ergonomics)  1860K->1781K(3584K), 0.0044581 secs]\n[Full GC (Ergonomics)  2802K->2754K(3584K), 0.0041726 secs]\n[Full GC (Ergonomics)  2802K->2799K(3584K), 0.0031293 secs]\n[Full GC (Ergonomics)  3023K->3023K(3584K), 0.0024830 secs]\n[Full GC (Ergonomics)  3071K->3068K(3584K), 0.0035025 secs]\n[Full GC (Allocation Failure)  3068K->405K(3584K), 0.0040672 secs]\n[GC (Allocation Failure)  1512K->1567K(3584K), 0.0011170 secs]\n[Full GC (Ergonomics)  1567K->1496K(3584K), 0.0048438 secs]\n```\n\n可以看到，并没有抛出OOM，而是进行多次了GC，可以明显的看到这一条：\n\n```bash\n[Full GC (Allocation Failure)  3068K->405K(3584K), 0.0040672 secs]\n```\n\n当内存不足时进行了一次Full GC，回收了大部分内存空间，也就是将大部分软引用指向的对象回收掉了。\n\n## 小结\n\n+ 软引用弱于强引用\n+ 软引用指向的对象会在内存不足时被垃圾回收清理掉\n+ JVM会优先回收长时间闲置不用的软引用对象，对那些刚刚构建的或刚刚使用过的软引用对象会尽可能保留\n+ 软引用可以有效的解决OOM问题\n+ 软引用适合用作非必须大对象的缓存\n\n至此，本篇就告一段落了，这里只简单的介绍了软引用的作用以及用法。其实软引用并没有这么好，它的使用有一些可能是致命的缺点，如果想要更深入的了解软引用的运行原理以及软引用到底是在何时进行回收，又是如何进行回收的话，可以查看翻阅后续的章节。 \n\n\n\n","slug":"java/reference/soft-reference","published":1,"updated":"2019-06-04T01:29:57.413Z","_id":"cjxze3gx4005x0cvwc2nksy7c","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>软引用是使用SoftReference创建的引用，强度弱于强引用，被其引用的对象在内存不足的时候会被回收，不会产生内存溢出。</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>软引用，顾名思义就是比较“软”一点的引用。<img src=\"/images/0003.png\" width=\"50\"></p>\n<p>当一个对象与GC Roots之间存在强引用时，无论何时都不会被GC回收掉。如果一个对象与GC Roots之间没有强引用与其关联而存在软引用关联时，那么垃圾回收器对它的态度就取决于内存的紧张程度了。如果内存空间足够，垃圾回收器就不会回收这个对象，但如果内存空间不足了，它就难逃被回收的厄运。<img src=\"/images/0005.png\" width=\"50\"></p>\n<blockquote>\n<p>软可达<br>如果一个对象与GC Roots之间不存在强引用，但是存在软引用，则称这个对象为<code>软可达（soft reachable）</code>对象。</p>\n</blockquote>\n<p>在垃圾回收器没有回收它的时候，软可达对象就像强可达对象一样，可以被程序正常访问和使用，但是需要通过软引用对象间接访问，需要的话也能重新使用强引用将其关联。所以软引用适合用来做内存敏感的高速缓存。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"keyword\">new</span> String(<span class=\"string\">\"Frank\"</span>);    <span class=\"comment\">// 创建强引用与String对象关联，现在该String对象为强可达状态</span></span><br><span class=\"line\">SoftReference&lt;String&gt; softRef = <span class=\"keyword\">new</span> SoftReference&lt;String&gt;(s);     <span class=\"comment\">// 再创建一个软引用关联该对象</span></span><br><span class=\"line\">s = <span class=\"keyword\">null</span>;        <span class=\"comment\">// 消除强引用，现在只剩下软引用与其关联，该String对象为软可达状态</span></span><br><span class=\"line\">s = softRef.get();  <span class=\"comment\">// 重新关联上强引用</span></span><br></pre></td></tr></table></figure>\n<p>这里变量s持有对字符串对象的强引用，而softRef持有对该对象的软引用，所以当执行s = null后，字符串对象就只剩下软引用了，这时如果因为内存不足发生Full GC，就会把这个字符串对象回收掉。</p>\n<blockquote>\n<p>注意<br>在垃圾回收器回收一个对象前，SoftReference类所提供的get方法会返回Java对象的强引用，一旦垃圾线程回收该对象之后，get方法将返回null。所以在获取软引用对象的代码中，一定要先判断返回是否为null，以免出现NullPointerException异常而导致应用崩溃。<img src=\"/images/2030.png\" width=\"50\"></p>\n</blockquote>\n<p>下面的代码会让s再次持有对象的强引用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = softRef.get();</span><br></pre></td></tr></table></figure>\n<p>如果在softRef指向的对象被回收前，用强引用指向该对象，那这个对象又会变成强可达。</p>\n<p>来看一个使用SoftReference的栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestA</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OOMClass</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] oom = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">1024</span> * <span class=\"number\">100</span>];<span class=\"comment\">// 100KB</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        ReferenceQueue&lt;OOMClass&gt; queue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\">        List&lt;SoftReference&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">                list.add(<span class=\"keyword\">new</span> SoftReference&lt;OOMClass&gt;(<span class=\"keyword\">new</span> OOMClass(), queue));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意<br>ReferenceQueue中声明的类型为OOMClass，即与SoftReference引用的类型一致。</p>\n</blockquote>\n<p>设置一下虚拟机参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-verbose:gc -Xms4m -Xmx4m -Xmn2m</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure)  1017K-&gt;432K(3584K), 0.0017239 secs]</span><br><span class=\"line\">[GC (Allocation Failure)  1072K-&gt;472K(3584K), 0.0099237 secs]</span><br><span class=\"line\">[GC (Allocation Failure)  1323K-&gt;1296K(3584K), 0.0009528 secs]</span><br><span class=\"line\">[GC (Allocation Failure)  2114K-&gt;2136K(3584K), 0.0009951 secs]</span><br><span class=\"line\">[Full GC (Ergonomics)  2136K-&gt;1992K(3584K), 0.0040658 secs]</span><br><span class=\"line\">[Full GC (Ergonomics)  2807K-&gt;2791K(3584K), 0.0036280 secs]</span><br><span class=\"line\">[Full GC (Allocation Failure)  2791K-&gt;373K(3584K), 0.0032477 secs]</span><br><span class=\"line\">[Full GC (Ergonomics)  2786K-&gt;2773K(3584K), 0.0034554 secs]</span><br><span class=\"line\">[Full GC (Allocation Failure)  2773K-&gt;373K(3584K), 0.0032667 secs]</span><br><span class=\"line\">[Full GC (Ergonomics)  2798K-&gt;2775K(3584K), 0.0036231 secs]</span><br><span class=\"line\">[Full GC (Allocation Failure)  2775K-&gt;375K(3584K), 0.0055482 secs]</span><br><span class=\"line\">[Full GC (Ergonomics)  2799K-&gt;2776K(3584K), 0.0031358 secs]</span><br><span class=\"line\">...省略n次GC信息</span><br></pre></td></tr></table></figure>\n<p>在TestA中，我们使用死循环不断的往list中添加新对象，如果是强引用，会很快因为内存不足而抛出OOM，因为这里的堆内存大小设置为了4M，而一个对象就有100KB，一个循环添加100个对象，也就是差不多10M，显然一个循环都跑不完就会内存不足，而这里，因为使用的是软引用，所以JVM会在内存不足的时候将软引用回收掉。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Full GC (Allocation Failure)  2791K-&gt;373K(3584K), 0.0032477 secs]</span><br></pre></td></tr></table></figure>\n<p>从这一条可以看出，在内存不足发生Full GC时，回收掉了大部分的软引用指向的对象，释放了大量的内存。</p>\n<p>因为这里新生代只分配了2M，所以很快就会发生GC，如果你的程序运行没有看到这个结果，请先确认一下虚拟机参数是否设置正确，如果设置正确还是没有看到，那么将循环次数由1000改为10000或者100000在试试看。<img src=\"/images/141.png\" width=\"50\"></p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>软引用关联的对象，只有在内存不足的时候JVM才会回收该对象。这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。 </p>\n<p>现在考虑这样一个场景 ，在很多应用中，都会出现大量的默认图片，比如说QQ的默认头像，应用内的默认图标等等，这些图片很多地方会用到。</p>\n<p>如果每次都去读取图片，由于读取文件速度较慢，大量重复的读取会导致性能下降。所以可以考虑将图片缓存起来，需要的时候直接从内存中读取。但是，由于图片占用内存空间比较大，缓存的图片过多会占用比较多的内存，就可能比较容易发生OOM。这时候，软引用就派得上用场了。<img src=\"/images/0009.png\" width=\"50\"></p>\n<blockquote>\n<p>注意<br>SoftReference对象是用来保存软引用的，但它同时也是一个Java对象。所以，当软可及对象被回收之后，虽然这个SoftReference对象的get()方法返回null，但SoftReference对象本身并不是null，而此时这个SoftReference对象已经不再具有存在的价值，需要一个适当的清除机制，避免大量SoftReference对象带来的内存泄漏。</p>\n</blockquote>\n<p>ReferenceQueue就是用来保存这些需要被清理的引用对象的。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>\n<p>下面用SoftReference来实现一个简单的缓存类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SoftCache</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 引用队列</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ReferenceQueue&lt;T&gt; referenceQueue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 保存软引用集合，在引用对象被回收后销毁</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Reference&lt;T&gt;&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加缓存对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(T obj)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 构建软引用</span></span><br><span class=\"line\">        Reference&lt;T&gt; reference = <span class=\"keyword\">new</span> SoftReference&lt;T&gt;(obj, referenceQueue);</span><br><span class=\"line\">        <span class=\"comment\">// 加入列表中</span></span><br><span class=\"line\">        list.add(reference);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取缓存对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> T <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先对无效引用进行清理</span></span><br><span class=\"line\">        clear();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span> || list.size() &lt; index)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Reference&lt;T&gt; reference = list.get(index);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> reference == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : reference.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Reference&lt;T&gt; reference;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">null</span> != (reference = (Reference&lt;T&gt;) referenceQueue.poll()))&#123;</span><br><span class=\"line\">            list.remove(reference);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后测试一下这个缓存类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SoftCacheTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        SoftCache&lt;OOMClass&gt; softCache = <span class=\"keyword\">new</span> SoftCache&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">40</span>; i++) &#123;</span><br><span class=\"line\">            softCache.add(<span class=\"keyword\">new</span> OOMClass(<span class=\"string\">\"OOM Obj-\"</span> + ++num));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(softCache.size());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; softCache.size(); i++) &#123;</span><br><span class=\"line\">            OOMClass obj = softCache.get(i);</span><br><span class=\"line\">            System.out.println(obj == <span class=\"keyword\">null</span> ? <span class=\"string\">\"null\"</span> : obj.name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(softCache.size());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OOMClass</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] oom = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">1024</span> * <span class=\"number\">100</span>];<span class=\"comment\">// 100KB</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">OOMClass</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>仍使用之前的虚拟机参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-verbose:gc -Xms4m -Xmx4m -Xmn2m</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure)  <span class=\"number\">1017</span>K-&gt;<span class=\"number\">432</span>K(<span class=\"number\">3584</span>K), <span class=\"number\">0.0012236</span> secs]</span><br><span class=\"line\">[GC (Allocation Failure)  <span class=\"number\">1117</span>K-&gt;<span class=\"number\">496</span>K(<span class=\"number\">3584</span>K), <span class=\"number\">0.0016875</span> secs]</span><br><span class=\"line\">[GC (Allocation Failure)  <span class=\"number\">1347</span>K-&gt;<span class=\"number\">1229</span>K(<span class=\"number\">3584</span>K), <span class=\"number\">0.0015059</span> secs]</span><br><span class=\"line\">[GC (Allocation Failure)  <span class=\"number\">2047</span>K-&gt;<span class=\"number\">2125</span>K(<span class=\"number\">3584</span>K), <span class=\"number\">0.0018090</span> secs]</span><br><span class=\"line\">[<span class=\"function\">Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2125K-&gt;1994<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0054759 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2822K-&gt;2794<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0023167 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span>  2794K-&gt;376<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0036056 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2795K-&gt;2776<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0042365 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span>  2776K-&gt;376<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0035122 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2795K-&gt;2776<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0054760 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span>  2776K-&gt;376<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0036965 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2802K-&gt;2777<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0044513 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span>  2777K-&gt;376<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0041400 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2796K-&gt;2777<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0025255 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span>  2777K-&gt;376<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0037690 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2817K-&gt;2777<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0037759 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span>  2777K-&gt;377<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0042416 secs]</span></span><br><span class=\"line\"><span class=\"function\">缓存列表大小：40</span></span><br><span class=\"line\"><span class=\"function\">OOM Obj-37</span></span><br><span class=\"line\"><span class=\"function\">OOM Obj-38</span></span><br><span class=\"line\"><span class=\"function\">OOM Obj-39</span></span><br><span class=\"line\"><span class=\"function\">OOM Obj-40</span></span><br><span class=\"line\"><span class=\"function\">缓存列表大小：4</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，缓存40个软引用对象之后，如果一次性全部存储，显然内存大小无法满足，所以在不断创建软引用对象的过程中，不断发生GC来进行垃圾回收，最终只有4个软引用未被清理掉。</p>\n<h2 id=\"强引用与软引用对比\"><a href=\"#强引用与软引用对比\" class=\"headerlink\" title=\"强引用与软引用对比\"></a>强引用与软引用对比</h2><p>没有对比就没有伤害，来将强引用和软引用对比一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OOMClass</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] oom = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        testStrongReference();</span><br><span class=\"line\">        <span class=\"comment\">//testSoftReference();</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testStrongReference</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        List&lt;OOMClass&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            list.add(<span class=\"keyword\">new</span> OOMClass());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testSoftReference</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        ReferenceQueue&lt;OOMClass&gt; referenceQueue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\">        List&lt;SoftReference&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            OOMClass oomClass = <span class=\"keyword\">new</span> OOMClass();</span><br><span class=\"line\">            list.add(<span class=\"keyword\">new</span> SoftReference(oomClass, referenceQueue));</span><br><span class=\"line\">            oomClass = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行testStrongReference方法的结果如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure)  <span class=\"number\">1019</span>K-&gt;<span class=\"number\">384</span>K(<span class=\"number\">3584</span>K), <span class=\"number\">0.0033595</span> secs]</span><br><span class=\"line\">[GC (Allocation Failure)  <span class=\"number\">1406</span>K-&gt;<span class=\"number\">856</span>K(<span class=\"number\">3584</span>K), <span class=\"number\">0.0013098</span> secs]</span><br><span class=\"line\">[GC (Allocation Failure)  <span class=\"number\">1880</span>K-&gt;<span class=\"number\">1836</span>K(<span class=\"number\">3584</span>K), <span class=\"number\">0.0014382</span> secs]</span><br><span class=\"line\">[<span class=\"function\">Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  1836K-&gt;1756<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0039761 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2778K-&gt;2758<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0021269 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2779K-&gt;2770<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0016329 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2779K-&gt;2775<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0023157 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2775K-&gt;2775<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0015927 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  3037K-&gt;3029<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0025071 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  3067K-&gt;3065<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0017529 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span>  3065K-&gt;3047<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0033445 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  3068K-&gt;3059<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0016623 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  3070K-&gt;3068<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0028357 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span>  3068K-&gt;3068<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0017616 secs]</span></span><br><span class=\"line\"><span class=\"function\">java.lang.OutOfMemoryError: Java heap space</span></span><br><span class=\"line\"><span class=\"function\">Dumping heap to java_pid3352.hprof ...</span></span><br><span class=\"line\"><span class=\"function\">Exception in thread \"main\" java.lang.OutOfMemoryError: Java heap space</span></span><br><span class=\"line\"><span class=\"function\">Heap dump file created [3855956 bytes in 0.017 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  3071K-&gt;376<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0032068 secs]</span></span><br><span class=\"line\"><span class=\"function\">\tat reference.Test$OOMClass.&lt;init&gt;<span class=\"params\">(Test.java:<span class=\"number\">11</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">\tat reference.Test.<span class=\"title\">testStrongReference</span><span class=\"params\">(Test.java:<span class=\"number\">22</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">\tat reference.Test.<span class=\"title\">main</span><span class=\"params\">(Test.java:<span class=\"number\">15</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">Process finished with exit code 1</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，很快就抛出了OOM，原因是Java heap space，也就是堆内存不足。</p>\n<p>如果运行testSoftReference方法，将会得到如下结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure)  <span class=\"number\">1019</span>K-&gt;<span class=\"number\">464</span>K(<span class=\"number\">3584</span>K), <span class=\"number\">0.0019850</span> secs]</span><br><span class=\"line\">[GC (Allocation Failure)  <span class=\"number\">1484</span>K-&gt;<span class=\"number\">844</span>K(<span class=\"number\">3584</span>K), <span class=\"number\">0.0015920</span> secs]</span><br><span class=\"line\">[GC (Allocation Failure)  <span class=\"number\">1868</span>K-&gt;<span class=\"number\">1860</span>K(<span class=\"number\">3584</span>K), <span class=\"number\">0.0043236</span> secs]</span><br><span class=\"line\">[<span class=\"function\">Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  1860K-&gt;1781<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0044581 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2802K-&gt;2754<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0041726 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2802K-&gt;2799<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0031293 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  3023K-&gt;3023<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0024830 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  3071K-&gt;3068<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0035025 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span>  3068K-&gt;405<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0040672 secs]</span></span><br><span class=\"line\"><span class=\"function\">[<span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span>  1512K-&gt;1567<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0011170 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  1567K-&gt;1496<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0048438 secs]</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，并没有抛出OOM，而是进行多次了GC，可以明显的看到这一条：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Full GC (Allocation Failure)  3068K-&gt;405K(3584K), 0.0040672 secs]</span><br></pre></td></tr></table></figure>\n<p>当内存不足时进行了一次Full GC，回收了大部分内存空间，也就是将大部分软引用指向的对象回收掉了。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>软引用弱于强引用</li>\n<li>软引用指向的对象会在内存不足时被垃圾回收清理掉</li>\n<li>JVM会优先回收长时间闲置不用的软引用对象，对那些刚刚构建的或刚刚使用过的软引用对象会尽可能保留</li>\n<li>软引用可以有效的解决OOM问题</li>\n<li>软引用适合用作非必须大对象的缓存</li>\n</ul>\n<p>至此，本篇就告一段落了，这里只简单的介绍了软引用的作用以及用法。其实软引用并没有这么好，它的使用有一些可能是致命的缺点，如果想要更深入的了解软引用的运行原理以及软引用到底是在何时进行回收，又是如何进行回收的话，可以查看翻阅后续的章节。 </p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>软引用是使用SoftReference创建的引用，强度弱于强引用，被其引用的对象在内存不足的时候会被回收，不会产生内存溢出。</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>软引用，顾名思义就是比较“软”一点的引用。<img src=\"/images/0003.png\" width=\"50\"></p>\n<p>当一个对象与GC Roots之间存在强引用时，无论何时都不会被GC回收掉。如果一个对象与GC Roots之间没有强引用与其关联而存在软引用关联时，那么垃圾回收器对它的态度就取决于内存的紧张程度了。如果内存空间足够，垃圾回收器就不会回收这个对象，但如果内存空间不足了，它就难逃被回收的厄运。<img src=\"/images/0005.png\" width=\"50\"></p>\n<blockquote>\n<p>软可达<br>如果一个对象与GC Roots之间不存在强引用，但是存在软引用，则称这个对象为<code>软可达（soft reachable）</code>对象。</p>\n</blockquote>\n<p>在垃圾回收器没有回收它的时候，软可达对象就像强可达对象一样，可以被程序正常访问和使用，但是需要通过软引用对象间接访问，需要的话也能重新使用强引用将其关联。所以软引用适合用来做内存敏感的高速缓存。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"keyword\">new</span> String(<span class=\"string\">\"Frank\"</span>);    <span class=\"comment\">// 创建强引用与String对象关联，现在该String对象为强可达状态</span></span><br><span class=\"line\">SoftReference&lt;String&gt; softRef = <span class=\"keyword\">new</span> SoftReference&lt;String&gt;(s);     <span class=\"comment\">// 再创建一个软引用关联该对象</span></span><br><span class=\"line\">s = <span class=\"keyword\">null</span>;        <span class=\"comment\">// 消除强引用，现在只剩下软引用与其关联，该String对象为软可达状态</span></span><br><span class=\"line\">s = softRef.get();  <span class=\"comment\">// 重新关联上强引用</span></span><br></pre></td></tr></table></figure>\n<p>这里变量s持有对字符串对象的强引用，而softRef持有对该对象的软引用，所以当执行s = null后，字符串对象就只剩下软引用了，这时如果因为内存不足发生Full GC，就会把这个字符串对象回收掉。</p>\n<blockquote>\n<p>注意<br>在垃圾回收器回收一个对象前，SoftReference类所提供的get方法会返回Java对象的强引用，一旦垃圾线程回收该对象之后，get方法将返回null。所以在获取软引用对象的代码中，一定要先判断返回是否为null，以免出现NullPointerException异常而导致应用崩溃。<img src=\"/images/2030.png\" width=\"50\"></p>\n</blockquote>\n<p>下面的代码会让s再次持有对象的强引用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = softRef.get();</span><br></pre></td></tr></table></figure>\n<p>如果在softRef指向的对象被回收前，用强引用指向该对象，那这个对象又会变成强可达。</p>\n<p>来看一个使用SoftReference的栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestA</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OOMClass</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] oom = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">1024</span> * <span class=\"number\">100</span>];<span class=\"comment\">// 100KB</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        ReferenceQueue&lt;OOMClass&gt; queue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\">        List&lt;SoftReference&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">                list.add(<span class=\"keyword\">new</span> SoftReference&lt;OOMClass&gt;(<span class=\"keyword\">new</span> OOMClass(), queue));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意<br>ReferenceQueue中声明的类型为OOMClass，即与SoftReference引用的类型一致。</p>\n</blockquote>\n<p>设置一下虚拟机参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-verbose:gc -Xms4m -Xmx4m -Xmn2m</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure)  1017K-&gt;432K(3584K), 0.0017239 secs]</span><br><span class=\"line\">[GC (Allocation Failure)  1072K-&gt;472K(3584K), 0.0099237 secs]</span><br><span class=\"line\">[GC (Allocation Failure)  1323K-&gt;1296K(3584K), 0.0009528 secs]</span><br><span class=\"line\">[GC (Allocation Failure)  2114K-&gt;2136K(3584K), 0.0009951 secs]</span><br><span class=\"line\">[Full GC (Ergonomics)  2136K-&gt;1992K(3584K), 0.0040658 secs]</span><br><span class=\"line\">[Full GC (Ergonomics)  2807K-&gt;2791K(3584K), 0.0036280 secs]</span><br><span class=\"line\">[Full GC (Allocation Failure)  2791K-&gt;373K(3584K), 0.0032477 secs]</span><br><span class=\"line\">[Full GC (Ergonomics)  2786K-&gt;2773K(3584K), 0.0034554 secs]</span><br><span class=\"line\">[Full GC (Allocation Failure)  2773K-&gt;373K(3584K), 0.0032667 secs]</span><br><span class=\"line\">[Full GC (Ergonomics)  2798K-&gt;2775K(3584K), 0.0036231 secs]</span><br><span class=\"line\">[Full GC (Allocation Failure)  2775K-&gt;375K(3584K), 0.0055482 secs]</span><br><span class=\"line\">[Full GC (Ergonomics)  2799K-&gt;2776K(3584K), 0.0031358 secs]</span><br><span class=\"line\">...省略n次GC信息</span><br></pre></td></tr></table></figure>\n<p>在TestA中，我们使用死循环不断的往list中添加新对象，如果是强引用，会很快因为内存不足而抛出OOM，因为这里的堆内存大小设置为了4M，而一个对象就有100KB，一个循环添加100个对象，也就是差不多10M，显然一个循环都跑不完就会内存不足，而这里，因为使用的是软引用，所以JVM会在内存不足的时候将软引用回收掉。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Full GC (Allocation Failure)  2791K-&gt;373K(3584K), 0.0032477 secs]</span><br></pre></td></tr></table></figure>\n<p>从这一条可以看出，在内存不足发生Full GC时，回收掉了大部分的软引用指向的对象，释放了大量的内存。</p>\n<p>因为这里新生代只分配了2M，所以很快就会发生GC，如果你的程序运行没有看到这个结果，请先确认一下虚拟机参数是否设置正确，如果设置正确还是没有看到，那么将循环次数由1000改为10000或者100000在试试看。<img src=\"/images/141.png\" width=\"50\"></p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>软引用关联的对象，只有在内存不足的时候JVM才会回收该对象。这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。 </p>\n<p>现在考虑这样一个场景 ，在很多应用中，都会出现大量的默认图片，比如说QQ的默认头像，应用内的默认图标等等，这些图片很多地方会用到。</p>\n<p>如果每次都去读取图片，由于读取文件速度较慢，大量重复的读取会导致性能下降。所以可以考虑将图片缓存起来，需要的时候直接从内存中读取。但是，由于图片占用内存空间比较大，缓存的图片过多会占用比较多的内存，就可能比较容易发生OOM。这时候，软引用就派得上用场了。<img src=\"/images/0009.png\" width=\"50\"></p>\n<blockquote>\n<p>注意<br>SoftReference对象是用来保存软引用的，但它同时也是一个Java对象。所以，当软可及对象被回收之后，虽然这个SoftReference对象的get()方法返回null，但SoftReference对象本身并不是null，而此时这个SoftReference对象已经不再具有存在的价值，需要一个适当的清除机制，避免大量SoftReference对象带来的内存泄漏。</p>\n</blockquote>\n<p>ReferenceQueue就是用来保存这些需要被清理的引用对象的。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>\n<p>下面用SoftReference来实现一个简单的缓存类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SoftCache</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 引用队列</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ReferenceQueue&lt;T&gt; referenceQueue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 保存软引用集合，在引用对象被回收后销毁</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Reference&lt;T&gt;&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加缓存对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(T obj)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 构建软引用</span></span><br><span class=\"line\">        Reference&lt;T&gt; reference = <span class=\"keyword\">new</span> SoftReference&lt;T&gt;(obj, referenceQueue);</span><br><span class=\"line\">        <span class=\"comment\">// 加入列表中</span></span><br><span class=\"line\">        list.add(reference);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取缓存对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> T <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先对无效引用进行清理</span></span><br><span class=\"line\">        clear();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span> || list.size() &lt; index)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Reference&lt;T&gt; reference = list.get(index);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> reference == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : reference.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Reference&lt;T&gt; reference;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">null</span> != (reference = (Reference&lt;T&gt;) referenceQueue.poll()))&#123;</span><br><span class=\"line\">            list.remove(reference);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后测试一下这个缓存类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SoftCacheTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        SoftCache&lt;OOMClass&gt; softCache = <span class=\"keyword\">new</span> SoftCache&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">40</span>; i++) &#123;</span><br><span class=\"line\">            softCache.add(<span class=\"keyword\">new</span> OOMClass(<span class=\"string\">\"OOM Obj-\"</span> + ++num));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(softCache.size());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; softCache.size(); i++) &#123;</span><br><span class=\"line\">            OOMClass obj = softCache.get(i);</span><br><span class=\"line\">            System.out.println(obj == <span class=\"keyword\">null</span> ? <span class=\"string\">\"null\"</span> : obj.name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(softCache.size());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OOMClass</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] oom = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">1024</span> * <span class=\"number\">100</span>];<span class=\"comment\">// 100KB</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">OOMClass</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>仍使用之前的虚拟机参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-verbose:gc -Xms4m -Xmx4m -Xmn2m</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure)  <span class=\"number\">1017</span>K-&gt;<span class=\"number\">432</span>K(<span class=\"number\">3584</span>K), <span class=\"number\">0.0012236</span> secs]</span><br><span class=\"line\">[GC (Allocation Failure)  <span class=\"number\">1117</span>K-&gt;<span class=\"number\">496</span>K(<span class=\"number\">3584</span>K), <span class=\"number\">0.0016875</span> secs]</span><br><span class=\"line\">[GC (Allocation Failure)  <span class=\"number\">1347</span>K-&gt;<span class=\"number\">1229</span>K(<span class=\"number\">3584</span>K), <span class=\"number\">0.0015059</span> secs]</span><br><span class=\"line\">[GC (Allocation Failure)  <span class=\"number\">2047</span>K-&gt;<span class=\"number\">2125</span>K(<span class=\"number\">3584</span>K), <span class=\"number\">0.0018090</span> secs]</span><br><span class=\"line\">[<span class=\"function\">Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2125K-&gt;1994<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0054759 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2822K-&gt;2794<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0023167 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span>  2794K-&gt;376<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0036056 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2795K-&gt;2776<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0042365 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span>  2776K-&gt;376<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0035122 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2795K-&gt;2776<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0054760 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span>  2776K-&gt;376<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0036965 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2802K-&gt;2777<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0044513 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span>  2777K-&gt;376<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0041400 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2796K-&gt;2777<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0025255 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span>  2777K-&gt;376<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0037690 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2817K-&gt;2777<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0037759 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span>  2777K-&gt;377<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0042416 secs]</span></span><br><span class=\"line\"><span class=\"function\">缓存列表大小：40</span></span><br><span class=\"line\"><span class=\"function\">OOM Obj-37</span></span><br><span class=\"line\"><span class=\"function\">OOM Obj-38</span></span><br><span class=\"line\"><span class=\"function\">OOM Obj-39</span></span><br><span class=\"line\"><span class=\"function\">OOM Obj-40</span></span><br><span class=\"line\"><span class=\"function\">缓存列表大小：4</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，缓存40个软引用对象之后，如果一次性全部存储，显然内存大小无法满足，所以在不断创建软引用对象的过程中，不断发生GC来进行垃圾回收，最终只有4个软引用未被清理掉。</p>\n<h2 id=\"强引用与软引用对比\"><a href=\"#强引用与软引用对比\" class=\"headerlink\" title=\"强引用与软引用对比\"></a>强引用与软引用对比</h2><p>没有对比就没有伤害，来将强引用和软引用对比一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OOMClass</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] oom = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        testStrongReference();</span><br><span class=\"line\">        <span class=\"comment\">//testSoftReference();</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testStrongReference</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        List&lt;OOMClass&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            list.add(<span class=\"keyword\">new</span> OOMClass());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testSoftReference</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        ReferenceQueue&lt;OOMClass&gt; referenceQueue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\">        List&lt;SoftReference&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            OOMClass oomClass = <span class=\"keyword\">new</span> OOMClass();</span><br><span class=\"line\">            list.add(<span class=\"keyword\">new</span> SoftReference(oomClass, referenceQueue));</span><br><span class=\"line\">            oomClass = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行testStrongReference方法的结果如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure)  <span class=\"number\">1019</span>K-&gt;<span class=\"number\">384</span>K(<span class=\"number\">3584</span>K), <span class=\"number\">0.0033595</span> secs]</span><br><span class=\"line\">[GC (Allocation Failure)  <span class=\"number\">1406</span>K-&gt;<span class=\"number\">856</span>K(<span class=\"number\">3584</span>K), <span class=\"number\">0.0013098</span> secs]</span><br><span class=\"line\">[GC (Allocation Failure)  <span class=\"number\">1880</span>K-&gt;<span class=\"number\">1836</span>K(<span class=\"number\">3584</span>K), <span class=\"number\">0.0014382</span> secs]</span><br><span class=\"line\">[<span class=\"function\">Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  1836K-&gt;1756<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0039761 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2778K-&gt;2758<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0021269 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2779K-&gt;2770<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0016329 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2779K-&gt;2775<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0023157 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2775K-&gt;2775<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0015927 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  3037K-&gt;3029<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0025071 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  3067K-&gt;3065<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0017529 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span>  3065K-&gt;3047<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0033445 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  3068K-&gt;3059<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0016623 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  3070K-&gt;3068<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0028357 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span>  3068K-&gt;3068<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0017616 secs]</span></span><br><span class=\"line\"><span class=\"function\">java.lang.OutOfMemoryError: Java heap space</span></span><br><span class=\"line\"><span class=\"function\">Dumping heap to java_pid3352.hprof ...</span></span><br><span class=\"line\"><span class=\"function\">Exception in thread \"main\" java.lang.OutOfMemoryError: Java heap space</span></span><br><span class=\"line\"><span class=\"function\">Heap dump file created [3855956 bytes in 0.017 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  3071K-&gt;376<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0032068 secs]</span></span><br><span class=\"line\"><span class=\"function\">\tat reference.Test$OOMClass.&lt;init&gt;<span class=\"params\">(Test.java:<span class=\"number\">11</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">\tat reference.Test.<span class=\"title\">testStrongReference</span><span class=\"params\">(Test.java:<span class=\"number\">22</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">\tat reference.Test.<span class=\"title\">main</span><span class=\"params\">(Test.java:<span class=\"number\">15</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">Process finished with exit code 1</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，很快就抛出了OOM，原因是Java heap space，也就是堆内存不足。</p>\n<p>如果运行testSoftReference方法，将会得到如下结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure)  <span class=\"number\">1019</span>K-&gt;<span class=\"number\">464</span>K(<span class=\"number\">3584</span>K), <span class=\"number\">0.0019850</span> secs]</span><br><span class=\"line\">[GC (Allocation Failure)  <span class=\"number\">1484</span>K-&gt;<span class=\"number\">844</span>K(<span class=\"number\">3584</span>K), <span class=\"number\">0.0015920</span> secs]</span><br><span class=\"line\">[GC (Allocation Failure)  <span class=\"number\">1868</span>K-&gt;<span class=\"number\">1860</span>K(<span class=\"number\">3584</span>K), <span class=\"number\">0.0043236</span> secs]</span><br><span class=\"line\">[<span class=\"function\">Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  1860K-&gt;1781<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0044581 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2802K-&gt;2754<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0041726 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  2802K-&gt;2799<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0031293 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  3023K-&gt;3023<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0024830 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  3071K-&gt;3068<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0035025 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span>  3068K-&gt;405<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0040672 secs]</span></span><br><span class=\"line\"><span class=\"function\">[<span class=\"title\">GC</span> <span class=\"params\">(Allocation Failure)</span>  1512K-&gt;1567<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0011170 secs]</span></span><br><span class=\"line\"><span class=\"function\">[Full <span class=\"title\">GC</span> <span class=\"params\">(Ergonomics)</span>  1567K-&gt;1496<span class=\"title\">K</span><span class=\"params\">(<span class=\"number\">3584</span>K)</span>, 0.0048438 secs]</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，并没有抛出OOM，而是进行多次了GC，可以明显的看到这一条：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Full GC (Allocation Failure)  3068K-&gt;405K(3584K), 0.0040672 secs]</span><br></pre></td></tr></table></figure>\n<p>当内存不足时进行了一次Full GC，回收了大部分内存空间，也就是将大部分软引用指向的对象回收掉了。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>软引用弱于强引用</li>\n<li>软引用指向的对象会在内存不足时被垃圾回收清理掉</li>\n<li>JVM会优先回收长时间闲置不用的软引用对象，对那些刚刚构建的或刚刚使用过的软引用对象会尽可能保留</li>\n<li>软引用可以有效的解决OOM问题</li>\n<li>软引用适合用作非必须大对象的缓存</li>\n</ul>\n<p>至此，本篇就告一段落了，这里只简单的介绍了软引用的作用以及用法。其实软引用并没有这么好，它的使用有一些可能是致命的缺点，如果想要更深入的了解软引用的运行原理以及软引用到底是在何时进行回收，又是如何进行回收的话，可以查看翻阅后续的章节。 </p>\n"},{"title":"【Java入门篇】起航","date":"2018-12-28T11:00:00.000Z","_content":"\n> 最怕的东西，最应该去突破。\n\n## 初衷\n\n之前在[博客园](http://www.cnblogs.com/mfrank/)已经陆续发了几十篇文章，但总体并没有一个很好的串联，在内容编排上也存在较多问题，因此特地将之前的文章做一个整理，一是将原有文章进行润色，让表达更加生动清晰，二是尽可能的将各个知识点连接成线，整理出自己的一套体系，并剔除其中的错误。\n\n本系列文章不会鼓吹Java怎么怎么好，也不打算尝试怂恿那些在Java边缘徘徊的人来学习Java，只想根据自己的学习经验来给那些想要学习Java却不得其法的人提供一点自己的经验和看法。\n\n## 编程的世界观\n\n编程写代码其实跟玩游戏很像，你不断学习，不断提升，然后写代码来完成各种工作的过程就像打怪升级，赚钱买装备，最终打倒BOSS的过程。\n\n每一款好的游戏都有一个较为统一完整的世界观，也会有一个统一的背景设定，你需要先接受和理解这个设定的背景，然后慢慢了解这个游戏的完整世界观，这样才能真正融入这个游戏。\n\n比如说，《剑网3》的世界观设计一直遵循“纯武侠，真江湖”设计，背景设定便是唐宋时期，武林纷争，各大门派先后崛起，而你出身草芥，通过自身努力加入门派，然后通过不断修炼内功和挑战各种任务来提升自我。\n\n又比如《饥荒》是关于一名科学家被恶魔传送到了异世界荒野的故事，游戏的主题是生存，所以你的目标是尽可能的利用各种资源来存活更长时间，同时要抵御各种外来威胁来保证自己的安全。\n\n如果把编程开发也比作游戏的话，它更像是《我的世界》这样的自由度很高的沙盒游戏。有的人会将《我的世界》玩成一款生存游戏，享受被僵尸追杀的快感，有人会将它玩成一款建筑游戏，打造属于自己的王国。带着不同的目的人，会有完全不同的游戏体验。\n\n编程也是如此，在编程的世界里，你拥有的是一个万能工厂，而你是一位工程师，在这里你可以生产出任何产品，汽车、轮船、火箭，如果你足够厉害，甚至可以创造一个新的世界，所有你需要做的，便是给出合格的设计图，接下来的事情，交给这个万能工厂就好了。\n\n每个人拥有这个万能工厂的人都有着不同的目的，有的人只是为了参观，有的人是为了制作出性能强悍的跑车，有的人是为了制作自己用的小玩具。不同的目的就会有完全不同的体验，有的人会觉得枯燥，有的人会觉得无聊，而有的人会感觉激情四射。如果你能真正体会到其中的乐趣，那么你一定会爱上这个工厂。\n\n但做出一张好的设计图并不是一件简单的事情，所以你需要不断的学习它的规范，设计出符合规范的设计图，才能被这个万能工厂正确生产出你想要的产品。等到你真正掌握了这个规范，就会发现，只满足于正确性还远远不够，于是渐渐的会开始追求效率和美感。为了提高设计效率，前辈们已经总结出很多种设计模式，适用于不同的设计场景，掌握了它们，在设计产品的时候便能更加随心所欲。\n\n而关于编程美学，也是一门用经验堆积起来的学问。毕竟，作为工程师的我们，需要与其他工程师不断交流切磋，我们会观摩欣赏别人的设计图，也会把自己的设计图和别人探讨。所以设计图不仅仅是为了给这个万能工厂来运转，也是为了阅读。\n\n当然，这都是后话了。\n\n## Java编程的世界观\n\nJava是一门高级编程语言，所谓的高级，是相对于汇编等机器语言而言的，有更高层次的抽象，更加接近自然语言和数学公式，基本脱离了机器的硬件系统。\n\n前面说到，每种编程语言都是一个万能工厂，Java也有一个万能工厂。不同语言代表的不同工厂都有各自的擅长领域。目前来说，Java的主流应用领域便是Web/APP后端开发、嵌入式设备、大数据、安卓开发，当然，Java也可以开发桌面应用程序，也可以写游戏，但那些并不是Java擅长的领域。就像你可以用菜刀砍树，用斧头切菜一样，可以做，但是会有些别扭，有其他更好用的工具为什么要选择这样蹩脚的方式呢。不要忘了，这些工厂都只是一个工具而已，你的最终目的是实现你的要的功能。\n\n简单来说，不管黑猫白猫，能抓住耗子的猫就是好猫。\n\n所以对待各种编程语言，首先要保持理智，他们都只是一个工具，我们的目的是为了解决问题，不要陷入对某种语言的盲目崇拜的陷阱里，脱离场景而进行语言之间的对比是毫无意义的。\n\nJava有很多开发方向，本系列文章将主要以JavaWeb开发为目标进行探索，利用Java这个大工厂来开发网站后端应用，为我们的前台页面提供强劲稳定的功能支持。\n\n相对于桌面开发而言，JavaWeb开发更多的时候开发出的产品是默默的在后台工作的，需要通过前台html页面或者手机app，亦或是桌面app才能进行间接的交互。比如你打开淘宝，看到的那些页面架构和好看的图片大都是前端和UI的功劳，而你看到的那些文字内容，大都是后端的数据驱动的成果。（当然，现在可能更多的功劳又要归功于基于大数据的推荐系统了）\n\n但不要因此而觉得Java后端开发很无聊，其实一个网站的后端就像一个程序的大脑，绝大部分的数据逻辑处理是由后端完成的，不仅要负责对数据进行处理，还需要跟数据库，各种消息中间件打交道，利用各种算法来实现特定的功能，比如根据销售数据进行热销推荐，对用户进行信用评级等等\n\n前端则负责展示处理后的结果，并做出相应的响应，是一个应用的门面。前端侧重展示和交互，后端侧重程序的逻辑，都是为了提供更好的用户体验，只是着力点不一样而已。\n\nJava这个大工厂能量无穷，想要完全掌控它的妙用需要一段较长的修炼时间，毕竟想要设计一张足够精巧的设计图纸并不是一件简单的事情，所以需要不断的学习。这个过程难免会遇到挫折和困难，其中很多坑对于新手而言是致命的，最简单的比如环境安装，很多人的兴趣就是夭折在环境的折腾上。其实很多坑，早有无数人踩过，也有很多人在网上分享过相关的解决办法，所以当你遇到问题的时候，可以先上百度找找，你要相信一定有人遇到过同样的问题，如果没找到，想想换个姿势搜索。\n\n当然也许苦苦搜寻之后，还是无法解决你的问题，这时候，来自共同学习的小伙伴的支持就显得弥足珍贵了，为此，博主创建了一个QQ群【529253292】，这里也许可以找到你想要的答案。\n\nJava的学习深造过程，就像是升级打怪过关卡，每个知识点都有些小boss，把它们打倒后便能获得相应的经验值，可以提升你的等级，但是随着你的等级的提升，这些小怪小boss对你的修炼的帮助已经聊胜于无了，于是你需要进行更艰难的修炼，去挑战更厉害的boss。\n\n在这个世界里，自由度很大，大到也许会让刚接触的你迷失方向，不知所措。所以本系列文章将会提供给你一条前往JavaWeb开发的修炼道路，虽然并不一定是最优路线，但至少总体方向不会错，如果你刚好想往这个方向发展，那么本系列文章将会给你提供一些帮助。注意，本系列文章主张的是夯实基础，先修炼内功，然后再修炼外功，所以如果你想要的是捷径，想要知道如何在一两个月之内找到工作，那么这个系列文章可能不太适合你。\n\n当你的经验累积到一定的值时，就能获得相应的头衔，在JavaWeb的发展中主要有两条升级路线，一条是技术路线，一条是管理路线，大致就像这样:\n\n{% asset_img java-started-1.png JavaWeb升级之路 %}\n\n两条路线的升级加点方式不太一样，但是都是当技术积累到一定程度后才能选择不同的升级路线。\n\n所以，年轻的勇士，不要犹豫了，拿起你的桃木剑，在Java这个世界探索出自己的道路吧！\n","source":"_posts/java/introduction/java-started.md","raw":"---\ntitle: 【Java入门篇】起航\ntags: \n - Java入门\n - Java\ncategories: 编程\ndate: 2018-12-28 19:00:00\n---\n\n> 最怕的东西，最应该去突破。\n\n## 初衷\n\n之前在[博客园](http://www.cnblogs.com/mfrank/)已经陆续发了几十篇文章，但总体并没有一个很好的串联，在内容编排上也存在较多问题，因此特地将之前的文章做一个整理，一是将原有文章进行润色，让表达更加生动清晰，二是尽可能的将各个知识点连接成线，整理出自己的一套体系，并剔除其中的错误。\n\n本系列文章不会鼓吹Java怎么怎么好，也不打算尝试怂恿那些在Java边缘徘徊的人来学习Java，只想根据自己的学习经验来给那些想要学习Java却不得其法的人提供一点自己的经验和看法。\n\n## 编程的世界观\n\n编程写代码其实跟玩游戏很像，你不断学习，不断提升，然后写代码来完成各种工作的过程就像打怪升级，赚钱买装备，最终打倒BOSS的过程。\n\n每一款好的游戏都有一个较为统一完整的世界观，也会有一个统一的背景设定，你需要先接受和理解这个设定的背景，然后慢慢了解这个游戏的完整世界观，这样才能真正融入这个游戏。\n\n比如说，《剑网3》的世界观设计一直遵循“纯武侠，真江湖”设计，背景设定便是唐宋时期，武林纷争，各大门派先后崛起，而你出身草芥，通过自身努力加入门派，然后通过不断修炼内功和挑战各种任务来提升自我。\n\n又比如《饥荒》是关于一名科学家被恶魔传送到了异世界荒野的故事，游戏的主题是生存，所以你的目标是尽可能的利用各种资源来存活更长时间，同时要抵御各种外来威胁来保证自己的安全。\n\n如果把编程开发也比作游戏的话，它更像是《我的世界》这样的自由度很高的沙盒游戏。有的人会将《我的世界》玩成一款生存游戏，享受被僵尸追杀的快感，有人会将它玩成一款建筑游戏，打造属于自己的王国。带着不同的目的人，会有完全不同的游戏体验。\n\n编程也是如此，在编程的世界里，你拥有的是一个万能工厂，而你是一位工程师，在这里你可以生产出任何产品，汽车、轮船、火箭，如果你足够厉害，甚至可以创造一个新的世界，所有你需要做的，便是给出合格的设计图，接下来的事情，交给这个万能工厂就好了。\n\n每个人拥有这个万能工厂的人都有着不同的目的，有的人只是为了参观，有的人是为了制作出性能强悍的跑车，有的人是为了制作自己用的小玩具。不同的目的就会有完全不同的体验，有的人会觉得枯燥，有的人会觉得无聊，而有的人会感觉激情四射。如果你能真正体会到其中的乐趣，那么你一定会爱上这个工厂。\n\n但做出一张好的设计图并不是一件简单的事情，所以你需要不断的学习它的规范，设计出符合规范的设计图，才能被这个万能工厂正确生产出你想要的产品。等到你真正掌握了这个规范，就会发现，只满足于正确性还远远不够，于是渐渐的会开始追求效率和美感。为了提高设计效率，前辈们已经总结出很多种设计模式，适用于不同的设计场景，掌握了它们，在设计产品的时候便能更加随心所欲。\n\n而关于编程美学，也是一门用经验堆积起来的学问。毕竟，作为工程师的我们，需要与其他工程师不断交流切磋，我们会观摩欣赏别人的设计图，也会把自己的设计图和别人探讨。所以设计图不仅仅是为了给这个万能工厂来运转，也是为了阅读。\n\n当然，这都是后话了。\n\n## Java编程的世界观\n\nJava是一门高级编程语言，所谓的高级，是相对于汇编等机器语言而言的，有更高层次的抽象，更加接近自然语言和数学公式，基本脱离了机器的硬件系统。\n\n前面说到，每种编程语言都是一个万能工厂，Java也有一个万能工厂。不同语言代表的不同工厂都有各自的擅长领域。目前来说，Java的主流应用领域便是Web/APP后端开发、嵌入式设备、大数据、安卓开发，当然，Java也可以开发桌面应用程序，也可以写游戏，但那些并不是Java擅长的领域。就像你可以用菜刀砍树，用斧头切菜一样，可以做，但是会有些别扭，有其他更好用的工具为什么要选择这样蹩脚的方式呢。不要忘了，这些工厂都只是一个工具而已，你的最终目的是实现你的要的功能。\n\n简单来说，不管黑猫白猫，能抓住耗子的猫就是好猫。\n\n所以对待各种编程语言，首先要保持理智，他们都只是一个工具，我们的目的是为了解决问题，不要陷入对某种语言的盲目崇拜的陷阱里，脱离场景而进行语言之间的对比是毫无意义的。\n\nJava有很多开发方向，本系列文章将主要以JavaWeb开发为目标进行探索，利用Java这个大工厂来开发网站后端应用，为我们的前台页面提供强劲稳定的功能支持。\n\n相对于桌面开发而言，JavaWeb开发更多的时候开发出的产品是默默的在后台工作的，需要通过前台html页面或者手机app，亦或是桌面app才能进行间接的交互。比如你打开淘宝，看到的那些页面架构和好看的图片大都是前端和UI的功劳，而你看到的那些文字内容，大都是后端的数据驱动的成果。（当然，现在可能更多的功劳又要归功于基于大数据的推荐系统了）\n\n但不要因此而觉得Java后端开发很无聊，其实一个网站的后端就像一个程序的大脑，绝大部分的数据逻辑处理是由后端完成的，不仅要负责对数据进行处理，还需要跟数据库，各种消息中间件打交道，利用各种算法来实现特定的功能，比如根据销售数据进行热销推荐，对用户进行信用评级等等\n\n前端则负责展示处理后的结果，并做出相应的响应，是一个应用的门面。前端侧重展示和交互，后端侧重程序的逻辑，都是为了提供更好的用户体验，只是着力点不一样而已。\n\nJava这个大工厂能量无穷，想要完全掌控它的妙用需要一段较长的修炼时间，毕竟想要设计一张足够精巧的设计图纸并不是一件简单的事情，所以需要不断的学习。这个过程难免会遇到挫折和困难，其中很多坑对于新手而言是致命的，最简单的比如环境安装，很多人的兴趣就是夭折在环境的折腾上。其实很多坑，早有无数人踩过，也有很多人在网上分享过相关的解决办法，所以当你遇到问题的时候，可以先上百度找找，你要相信一定有人遇到过同样的问题，如果没找到，想想换个姿势搜索。\n\n当然也许苦苦搜寻之后，还是无法解决你的问题，这时候，来自共同学习的小伙伴的支持就显得弥足珍贵了，为此，博主创建了一个QQ群【529253292】，这里也许可以找到你想要的答案。\n\nJava的学习深造过程，就像是升级打怪过关卡，每个知识点都有些小boss，把它们打倒后便能获得相应的经验值，可以提升你的等级，但是随着你的等级的提升，这些小怪小boss对你的修炼的帮助已经聊胜于无了，于是你需要进行更艰难的修炼，去挑战更厉害的boss。\n\n在这个世界里，自由度很大，大到也许会让刚接触的你迷失方向，不知所措。所以本系列文章将会提供给你一条前往JavaWeb开发的修炼道路，虽然并不一定是最优路线，但至少总体方向不会错，如果你刚好想往这个方向发展，那么本系列文章将会给你提供一些帮助。注意，本系列文章主张的是夯实基础，先修炼内功，然后再修炼外功，所以如果你想要的是捷径，想要知道如何在一两个月之内找到工作，那么这个系列文章可能不太适合你。\n\n当你的经验累积到一定的值时，就能获得相应的头衔，在JavaWeb的发展中主要有两条升级路线，一条是技术路线，一条是管理路线，大致就像这样:\n\n{% asset_img java-started-1.png JavaWeb升级之路 %}\n\n两条路线的升级加点方式不太一样，但是都是当技术积累到一定程度后才能选择不同的升级路线。\n\n所以，年轻的勇士，不要犹豫了，拿起你的桃木剑，在Java这个世界探索出自己的道路吧！\n","slug":"java/introduction/java-started","published":1,"updated":"2019-06-04T01:29:57.329Z","_id":"cjxze3gx400600cvw5txb31od","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>最怕的东西，最应该去突破。</p>\n</blockquote>\n<h2 id=\"初衷\"><a href=\"#初衷\" class=\"headerlink\" title=\"初衷\"></a>初衷</h2><p>之前在<a href=\"http://www.cnblogs.com/mfrank/\" target=\"_blank\" rel=\"noopener\">博客园</a>已经陆续发了几十篇文章，但总体并没有一个很好的串联，在内容编排上也存在较多问题，因此特地将之前的文章做一个整理，一是将原有文章进行润色，让表达更加生动清晰，二是尽可能的将各个知识点连接成线，整理出自己的一套体系，并剔除其中的错误。</p>\n<p>本系列文章不会鼓吹Java怎么怎么好，也不打算尝试怂恿那些在Java边缘徘徊的人来学习Java，只想根据自己的学习经验来给那些想要学习Java却不得其法的人提供一点自己的经验和看法。</p>\n<h2 id=\"编程的世界观\"><a href=\"#编程的世界观\" class=\"headerlink\" title=\"编程的世界观\"></a>编程的世界观</h2><p>编程写代码其实跟玩游戏很像，你不断学习，不断提升，然后写代码来完成各种工作的过程就像打怪升级，赚钱买装备，最终打倒BOSS的过程。</p>\n<p>每一款好的游戏都有一个较为统一完整的世界观，也会有一个统一的背景设定，你需要先接受和理解这个设定的背景，然后慢慢了解这个游戏的完整世界观，这样才能真正融入这个游戏。</p>\n<p>比如说，《剑网3》的世界观设计一直遵循“纯武侠，真江湖”设计，背景设定便是唐宋时期，武林纷争，各大门派先后崛起，而你出身草芥，通过自身努力加入门派，然后通过不断修炼内功和挑战各种任务来提升自我。</p>\n<p>又比如《饥荒》是关于一名科学家被恶魔传送到了异世界荒野的故事，游戏的主题是生存，所以你的目标是尽可能的利用各种资源来存活更长时间，同时要抵御各种外来威胁来保证自己的安全。</p>\n<p>如果把编程开发也比作游戏的话，它更像是《我的世界》这样的自由度很高的沙盒游戏。有的人会将《我的世界》玩成一款生存游戏，享受被僵尸追杀的快感，有人会将它玩成一款建筑游戏，打造属于自己的王国。带着不同的目的人，会有完全不同的游戏体验。</p>\n<p>编程也是如此，在编程的世界里，你拥有的是一个万能工厂，而你是一位工程师，在这里你可以生产出任何产品，汽车、轮船、火箭，如果你足够厉害，甚至可以创造一个新的世界，所有你需要做的，便是给出合格的设计图，接下来的事情，交给这个万能工厂就好了。</p>\n<p>每个人拥有这个万能工厂的人都有着不同的目的，有的人只是为了参观，有的人是为了制作出性能强悍的跑车，有的人是为了制作自己用的小玩具。不同的目的就会有完全不同的体验，有的人会觉得枯燥，有的人会觉得无聊，而有的人会感觉激情四射。如果你能真正体会到其中的乐趣，那么你一定会爱上这个工厂。</p>\n<p>但做出一张好的设计图并不是一件简单的事情，所以你需要不断的学习它的规范，设计出符合规范的设计图，才能被这个万能工厂正确生产出你想要的产品。等到你真正掌握了这个规范，就会发现，只满足于正确性还远远不够，于是渐渐的会开始追求效率和美感。为了提高设计效率，前辈们已经总结出很多种设计模式，适用于不同的设计场景，掌握了它们，在设计产品的时候便能更加随心所欲。</p>\n<p>而关于编程美学，也是一门用经验堆积起来的学问。毕竟，作为工程师的我们，需要与其他工程师不断交流切磋，我们会观摩欣赏别人的设计图，也会把自己的设计图和别人探讨。所以设计图不仅仅是为了给这个万能工厂来运转，也是为了阅读。</p>\n<p>当然，这都是后话了。</p>\n<h2 id=\"Java编程的世界观\"><a href=\"#Java编程的世界观\" class=\"headerlink\" title=\"Java编程的世界观\"></a>Java编程的世界观</h2><p>Java是一门高级编程语言，所谓的高级，是相对于汇编等机器语言而言的，有更高层次的抽象，更加接近自然语言和数学公式，基本脱离了机器的硬件系统。</p>\n<p>前面说到，每种编程语言都是一个万能工厂，Java也有一个万能工厂。不同语言代表的不同工厂都有各自的擅长领域。目前来说，Java的主流应用领域便是Web/APP后端开发、嵌入式设备、大数据、安卓开发，当然，Java也可以开发桌面应用程序，也可以写游戏，但那些并不是Java擅长的领域。就像你可以用菜刀砍树，用斧头切菜一样，可以做，但是会有些别扭，有其他更好用的工具为什么要选择这样蹩脚的方式呢。不要忘了，这些工厂都只是一个工具而已，你的最终目的是实现你的要的功能。</p>\n<p>简单来说，不管黑猫白猫，能抓住耗子的猫就是好猫。</p>\n<p>所以对待各种编程语言，首先要保持理智，他们都只是一个工具，我们的目的是为了解决问题，不要陷入对某种语言的盲目崇拜的陷阱里，脱离场景而进行语言之间的对比是毫无意义的。</p>\n<p>Java有很多开发方向，本系列文章将主要以JavaWeb开发为目标进行探索，利用Java这个大工厂来开发网站后端应用，为我们的前台页面提供强劲稳定的功能支持。</p>\n<p>相对于桌面开发而言，JavaWeb开发更多的时候开发出的产品是默默的在后台工作的，需要通过前台html页面或者手机app，亦或是桌面app才能进行间接的交互。比如你打开淘宝，看到的那些页面架构和好看的图片大都是前端和UI的功劳，而你看到的那些文字内容，大都是后端的数据驱动的成果。（当然，现在可能更多的功劳又要归功于基于大数据的推荐系统了）</p>\n<p>但不要因此而觉得Java后端开发很无聊，其实一个网站的后端就像一个程序的大脑，绝大部分的数据逻辑处理是由后端完成的，不仅要负责对数据进行处理，还需要跟数据库，各种消息中间件打交道，利用各种算法来实现特定的功能，比如根据销售数据进行热销推荐，对用户进行信用评级等等</p>\n<p>前端则负责展示处理后的结果，并做出相应的响应，是一个应用的门面。前端侧重展示和交互，后端侧重程序的逻辑，都是为了提供更好的用户体验，只是着力点不一样而已。</p>\n<p>Java这个大工厂能量无穷，想要完全掌控它的妙用需要一段较长的修炼时间，毕竟想要设计一张足够精巧的设计图纸并不是一件简单的事情，所以需要不断的学习。这个过程难免会遇到挫折和困难，其中很多坑对于新手而言是致命的，最简单的比如环境安装，很多人的兴趣就是夭折在环境的折腾上。其实很多坑，早有无数人踩过，也有很多人在网上分享过相关的解决办法，所以当你遇到问题的时候，可以先上百度找找，你要相信一定有人遇到过同样的问题，如果没找到，想想换个姿势搜索。</p>\n<p>当然也许苦苦搜寻之后，还是无法解决你的问题，这时候，来自共同学习的小伙伴的支持就显得弥足珍贵了，为此，博主创建了一个QQ群【529253292】，这里也许可以找到你想要的答案。</p>\n<p>Java的学习深造过程，就像是升级打怪过关卡，每个知识点都有些小boss，把它们打倒后便能获得相应的经验值，可以提升你的等级，但是随着你的等级的提升，这些小怪小boss对你的修炼的帮助已经聊胜于无了，于是你需要进行更艰难的修炼，去挑战更厉害的boss。</p>\n<p>在这个世界里，自由度很大，大到也许会让刚接触的你迷失方向，不知所措。所以本系列文章将会提供给你一条前往JavaWeb开发的修炼道路，虽然并不一定是最优路线，但至少总体方向不会错，如果你刚好想往这个方向发展，那么本系列文章将会给你提供一些帮助。注意，本系列文章主张的是夯实基础，先修炼内功，然后再修炼外功，所以如果你想要的是捷径，想要知道如何在一两个月之内找到工作，那么这个系列文章可能不太适合你。</p>\n<p>当你的经验累积到一定的值时，就能获得相应的头衔，在JavaWeb的发展中主要有两条升级路线，一条是技术路线，一条是管理路线，大致就像这样:</p>\n<img src=\"/programming/java/introduction/java-started/java-started-1.png\" title=\"JavaWeb升级之路\">\n<p>两条路线的升级加点方式不太一样，但是都是当技术积累到一定程度后才能选择不同的升级路线。</p>\n<p>所以，年轻的勇士，不要犹豫了，拿起你的桃木剑，在Java这个世界探索出自己的道路吧！</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<blockquote>\n<p>最怕的东西，最应该去突破。</p>\n</blockquote>\n<h2 id=\"初衷\"><a href=\"#初衷\" class=\"headerlink\" title=\"初衷\"></a>初衷</h2><p>之前在<a href=\"http://www.cnblogs.com/mfrank/\" target=\"_blank\" rel=\"noopener\">博客园</a>已经陆续发了几十篇文章，但总体并没有一个很好的串联，在内容编排上也存在较多问题，因此特地将之前的文章做一个整理，一是将原有文章进行润色，让表达更加生动清晰，二是尽可能的将各个知识点连接成线，整理出自己的一套体系，并剔除其中的错误。</p>\n<p>本系列文章不会鼓吹Java怎么怎么好，也不打算尝试怂恿那些在Java边缘徘徊的人来学习Java，只想根据自己的学习经验来给那些想要学习Java却不得其法的人提供一点自己的经验和看法。</p>\n<h2 id=\"编程的世界观\"><a href=\"#编程的世界观\" class=\"headerlink\" title=\"编程的世界观\"></a>编程的世界观</h2><p>编程写代码其实跟玩游戏很像，你不断学习，不断提升，然后写代码来完成各种工作的过程就像打怪升级，赚钱买装备，最终打倒BOSS的过程。</p>\n<p>每一款好的游戏都有一个较为统一完整的世界观，也会有一个统一的背景设定，你需要先接受和理解这个设定的背景，然后慢慢了解这个游戏的完整世界观，这样才能真正融入这个游戏。</p>\n<p>比如说，《剑网3》的世界观设计一直遵循“纯武侠，真江湖”设计，背景设定便是唐宋时期，武林纷争，各大门派先后崛起，而你出身草芥，通过自身努力加入门派，然后通过不断修炼内功和挑战各种任务来提升自我。</p>\n<p>又比如《饥荒》是关于一名科学家被恶魔传送到了异世界荒野的故事，游戏的主题是生存，所以你的目标是尽可能的利用各种资源来存活更长时间，同时要抵御各种外来威胁来保证自己的安全。</p>\n<p>如果把编程开发也比作游戏的话，它更像是《我的世界》这样的自由度很高的沙盒游戏。有的人会将《我的世界》玩成一款生存游戏，享受被僵尸追杀的快感，有人会将它玩成一款建筑游戏，打造属于自己的王国。带着不同的目的人，会有完全不同的游戏体验。</p>\n<p>编程也是如此，在编程的世界里，你拥有的是一个万能工厂，而你是一位工程师，在这里你可以生产出任何产品，汽车、轮船、火箭，如果你足够厉害，甚至可以创造一个新的世界，所有你需要做的，便是给出合格的设计图，接下来的事情，交给这个万能工厂就好了。</p>\n<p>每个人拥有这个万能工厂的人都有着不同的目的，有的人只是为了参观，有的人是为了制作出性能强悍的跑车，有的人是为了制作自己用的小玩具。不同的目的就会有完全不同的体验，有的人会觉得枯燥，有的人会觉得无聊，而有的人会感觉激情四射。如果你能真正体会到其中的乐趣，那么你一定会爱上这个工厂。</p>\n<p>但做出一张好的设计图并不是一件简单的事情，所以你需要不断的学习它的规范，设计出符合规范的设计图，才能被这个万能工厂正确生产出你想要的产品。等到你真正掌握了这个规范，就会发现，只满足于正确性还远远不够，于是渐渐的会开始追求效率和美感。为了提高设计效率，前辈们已经总结出很多种设计模式，适用于不同的设计场景，掌握了它们，在设计产品的时候便能更加随心所欲。</p>\n<p>而关于编程美学，也是一门用经验堆积起来的学问。毕竟，作为工程师的我们，需要与其他工程师不断交流切磋，我们会观摩欣赏别人的设计图，也会把自己的设计图和别人探讨。所以设计图不仅仅是为了给这个万能工厂来运转，也是为了阅读。</p>\n<p>当然，这都是后话了。</p>\n<h2 id=\"Java编程的世界观\"><a href=\"#Java编程的世界观\" class=\"headerlink\" title=\"Java编程的世界观\"></a>Java编程的世界观</h2><p>Java是一门高级编程语言，所谓的高级，是相对于汇编等机器语言而言的，有更高层次的抽象，更加接近自然语言和数学公式，基本脱离了机器的硬件系统。</p>\n<p>前面说到，每种编程语言都是一个万能工厂，Java也有一个万能工厂。不同语言代表的不同工厂都有各自的擅长领域。目前来说，Java的主流应用领域便是Web/APP后端开发、嵌入式设备、大数据、安卓开发，当然，Java也可以开发桌面应用程序，也可以写游戏，但那些并不是Java擅长的领域。就像你可以用菜刀砍树，用斧头切菜一样，可以做，但是会有些别扭，有其他更好用的工具为什么要选择这样蹩脚的方式呢。不要忘了，这些工厂都只是一个工具而已，你的最终目的是实现你的要的功能。</p>\n<p>简单来说，不管黑猫白猫，能抓住耗子的猫就是好猫。</p>\n<p>所以对待各种编程语言，首先要保持理智，他们都只是一个工具，我们的目的是为了解决问题，不要陷入对某种语言的盲目崇拜的陷阱里，脱离场景而进行语言之间的对比是毫无意义的。</p>\n<p>Java有很多开发方向，本系列文章将主要以JavaWeb开发为目标进行探索，利用Java这个大工厂来开发网站后端应用，为我们的前台页面提供强劲稳定的功能支持。</p>\n<p>相对于桌面开发而言，JavaWeb开发更多的时候开发出的产品是默默的在后台工作的，需要通过前台html页面或者手机app，亦或是桌面app才能进行间接的交互。比如你打开淘宝，看到的那些页面架构和好看的图片大都是前端和UI的功劳，而你看到的那些文字内容，大都是后端的数据驱动的成果。（当然，现在可能更多的功劳又要归功于基于大数据的推荐系统了）</p>\n<p>但不要因此而觉得Java后端开发很无聊，其实一个网站的后端就像一个程序的大脑，绝大部分的数据逻辑处理是由后端完成的，不仅要负责对数据进行处理，还需要跟数据库，各种消息中间件打交道，利用各种算法来实现特定的功能，比如根据销售数据进行热销推荐，对用户进行信用评级等等</p>\n<p>前端则负责展示处理后的结果，并做出相应的响应，是一个应用的门面。前端侧重展示和交互，后端侧重程序的逻辑，都是为了提供更好的用户体验，只是着力点不一样而已。</p>\n<p>Java这个大工厂能量无穷，想要完全掌控它的妙用需要一段较长的修炼时间，毕竟想要设计一张足够精巧的设计图纸并不是一件简单的事情，所以需要不断的学习。这个过程难免会遇到挫折和困难，其中很多坑对于新手而言是致命的，最简单的比如环境安装，很多人的兴趣就是夭折在环境的折腾上。其实很多坑，早有无数人踩过，也有很多人在网上分享过相关的解决办法，所以当你遇到问题的时候，可以先上百度找找，你要相信一定有人遇到过同样的问题，如果没找到，想想换个姿势搜索。</p>\n<p>当然也许苦苦搜寻之后，还是无法解决你的问题，这时候，来自共同学习的小伙伴的支持就显得弥足珍贵了，为此，博主创建了一个QQ群【529253292】，这里也许可以找到你想要的答案。</p>\n<p>Java的学习深造过程，就像是升级打怪过关卡，每个知识点都有些小boss，把它们打倒后便能获得相应的经验值，可以提升你的等级，但是随着你的等级的提升，这些小怪小boss对你的修炼的帮助已经聊胜于无了，于是你需要进行更艰难的修炼，去挑战更厉害的boss。</p>\n<p>在这个世界里，自由度很大，大到也许会让刚接触的你迷失方向，不知所措。所以本系列文章将会提供给你一条前往JavaWeb开发的修炼道路，虽然并不一定是最优路线，但至少总体方向不会错，如果你刚好想往这个方向发展，那么本系列文章将会给你提供一些帮助。注意，本系列文章主张的是夯实基础，先修炼内功，然后再修炼外功，所以如果你想要的是捷径，想要知道如何在一两个月之内找到工作，那么这个系列文章可能不太适合你。</p>\n<p>当你的经验累积到一定的值时，就能获得相应的头衔，在JavaWeb的发展中主要有两条升级路线，一条是技术路线，一条是管理路线，大致就像这样:</p>\n<img src=\"/programming/java/introduction/java-started/java-started-1.png\" title=\"JavaWeb升级之路\">\n<p>两条路线的升级加点方式不太一样，但是都是当技术积累到一定程度后才能选择不同的升级路线。</p>\n<p>所以，年轻的勇士，不要犹豫了，拿起你的桃木剑，在Java这个世界探索出自己的道路吧！</p>\n"},{"title":"强引用","date":"2018-12-29T11:56:51.000Z","_content":"\n## 定义\n\n强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器宁愿抛出OOM（OutOfMemoryError）也不会回收它。\n\n## 说明\n\n不要被这个`强`字吓到，以为这个引用就很厉害，其实强引用就是程序中使用的一般引用类型。<img src=\"/images/0009.png\" width=\"50\"/>举个简单的栗子：\n\n```java\nString s = new String(\"Hello Frank!\");\n```\n\n> 强可达\n> 如果一个对象与GC Roots之间存在强引用，则称这个对象为`强可达（strong reachable）`对象。\n\n关于可达性如果不太清楚的话，可以翻阅[这篇文章](../jvm/reachable.html)。\n\n当你声明一个变量并指向一个实例的时候，其实就是在创造一个强引用。那么，既然叫强引用，它“强”在哪里呢？<img src=\"/images/0003.png\" width=\"50\"/>\n\n这主要体现在JVM进行GC的时候，只要对象有强引用与其关联，就绝对不会对它进行回收，即使已经内存不足了也不会收回有强引用指向的对象。\n\n> 强引用独白\n> 这是我小弟，有我罩着，垃圾回收器你别动它。\n\n如果你不需要使用某个对象了，可以将相应的引用设置为null，消除强引用来帮助垃圾回收器进行回收。因为过多的强引用也是导致OOM的罪魁祸首。\n\n```java\ns = null;\n```\n\n显式地设置消除引用，或已超出对象的生命周期范围，则JVM会认为该对象不存在引用，这时就可能会回收这个对象。但是具体什么时候收集这要取决于具体的GC算法。\n\n如果在一个方法的内部有一个变量s持有一个对象（Object）的强引用，那么这个变量s保存在栈中，而真正的引用内容（object）保存在堆中。当这个方法运行完成后就会退出方法栈，则引用s也会被销毁，这个object就可能会在之后的一次GC中回收。但是当这个s是全局变量时，就需要在不再使用这个对象时将引用s赋值为null，也就是消除与object对象之间的强引用，因为有强引用关联的对象是不会被垃圾回收的。<img src=\"/images/0013.png\" width=\"50\"/>\n\n下面看另一个🌰：\n\n```java\nA a = new A();\nB b = new B(a);\na = null;\n```\n\n这里a和b都持有一个对象的强引用，当执行 a = null 时， a 不再持有 A 的强引用。讲道理，A 已经该被回收了。但是这里a = null 时，A 对象不满足被回收的条件，因为还有一个B对象持有其强引用，这时候就会造成[内存泄漏](../jvm/memory-leak.html)。<img src=\"/images/8111.png\" width=\"50\"/>\n\n再看另一个会导致内存泄漏的栗子：\n\n```java\npublic static ArrayList<Object> list = new ArrayList<Object>();\npublic void stackOverflowTest(Object object){\n    list.add(object);\n    object = null;\n}\n```\n\nGC回收的是不可达对象，但是，在这个静态集合类对象中，持有了对象的强引用，但却有可能其中的某些对象已经不再使用了，所以当非静态对象被静态变量持有强引用的时候，最容易发生内存泄露。\n\n在方法中从list获取到对象后赋值给一个变量，使用完之后将这个变量设置为null并不会释放object引用的对象，因为list中还是持有对象的强引用。这时就造成了[内存泄漏](../jvm/memory-leak.html)。 \n\n## 小结\n\n所以小结一下强引用的特点：\n\n- 强引用就是最普通的引用\n- 可以使用强引用直接访问目标对象\n- 强引用指向的对象在任何时候都不会被系统回收\n- 强引用可能会导致内存泄漏\n- 过多的强引用会导致OOM\n\n","source":"_posts/java/reference/strong-reference.md","raw":"---\ntitle: 强引用\ntags: \n - Java\n - 引用类型\ncategories: 编程\ndate: 2018-12-29 19:56:51\n---\n\n## 定义\n\n强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器宁愿抛出OOM（OutOfMemoryError）也不会回收它。\n\n## 说明\n\n不要被这个`强`字吓到，以为这个引用就很厉害，其实强引用就是程序中使用的一般引用类型。<img src=\"/images/0009.png\" width=\"50\"/>举个简单的栗子：\n\n```java\nString s = new String(\"Hello Frank!\");\n```\n\n> 强可达\n> 如果一个对象与GC Roots之间存在强引用，则称这个对象为`强可达（strong reachable）`对象。\n\n关于可达性如果不太清楚的话，可以翻阅[这篇文章](../jvm/reachable.html)。\n\n当你声明一个变量并指向一个实例的时候，其实就是在创造一个强引用。那么，既然叫强引用，它“强”在哪里呢？<img src=\"/images/0003.png\" width=\"50\"/>\n\n这主要体现在JVM进行GC的时候，只要对象有强引用与其关联，就绝对不会对它进行回收，即使已经内存不足了也不会收回有强引用指向的对象。\n\n> 强引用独白\n> 这是我小弟，有我罩着，垃圾回收器你别动它。\n\n如果你不需要使用某个对象了，可以将相应的引用设置为null，消除强引用来帮助垃圾回收器进行回收。因为过多的强引用也是导致OOM的罪魁祸首。\n\n```java\ns = null;\n```\n\n显式地设置消除引用，或已超出对象的生命周期范围，则JVM会认为该对象不存在引用，这时就可能会回收这个对象。但是具体什么时候收集这要取决于具体的GC算法。\n\n如果在一个方法的内部有一个变量s持有一个对象（Object）的强引用，那么这个变量s保存在栈中，而真正的引用内容（object）保存在堆中。当这个方法运行完成后就会退出方法栈，则引用s也会被销毁，这个object就可能会在之后的一次GC中回收。但是当这个s是全局变量时，就需要在不再使用这个对象时将引用s赋值为null，也就是消除与object对象之间的强引用，因为有强引用关联的对象是不会被垃圾回收的。<img src=\"/images/0013.png\" width=\"50\"/>\n\n下面看另一个🌰：\n\n```java\nA a = new A();\nB b = new B(a);\na = null;\n```\n\n这里a和b都持有一个对象的强引用，当执行 a = null 时， a 不再持有 A 的强引用。讲道理，A 已经该被回收了。但是这里a = null 时，A 对象不满足被回收的条件，因为还有一个B对象持有其强引用，这时候就会造成[内存泄漏](../jvm/memory-leak.html)。<img src=\"/images/8111.png\" width=\"50\"/>\n\n再看另一个会导致内存泄漏的栗子：\n\n```java\npublic static ArrayList<Object> list = new ArrayList<Object>();\npublic void stackOverflowTest(Object object){\n    list.add(object);\n    object = null;\n}\n```\n\nGC回收的是不可达对象，但是，在这个静态集合类对象中，持有了对象的强引用，但却有可能其中的某些对象已经不再使用了，所以当非静态对象被静态变量持有强引用的时候，最容易发生内存泄露。\n\n在方法中从list获取到对象后赋值给一个变量，使用完之后将这个变量设置为null并不会释放object引用的对象，因为list中还是持有对象的强引用。这时就造成了[内存泄漏](../jvm/memory-leak.html)。 \n\n## 小结\n\n所以小结一下强引用的特点：\n\n- 强引用就是最普通的引用\n- 可以使用强引用直接访问目标对象\n- 强引用指向的对象在任何时候都不会被系统回收\n- 强引用可能会导致内存泄漏\n- 过多的强引用会导致OOM\n\n","slug":"java/reference/strong-reference","published":1,"updated":"2019-06-04T01:29:57.414Z","_id":"cjxze3gx400640cvwg6sj2kyp","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器宁愿抛出OOM（OutOfMemoryError）也不会回收它。</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>不要被这个<code>强</code>字吓到，以为这个引用就很厉害，其实强引用就是程序中使用的一般引用类型。<img src=\"/images/0009.png\" width=\"50\">举个简单的栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"keyword\">new</span> String(<span class=\"string\">\"Hello Frank!\"</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>强可达<br>如果一个对象与GC Roots之间存在强引用，则称这个对象为<code>强可达（strong reachable）</code>对象。</p>\n</blockquote>\n<p>关于可达性如果不太清楚的话，可以翻阅<a href=\"../jvm/reachable.html\">这篇文章</a>。</p>\n<p>当你声明一个变量并指向一个实例的时候，其实就是在创造一个强引用。那么，既然叫强引用，它“强”在哪里呢？<img src=\"/images/0003.png\" width=\"50\"></p>\n<p>这主要体现在JVM进行GC的时候，只要对象有强引用与其关联，就绝对不会对它进行回收，即使已经内存不足了也不会收回有强引用指向的对象。</p>\n<blockquote>\n<p>强引用独白<br>这是我小弟，有我罩着，垃圾回收器你别动它。</p>\n</blockquote>\n<p>如果你不需要使用某个对象了，可以将相应的引用设置为null，消除强引用来帮助垃圾回收器进行回收。因为过多的强引用也是导致OOM的罪魁祸首。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>显式地设置消除引用，或已超出对象的生命周期范围，则JVM会认为该对象不存在引用，这时就可能会回收这个对象。但是具体什么时候收集这要取决于具体的GC算法。</p>\n<p>如果在一个方法的内部有一个变量s持有一个对象（Object）的强引用，那么这个变量s保存在栈中，而真正的引用内容（object）保存在堆中。当这个方法运行完成后就会退出方法栈，则引用s也会被销毁，这个object就可能会在之后的一次GC中回收。但是当这个s是全局变量时，就需要在不再使用这个对象时将引用s赋值为null，也就是消除与object对象之间的强引用，因为有强引用关联的对象是不会被垃圾回收的。<img src=\"/images/0013.png\" width=\"50\"></p>\n<p>下面看另一个🌰：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A a = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">B b = <span class=\"keyword\">new</span> B(a);</span><br><span class=\"line\">a = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>这里a和b都持有一个对象的强引用，当执行 a = null 时， a 不再持有 A 的强引用。讲道理，A 已经该被回收了。但是这里a = null 时，A 对象不满足被回收的条件，因为还有一个B对象持有其强引用，这时候就会造成<a href=\"../jvm/memory-leak.html\">内存泄漏</a>。<img src=\"/images/8111.png\" width=\"50\"></p>\n<p>再看另一个会导致内存泄漏的栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ArrayList&lt;Object&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;Object&gt;();</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stackOverflowTest</span><span class=\"params\">(Object object)</span></span>&#123;</span><br><span class=\"line\">    list.add(object);</span><br><span class=\"line\">    object = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>GC回收的是不可达对象，但是，在这个静态集合类对象中，持有了对象的强引用，但却有可能其中的某些对象已经不再使用了，所以当非静态对象被静态变量持有强引用的时候，最容易发生内存泄露。</p>\n<p>在方法中从list获取到对象后赋值给一个变量，使用完之后将这个变量设置为null并不会释放object引用的对象，因为list中还是持有对象的强引用。这时就造成了<a href=\"../jvm/memory-leak.html\">内存泄漏</a>。 </p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>所以小结一下强引用的特点：</p>\n<ul>\n<li>强引用就是最普通的引用</li>\n<li>可以使用强引用直接访问目标对象</li>\n<li>强引用指向的对象在任何时候都不会被系统回收</li>\n<li>强引用可能会导致内存泄漏</li>\n<li>过多的强引用会导致OOM</li>\n</ul>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器宁愿抛出OOM（OutOfMemoryError）也不会回收它。</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>不要被这个<code>强</code>字吓到，以为这个引用就很厉害，其实强引用就是程序中使用的一般引用类型。<img src=\"/images/0009.png\" width=\"50\">举个简单的栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"keyword\">new</span> String(<span class=\"string\">\"Hello Frank!\"</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>强可达<br>如果一个对象与GC Roots之间存在强引用，则称这个对象为<code>强可达（strong reachable）</code>对象。</p>\n</blockquote>\n<p>关于可达性如果不太清楚的话，可以翻阅<a href=\"../jvm/reachable.html\">这篇文章</a>。</p>\n<p>当你声明一个变量并指向一个实例的时候，其实就是在创造一个强引用。那么，既然叫强引用，它“强”在哪里呢？<img src=\"/images/0003.png\" width=\"50\"></p>\n<p>这主要体现在JVM进行GC的时候，只要对象有强引用与其关联，就绝对不会对它进行回收，即使已经内存不足了也不会收回有强引用指向的对象。</p>\n<blockquote>\n<p>强引用独白<br>这是我小弟，有我罩着，垃圾回收器你别动它。</p>\n</blockquote>\n<p>如果你不需要使用某个对象了，可以将相应的引用设置为null，消除强引用来帮助垃圾回收器进行回收。因为过多的强引用也是导致OOM的罪魁祸首。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>显式地设置消除引用，或已超出对象的生命周期范围，则JVM会认为该对象不存在引用，这时就可能会回收这个对象。但是具体什么时候收集这要取决于具体的GC算法。</p>\n<p>如果在一个方法的内部有一个变量s持有一个对象（Object）的强引用，那么这个变量s保存在栈中，而真正的引用内容（object）保存在堆中。当这个方法运行完成后就会退出方法栈，则引用s也会被销毁，这个object就可能会在之后的一次GC中回收。但是当这个s是全局变量时，就需要在不再使用这个对象时将引用s赋值为null，也就是消除与object对象之间的强引用，因为有强引用关联的对象是不会被垃圾回收的。<img src=\"/images/0013.png\" width=\"50\"></p>\n<p>下面看另一个🌰：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A a = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">B b = <span class=\"keyword\">new</span> B(a);</span><br><span class=\"line\">a = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>这里a和b都持有一个对象的强引用，当执行 a = null 时， a 不再持有 A 的强引用。讲道理，A 已经该被回收了。但是这里a = null 时，A 对象不满足被回收的条件，因为还有一个B对象持有其强引用，这时候就会造成<a href=\"../jvm/memory-leak.html\">内存泄漏</a>。<img src=\"/images/8111.png\" width=\"50\"></p>\n<p>再看另一个会导致内存泄漏的栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ArrayList&lt;Object&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;Object&gt;();</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stackOverflowTest</span><span class=\"params\">(Object object)</span></span>&#123;</span><br><span class=\"line\">    list.add(object);</span><br><span class=\"line\">    object = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>GC回收的是不可达对象，但是，在这个静态集合类对象中，持有了对象的强引用，但却有可能其中的某些对象已经不再使用了，所以当非静态对象被静态变量持有强引用的时候，最容易发生内存泄露。</p>\n<p>在方法中从list获取到对象后赋值给一个变量，使用完之后将这个变量设置为null并不会释放object引用的对象，因为list中还是持有对象的强引用。这时就造成了<a href=\"../jvm/memory-leak.html\">内存泄漏</a>。 </p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>所以小结一下强引用的特点：</p>\n<ul>\n<li>强引用就是最普通的引用</li>\n<li>可以使用强引用直接访问目标对象</li>\n<li>强引用指向的对象在任何时候都不会被系统回收</li>\n<li>强引用可能会导致内存泄漏</li>\n<li>过多的强引用会导致OOM</li>\n</ul>\n"},{"title":"SoftReference源码详解","date":"2018-12-29T12:20:51.000Z","_content":"\n## 定义\n\nSoftReference是软引用，其引用的对象在内存不足的时候会被回收。只有软引用指向的对象称为软可达（softly-reachable）对象。\n\n## 说明\n\n垃圾回收器会在内存不足，经过一次垃圾回收后，内存仍旧不足的时候回收掉软可达对象。在虚拟机抛出OOM之前，会保证已经清除了所有指向软可达对象的软引用。\n\n如果内存足够，并没有规定回收软引用的具体时间，所以在内存充足的情况下，软引用对象也可能存活很长时间。\n\nJVM会根据当前内存的情况来决定是否回收softly-reachable对象，但只要referent有强引用存在，该referent就一定不会被清理，因此SoftReference适合用来实现memory-sensitive caches。软引用的回收策略在不同的JVM实现会略有不同。\n\n另外，JVM不仅仅只会考虑当前内存情况，还会考虑软引用所指向的referent最近使用情况和创建时间来综合决定是否回收该referent。\n\n一般而言，SoftReference对象会在垃圾回收器回收其内部referent后，才会被放入其注册的引用队列中（如果创建时注册了的话）。\n\n```ba&#39;sh\nSoft reference objects, which are cleared at the discretion of the garbage collector in response to memory demand. \n```\n\n就是说，软引用具体什么时候回收最终还是由虚拟机自己决定的，所以不同虚拟机对软引用的回收方式会有些不一样。\n\n## SoftReference源码\n\n```java\npublic class SoftReference<T> extends Reference<T> {\n    /**\n     * 由垃圾回收器负责更新的时间戳\n     */\n    static private long clock;\n\n    /**\n     * 在get方法调用时更新的时间戳，当虚拟机选择软引用进行清理时，可能会参考这个字段。\n     */\n    private long timestamp;\n\n    public SoftReference(T referent) {\n        super(referent);\n        this.timestamp = clock;\n    }\n\n    public SoftReference(T referent, ReferenceQueue<? super T> q) {\n        super(referent, q);\n        this.timestamp = clock;\n    }\n\n    /**\n     * 返回引用指向的对象，如果referent已经被程序或者垃圾回收器清理，则返回null。\n     */\n    public T get() {\n        T o = super.get();\n        if (o != null && this.timestamp != clock)\n            this.timestamp = clock;\n        return o;\n    }\n}\n```\n\nSoftReference类内部代码很少，两个成员变量，clock是一个静态变量，是由垃圾回收器负责更新的时间戳，在JVM初始化时，会对变量clock进行初始化，同时，在JVM发生GC时，也会更新clock的值，所以clock会记录上次GC发生的时间点。\n\ntimestamp是在创建和更新时更新的时间戳，将其更新为clock的值，垃圾回收器在回收软引用对象时可能会参考timestamp。\n\nSoftReference类有两个构造函数，一个是不传引用队列，一个传引用队列。在创建时，都会更新timestamp，将其赋值为clock的值，get方法也并没有什么骚操作，只是简单的调用 super.get() 并在返回值不为null时更新timestamp。\n\n## 软引用何时回收\n\n前面说过，软引用会在内存不足的时候进行回收，但是回收时并不会一次性全部回收，而是会使用一定的回收策略。\n\n下面以最常用的虚拟机HotSpot进行说明。下面是Oracle文档中的说明：\n\n```java\nThe default value is 1000 ms per megabyte, which means that a soft reference will survive (after the last strong reference to the object has been collected) for 1 second for each megabyte of free space in the heap\n```\n\n默认的生存周期为1000ms/Mb，举个具体的栗子：\n\n假设，堆内存为512Mb，并且可用内存为400Mb，我们创建一个object A，用软引用创建一个引用A的缓存对象cache，以及另一个object B 引用object A。此时，由于B持有A的强引用，所以对象A是强可达并且不会被垃圾回收器回收。\n\n{% asset_img soft-reference-3.png soft-reference-3 %}\n\n如果B被删除了，那么A仅剩下一个软引用cache引用它，如果A在400s内没有再次被强引用关联，它将会在超时后被删除。\n\n{% asset_img soft-reference-2.png soft-reference-2 %}\n\n下面是一个控制软引用的栗子：\n\n```java\npublic class SoftRefTest {\n    public static class A{\n    }\n    public static class B{\n        private A strongRef;\n \n        public void setStrongRef(A ref) {\n            this.strongRef = ref;\n        }\n    }\n    public static SoftReference<A> cache;\n \n    public static void main(String[] args) throws InterruptedException{\n        //用一个A类实例的软引用初始化cache对象\n        SoftRefTest.A instanceA = new SoftRefTest.A();\n        cache = new SoftReference<SoftRefTest.A>(instanceA);\n        instanceA = null;\n        // instanceA 现在是软可达状态，并且会在之后的某个时间被垃圾回收器回收\n        Thread.sleep(10000);\n \n        ...\n        SoftRefTest.B instanceB = new SoftRefTest.B();\n        //由于cache仅持有instanceA的软引用，所以无法保证instanceA仍然存活\n        instanceA = cache.get();\n        if (instanceA == null){\n            instanceA = new SoftRefTest.A();\n            cache = new SoftReference<SoftRefTest.A>(instanceA);\n        }\n        instanceB.setStrongRef(instanceA);\n        instanceA = null;\n        // instanceA现在与cache对象存在软引用并且与B对象存在强引用，所以它不会被垃圾回收器回收\n \n        ...\n    }\n}\n```\n\n但是需要注意的是，被软引用对象关联的对象会自动被垃圾回收器回收，但是软引用对象本身也是一个对象，这些创建的软引用并不会自动被垃圾回收器回收掉，所以在之前一篇中说明里的[栗子](./soft-reference.md#说明)里，软引用是不会被释放掉的。\n\n所以，你仍然需要手动去清理它们，否则也会导致OOM的产生，这里也举一个小栗子：\n\n```java\npublic class SoftReferenceTest{\n\n    public static class MyBigObject{\n        int[] data = new int[128];\n    }\n\n    public static int CACHE_INITIAL_CAPACITY = 100_000;\n    // 静态集合保存软引用，会导致这些软引用对象本身无法被垃圾回收器回收\n    public static Set<SoftReference<MyBigObject>> cache = new HashSet<>(CACHE_INITIAL_CAPACITY);\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 100_000; i++) {\n            MyBigObject obj = new MyBigObject();\n            cache.add(new SoftReference<>(obj));\n            if (i%10_000 == 0){\n                System.out.println(\"size of cache:\" + cache.size());\n            }\n        }\n        System.out.println(\"End\");\n    }\n}\n```\n\n使用的虚拟机参数为：\n\n```java\n-Xms4m -Xmx4m -Xmn2m\n```\n\n输出如下：\n\n```bash\nsize of cache:1\nsize of cache:10001\nsize of cache:20001\nsize of cache:30001\nException in thread \"main\" java.lang.OutOfMemoryError: GC overhead limit exceeded\n```\n\n最终抛出了OOM，但这里的原因却并不是`Java heap space`，而是` GC overhead limit exceeded ` ，之所以会抛出这个错误，是由于虚拟机一直在不断回收软引用，回收进行的速度过快，占用的cpu过大（超过98%），并且每次回收掉的内存过小（小于2%），导致最终抛出了这个错误。\n\n对于这里，合适的处理方式是注册一个引用队列，每次循环之后将引用队列中出现的软引用对象从cache中移除。\n\n```java\npublic class SoftReferenceTest{\n\n    public static int removedSoftRefs = 0;\n\n    public static class MyBigObject{\n        int[] data = new int[128];\n    }\n\n    public static int CACHE_INITIAL_CAPACITY = 100_000;\n    // 静态集合保存软引用，会导致这些软引用对象本身无法被垃圾回收器回收\n    public static Set<SoftReference<MyBigObject>> cache = new HashSet<>(CACHE_INITIAL_CAPACITY);\n    public static ReferenceQueue<MyBigObject> referenceQueue = new ReferenceQueue<>();\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 100_000; i++) {\n            MyBigObject obj = new MyBigObject();\n            cache.add(new SoftReference<>(obj, referenceQueue));\n            clearUselessReferences();\n        }\n        System.out.println(\"End, removed soft references=\" + removedSoftRefs);\n    }\n\n    public static void clearUselessReferences() {\n        Reference<? extends MyBigObject> ref = referenceQueue.poll();\n        while (ref != null) {\n            if (cache.remove(ref)) {\n                removedSoftRefs++;\n            }\n            ref = referenceQueue.poll();\n        }\n    }\n}\n```\n\n使用同样的虚拟机配置，输出如下：\n\n```bash\nEnd, removed soft references=97319\n```\n\n## HotSpot虚拟机对于软引用的处理\n\n就HotSpot虚拟机而言，常用的回收策略是基于当前堆大小的LRU策略（LRUCurrentHeapPolicy），会使用clock的值减去timestamp，得到的差值，就是这个软引用被闲置的时间，如果闲置足够长时间，就认为是可被回收的。\n\n```c++\nbool LRUCurrentHeapPolicy::should_clear_reference(oop p,\n                                                  jlong timestamp_clock) {\n  jlong interval = timestamp_clock - java_lang_ref_SoftReference::timestamp(p);\n  assert(interval >= 0, \"Sanity check\");\n\n  if(interval <= _max_interval) {\n    return false;\n  }\n\n  return true;\n}\n```\n\n这里 `timestamp_clock` 即SoftReference中clock的值，即上次GC时间。java_lang_ref_SoftReference::timestamp(p)可以获取引用中timestamp的值。\n\n那么这个足够长的时间 `_max_interval`是怎么计算的呢？\n\n```c++\nvoid LRUCurrentHeapPolicy::setup() {\n  _max_interval = (Universe::get_heap_free_at_last_gc() / M) * SoftRefLRUPolicyMSPerMB;\n  assert(_max_interval >= 0,\"Sanity check\");\n}\n```\n\n其中`SoftRefLRUPolicyMSPerMB`默认1000，所以可以看出这个回收时间与上次GC后的剩余空间大小有关，可用空间越大，`_max_interval`就越大。\n\n如果GC之后，堆的可用空间还很大的话，SoftReference对象可以长时间的在堆中而不被回收。反之，如果GC之后，只剩下很少的内存可用，那么SoftReference对象便会很快进行回收。\n\nSoftReference在一定程度上会影响垃圾回收，如果软可达对象中对应的referent多次垃圾回收仍然不满足释放条件，那么它会停留在堆的老年代，占据很大部分空间，在JVM没有抛出OutOfMemoryError前，它有可能会导致频繁的Full GC，会对性能有一定的影响。 \n\n## 小结\n\n+ 软引用的具体回收时间与具体虚拟机有关\n+ 软引用中会在创建和调用get方法的时候更新内部timestamp，提供给虚拟机回收时进行参考\n+ hotspot虚拟机对于软引用使用的是LRU策略，回收时会根据软引用被闲置的时间和当前内存综合进行判断\n\n","source":"_posts/java/reference/soft-reference-code-detail.md","raw":"---\ntitle: SoftReference源码详解\ntags: \n - Java\n - 引用类型\ncategories: 编程\ndate: 2018-12-29 20:20:51\n---\n\n## 定义\n\nSoftReference是软引用，其引用的对象在内存不足的时候会被回收。只有软引用指向的对象称为软可达（softly-reachable）对象。\n\n## 说明\n\n垃圾回收器会在内存不足，经过一次垃圾回收后，内存仍旧不足的时候回收掉软可达对象。在虚拟机抛出OOM之前，会保证已经清除了所有指向软可达对象的软引用。\n\n如果内存足够，并没有规定回收软引用的具体时间，所以在内存充足的情况下，软引用对象也可能存活很长时间。\n\nJVM会根据当前内存的情况来决定是否回收softly-reachable对象，但只要referent有强引用存在，该referent就一定不会被清理，因此SoftReference适合用来实现memory-sensitive caches。软引用的回收策略在不同的JVM实现会略有不同。\n\n另外，JVM不仅仅只会考虑当前内存情况，还会考虑软引用所指向的referent最近使用情况和创建时间来综合决定是否回收该referent。\n\n一般而言，SoftReference对象会在垃圾回收器回收其内部referent后，才会被放入其注册的引用队列中（如果创建时注册了的话）。\n\n```ba&#39;sh\nSoft reference objects, which are cleared at the discretion of the garbage collector in response to memory demand. \n```\n\n就是说，软引用具体什么时候回收最终还是由虚拟机自己决定的，所以不同虚拟机对软引用的回收方式会有些不一样。\n\n## SoftReference源码\n\n```java\npublic class SoftReference<T> extends Reference<T> {\n    /**\n     * 由垃圾回收器负责更新的时间戳\n     */\n    static private long clock;\n\n    /**\n     * 在get方法调用时更新的时间戳，当虚拟机选择软引用进行清理时，可能会参考这个字段。\n     */\n    private long timestamp;\n\n    public SoftReference(T referent) {\n        super(referent);\n        this.timestamp = clock;\n    }\n\n    public SoftReference(T referent, ReferenceQueue<? super T> q) {\n        super(referent, q);\n        this.timestamp = clock;\n    }\n\n    /**\n     * 返回引用指向的对象，如果referent已经被程序或者垃圾回收器清理，则返回null。\n     */\n    public T get() {\n        T o = super.get();\n        if (o != null && this.timestamp != clock)\n            this.timestamp = clock;\n        return o;\n    }\n}\n```\n\nSoftReference类内部代码很少，两个成员变量，clock是一个静态变量，是由垃圾回收器负责更新的时间戳，在JVM初始化时，会对变量clock进行初始化，同时，在JVM发生GC时，也会更新clock的值，所以clock会记录上次GC发生的时间点。\n\ntimestamp是在创建和更新时更新的时间戳，将其更新为clock的值，垃圾回收器在回收软引用对象时可能会参考timestamp。\n\nSoftReference类有两个构造函数，一个是不传引用队列，一个传引用队列。在创建时，都会更新timestamp，将其赋值为clock的值，get方法也并没有什么骚操作，只是简单的调用 super.get() 并在返回值不为null时更新timestamp。\n\n## 软引用何时回收\n\n前面说过，软引用会在内存不足的时候进行回收，但是回收时并不会一次性全部回收，而是会使用一定的回收策略。\n\n下面以最常用的虚拟机HotSpot进行说明。下面是Oracle文档中的说明：\n\n```java\nThe default value is 1000 ms per megabyte, which means that a soft reference will survive (after the last strong reference to the object has been collected) for 1 second for each megabyte of free space in the heap\n```\n\n默认的生存周期为1000ms/Mb，举个具体的栗子：\n\n假设，堆内存为512Mb，并且可用内存为400Mb，我们创建一个object A，用软引用创建一个引用A的缓存对象cache，以及另一个object B 引用object A。此时，由于B持有A的强引用，所以对象A是强可达并且不会被垃圾回收器回收。\n\n{% asset_img soft-reference-3.png soft-reference-3 %}\n\n如果B被删除了，那么A仅剩下一个软引用cache引用它，如果A在400s内没有再次被强引用关联，它将会在超时后被删除。\n\n{% asset_img soft-reference-2.png soft-reference-2 %}\n\n下面是一个控制软引用的栗子：\n\n```java\npublic class SoftRefTest {\n    public static class A{\n    }\n    public static class B{\n        private A strongRef;\n \n        public void setStrongRef(A ref) {\n            this.strongRef = ref;\n        }\n    }\n    public static SoftReference<A> cache;\n \n    public static void main(String[] args) throws InterruptedException{\n        //用一个A类实例的软引用初始化cache对象\n        SoftRefTest.A instanceA = new SoftRefTest.A();\n        cache = new SoftReference<SoftRefTest.A>(instanceA);\n        instanceA = null;\n        // instanceA 现在是软可达状态，并且会在之后的某个时间被垃圾回收器回收\n        Thread.sleep(10000);\n \n        ...\n        SoftRefTest.B instanceB = new SoftRefTest.B();\n        //由于cache仅持有instanceA的软引用，所以无法保证instanceA仍然存活\n        instanceA = cache.get();\n        if (instanceA == null){\n            instanceA = new SoftRefTest.A();\n            cache = new SoftReference<SoftRefTest.A>(instanceA);\n        }\n        instanceB.setStrongRef(instanceA);\n        instanceA = null;\n        // instanceA现在与cache对象存在软引用并且与B对象存在强引用，所以它不会被垃圾回收器回收\n \n        ...\n    }\n}\n```\n\n但是需要注意的是，被软引用对象关联的对象会自动被垃圾回收器回收，但是软引用对象本身也是一个对象，这些创建的软引用并不会自动被垃圾回收器回收掉，所以在之前一篇中说明里的[栗子](./soft-reference.md#说明)里，软引用是不会被释放掉的。\n\n所以，你仍然需要手动去清理它们，否则也会导致OOM的产生，这里也举一个小栗子：\n\n```java\npublic class SoftReferenceTest{\n\n    public static class MyBigObject{\n        int[] data = new int[128];\n    }\n\n    public static int CACHE_INITIAL_CAPACITY = 100_000;\n    // 静态集合保存软引用，会导致这些软引用对象本身无法被垃圾回收器回收\n    public static Set<SoftReference<MyBigObject>> cache = new HashSet<>(CACHE_INITIAL_CAPACITY);\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 100_000; i++) {\n            MyBigObject obj = new MyBigObject();\n            cache.add(new SoftReference<>(obj));\n            if (i%10_000 == 0){\n                System.out.println(\"size of cache:\" + cache.size());\n            }\n        }\n        System.out.println(\"End\");\n    }\n}\n```\n\n使用的虚拟机参数为：\n\n```java\n-Xms4m -Xmx4m -Xmn2m\n```\n\n输出如下：\n\n```bash\nsize of cache:1\nsize of cache:10001\nsize of cache:20001\nsize of cache:30001\nException in thread \"main\" java.lang.OutOfMemoryError: GC overhead limit exceeded\n```\n\n最终抛出了OOM，但这里的原因却并不是`Java heap space`，而是` GC overhead limit exceeded ` ，之所以会抛出这个错误，是由于虚拟机一直在不断回收软引用，回收进行的速度过快，占用的cpu过大（超过98%），并且每次回收掉的内存过小（小于2%），导致最终抛出了这个错误。\n\n对于这里，合适的处理方式是注册一个引用队列，每次循环之后将引用队列中出现的软引用对象从cache中移除。\n\n```java\npublic class SoftReferenceTest{\n\n    public static int removedSoftRefs = 0;\n\n    public static class MyBigObject{\n        int[] data = new int[128];\n    }\n\n    public static int CACHE_INITIAL_CAPACITY = 100_000;\n    // 静态集合保存软引用，会导致这些软引用对象本身无法被垃圾回收器回收\n    public static Set<SoftReference<MyBigObject>> cache = new HashSet<>(CACHE_INITIAL_CAPACITY);\n    public static ReferenceQueue<MyBigObject> referenceQueue = new ReferenceQueue<>();\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 100_000; i++) {\n            MyBigObject obj = new MyBigObject();\n            cache.add(new SoftReference<>(obj, referenceQueue));\n            clearUselessReferences();\n        }\n        System.out.println(\"End, removed soft references=\" + removedSoftRefs);\n    }\n\n    public static void clearUselessReferences() {\n        Reference<? extends MyBigObject> ref = referenceQueue.poll();\n        while (ref != null) {\n            if (cache.remove(ref)) {\n                removedSoftRefs++;\n            }\n            ref = referenceQueue.poll();\n        }\n    }\n}\n```\n\n使用同样的虚拟机配置，输出如下：\n\n```bash\nEnd, removed soft references=97319\n```\n\n## HotSpot虚拟机对于软引用的处理\n\n就HotSpot虚拟机而言，常用的回收策略是基于当前堆大小的LRU策略（LRUCurrentHeapPolicy），会使用clock的值减去timestamp，得到的差值，就是这个软引用被闲置的时间，如果闲置足够长时间，就认为是可被回收的。\n\n```c++\nbool LRUCurrentHeapPolicy::should_clear_reference(oop p,\n                                                  jlong timestamp_clock) {\n  jlong interval = timestamp_clock - java_lang_ref_SoftReference::timestamp(p);\n  assert(interval >= 0, \"Sanity check\");\n\n  if(interval <= _max_interval) {\n    return false;\n  }\n\n  return true;\n}\n```\n\n这里 `timestamp_clock` 即SoftReference中clock的值，即上次GC时间。java_lang_ref_SoftReference::timestamp(p)可以获取引用中timestamp的值。\n\n那么这个足够长的时间 `_max_interval`是怎么计算的呢？\n\n```c++\nvoid LRUCurrentHeapPolicy::setup() {\n  _max_interval = (Universe::get_heap_free_at_last_gc() / M) * SoftRefLRUPolicyMSPerMB;\n  assert(_max_interval >= 0,\"Sanity check\");\n}\n```\n\n其中`SoftRefLRUPolicyMSPerMB`默认1000，所以可以看出这个回收时间与上次GC后的剩余空间大小有关，可用空间越大，`_max_interval`就越大。\n\n如果GC之后，堆的可用空间还很大的话，SoftReference对象可以长时间的在堆中而不被回收。反之，如果GC之后，只剩下很少的内存可用，那么SoftReference对象便会很快进行回收。\n\nSoftReference在一定程度上会影响垃圾回收，如果软可达对象中对应的referent多次垃圾回收仍然不满足释放条件，那么它会停留在堆的老年代，占据很大部分空间，在JVM没有抛出OutOfMemoryError前，它有可能会导致频繁的Full GC，会对性能有一定的影响。 \n\n## 小结\n\n+ 软引用的具体回收时间与具体虚拟机有关\n+ 软引用中会在创建和调用get方法的时候更新内部timestamp，提供给虚拟机回收时进行参考\n+ hotspot虚拟机对于软引用使用的是LRU策略，回收时会根据软引用被闲置的时间和当前内存综合进行判断\n\n","slug":"java/reference/soft-reference-code-detail","published":1,"updated":"2019-06-04T01:29:57.411Z","_id":"cjxze3gxe00670cvwchtc3rmu","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>SoftReference是软引用，其引用的对象在内存不足的时候会被回收。只有软引用指向的对象称为软可达（softly-reachable）对象。</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>垃圾回收器会在内存不足，经过一次垃圾回收后，内存仍旧不足的时候回收掉软可达对象。在虚拟机抛出OOM之前，会保证已经清除了所有指向软可达对象的软引用。</p>\n<p>如果内存足够，并没有规定回收软引用的具体时间，所以在内存充足的情况下，软引用对象也可能存活很长时间。</p>\n<p>JVM会根据当前内存的情况来决定是否回收softly-reachable对象，但只要referent有强引用存在，该referent就一定不会被清理，因此SoftReference适合用来实现memory-sensitive caches。软引用的回收策略在不同的JVM实现会略有不同。</p>\n<p>另外，JVM不仅仅只会考虑当前内存情况，还会考虑软引用所指向的referent最近使用情况和创建时间来综合决定是否回收该referent。</p>\n<p>一般而言，SoftReference对象会在垃圾回收器回收其内部referent后，才会被放入其注册的引用队列中（如果创建时注册了的话）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Soft reference objects, which are cleared at the discretion of the garbage collector in response to memory demand.</span><br></pre></td></tr></table></figure>\n<p>就是说，软引用具体什么时候回收最终还是由虚拟机自己决定的，所以不同虚拟机对软引用的回收方式会有些不一样。</p>\n<h2 id=\"SoftReference源码\"><a href=\"#SoftReference源码\" class=\"headerlink\" title=\"SoftReference源码\"></a>SoftReference源码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SoftReference</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Reference</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 由垃圾回收器负责更新的时间戳</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> clock;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在get方法调用时更新的时间戳，当虚拟机选择软引用进行清理时，可能会参考这个字段。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> timestamp;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SoftReference</span><span class=\"params\">(T referent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(referent);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.timestamp = clock;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SoftReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"keyword\">super</span> T&gt; q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(referent, q);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.timestamp = clock;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回引用指向的对象，如果referent已经被程序或者垃圾回收器清理，则返回null。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        T o = <span class=\"keyword\">super</span>.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o != <span class=\"keyword\">null</span> &amp;&amp; <span class=\"keyword\">this</span>.timestamp != clock)</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.timestamp = clock;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>SoftReference类内部代码很少，两个成员变量，clock是一个静态变量，是由垃圾回收器负责更新的时间戳，在JVM初始化时，会对变量clock进行初始化，同时，在JVM发生GC时，也会更新clock的值，所以clock会记录上次GC发生的时间点。</p>\n<p>timestamp是在创建和更新时更新的时间戳，将其更新为clock的值，垃圾回收器在回收软引用对象时可能会参考timestamp。</p>\n<p>SoftReference类有两个构造函数，一个是不传引用队列，一个传引用队列。在创建时，都会更新timestamp，将其赋值为clock的值，get方法也并没有什么骚操作，只是简单的调用 super.get() 并在返回值不为null时更新timestamp。</p>\n<h2 id=\"软引用何时回收\"><a href=\"#软引用何时回收\" class=\"headerlink\" title=\"软引用何时回收\"></a>软引用何时回收</h2><p>前面说过，软引用会在内存不足的时候进行回收，但是回收时并不会一次性全部回收，而是会使用一定的回收策略。</p>\n<p>下面以最常用的虚拟机HotSpot进行说明。下面是Oracle文档中的说明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The <span class=\"keyword\">default</span> value is <span class=\"number\">1000</span> ms per megabyte, <span class=\"function\">which means that a soft reference will <span class=\"title\">survive</span> <span class=\"params\">(after the last strong reference to the object has been collected)</span> <span class=\"keyword\">for</span> 1 second <span class=\"keyword\">for</span> each megabyte of free space in the heap</span></span><br></pre></td></tr></table></figure>\n<p>默认的生存周期为1000ms/Mb，举个具体的栗子：</p>\n<p>假设，堆内存为512Mb，并且可用内存为400Mb，我们创建一个object A，用软引用创建一个引用A的缓存对象cache，以及另一个object B 引用object A。此时，由于B持有A的强引用，所以对象A是强可达并且不会被垃圾回收器回收。</p>\n<img src=\"/programming/java/reference/soft-reference-code-detail/soft-reference-3.png\" title=\"soft-reference-3\">\n<p>如果B被删除了，那么A仅剩下一个软引用cache引用它，如果A在400s内没有再次被强引用关联，它将会在超时后被删除。</p>\n<img src=\"/programming/java/reference/soft-reference-code-detail/soft-reference-2.png\" title=\"soft-reference-2\">\n<p>下面是一个控制软引用的栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SoftRefTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> A strongRef;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setStrongRef</span><span class=\"params\">(A ref)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.strongRef = ref;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SoftReference&lt;A&gt; cache;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//用一个A类实例的软引用初始化cache对象</span></span><br><span class=\"line\">        SoftRefTest.A instanceA = <span class=\"keyword\">new</span> SoftRefTest.A();</span><br><span class=\"line\">        cache = <span class=\"keyword\">new</span> SoftReference&lt;SoftRefTest.A&gt;(instanceA);</span><br><span class=\"line\">        instanceA = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// instanceA 现在是软可达状态，并且会在之后的某个时间被垃圾回收器回收</span></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">10000</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">        ...</span><br><span class=\"line\">        SoftRefTest.B instanceB = <span class=\"keyword\">new</span> SoftRefTest.B();</span><br><span class=\"line\">        <span class=\"comment\">//由于cache仅持有instanceA的软引用，所以无法保证instanceA仍然存活</span></span><br><span class=\"line\">        instanceA = cache.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instanceA == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            instanceA = <span class=\"keyword\">new</span> SoftRefTest.A();</span><br><span class=\"line\">            cache = <span class=\"keyword\">new</span> SoftReference&lt;SoftRefTest.A&gt;(instanceA);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        instanceB.setStrongRef(instanceA);</span><br><span class=\"line\">        instanceA = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// instanceA现在与cache对象存在软引用并且与B对象存在强引用，所以它不会被垃圾回收器回收</span></span><br><span class=\"line\"> </span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是需要注意的是，被软引用对象关联的对象会自动被垃圾回收器回收，但是软引用对象本身也是一个对象，这些创建的软引用并不会自动被垃圾回收器回收掉，所以在之前一篇中说明里的<a href=\"./soft-reference.md#说明\">栗子</a>里，软引用是不会被释放掉的。</p>\n<p>所以，你仍然需要手动去清理它们，否则也会导致OOM的产生，这里也举一个小栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SoftReferenceTest</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyBigObject</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] data = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">128</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> CACHE_INITIAL_CAPACITY = <span class=\"number\">100_000</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 静态集合保存软引用，会导致这些软引用对象本身无法被垃圾回收器回收</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Set&lt;SoftReference&lt;MyBigObject&gt;&gt; cache = <span class=\"keyword\">new</span> HashSet&lt;&gt;(CACHE_INITIAL_CAPACITY);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100_000</span>; i++) &#123;</span><br><span class=\"line\">            MyBigObject obj = <span class=\"keyword\">new</span> MyBigObject();</span><br><span class=\"line\">            cache.add(<span class=\"keyword\">new</span> SoftReference&lt;&gt;(obj));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i%<span class=\"number\">10_000</span> == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"size of cache:\"</span> + cache.size());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"End\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用的虚拟机参数为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xms4m -Xmx4m -Xmn2m</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">size of cache:1</span><br><span class=\"line\">size of cache:10001</span><br><span class=\"line\">size of cache:20001</span><br><span class=\"line\">size of cache:30001</span><br><span class=\"line\">Exception <span class=\"keyword\">in</span> thread <span class=\"string\">\"main\"</span> java.lang.OutOfMemoryError: GC overhead <span class=\"built_in\">limit</span> exceeded</span><br></pre></td></tr></table></figure>\n<p>最终抛出了OOM，但这里的原因却并不是<code>Java heap space</code>，而是<code>GC overhead limit exceeded</code> ，之所以会抛出这个错误，是由于虚拟机一直在不断回收软引用，回收进行的速度过快，占用的cpu过大（超过98%），并且每次回收掉的内存过小（小于2%），导致最终抛出了这个错误。</p>\n<p>对于这里，合适的处理方式是注册一个引用队列，每次循环之后将引用队列中出现的软引用对象从cache中移除。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SoftReferenceTest</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> removedSoftRefs = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyBigObject</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] data = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">128</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> CACHE_INITIAL_CAPACITY = <span class=\"number\">100_000</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 静态集合保存软引用，会导致这些软引用对象本身无法被垃圾回收器回收</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Set&lt;SoftReference&lt;MyBigObject&gt;&gt; cache = <span class=\"keyword\">new</span> HashSet&lt;&gt;(CACHE_INITIAL_CAPACITY);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ReferenceQueue&lt;MyBigObject&gt; referenceQueue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100_000</span>; i++) &#123;</span><br><span class=\"line\">            MyBigObject obj = <span class=\"keyword\">new</span> MyBigObject();</span><br><span class=\"line\">            cache.add(<span class=\"keyword\">new</span> SoftReference&lt;&gt;(obj, referenceQueue));</span><br><span class=\"line\">            clearUselessReferences();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"End, removed soft references=\"</span> + removedSoftRefs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">clearUselessReferences</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Reference&lt;? extends MyBigObject&gt; ref = referenceQueue.poll();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (ref != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cache.remove(ref)) &#123;</span><br><span class=\"line\">                removedSoftRefs++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ref = referenceQueue.poll();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用同样的虚拟机配置，输出如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">End, removed soft references=97319</span><br></pre></td></tr></table></figure>\n<h2 id=\"HotSpot虚拟机对于软引用的处理\"><a href=\"#HotSpot虚拟机对于软引用的处理\" class=\"headerlink\" title=\"HotSpot虚拟机对于软引用的处理\"></a>HotSpot虚拟机对于软引用的处理</h2><p>就HotSpot虚拟机而言，常用的回收策略是基于当前堆大小的LRU策略（LRUCurrentHeapPolicy），会使用clock的值减去timestamp，得到的差值，就是这个软引用被闲置的时间，如果闲置足够长时间，就认为是可被回收的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> LRUCurrentHeapPolicy::should_clear_reference(oop p,</span><br><span class=\"line\">                                                  jlong timestamp_clock) &#123;</span><br><span class=\"line\">  jlong interval = timestamp_clock - java_lang_ref_SoftReference::timestamp(p);</span><br><span class=\"line\">  assert(interval &gt;= <span class=\"number\">0</span>, <span class=\"string\">\"Sanity check\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(interval &lt;= _max_interval) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里 <code>timestamp_clock</code> 即SoftReference中clock的值，即上次GC时间。java_lang_ref_SoftReference::timestamp(p)可以获取引用中timestamp的值。</p>\n<p>那么这个足够长的时间 <code>_max_interval</code>是怎么计算的呢？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> LRUCurrentHeapPolicy::setup() &#123;</span><br><span class=\"line\">  _max_interval = (Universe::get_heap_free_at_last_gc() / M) * SoftRefLRUPolicyMSPerMB;</span><br><span class=\"line\">  assert(_max_interval &gt;= <span class=\"number\">0</span>,<span class=\"string\">\"Sanity check\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中<code>SoftRefLRUPolicyMSPerMB</code>默认1000，所以可以看出这个回收时间与上次GC后的剩余空间大小有关，可用空间越大，<code>_max_interval</code>就越大。</p>\n<p>如果GC之后，堆的可用空间还很大的话，SoftReference对象可以长时间的在堆中而不被回收。反之，如果GC之后，只剩下很少的内存可用，那么SoftReference对象便会很快进行回收。</p>\n<p>SoftReference在一定程度上会影响垃圾回收，如果软可达对象中对应的referent多次垃圾回收仍然不满足释放条件，那么它会停留在堆的老年代，占据很大部分空间，在JVM没有抛出OutOfMemoryError前，它有可能会导致频繁的Full GC，会对性能有一定的影响。 </p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>软引用的具体回收时间与具体虚拟机有关</li>\n<li>软引用中会在创建和调用get方法的时候更新内部timestamp，提供给虚拟机回收时进行参考</li>\n<li>hotspot虚拟机对于软引用使用的是LRU策略，回收时会根据软引用被闲置的时间和当前内存综合进行判断</li>\n</ul>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>SoftReference是软引用，其引用的对象在内存不足的时候会被回收。只有软引用指向的对象称为软可达（softly-reachable）对象。</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>垃圾回收器会在内存不足，经过一次垃圾回收后，内存仍旧不足的时候回收掉软可达对象。在虚拟机抛出OOM之前，会保证已经清除了所有指向软可达对象的软引用。</p>\n<p>如果内存足够，并没有规定回收软引用的具体时间，所以在内存充足的情况下，软引用对象也可能存活很长时间。</p>\n<p>JVM会根据当前内存的情况来决定是否回收softly-reachable对象，但只要referent有强引用存在，该referent就一定不会被清理，因此SoftReference适合用来实现memory-sensitive caches。软引用的回收策略在不同的JVM实现会略有不同。</p>\n<p>另外，JVM不仅仅只会考虑当前内存情况，还会考虑软引用所指向的referent最近使用情况和创建时间来综合决定是否回收该referent。</p>\n<p>一般而言，SoftReference对象会在垃圾回收器回收其内部referent后，才会被放入其注册的引用队列中（如果创建时注册了的话）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Soft reference objects, which are cleared at the discretion of the garbage collector in response to memory demand.</span><br></pre></td></tr></table></figure>\n<p>就是说，软引用具体什么时候回收最终还是由虚拟机自己决定的，所以不同虚拟机对软引用的回收方式会有些不一样。</p>\n<h2 id=\"SoftReference源码\"><a href=\"#SoftReference源码\" class=\"headerlink\" title=\"SoftReference源码\"></a>SoftReference源码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SoftReference</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Reference</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 由垃圾回收器负责更新的时间戳</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> clock;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在get方法调用时更新的时间戳，当虚拟机选择软引用进行清理时，可能会参考这个字段。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> timestamp;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SoftReference</span><span class=\"params\">(T referent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(referent);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.timestamp = clock;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SoftReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"keyword\">super</span> T&gt; q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(referent, q);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.timestamp = clock;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回引用指向的对象，如果referent已经被程序或者垃圾回收器清理，则返回null。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        T o = <span class=\"keyword\">super</span>.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o != <span class=\"keyword\">null</span> &amp;&amp; <span class=\"keyword\">this</span>.timestamp != clock)</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.timestamp = clock;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>SoftReference类内部代码很少，两个成员变量，clock是一个静态变量，是由垃圾回收器负责更新的时间戳，在JVM初始化时，会对变量clock进行初始化，同时，在JVM发生GC时，也会更新clock的值，所以clock会记录上次GC发生的时间点。</p>\n<p>timestamp是在创建和更新时更新的时间戳，将其更新为clock的值，垃圾回收器在回收软引用对象时可能会参考timestamp。</p>\n<p>SoftReference类有两个构造函数，一个是不传引用队列，一个传引用队列。在创建时，都会更新timestamp，将其赋值为clock的值，get方法也并没有什么骚操作，只是简单的调用 super.get() 并在返回值不为null时更新timestamp。</p>\n<h2 id=\"软引用何时回收\"><a href=\"#软引用何时回收\" class=\"headerlink\" title=\"软引用何时回收\"></a>软引用何时回收</h2><p>前面说过，软引用会在内存不足的时候进行回收，但是回收时并不会一次性全部回收，而是会使用一定的回收策略。</p>\n<p>下面以最常用的虚拟机HotSpot进行说明。下面是Oracle文档中的说明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The <span class=\"keyword\">default</span> value is <span class=\"number\">1000</span> ms per megabyte, <span class=\"function\">which means that a soft reference will <span class=\"title\">survive</span> <span class=\"params\">(after the last strong reference to the object has been collected)</span> <span class=\"keyword\">for</span> 1 second <span class=\"keyword\">for</span> each megabyte of free space in the heap</span></span><br></pre></td></tr></table></figure>\n<p>默认的生存周期为1000ms/Mb，举个具体的栗子：</p>\n<p>假设，堆内存为512Mb，并且可用内存为400Mb，我们创建一个object A，用软引用创建一个引用A的缓存对象cache，以及另一个object B 引用object A。此时，由于B持有A的强引用，所以对象A是强可达并且不会被垃圾回收器回收。</p>\n<img src=\"/programming/java/reference/soft-reference-code-detail/soft-reference-3.png\" title=\"soft-reference-3\">\n<p>如果B被删除了，那么A仅剩下一个软引用cache引用它，如果A在400s内没有再次被强引用关联，它将会在超时后被删除。</p>\n<img src=\"/programming/java/reference/soft-reference-code-detail/soft-reference-2.png\" title=\"soft-reference-2\">\n<p>下面是一个控制软引用的栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SoftRefTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> A strongRef;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setStrongRef</span><span class=\"params\">(A ref)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.strongRef = ref;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SoftReference&lt;A&gt; cache;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//用一个A类实例的软引用初始化cache对象</span></span><br><span class=\"line\">        SoftRefTest.A instanceA = <span class=\"keyword\">new</span> SoftRefTest.A();</span><br><span class=\"line\">        cache = <span class=\"keyword\">new</span> SoftReference&lt;SoftRefTest.A&gt;(instanceA);</span><br><span class=\"line\">        instanceA = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// instanceA 现在是软可达状态，并且会在之后的某个时间被垃圾回收器回收</span></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">10000</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">        ...</span><br><span class=\"line\">        SoftRefTest.B instanceB = <span class=\"keyword\">new</span> SoftRefTest.B();</span><br><span class=\"line\">        <span class=\"comment\">//由于cache仅持有instanceA的软引用，所以无法保证instanceA仍然存活</span></span><br><span class=\"line\">        instanceA = cache.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instanceA == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            instanceA = <span class=\"keyword\">new</span> SoftRefTest.A();</span><br><span class=\"line\">            cache = <span class=\"keyword\">new</span> SoftReference&lt;SoftRefTest.A&gt;(instanceA);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        instanceB.setStrongRef(instanceA);</span><br><span class=\"line\">        instanceA = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// instanceA现在与cache对象存在软引用并且与B对象存在强引用，所以它不会被垃圾回收器回收</span></span><br><span class=\"line\"> </span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是需要注意的是，被软引用对象关联的对象会自动被垃圾回收器回收，但是软引用对象本身也是一个对象，这些创建的软引用并不会自动被垃圾回收器回收掉，所以在之前一篇中说明里的<a href=\"./soft-reference.md#说明\">栗子</a>里，软引用是不会被释放掉的。</p>\n<p>所以，你仍然需要手动去清理它们，否则也会导致OOM的产生，这里也举一个小栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SoftReferenceTest</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyBigObject</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] data = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">128</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> CACHE_INITIAL_CAPACITY = <span class=\"number\">100_000</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 静态集合保存软引用，会导致这些软引用对象本身无法被垃圾回收器回收</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Set&lt;SoftReference&lt;MyBigObject&gt;&gt; cache = <span class=\"keyword\">new</span> HashSet&lt;&gt;(CACHE_INITIAL_CAPACITY);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100_000</span>; i++) &#123;</span><br><span class=\"line\">            MyBigObject obj = <span class=\"keyword\">new</span> MyBigObject();</span><br><span class=\"line\">            cache.add(<span class=\"keyword\">new</span> SoftReference&lt;&gt;(obj));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i%<span class=\"number\">10_000</span> == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"size of cache:\"</span> + cache.size());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"End\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用的虚拟机参数为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xms4m -Xmx4m -Xmn2m</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">size of cache:1</span><br><span class=\"line\">size of cache:10001</span><br><span class=\"line\">size of cache:20001</span><br><span class=\"line\">size of cache:30001</span><br><span class=\"line\">Exception <span class=\"keyword\">in</span> thread <span class=\"string\">\"main\"</span> java.lang.OutOfMemoryError: GC overhead <span class=\"built_in\">limit</span> exceeded</span><br></pre></td></tr></table></figure>\n<p>最终抛出了OOM，但这里的原因却并不是<code>Java heap space</code>，而是<code>GC overhead limit exceeded</code> ，之所以会抛出这个错误，是由于虚拟机一直在不断回收软引用，回收进行的速度过快，占用的cpu过大（超过98%），并且每次回收掉的内存过小（小于2%），导致最终抛出了这个错误。</p>\n<p>对于这里，合适的处理方式是注册一个引用队列，每次循环之后将引用队列中出现的软引用对象从cache中移除。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SoftReferenceTest</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> removedSoftRefs = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyBigObject</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] data = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">128</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> CACHE_INITIAL_CAPACITY = <span class=\"number\">100_000</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 静态集合保存软引用，会导致这些软引用对象本身无法被垃圾回收器回收</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Set&lt;SoftReference&lt;MyBigObject&gt;&gt; cache = <span class=\"keyword\">new</span> HashSet&lt;&gt;(CACHE_INITIAL_CAPACITY);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ReferenceQueue&lt;MyBigObject&gt; referenceQueue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100_000</span>; i++) &#123;</span><br><span class=\"line\">            MyBigObject obj = <span class=\"keyword\">new</span> MyBigObject();</span><br><span class=\"line\">            cache.add(<span class=\"keyword\">new</span> SoftReference&lt;&gt;(obj, referenceQueue));</span><br><span class=\"line\">            clearUselessReferences();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"End, removed soft references=\"</span> + removedSoftRefs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">clearUselessReferences</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Reference&lt;? extends MyBigObject&gt; ref = referenceQueue.poll();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (ref != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cache.remove(ref)) &#123;</span><br><span class=\"line\">                removedSoftRefs++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ref = referenceQueue.poll();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用同样的虚拟机配置，输出如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">End, removed soft references=97319</span><br></pre></td></tr></table></figure>\n<h2 id=\"HotSpot虚拟机对于软引用的处理\"><a href=\"#HotSpot虚拟机对于软引用的处理\" class=\"headerlink\" title=\"HotSpot虚拟机对于软引用的处理\"></a>HotSpot虚拟机对于软引用的处理</h2><p>就HotSpot虚拟机而言，常用的回收策略是基于当前堆大小的LRU策略（LRUCurrentHeapPolicy），会使用clock的值减去timestamp，得到的差值，就是这个软引用被闲置的时间，如果闲置足够长时间，就认为是可被回收的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> LRUCurrentHeapPolicy::should_clear_reference(oop p,</span><br><span class=\"line\">                                                  jlong timestamp_clock) &#123;</span><br><span class=\"line\">  jlong interval = timestamp_clock - java_lang_ref_SoftReference::timestamp(p);</span><br><span class=\"line\">  assert(interval &gt;= <span class=\"number\">0</span>, <span class=\"string\">\"Sanity check\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(interval &lt;= _max_interval) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里 <code>timestamp_clock</code> 即SoftReference中clock的值，即上次GC时间。java_lang_ref_SoftReference::timestamp(p)可以获取引用中timestamp的值。</p>\n<p>那么这个足够长的时间 <code>_max_interval</code>是怎么计算的呢？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> LRUCurrentHeapPolicy::setup() &#123;</span><br><span class=\"line\">  _max_interval = (Universe::get_heap_free_at_last_gc() / M) * SoftRefLRUPolicyMSPerMB;</span><br><span class=\"line\">  assert(_max_interval &gt;= <span class=\"number\">0</span>,<span class=\"string\">\"Sanity check\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中<code>SoftRefLRUPolicyMSPerMB</code>默认1000，所以可以看出这个回收时间与上次GC后的剩余空间大小有关，可用空间越大，<code>_max_interval</code>就越大。</p>\n<p>如果GC之后，堆的可用空间还很大的话，SoftReference对象可以长时间的在堆中而不被回收。反之，如果GC之后，只剩下很少的内存可用，那么SoftReference对象便会很快进行回收。</p>\n<p>SoftReference在一定程度上会影响垃圾回收，如果软可达对象中对应的referent多次垃圾回收仍然不满足释放条件，那么它会停留在堆的老年代，占据很大部分空间，在JVM没有抛出OutOfMemoryError前，它有可能会导致频繁的Full GC，会对性能有一定的影响。 </p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>软引用的具体回收时间与具体虚拟机有关</li>\n<li>软引用中会在创建和调用get方法的时候更新内部timestamp，提供给虚拟机回收时进行参考</li>\n<li>hotspot虚拟机对于软引用使用的是LRU策略，回收时会根据软引用被闲置的时间和当前内存综合进行判断</li>\n</ul>\n"},{"title":"WeakReference源码详解","date":"2018-12-29T12:20:51.000Z","_content":"\n## 定义\n\nWeakReference是弱引用，该引用不会影响垃圾回收器对对象的回收，不会影响对象的生命周期。\n\n## 说明\n\n当虚拟机在某个时间点决定要回收一个弱可达（weakly-reachable）对象时，会自动清除该对象的所有弱引用。并且会将对象变为finalizable状态，然后把这些刚清除的弱引用放到其注册的引用队列中。\n\n[前面](./weak-reference.html)已经说明过WeakReference的用法了，本篇仅对WeakReference从源码角度做一些补充。\n\n## 源码\n\n```java\npublic class WeakReference<T> extends Reference<T> {\n    public WeakReference(T referent) {\n        super(referent);\n    }\n    \n    public WeakReference(T referent, ReferenceQueue<? super T> q) {\n        super(referent, q);\n    }\n    \n}\n```\n\n嗯，十行代码，可以说是很简单的一个类了，只有两个构造函数，一个传引用队列，另一个不传，没有覆盖父类Reference的任何方法。\n\n## WeakHashMap\n\n说到WeakReference，自然不能不说WeakHashMap，这个map的用法与hashmap基本一致，它的特点便是使用弱引用作为key，这就让它有一个很重要的特性，它可以自动清除自身，这样就不需要再像之前SoftReference那样需要手动去释放引用实例。\n\n如果想了解关于WeakHashMap更详细的内容，可以戳[这里](../collections/weakhashmap-code-detail.html)。\n\n<img src=\"/images/06.png\" width=\"40\"/>好像。。。没什么可讲的了。在前面弱引用一篇里基本都讲完了。 ","source":"_posts/java/reference/weak-reference-code-detail.md","raw":"---\ntitle: WeakReference源码详解\ntags: \n - Java\n - 引用类型\ncategories: 编程\ndate: 2018-12-29 20:20:51\n---\n\n## 定义\n\nWeakReference是弱引用，该引用不会影响垃圾回收器对对象的回收，不会影响对象的生命周期。\n\n## 说明\n\n当虚拟机在某个时间点决定要回收一个弱可达（weakly-reachable）对象时，会自动清除该对象的所有弱引用。并且会将对象变为finalizable状态，然后把这些刚清除的弱引用放到其注册的引用队列中。\n\n[前面](./weak-reference.html)已经说明过WeakReference的用法了，本篇仅对WeakReference从源码角度做一些补充。\n\n## 源码\n\n```java\npublic class WeakReference<T> extends Reference<T> {\n    public WeakReference(T referent) {\n        super(referent);\n    }\n    \n    public WeakReference(T referent, ReferenceQueue<? super T> q) {\n        super(referent, q);\n    }\n    \n}\n```\n\n嗯，十行代码，可以说是很简单的一个类了，只有两个构造函数，一个传引用队列，另一个不传，没有覆盖父类Reference的任何方法。\n\n## WeakHashMap\n\n说到WeakReference，自然不能不说WeakHashMap，这个map的用法与hashmap基本一致，它的特点便是使用弱引用作为key，这就让它有一个很重要的特性，它可以自动清除自身，这样就不需要再像之前SoftReference那样需要手动去释放引用实例。\n\n如果想了解关于WeakHashMap更详细的内容，可以戳[这里](../collections/weakhashmap-code-detail.html)。\n\n<img src=\"/images/06.png\" width=\"40\"/>好像。。。没什么可讲的了。在前面弱引用一篇里基本都讲完了。 ","slug":"java/reference/weak-reference-code-detail","published":1,"updated":"2019-06-04T01:29:57.414Z","_id":"cjxze3gxe006b0cvwp2lb0o4u","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>WeakReference是弱引用，该引用不会影响垃圾回收器对对象的回收，不会影响对象的生命周期。</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>当虚拟机在某个时间点决定要回收一个弱可达（weakly-reachable）对象时，会自动清除该对象的所有弱引用。并且会将对象变为finalizable状态，然后把这些刚清除的弱引用放到其注册的引用队列中。</p>\n<p><a href=\"./weak-reference.html\">前面</a>已经说明过WeakReference的用法了，本篇仅对WeakReference从源码角度做一些补充。</p>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Reference</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WeakReference</span><span class=\"params\">(T referent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(referent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WeakReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"keyword\">super</span> T&gt; q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(referent, q);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>嗯，十行代码，可以说是很简单的一个类了，只有两个构造函数，一个传引用队列，另一个不传，没有覆盖父类Reference的任何方法。</p>\n<h2 id=\"WeakHashMap\"><a href=\"#WeakHashMap\" class=\"headerlink\" title=\"WeakHashMap\"></a>WeakHashMap</h2><p>说到WeakReference，自然不能不说WeakHashMap，这个map的用法与hashmap基本一致，它的特点便是使用弱引用作为key，这就让它有一个很重要的特性，它可以自动清除自身，这样就不需要再像之前SoftReference那样需要手动去释放引用实例。</p>\n<p>如果想了解关于WeakHashMap更详细的内容，可以戳<a href=\"../collections/weakhashmap-code-detail.html\">这里</a>。</p>\n<p><img src=\"/images/06.png\" width=\"40\">好像。。。没什么可讲的了。在前面弱引用一篇里基本都讲完了。 </p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>WeakReference是弱引用，该引用不会影响垃圾回收器对对象的回收，不会影响对象的生命周期。</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>当虚拟机在某个时间点决定要回收一个弱可达（weakly-reachable）对象时，会自动清除该对象的所有弱引用。并且会将对象变为finalizable状态，然后把这些刚清除的弱引用放到其注册的引用队列中。</p>\n<p><a href=\"./weak-reference.html\">前面</a>已经说明过WeakReference的用法了，本篇仅对WeakReference从源码角度做一些补充。</p>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Reference</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WeakReference</span><span class=\"params\">(T referent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(referent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WeakReference</span><span class=\"params\">(T referent, ReferenceQueue&lt;? <span class=\"keyword\">super</span> T&gt; q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(referent, q);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>嗯，十行代码，可以说是很简单的一个类了，只有两个构造函数，一个传引用队列，另一个不传，没有覆盖父类Reference的任何方法。</p>\n<h2 id=\"WeakHashMap\"><a href=\"#WeakHashMap\" class=\"headerlink\" title=\"WeakHashMap\"></a>WeakHashMap</h2><p>说到WeakReference，自然不能不说WeakHashMap，这个map的用法与hashmap基本一致，它的特点便是使用弱引用作为key，这就让它有一个很重要的特性，它可以自动清除自身，这样就不需要再像之前SoftReference那样需要手动去释放引用实例。</p>\n<p>如果想了解关于WeakHashMap更详细的内容，可以戳<a href=\"../collections/weakhashmap-code-detail.html\">这里</a>。</p>\n<p><img src=\"/images/06.png\" width=\"40\">好像。。。没什么可讲的了。在前面弱引用一篇里基本都讲完了。 </p>\n"},{"title":"ReferenceQueue源码详解","date":"2018-12-30T12:10:51.000Z","_content":"\n## 定义\n\nReferenceQueue是引用队列，用于存放待回收的引用对象.\n\n## 说明\n\n对于软引用、弱引用和虚引用，如果我们希望当一个对象被垃圾回收器回收时能得到通知，进行额外的处理，这时候就需要使用到引用队列了。 \n\n在一个对象被垃圾回收器扫描到将要进行回收时，其相应的引用包装类，即reference对象会被放入其注册的引用队列queue中。可以从queue中获取到相应的对象信息，同时进行额外的处理。比如反向操作，数据清理，资源释放等。\n\n## 使用例子\n\n```java\npublic class ReferenceQueueTest {\n    private static ReferenceQueue<byte[]> rq = new ReferenceQueue<>();\n    private static int _1M = 1024 * 1024;\n\n    public static void main(String[] args) {\n        Object value = new Object();\n        Map<WeakReference<byte[]>, Object> map = new HashMap<>();\n        Thread thread = new Thread(ReferenceQueueTest::run);\n        thread.setDaemon(true);\n        thread.start();\n\n        for(int i = 0;i < 100;i++) {\n            byte[] bytes = new byte[_1M];\n            WeakReference<byte[]> weakReference = new WeakReference<>(bytes, rq);\n            map.put(weakReference, value);\n        }\n        System.out.println(\"map.size->\" + map.size());\n        \n        int aliveNum = 0;\n        for (Map.Entry<WeakReference<byte[]>, Object> entry : map.entrySet()){\n            if (entry != null){\n                if (entry.getKey().get() != null){\n                    aliveNum++;\n                }\n            }\n        }\n        System.out.println(\"100个对象中存活的对象数量：\" + aliveNum);\n    }\n\n    private static void run() {\n        try {\n            int n = 0;\n            WeakReference k;\n            while ((k = (WeakReference) rq.remove()) != null) {\n                System.out.println((++n) + \"回收了:\" + k);\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n这里有一个小栗子，main方法中，创建了一条线程，使用死循环来从引用队列中获取元素，监控对象被回收的状态。然后循环往map中添加了100个映射关系，以下是运行结果：\n\n```java\n...前面省略了大量相似输出\n85回收了:java.lang.ref.WeakReference@7106e68e\n86回收了:java.lang.ref.WeakReference@1f17ae12\n87回收了:java.lang.ref.WeakReference@c4437c4\nmap.size->100\n100个对象中存活的对象数量：12\n```\n\n通过配合使用ReferenceQueue，可以较好的监控对象的生存状态。\n\n## 成员变量\n\nReferenceQueue中内部成员变量也很少，主要有这么几个：\n\n```java\nstatic ReferenceQueue<Object> NULL = new Null<>();\nstatic ReferenceQueue<Object> ENQUEUED = new Null<>();\n```\n\n有两个用来做为特殊标记的静态成员变量，一个是NULL，一个是ENQUEUE，上一篇中说的ReferenceQueue.NULL和ReferenceQueue.ENQUEUED就是这两个家伙。\n\n来看看Null长什么样：\n\n```java\nprivate static class Null<S> extends ReferenceQueue<S> {\n    boolean enqueue(Reference<? extends S> r) {\n        return false;\n    }\n}\n```\n\n只是简单继承了ReferenceQueue的一个类，emmm，为什么不直接new一个ReferenceQueue呢？这里自然是有它的道理的，如果直接使用ReferenceQueue，就会导致有可能误操作这个NULL和ENQUEUED变量，因为ReferenceQueue中enqueue方法是需要使用lock对象锁的，这里覆盖了这个方法并直接返回false，这样就避免了乱用的可能性，也避免了不必要的资源浪费。\n\n```java\nstatic private class Lock { };\nprivate Lock lock = new Lock();\n```\n\n跟Reference一样，有一个lock对象用来做同步对象。\n\n```java\nprivate volatile Reference<? extends T> head = null;\n```\n\nhead用来保存队列的头结点，因为Reference是一个单链表结构，所以只需要保存头结点即可。\n\n```java\nprivate long queueLength = 0;\n```\n\nqueueLength用来保存队列长度，在添加元素的时候+1，移除元素的时候-1，因为在添加和移除操作的时候都会使用synchronized进行同步，所以不用担心多线程修改会不会出错的问题。\n\n## 内部方法\n\n```java\n// 这个方法仅会被Reference类调用\nboolean enqueue(Reference<? extends T> r) { \n    synchronized (lock) {\n        // 检测从获取这个锁之后，该Reference没有入队，并且没有被移除\n        ReferenceQueue<?> queue = r.queue;\n        if ((queue == NULL) || (queue == ENQUEUED)) {\n            return false;\n        }\n        assert queue == this;\n        // 将reference的queue标记为ENQUEUED\n        r.queue = ENQUEUED;\n        // 将r设置为链表的头结点\n        r.next = (head == null) ? r : head;\n        head = r;\n        queueLength++;\n        // 如果r的FinalReference类型，则将FinalRef+1\n        if (r instanceof FinalReference) {\n            sun.misc.VM.addFinalRefCount(1);\n        }\n        lock.notifyAll();\n        return true;\n    }\n}\n```\n\n这里是入队的方法，使用了lock对象锁进行同步，将传入的r添加到队列中，并重置头结点为传入的节点。\n\n```java\npublic Reference<? extends T> poll() {\n    if (head == null)\n        return null;\n    synchronized (lock) {\n        return reallyPoll();\n    }\n}\n\nprivate Reference<? extends T> reallyPoll() {     \n    Reference<? extends T> r = head;\n    if (r != null) {\n        head = (r.next == r) ?\n            null : r.next;\n        r.queue = NULL;\n        r.next = r;\n        queueLength--;\n        if (r instanceof FinalReference) {\n            sun.misc.VM.addFinalRefCount(-1);\n        }\n        return r;\n    }\n    return null;\n}\n```\n\npoll方法将头结点弹出。嗯，没错，弹出的是头结点而不是尾节点，名义上，它叫ReferenceQueue，实际上是一个ReferenceStack（滑稽）。惊不惊喜，意不意外。<img src=\"/images/0001.png\" width=\"50\"/>\n\n```java\n/**\n  * 移除并返回队列首节点，此方法将阻塞到获取到一个Reference对象或者超时才会返回\n  * timeout时间的单位是毫秒\n  */\npublic Reference<? extends T> remove(long timeout)\n    throws IllegalArgumentException, InterruptedException{\n    if (timeout < 0) {\n        throw new IllegalArgumentException(\"Negative timeout value\");\n    }\n    synchronized (lock) {\n        Reference<? extends T> r = reallyPoll();\n        if (r != null) return r;\n        long start = (timeout == 0) ? 0 : System.nanoTime();\n        // 死循环，直到取到数据或者超时\n        for (;;) {\n            lock.wait(timeout);\n            r = reallyPoll();\n            if (r != null) return r;\n            if (timeout != 0) {\n                // System.nanoTime方法返回的是纳秒，1毫秒=1纳秒*1000*1000\n                long end = System.nanoTime();\n                timeout -= (end - start) / 1000_000;\n                if (timeout <= 0) return null;\n                start = end;\n            }\n        }\n    }\n}\n\n/**\n * 移除并返回队列首节点，此方法将阻塞到获取到一个Reference对象才会返回\n */\npublic Reference<? extends T> remove() throws InterruptedException {\n\treturn remove(0);\n}\n```\n\n这里两个方法都是从队列中移除首节点，与poll不同的是，它会阻塞到超时或者取到一个Reference对象才会返回。\n\n聪明的你可能会想到，调用remove方法的时候，如果队列为空，则会一直阻塞，也会一直占用lock对象锁，这个时候，有引用需要入队的话，不就进不来了吗？\n\n嗯，讲道理确实是这样的，但是注意注释，enqueue只是给Reference调用的，在Reference的public方法enqueue中可以将该引用直接入队，但是虚拟机作为程序的管理者可不吃这套，而是通过其它方式将Reference对象塞进去的，所以才会出现之前的栗子中，死循环调用remove方法，并不会阻塞引用进入队列中的情况。\n\n## 应用场景\n\nReferenceQueue一般用来与SoftReference、WeakReference或者PhantomReference配合使用，将需要关注的引用对象注册到引用队列后，便可以通过监控该队列来判断关注的对象是否被回收，从而执行相应的方法。\n\n主要使用场景：\n\n1、使用引用队列进行数据监控，类似前面栗子的用法。\n\n2、队列监控的反向操作\n\n反向操作，即意味着一个数据变化了，可以通过Reference对象反向拿到相关的数据，从而进行后续的处理。下面有个小栗子：\n\n```java\npublic class TestB {\n\n    private static ReferenceQueue<byte[]> referenceQueue = new ReferenceQueue<>();\n    private static int _1M = 1024 * 1024;\n\n    public static void main(String[] args) throws InterruptedException {\n        final Map<Object, MyWeakReference> hashMap = new HashMap<>();\n        Thread thread = new Thread(() -> {\n            try {\n                int n = 0;\n                MyWeakReference k;\n                while(null != (k = (MyWeakReference) referenceQueue.remove())) {\n                    System.out.println((++n) + \"回收了:\" + k);\n                    //反向获取，移除对应的entry\n                    hashMap.remove(k.key);\n                    //额外对key对象作其它处理，比如关闭流，通知操作等\n                }\n            } catch(InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        thread.setDaemon(true);\n        thread.start();\n\n        for(int i = 0;i < 10000;i++) {\n            byte[] bytesKey = new byte[_1M];\n            byte[] bytesValue = new byte[_1M];\n            hashMap.put(bytesKey, new MyWeakReference(bytesKey, bytesValue, referenceQueue));\n        }\n    }\n\n    static class MyWeakReference extends WeakReference<byte[]> {\n        private Object key;\n        MyWeakReference(Object key, byte[] referent, ReferenceQueue<? super byte[]> q) {\n            super(referent, q);\n            this.key = key;\n        }\n    }\n}\n```\n\n这里通过referenceQueue监控到有引用被回收后，通过map反向获取到对应的value，然后进行资源释放等。\n\n## 小结\n\n+ ReferenceQueue是用来保存需要关注的Reference队列\n+ ReferenceQueue内部实现实际上是一个栈\n+ ReferenceQueue可以用来进行数据监控，资源释放等\n","source":"_posts/java/reference/reference-queue-code-detail.md","raw":"---\ntitle: ReferenceQueue源码详解\ntags: \n - Java\n - 引用类型\ncategories: 编程\ndate: 2018-12-30 20:10:51\n---\n\n## 定义\n\nReferenceQueue是引用队列，用于存放待回收的引用对象.\n\n## 说明\n\n对于软引用、弱引用和虚引用，如果我们希望当一个对象被垃圾回收器回收时能得到通知，进行额外的处理，这时候就需要使用到引用队列了。 \n\n在一个对象被垃圾回收器扫描到将要进行回收时，其相应的引用包装类，即reference对象会被放入其注册的引用队列queue中。可以从queue中获取到相应的对象信息，同时进行额外的处理。比如反向操作，数据清理，资源释放等。\n\n## 使用例子\n\n```java\npublic class ReferenceQueueTest {\n    private static ReferenceQueue<byte[]> rq = new ReferenceQueue<>();\n    private static int _1M = 1024 * 1024;\n\n    public static void main(String[] args) {\n        Object value = new Object();\n        Map<WeakReference<byte[]>, Object> map = new HashMap<>();\n        Thread thread = new Thread(ReferenceQueueTest::run);\n        thread.setDaemon(true);\n        thread.start();\n\n        for(int i = 0;i < 100;i++) {\n            byte[] bytes = new byte[_1M];\n            WeakReference<byte[]> weakReference = new WeakReference<>(bytes, rq);\n            map.put(weakReference, value);\n        }\n        System.out.println(\"map.size->\" + map.size());\n        \n        int aliveNum = 0;\n        for (Map.Entry<WeakReference<byte[]>, Object> entry : map.entrySet()){\n            if (entry != null){\n                if (entry.getKey().get() != null){\n                    aliveNum++;\n                }\n            }\n        }\n        System.out.println(\"100个对象中存活的对象数量：\" + aliveNum);\n    }\n\n    private static void run() {\n        try {\n            int n = 0;\n            WeakReference k;\n            while ((k = (WeakReference) rq.remove()) != null) {\n                System.out.println((++n) + \"回收了:\" + k);\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n这里有一个小栗子，main方法中，创建了一条线程，使用死循环来从引用队列中获取元素，监控对象被回收的状态。然后循环往map中添加了100个映射关系，以下是运行结果：\n\n```java\n...前面省略了大量相似输出\n85回收了:java.lang.ref.WeakReference@7106e68e\n86回收了:java.lang.ref.WeakReference@1f17ae12\n87回收了:java.lang.ref.WeakReference@c4437c4\nmap.size->100\n100个对象中存活的对象数量：12\n```\n\n通过配合使用ReferenceQueue，可以较好的监控对象的生存状态。\n\n## 成员变量\n\nReferenceQueue中内部成员变量也很少，主要有这么几个：\n\n```java\nstatic ReferenceQueue<Object> NULL = new Null<>();\nstatic ReferenceQueue<Object> ENQUEUED = new Null<>();\n```\n\n有两个用来做为特殊标记的静态成员变量，一个是NULL，一个是ENQUEUE，上一篇中说的ReferenceQueue.NULL和ReferenceQueue.ENQUEUED就是这两个家伙。\n\n来看看Null长什么样：\n\n```java\nprivate static class Null<S> extends ReferenceQueue<S> {\n    boolean enqueue(Reference<? extends S> r) {\n        return false;\n    }\n}\n```\n\n只是简单继承了ReferenceQueue的一个类，emmm，为什么不直接new一个ReferenceQueue呢？这里自然是有它的道理的，如果直接使用ReferenceQueue，就会导致有可能误操作这个NULL和ENQUEUED变量，因为ReferenceQueue中enqueue方法是需要使用lock对象锁的，这里覆盖了这个方法并直接返回false，这样就避免了乱用的可能性，也避免了不必要的资源浪费。\n\n```java\nstatic private class Lock { };\nprivate Lock lock = new Lock();\n```\n\n跟Reference一样，有一个lock对象用来做同步对象。\n\n```java\nprivate volatile Reference<? extends T> head = null;\n```\n\nhead用来保存队列的头结点，因为Reference是一个单链表结构，所以只需要保存头结点即可。\n\n```java\nprivate long queueLength = 0;\n```\n\nqueueLength用来保存队列长度，在添加元素的时候+1，移除元素的时候-1，因为在添加和移除操作的时候都会使用synchronized进行同步，所以不用担心多线程修改会不会出错的问题。\n\n## 内部方法\n\n```java\n// 这个方法仅会被Reference类调用\nboolean enqueue(Reference<? extends T> r) { \n    synchronized (lock) {\n        // 检测从获取这个锁之后，该Reference没有入队，并且没有被移除\n        ReferenceQueue<?> queue = r.queue;\n        if ((queue == NULL) || (queue == ENQUEUED)) {\n            return false;\n        }\n        assert queue == this;\n        // 将reference的queue标记为ENQUEUED\n        r.queue = ENQUEUED;\n        // 将r设置为链表的头结点\n        r.next = (head == null) ? r : head;\n        head = r;\n        queueLength++;\n        // 如果r的FinalReference类型，则将FinalRef+1\n        if (r instanceof FinalReference) {\n            sun.misc.VM.addFinalRefCount(1);\n        }\n        lock.notifyAll();\n        return true;\n    }\n}\n```\n\n这里是入队的方法，使用了lock对象锁进行同步，将传入的r添加到队列中，并重置头结点为传入的节点。\n\n```java\npublic Reference<? extends T> poll() {\n    if (head == null)\n        return null;\n    synchronized (lock) {\n        return reallyPoll();\n    }\n}\n\nprivate Reference<? extends T> reallyPoll() {     \n    Reference<? extends T> r = head;\n    if (r != null) {\n        head = (r.next == r) ?\n            null : r.next;\n        r.queue = NULL;\n        r.next = r;\n        queueLength--;\n        if (r instanceof FinalReference) {\n            sun.misc.VM.addFinalRefCount(-1);\n        }\n        return r;\n    }\n    return null;\n}\n```\n\npoll方法将头结点弹出。嗯，没错，弹出的是头结点而不是尾节点，名义上，它叫ReferenceQueue，实际上是一个ReferenceStack（滑稽）。惊不惊喜，意不意外。<img src=\"/images/0001.png\" width=\"50\"/>\n\n```java\n/**\n  * 移除并返回队列首节点，此方法将阻塞到获取到一个Reference对象或者超时才会返回\n  * timeout时间的单位是毫秒\n  */\npublic Reference<? extends T> remove(long timeout)\n    throws IllegalArgumentException, InterruptedException{\n    if (timeout < 0) {\n        throw new IllegalArgumentException(\"Negative timeout value\");\n    }\n    synchronized (lock) {\n        Reference<? extends T> r = reallyPoll();\n        if (r != null) return r;\n        long start = (timeout == 0) ? 0 : System.nanoTime();\n        // 死循环，直到取到数据或者超时\n        for (;;) {\n            lock.wait(timeout);\n            r = reallyPoll();\n            if (r != null) return r;\n            if (timeout != 0) {\n                // System.nanoTime方法返回的是纳秒，1毫秒=1纳秒*1000*1000\n                long end = System.nanoTime();\n                timeout -= (end - start) / 1000_000;\n                if (timeout <= 0) return null;\n                start = end;\n            }\n        }\n    }\n}\n\n/**\n * 移除并返回队列首节点，此方法将阻塞到获取到一个Reference对象才会返回\n */\npublic Reference<? extends T> remove() throws InterruptedException {\n\treturn remove(0);\n}\n```\n\n这里两个方法都是从队列中移除首节点，与poll不同的是，它会阻塞到超时或者取到一个Reference对象才会返回。\n\n聪明的你可能会想到，调用remove方法的时候，如果队列为空，则会一直阻塞，也会一直占用lock对象锁，这个时候，有引用需要入队的话，不就进不来了吗？\n\n嗯，讲道理确实是这样的，但是注意注释，enqueue只是给Reference调用的，在Reference的public方法enqueue中可以将该引用直接入队，但是虚拟机作为程序的管理者可不吃这套，而是通过其它方式将Reference对象塞进去的，所以才会出现之前的栗子中，死循环调用remove方法，并不会阻塞引用进入队列中的情况。\n\n## 应用场景\n\nReferenceQueue一般用来与SoftReference、WeakReference或者PhantomReference配合使用，将需要关注的引用对象注册到引用队列后，便可以通过监控该队列来判断关注的对象是否被回收，从而执行相应的方法。\n\n主要使用场景：\n\n1、使用引用队列进行数据监控，类似前面栗子的用法。\n\n2、队列监控的反向操作\n\n反向操作，即意味着一个数据变化了，可以通过Reference对象反向拿到相关的数据，从而进行后续的处理。下面有个小栗子：\n\n```java\npublic class TestB {\n\n    private static ReferenceQueue<byte[]> referenceQueue = new ReferenceQueue<>();\n    private static int _1M = 1024 * 1024;\n\n    public static void main(String[] args) throws InterruptedException {\n        final Map<Object, MyWeakReference> hashMap = new HashMap<>();\n        Thread thread = new Thread(() -> {\n            try {\n                int n = 0;\n                MyWeakReference k;\n                while(null != (k = (MyWeakReference) referenceQueue.remove())) {\n                    System.out.println((++n) + \"回收了:\" + k);\n                    //反向获取，移除对应的entry\n                    hashMap.remove(k.key);\n                    //额外对key对象作其它处理，比如关闭流，通知操作等\n                }\n            } catch(InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        thread.setDaemon(true);\n        thread.start();\n\n        for(int i = 0;i < 10000;i++) {\n            byte[] bytesKey = new byte[_1M];\n            byte[] bytesValue = new byte[_1M];\n            hashMap.put(bytesKey, new MyWeakReference(bytesKey, bytesValue, referenceQueue));\n        }\n    }\n\n    static class MyWeakReference extends WeakReference<byte[]> {\n        private Object key;\n        MyWeakReference(Object key, byte[] referent, ReferenceQueue<? super byte[]> q) {\n            super(referent, q);\n            this.key = key;\n        }\n    }\n}\n```\n\n这里通过referenceQueue监控到有引用被回收后，通过map反向获取到对应的value，然后进行资源释放等。\n\n## 小结\n\n+ ReferenceQueue是用来保存需要关注的Reference队列\n+ ReferenceQueue内部实现实际上是一个栈\n+ ReferenceQueue可以用来进行数据监控，资源释放等\n","slug":"java/reference/reference-queue-code-detail","published":1,"updated":"2019-06-04T01:29:57.403Z","_id":"cjxze3gxe006e0cvwctmnxum0","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>ReferenceQueue是引用队列，用于存放待回收的引用对象.</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>对于软引用、弱引用和虚引用，如果我们希望当一个对象被垃圾回收器回收时能得到通知，进行额外的处理，这时候就需要使用到引用队列了。 </p>\n<p>在一个对象被垃圾回收器扫描到将要进行回收时，其相应的引用包装类，即reference对象会被放入其注册的引用队列queue中。可以从queue中获取到相应的对象信息，同时进行额外的处理。比如反向操作，数据清理，资源释放等。</p>\n<h2 id=\"使用例子\"><a href=\"#使用例子\" class=\"headerlink\" title=\"使用例子\"></a>使用例子</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReferenceQueueTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ReferenceQueue&lt;<span class=\"keyword\">byte</span>[]&gt; rq = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> _1M = <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Object value = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">        Map&lt;WeakReference&lt;<span class=\"keyword\">byte</span>[]&gt;, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread(ReferenceQueueTest::run);</span><br><span class=\"line\">        thread.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">100</span>;i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_1M];</span><br><span class=\"line\">            WeakReference&lt;<span class=\"keyword\">byte</span>[]&gt; weakReference = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(bytes, rq);</span><br><span class=\"line\">            map.put(weakReference, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"map.size-&gt;\"</span> + map.size());</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> aliveNum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;WeakReference&lt;<span class=\"keyword\">byte</span>[]&gt;, Object&gt; entry : map.entrySet())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (entry != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (entry.getKey().get() != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                    aliveNum++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"100个对象中存活的对象数量：\"</span> + aliveNum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">            WeakReference k;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((k = (WeakReference) rq.remove()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                System.out.println((++n) + <span class=\"string\">\"回收了:\"</span> + k);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有一个小栗子，main方法中，创建了一条线程，使用死循环来从引用队列中获取元素，监控对象被回收的状态。然后循环往map中添加了100个映射关系，以下是运行结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...前面省略了大量相似输出</span><br><span class=\"line\"><span class=\"number\">85</span>回收了:java.lang.ref.WeakReference@<span class=\"number\">7106e68</span>e</span><br><span class=\"line\"><span class=\"number\">86</span>回收了:java.lang.ref.WeakReference@<span class=\"number\">1f</span>17ae12</span><br><span class=\"line\"><span class=\"number\">87</span>回收了:java.lang.ref.WeakReference<span class=\"meta\">@c</span>4437c4</span><br><span class=\"line\">map.size-&gt;<span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"number\">100</span>个对象中存活的对象数量：<span class=\"number\">12</span></span><br></pre></td></tr></table></figure>\n<p>通过配合使用ReferenceQueue，可以较好的监控对象的生存状态。</p>\n<h2 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h2><p>ReferenceQueue中内部成员变量也很少，主要有这么几个：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> ReferenceQueue&lt;Object&gt; NULL = <span class=\"keyword\">new</span> Null&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">static</span> ReferenceQueue&lt;Object&gt; ENQUEUED = <span class=\"keyword\">new</span> Null&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<p>有两个用来做为特殊标记的静态成员变量，一个是NULL，一个是ENQUEUE，上一篇中说的ReferenceQueue.NULL和ReferenceQueue.ENQUEUED就是这两个家伙。</p>\n<p>来看看Null长什么样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Null</span>&lt;<span class=\"title\">S</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ReferenceQueue</span>&lt;<span class=\"title\">S</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueue</span><span class=\"params\">(Reference&lt;? extends S&gt; r)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只是简单继承了ReferenceQueue的一个类，emmm，为什么不直接new一个ReferenceQueue呢？这里自然是有它的道理的，如果直接使用ReferenceQueue，就会导致有可能误操作这个NULL和ENQUEUED变量，因为ReferenceQueue中enqueue方法是需要使用lock对象锁的，这里覆盖了这个方法并直接返回false，这样就避免了乱用的可能性，也避免了不必要的资源浪费。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Lock</span> </span>&#123; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">private</span> Lock lock = <span class=\"keyword\">new</span> Lock();</span><br></pre></td></tr></table></figure>\n<p>跟Reference一样，有一个lock对象用来做同步对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> Reference&lt;? extends T&gt; head = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>head用来保存队列的头结点，因为Reference是一个单链表结构，所以只需要保存头结点即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> queueLength = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n<p>queueLength用来保存队列长度，在添加元素的时候+1，移除元素的时候-1，因为在添加和移除操作的时候都会使用synchronized进行同步，所以不用担心多线程修改会不会出错的问题。</p>\n<h2 id=\"内部方法\"><a href=\"#内部方法\" class=\"headerlink\" title=\"内部方法\"></a>内部方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这个方法仅会被Reference类调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueue</span><span class=\"params\">(Reference&lt;? extends T&gt; r)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 检测从获取这个锁之后，该Reference没有入队，并且没有被移除</span></span><br><span class=\"line\">        ReferenceQueue&lt;?&gt; queue = r.queue;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((queue == NULL) || (queue == ENQUEUED)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> queue == <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 将reference的queue标记为ENQUEUED</span></span><br><span class=\"line\">        r.queue = ENQUEUED;</span><br><span class=\"line\">        <span class=\"comment\">// 将r设置为链表的头结点</span></span><br><span class=\"line\">        r.next = (head == <span class=\"keyword\">null</span>) ? r : head;</span><br><span class=\"line\">        head = r;</span><br><span class=\"line\">        queueLength++;</span><br><span class=\"line\">        <span class=\"comment\">// 如果r的FinalReference类型，则将FinalRef+1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r <span class=\"keyword\">instanceof</span> FinalReference) &#123;</span><br><span class=\"line\">            sun.misc.VM.addFinalRefCount(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lock.notifyAll();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里是入队的方法，使用了lock对象锁进行同步，将传入的r添加到队列中，并重置头结点为传入的节点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Reference&lt;? extends T&gt; poll() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> reallyPoll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> Reference&lt;? extends T&gt; reallyPoll() &#123;     </span><br><span class=\"line\">    Reference&lt;? extends T&gt; r = head;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        head = (r.next == r) ?</span><br><span class=\"line\">            <span class=\"keyword\">null</span> : r.next;</span><br><span class=\"line\">        r.queue = NULL;</span><br><span class=\"line\">        r.next = r;</span><br><span class=\"line\">        queueLength--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r <span class=\"keyword\">instanceof</span> FinalReference) &#123;</span><br><span class=\"line\">            sun.misc.VM.addFinalRefCount(-<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>poll方法将头结点弹出。嗯，没错，弹出的是头结点而不是尾节点，名义上，它叫ReferenceQueue，实际上是一个ReferenceStack（滑稽）。惊不惊喜，意不意外。<img src=\"/images/0001.png\" width=\"50\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 移除并返回队列首节点，此方法将阻塞到获取到一个Reference对象或者超时才会返回</span></span><br><span class=\"line\"><span class=\"comment\">  * timeout时间的单位是毫秒</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Reference&lt;? extends T&gt; remove(<span class=\"keyword\">long</span> timeout)</span><br><span class=\"line\">    <span class=\"keyword\">throws</span> IllegalArgumentException, InterruptedException&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timeout &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Negative timeout value\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">        Reference&lt;? extends T&gt; r = reallyPoll();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = (timeout == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : System.nanoTime();</span><br><span class=\"line\">        <span class=\"comment\">// 死循环，直到取到数据或者超时</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            lock.wait(timeout);</span><br><span class=\"line\">            r = reallyPoll();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (timeout != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// System.nanoTime方法返回的是纳秒，1毫秒=1纳秒*1000*1000</span></span><br><span class=\"line\">                <span class=\"keyword\">long</span> end = System.nanoTime();</span><br><span class=\"line\">                timeout -= (end - start) / <span class=\"number\">1000_000</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (timeout &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                start = end;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 移除并返回队列首节点，此方法将阻塞到获取到一个Reference对象才会返回</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Reference&lt;? extends T&gt; remove() <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> remove(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里两个方法都是从队列中移除首节点，与poll不同的是，它会阻塞到超时或者取到一个Reference对象才会返回。</p>\n<p>聪明的你可能会想到，调用remove方法的时候，如果队列为空，则会一直阻塞，也会一直占用lock对象锁，这个时候，有引用需要入队的话，不就进不来了吗？</p>\n<p>嗯，讲道理确实是这样的，但是注意注释，enqueue只是给Reference调用的，在Reference的public方法enqueue中可以将该引用直接入队，但是虚拟机作为程序的管理者可不吃这套，而是通过其它方式将Reference对象塞进去的，所以才会出现之前的栗子中，死循环调用remove方法，并不会阻塞引用进入队列中的情况。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>ReferenceQueue一般用来与SoftReference、WeakReference或者PhantomReference配合使用，将需要关注的引用对象注册到引用队列后，便可以通过监控该队列来判断关注的对象是否被回收，从而执行相应的方法。</p>\n<p>主要使用场景：</p>\n<p>1、使用引用队列进行数据监控，类似前面栗子的用法。</p>\n<p>2、队列监控的反向操作</p>\n<p>反向操作，即意味着一个数据变化了，可以通过Reference对象反向拿到相关的数据，从而进行后续的处理。下面有个小栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestB</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ReferenceQueue&lt;<span class=\"keyword\">byte</span>[]&gt; referenceQueue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> _1M = <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Map&lt;Object, MyWeakReference&gt; hashMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">                MyWeakReference k;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(<span class=\"keyword\">null</span> != (k = (MyWeakReference) referenceQueue.remove())) &#123;</span><br><span class=\"line\">                    System.out.println((++n) + <span class=\"string\">\"回收了:\"</span> + k);</span><br><span class=\"line\">                    <span class=\"comment\">//反向获取，移除对应的entry</span></span><br><span class=\"line\">                    hashMap.remove(k.key);</span><br><span class=\"line\">                    <span class=\"comment\">//额外对key对象作其它处理，比如关闭流，通知操作等</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span>(InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        thread.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">10000</span>;i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytesKey = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_1M];</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytesValue = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_1M];</span><br><span class=\"line\">            hashMap.put(bytesKey, <span class=\"keyword\">new</span> MyWeakReference(bytesKey, bytesValue, referenceQueue));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static class MyWeakReference extends WeakReference&lt;byte[]&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Object key;</span><br><span class=\"line\">        MyWeakReference(Object key, <span class=\"keyword\">byte</span>[] referent, ReferenceQueue&lt;? <span class=\"keyword\">super</span> <span class=\"keyword\">byte</span>[]&gt; q) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(referent, q);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里通过referenceQueue监控到有引用被回收后，通过map反向获取到对应的value，然后进行资源释放等。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>ReferenceQueue是用来保存需要关注的Reference队列</li>\n<li>ReferenceQueue内部实现实际上是一个栈</li>\n<li>ReferenceQueue可以用来进行数据监控，资源释放等</li>\n</ul>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>ReferenceQueue是引用队列，用于存放待回收的引用对象.</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>对于软引用、弱引用和虚引用，如果我们希望当一个对象被垃圾回收器回收时能得到通知，进行额外的处理，这时候就需要使用到引用队列了。 </p>\n<p>在一个对象被垃圾回收器扫描到将要进行回收时，其相应的引用包装类，即reference对象会被放入其注册的引用队列queue中。可以从queue中获取到相应的对象信息，同时进行额外的处理。比如反向操作，数据清理，资源释放等。</p>\n<h2 id=\"使用例子\"><a href=\"#使用例子\" class=\"headerlink\" title=\"使用例子\"></a>使用例子</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReferenceQueueTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ReferenceQueue&lt;<span class=\"keyword\">byte</span>[]&gt; rq = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> _1M = <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Object value = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">        Map&lt;WeakReference&lt;<span class=\"keyword\">byte</span>[]&gt;, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread(ReferenceQueueTest::run);</span><br><span class=\"line\">        thread.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">100</span>;i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_1M];</span><br><span class=\"line\">            WeakReference&lt;<span class=\"keyword\">byte</span>[]&gt; weakReference = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(bytes, rq);</span><br><span class=\"line\">            map.put(weakReference, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"map.size-&gt;\"</span> + map.size());</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> aliveNum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;WeakReference&lt;<span class=\"keyword\">byte</span>[]&gt;, Object&gt; entry : map.entrySet())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (entry != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (entry.getKey().get() != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                    aliveNum++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"100个对象中存活的对象数量：\"</span> + aliveNum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">            WeakReference k;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((k = (WeakReference) rq.remove()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                System.out.println((++n) + <span class=\"string\">\"回收了:\"</span> + k);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有一个小栗子，main方法中，创建了一条线程，使用死循环来从引用队列中获取元素，监控对象被回收的状态。然后循环往map中添加了100个映射关系，以下是运行结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...前面省略了大量相似输出</span><br><span class=\"line\"><span class=\"number\">85</span>回收了:java.lang.ref.WeakReference@<span class=\"number\">7106e68</span>e</span><br><span class=\"line\"><span class=\"number\">86</span>回收了:java.lang.ref.WeakReference@<span class=\"number\">1f</span>17ae12</span><br><span class=\"line\"><span class=\"number\">87</span>回收了:java.lang.ref.WeakReference<span class=\"meta\">@c</span>4437c4</span><br><span class=\"line\">map.size-&gt;<span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"number\">100</span>个对象中存活的对象数量：<span class=\"number\">12</span></span><br></pre></td></tr></table></figure>\n<p>通过配合使用ReferenceQueue，可以较好的监控对象的生存状态。</p>\n<h2 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h2><p>ReferenceQueue中内部成员变量也很少，主要有这么几个：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> ReferenceQueue&lt;Object&gt; NULL = <span class=\"keyword\">new</span> Null&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">static</span> ReferenceQueue&lt;Object&gt; ENQUEUED = <span class=\"keyword\">new</span> Null&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<p>有两个用来做为特殊标记的静态成员变量，一个是NULL，一个是ENQUEUE，上一篇中说的ReferenceQueue.NULL和ReferenceQueue.ENQUEUED就是这两个家伙。</p>\n<p>来看看Null长什么样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Null</span>&lt;<span class=\"title\">S</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ReferenceQueue</span>&lt;<span class=\"title\">S</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueue</span><span class=\"params\">(Reference&lt;? extends S&gt; r)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只是简单继承了ReferenceQueue的一个类，emmm，为什么不直接new一个ReferenceQueue呢？这里自然是有它的道理的，如果直接使用ReferenceQueue，就会导致有可能误操作这个NULL和ENQUEUED变量，因为ReferenceQueue中enqueue方法是需要使用lock对象锁的，这里覆盖了这个方法并直接返回false，这样就避免了乱用的可能性，也避免了不必要的资源浪费。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Lock</span> </span>&#123; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">private</span> Lock lock = <span class=\"keyword\">new</span> Lock();</span><br></pre></td></tr></table></figure>\n<p>跟Reference一样，有一个lock对象用来做同步对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> Reference&lt;? extends T&gt; head = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>head用来保存队列的头结点，因为Reference是一个单链表结构，所以只需要保存头结点即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> queueLength = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n<p>queueLength用来保存队列长度，在添加元素的时候+1，移除元素的时候-1，因为在添加和移除操作的时候都会使用synchronized进行同步，所以不用担心多线程修改会不会出错的问题。</p>\n<h2 id=\"内部方法\"><a href=\"#内部方法\" class=\"headerlink\" title=\"内部方法\"></a>内部方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这个方法仅会被Reference类调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueue</span><span class=\"params\">(Reference&lt;? extends T&gt; r)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 检测从获取这个锁之后，该Reference没有入队，并且没有被移除</span></span><br><span class=\"line\">        ReferenceQueue&lt;?&gt; queue = r.queue;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((queue == NULL) || (queue == ENQUEUED)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> queue == <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 将reference的queue标记为ENQUEUED</span></span><br><span class=\"line\">        r.queue = ENQUEUED;</span><br><span class=\"line\">        <span class=\"comment\">// 将r设置为链表的头结点</span></span><br><span class=\"line\">        r.next = (head == <span class=\"keyword\">null</span>) ? r : head;</span><br><span class=\"line\">        head = r;</span><br><span class=\"line\">        queueLength++;</span><br><span class=\"line\">        <span class=\"comment\">// 如果r的FinalReference类型，则将FinalRef+1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r <span class=\"keyword\">instanceof</span> FinalReference) &#123;</span><br><span class=\"line\">            sun.misc.VM.addFinalRefCount(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lock.notifyAll();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里是入队的方法，使用了lock对象锁进行同步，将传入的r添加到队列中，并重置头结点为传入的节点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Reference&lt;? extends T&gt; poll() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> reallyPoll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> Reference&lt;? extends T&gt; reallyPoll() &#123;     </span><br><span class=\"line\">    Reference&lt;? extends T&gt; r = head;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        head = (r.next == r) ?</span><br><span class=\"line\">            <span class=\"keyword\">null</span> : r.next;</span><br><span class=\"line\">        r.queue = NULL;</span><br><span class=\"line\">        r.next = r;</span><br><span class=\"line\">        queueLength--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r <span class=\"keyword\">instanceof</span> FinalReference) &#123;</span><br><span class=\"line\">            sun.misc.VM.addFinalRefCount(-<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>poll方法将头结点弹出。嗯，没错，弹出的是头结点而不是尾节点，名义上，它叫ReferenceQueue，实际上是一个ReferenceStack（滑稽）。惊不惊喜，意不意外。<img src=\"/images/0001.png\" width=\"50\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 移除并返回队列首节点，此方法将阻塞到获取到一个Reference对象或者超时才会返回</span></span><br><span class=\"line\"><span class=\"comment\">  * timeout时间的单位是毫秒</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Reference&lt;? extends T&gt; remove(<span class=\"keyword\">long</span> timeout)</span><br><span class=\"line\">    <span class=\"keyword\">throws</span> IllegalArgumentException, InterruptedException&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timeout &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Negative timeout value\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">        Reference&lt;? extends T&gt; r = reallyPoll();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = (timeout == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : System.nanoTime();</span><br><span class=\"line\">        <span class=\"comment\">// 死循环，直到取到数据或者超时</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            lock.wait(timeout);</span><br><span class=\"line\">            r = reallyPoll();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (timeout != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// System.nanoTime方法返回的是纳秒，1毫秒=1纳秒*1000*1000</span></span><br><span class=\"line\">                <span class=\"keyword\">long</span> end = System.nanoTime();</span><br><span class=\"line\">                timeout -= (end - start) / <span class=\"number\">1000_000</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (timeout &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                start = end;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 移除并返回队列首节点，此方法将阻塞到获取到一个Reference对象才会返回</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Reference&lt;? extends T&gt; remove() <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> remove(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里两个方法都是从队列中移除首节点，与poll不同的是，它会阻塞到超时或者取到一个Reference对象才会返回。</p>\n<p>聪明的你可能会想到，调用remove方法的时候，如果队列为空，则会一直阻塞，也会一直占用lock对象锁，这个时候，有引用需要入队的话，不就进不来了吗？</p>\n<p>嗯，讲道理确实是这样的，但是注意注释，enqueue只是给Reference调用的，在Reference的public方法enqueue中可以将该引用直接入队，但是虚拟机作为程序的管理者可不吃这套，而是通过其它方式将Reference对象塞进去的，所以才会出现之前的栗子中，死循环调用remove方法，并不会阻塞引用进入队列中的情况。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>ReferenceQueue一般用来与SoftReference、WeakReference或者PhantomReference配合使用，将需要关注的引用对象注册到引用队列后，便可以通过监控该队列来判断关注的对象是否被回收，从而执行相应的方法。</p>\n<p>主要使用场景：</p>\n<p>1、使用引用队列进行数据监控，类似前面栗子的用法。</p>\n<p>2、队列监控的反向操作</p>\n<p>反向操作，即意味着一个数据变化了，可以通过Reference对象反向拿到相关的数据，从而进行后续的处理。下面有个小栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestB</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ReferenceQueue&lt;<span class=\"keyword\">byte</span>[]&gt; referenceQueue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> _1M = <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Map&lt;Object, MyWeakReference&gt; hashMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">                MyWeakReference k;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(<span class=\"keyword\">null</span> != (k = (MyWeakReference) referenceQueue.remove())) &#123;</span><br><span class=\"line\">                    System.out.println((++n) + <span class=\"string\">\"回收了:\"</span> + k);</span><br><span class=\"line\">                    <span class=\"comment\">//反向获取，移除对应的entry</span></span><br><span class=\"line\">                    hashMap.remove(k.key);</span><br><span class=\"line\">                    <span class=\"comment\">//额外对key对象作其它处理，比如关闭流，通知操作等</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span>(InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        thread.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">10000</span>;i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytesKey = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_1M];</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytesValue = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[_1M];</span><br><span class=\"line\">            hashMap.put(bytesKey, <span class=\"keyword\">new</span> MyWeakReference(bytesKey, bytesValue, referenceQueue));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static class MyWeakReference extends WeakReference&lt;byte[]&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Object key;</span><br><span class=\"line\">        MyWeakReference(Object key, <span class=\"keyword\">byte</span>[] referent, ReferenceQueue&lt;? <span class=\"keyword\">super</span> <span class=\"keyword\">byte</span>[]&gt; q) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(referent, q);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里通过referenceQueue监控到有引用被回收后，通过map反向获取到对应的value，然后进行资源释放等。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>ReferenceQueue是用来保存需要关注的Reference队列</li>\n<li>ReferenceQueue内部实现实际上是一个栈</li>\n<li>ReferenceQueue可以用来进行数据监控，资源释放等</li>\n</ul>\n"},{"title":"四种引用类型总结","date":"2018-12-29T12:20:51.000Z","_content":"\n## 四种引用类型总结\n\n引用级别：强引用 > 软引用 > 弱引用 > 虚引用\n\n## 理解\n\n就如最开始说的，设置四种引用类型，是为了更好的控制对象的生命周期，让代码能够一定程度上干涉GC过程，所以引用类型主要就是跟垃圾回收有关了。\n\n对于JVM、GC和内存，可以这样理解，内存好比你的抽屉，这个抽屉有一定大小，并不能无限存放东西。\n\nJVM好比你自己，会时不时来整理抽屉。那些申请的对象好比放在抽屉里的东西，生活中的必需品就好比强引用，而那些可能用到的东西（非必需品）就好比软引用或者弱引用。\n\n当抽屉还很空的时候，放一些非必须品你也不会在意，但是随着买的东西越来越多，抽屉里快放不下的时候，就需要根据重要程度来选择一些东西扔出抽屉，这个过程就好比GC。\n\nJVM在内存够用的时候，不会对软引用的对象进行回收，但是当内存紧张的时候，就会对它们进行清理。\n\n## 四种引用类型对比\n\n| 引用类型 | 引用对象被垃圾回收的时间                        | 用途                                       | 是否可以转为强引用 | 对应的类                       |\n| :------- | ----------------------------------------------- | ------------------------------------------ | ------------------ | ------------------------------ |\n| 强引用   | 从来不会                                        | 一般用途，保持对象不被回收                 | 可以               | 默认                           |\n| 软引用   | 发生一次GC后，JVM决定还需要进一步回收更多空间时 | 缓存，保持对象在内存足够时不被回收         | 可以               | SoftReference                  |\n| 弱引用   | 进行垃圾回收时，如果对象只存在弱引用            | 缓存，仅仅在对象仍被使用时保持其不被回收   | 可以               | WeakReference<br />WeakHashMap |\n| 虚引用   | 进行垃圾回收时                                  | 跟踪GC过程，在对象被回收前进行一些清理工作 | 不可以             | PhantomReference               |\n\n## 题外话\n\nemmmm….总觉得少了点什么，有没有想过，为什么没有StrongReference类？ \n\n嗯，讲道理，软引用，弱引用，虚引用都有其对应的类，为什么强引用却没有？试想一下，如果有StrongReference类，那么在自定义缓存中进行引用类型判断时将会比较方便，事实上，在guava的LocalCache中，确实构造了一个[StrongValueReference](https://github.com/google/guava/blob/1670960e088fe9c1e78b5d7dd7c0505741bf2988/guava/src/com/google/common/cache/LocalCache.java#L1676)的类，用来包裹一个强引用。\n\n所以当你想要自己造缓存的轮子时，可以先看看人家的轮子好不好用。<img src=\"/images/0003.png\" width=\"50\"/>\n\n至此，这一系列就算告一段落了，为了写这一系列文章，花了不少心思，离底层实现越来越近的感觉就像山洞探险，这个探索过程的曲径通幽，柳暗花明处其实就是最好的奖励。\n\n对于学习，就像是打通经脉的过程，从一个一个零散的点，到慢慢将它们贯通成线，点与点的联结会让人产生极大的快感，最终如果能将这些点编织成网，便像打通奇经八脉那样，知识不过是手到擒来了。<img src=\"/images/94.png\" width=\"50\"/>\n\n（这个B装的不错，还多了一些细节在里面，哈哈哈哈，溜了溜了）","source":"_posts/java/reference/reference-summary.md","raw":"---\ntitle: 四种引用类型总结\ntags: \n - Java\n - 引用类型\ncategories: 编程\ndate: 2018-12-29 20:20:51\n---\n\n## 四种引用类型总结\n\n引用级别：强引用 > 软引用 > 弱引用 > 虚引用\n\n## 理解\n\n就如最开始说的，设置四种引用类型，是为了更好的控制对象的生命周期，让代码能够一定程度上干涉GC过程，所以引用类型主要就是跟垃圾回收有关了。\n\n对于JVM、GC和内存，可以这样理解，内存好比你的抽屉，这个抽屉有一定大小，并不能无限存放东西。\n\nJVM好比你自己，会时不时来整理抽屉。那些申请的对象好比放在抽屉里的东西，生活中的必需品就好比强引用，而那些可能用到的东西（非必需品）就好比软引用或者弱引用。\n\n当抽屉还很空的时候，放一些非必须品你也不会在意，但是随着买的东西越来越多，抽屉里快放不下的时候，就需要根据重要程度来选择一些东西扔出抽屉，这个过程就好比GC。\n\nJVM在内存够用的时候，不会对软引用的对象进行回收，但是当内存紧张的时候，就会对它们进行清理。\n\n## 四种引用类型对比\n\n| 引用类型 | 引用对象被垃圾回收的时间                        | 用途                                       | 是否可以转为强引用 | 对应的类                       |\n| :------- | ----------------------------------------------- | ------------------------------------------ | ------------------ | ------------------------------ |\n| 强引用   | 从来不会                                        | 一般用途，保持对象不被回收                 | 可以               | 默认                           |\n| 软引用   | 发生一次GC后，JVM决定还需要进一步回收更多空间时 | 缓存，保持对象在内存足够时不被回收         | 可以               | SoftReference                  |\n| 弱引用   | 进行垃圾回收时，如果对象只存在弱引用            | 缓存，仅仅在对象仍被使用时保持其不被回收   | 可以               | WeakReference<br />WeakHashMap |\n| 虚引用   | 进行垃圾回收时                                  | 跟踪GC过程，在对象被回收前进行一些清理工作 | 不可以             | PhantomReference               |\n\n## 题外话\n\nemmmm….总觉得少了点什么，有没有想过，为什么没有StrongReference类？ \n\n嗯，讲道理，软引用，弱引用，虚引用都有其对应的类，为什么强引用却没有？试想一下，如果有StrongReference类，那么在自定义缓存中进行引用类型判断时将会比较方便，事实上，在guava的LocalCache中，确实构造了一个[StrongValueReference](https://github.com/google/guava/blob/1670960e088fe9c1e78b5d7dd7c0505741bf2988/guava/src/com/google/common/cache/LocalCache.java#L1676)的类，用来包裹一个强引用。\n\n所以当你想要自己造缓存的轮子时，可以先看看人家的轮子好不好用。<img src=\"/images/0003.png\" width=\"50\"/>\n\n至此，这一系列就算告一段落了，为了写这一系列文章，花了不少心思，离底层实现越来越近的感觉就像山洞探险，这个探索过程的曲径通幽，柳暗花明处其实就是最好的奖励。\n\n对于学习，就像是打通经脉的过程，从一个一个零散的点，到慢慢将它们贯通成线，点与点的联结会让人产生极大的快感，最终如果能将这些点编织成网，便像打通奇经八脉那样，知识不过是手到擒来了。<img src=\"/images/94.png\" width=\"50\"/>\n\n（这个B装的不错，还多了一些细节在里面，哈哈哈哈，溜了溜了）","slug":"java/reference/reference-summary","published":1,"updated":"2019-06-04T01:29:57.410Z","_id":"cjxze3gxe006h0cvwsozru4mv","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"四种引用类型总结\"><a href=\"#四种引用类型总结\" class=\"headerlink\" title=\"四种引用类型总结\"></a>四种引用类型总结</h2><p>引用级别：强引用 &gt; 软引用 &gt; 弱引用 &gt; 虚引用</p>\n<h2 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h2><p>就如最开始说的，设置四种引用类型，是为了更好的控制对象的生命周期，让代码能够一定程度上干涉GC过程，所以引用类型主要就是跟垃圾回收有关了。</p>\n<p>对于JVM、GC和内存，可以这样理解，内存好比你的抽屉，这个抽屉有一定大小，并不能无限存放东西。</p>\n<p>JVM好比你自己，会时不时来整理抽屉。那些申请的对象好比放在抽屉里的东西，生活中的必需品就好比强引用，而那些可能用到的东西（非必需品）就好比软引用或者弱引用。</p>\n<p>当抽屉还很空的时候，放一些非必须品你也不会在意，但是随着买的东西越来越多，抽屉里快放不下的时候，就需要根据重要程度来选择一些东西扔出抽屉，这个过程就好比GC。</p>\n<p>JVM在内存够用的时候，不会对软引用的对象进行回收，但是当内存紧张的时候，就会对它们进行清理。</p>\n<h2 id=\"四种引用类型对比\"><a href=\"#四种引用类型对比\" class=\"headerlink\" title=\"四种引用类型对比\"></a>四种引用类型对比</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">引用类型</th>\n<th>引用对象被垃圾回收的时间</th>\n<th>用途</th>\n<th>是否可以转为强引用</th>\n<th>对应的类</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">强引用</td>\n<td>从来不会</td>\n<td>一般用途，保持对象不被回收</td>\n<td>可以</td>\n<td>默认</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">软引用</td>\n<td>发生一次GC后，JVM决定还需要进一步回收更多空间时</td>\n<td>缓存，保持对象在内存足够时不被回收</td>\n<td>可以</td>\n<td>SoftReference</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">弱引用</td>\n<td>进行垃圾回收时，如果对象只存在弱引用</td>\n<td>缓存，仅仅在对象仍被使用时保持其不被回收</td>\n<td>可以</td>\n<td>WeakReference<br>WeakHashMap</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">虚引用</td>\n<td>进行垃圾回收时</td>\n<td>跟踪GC过程，在对象被回收前进行一些清理工作</td>\n<td>不可以</td>\n<td>PhantomReference</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h2><p>emmmm….总觉得少了点什么，有没有想过，为什么没有StrongReference类？ </p>\n<p>嗯，讲道理，软引用，弱引用，虚引用都有其对应的类，为什么强引用却没有？试想一下，如果有StrongReference类，那么在自定义缓存中进行引用类型判断时将会比较方便，事实上，在guava的LocalCache中，确实构造了一个<a href=\"https://github.com/google/guava/blob/1670960e088fe9c1e78b5d7dd7c0505741bf2988/guava/src/com/google/common/cache/LocalCache.java#L1676\" target=\"_blank\" rel=\"noopener\">StrongValueReference</a>的类，用来包裹一个强引用。</p>\n<p>所以当你想要自己造缓存的轮子时，可以先看看人家的轮子好不好用。<img src=\"/images/0003.png\" width=\"50\"></p>\n<p>至此，这一系列就算告一段落了，为了写这一系列文章，花了不少心思，离底层实现越来越近的感觉就像山洞探险，这个探索过程的曲径通幽，柳暗花明处其实就是最好的奖励。</p>\n<p>对于学习，就像是打通经脉的过程，从一个一个零散的点，到慢慢将它们贯通成线，点与点的联结会让人产生极大的快感，最终如果能将这些点编织成网，便像打通奇经八脉那样，知识不过是手到擒来了。<img src=\"/images/94.png\" width=\"50\"></p>\n<p>（这个B装的不错，还多了一些细节在里面，哈哈哈哈，溜了溜了）</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"四种引用类型总结\"><a href=\"#四种引用类型总结\" class=\"headerlink\" title=\"四种引用类型总结\"></a>四种引用类型总结</h2><p>引用级别：强引用 &gt; 软引用 &gt; 弱引用 &gt; 虚引用</p>\n<h2 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h2><p>就如最开始说的，设置四种引用类型，是为了更好的控制对象的生命周期，让代码能够一定程度上干涉GC过程，所以引用类型主要就是跟垃圾回收有关了。</p>\n<p>对于JVM、GC和内存，可以这样理解，内存好比你的抽屉，这个抽屉有一定大小，并不能无限存放东西。</p>\n<p>JVM好比你自己，会时不时来整理抽屉。那些申请的对象好比放在抽屉里的东西，生活中的必需品就好比强引用，而那些可能用到的东西（非必需品）就好比软引用或者弱引用。</p>\n<p>当抽屉还很空的时候，放一些非必须品你也不会在意，但是随着买的东西越来越多，抽屉里快放不下的时候，就需要根据重要程度来选择一些东西扔出抽屉，这个过程就好比GC。</p>\n<p>JVM在内存够用的时候，不会对软引用的对象进行回收，但是当内存紧张的时候，就会对它们进行清理。</p>\n<h2 id=\"四种引用类型对比\"><a href=\"#四种引用类型对比\" class=\"headerlink\" title=\"四种引用类型对比\"></a>四种引用类型对比</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">引用类型</th>\n<th>引用对象被垃圾回收的时间</th>\n<th>用途</th>\n<th>是否可以转为强引用</th>\n<th>对应的类</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">强引用</td>\n<td>从来不会</td>\n<td>一般用途，保持对象不被回收</td>\n<td>可以</td>\n<td>默认</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">软引用</td>\n<td>发生一次GC后，JVM决定还需要进一步回收更多空间时</td>\n<td>缓存，保持对象在内存足够时不被回收</td>\n<td>可以</td>\n<td>SoftReference</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">弱引用</td>\n<td>进行垃圾回收时，如果对象只存在弱引用</td>\n<td>缓存，仅仅在对象仍被使用时保持其不被回收</td>\n<td>可以</td>\n<td>WeakReference<br>WeakHashMap</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">虚引用</td>\n<td>进行垃圾回收时</td>\n<td>跟踪GC过程，在对象被回收前进行一些清理工作</td>\n<td>不可以</td>\n<td>PhantomReference</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h2><p>emmmm….总觉得少了点什么，有没有想过，为什么没有StrongReference类？ </p>\n<p>嗯，讲道理，软引用，弱引用，虚引用都有其对应的类，为什么强引用却没有？试想一下，如果有StrongReference类，那么在自定义缓存中进行引用类型判断时将会比较方便，事实上，在guava的LocalCache中，确实构造了一个<a href=\"https://github.com/google/guava/blob/1670960e088fe9c1e78b5d7dd7c0505741bf2988/guava/src/com/google/common/cache/LocalCache.java#L1676\" target=\"_blank\" rel=\"noopener\">StrongValueReference</a>的类，用来包裹一个强引用。</p>\n<p>所以当你想要自己造缓存的轮子时，可以先看看人家的轮子好不好用。<img src=\"/images/0003.png\" width=\"50\"></p>\n<p>至此，这一系列就算告一段落了，为了写这一系列文章，花了不少心思，离底层实现越来越近的感觉就像山洞探险，这个探索过程的曲径通幽，柳暗花明处其实就是最好的奖励。</p>\n<p>对于学习，就像是打通经脉的过程，从一个一个零散的点，到慢慢将它们贯通成线，点与点的联结会让人产生极大的快感，最终如果能将这些点编织成网，便像打通奇经八脉那样，知识不过是手到擒来了。<img src=\"/images/94.png\" width=\"50\"></p>\n<p>（这个B装的不错，还多了一些细节在里面，哈哈哈哈，溜了溜了）</p>\n"},{"title":"弱引用","date":"2018-12-29T11:57:51.000Z","_content":"\n## 定义\n\n弱引用是使用WeakReference创建的引用，弱引用也是用来描述非必需对象的，它是比软引用更弱的引用类型。在发生GC时，只要发现弱引用，不管系统堆空间是否足够，都会将对象进行回收。\n\n## 说明\n\n弱引用，从名字来看就很弱嘛，这种引用指向的对象，一旦在GC时被扫描到，就逃脱不了被回收的命运。<img src=\"/images/0040.png\" width=\"50\"/>\n\n但是，弱引用指向的对象也并不一定就马上会被回收，如果弱引用对象较大，直接进到了老年代，那么就可以苟且偷生到Full GC触发前，所以弱引用对象也可能存在较长的一段时间。一旦一个弱引用对象被垃圾回收器回收，便会加入到一个引用队列中（如果有的话）。\n\n弱引用对应的类为WeakReference，举个栗子：\n\n```java\nString s = new String(\"Frank\");    \nWeakReference<String> weakRef = new WeakReference<String>(s);\ns = null;\n```\n\n这里我们把s设置为null后，字符串对象便只有弱引用指向它。\n\n> 弱可达\n> 如果一个对象与GC Roots之间仅存在弱引用，则称这个对象为`弱可达(weakly reachable)`对象。\n\n> warning 注意\n> 在垃圾回收器回收一个对象前，WeakReference类所提供的get方法会返回其引用对象的强引用，一旦垃圾回收器回收掉该对象之后，get方法将返回null。所以在获取弱引用对象的代码中，一定要判断是否为null，以免出现NullPointerException异常导致应用崩溃。<img src=\"/images/0019.png\" width=\"50\"/>\n\n下面的代码会让s再次持有对象的强引用：\n\n```java\ns = weakRef.get();\n```\n\n如果在weakRef包裹的对象被回收前，用强引用关联该对象，那这个对象又会变成强可达状态。\n\n来看一个简单的栗子了解一下WeakReference引用的对象是何时被回收的：\n\n```java\npublic class WeakReferenceTest {\n    private static final List<Object> TEST_DATA = new LinkedList<>();\n    private static final ReferenceQueue<TestClass> QUEUE = new ReferenceQueue<>();\n\n    public static void main(String[] args) {\n        TestClass obj = new TestClass(\"Test\");\n        WeakReference<TestClass> weakRef = new WeakReference<>(obj, QUEUE);\n        //可以重新获得OOMClass对象，并用一个强引用指向它\n        //oomObj = weakRef.get();\n\n        // 该线程不断读取这个弱引用，并不断往列表里插入数据，以促使系统早点进行GC\n        new Thread(() -> {\n            while (true) {\n                TEST_DATA.add(new byte[1024 * 100]);\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    Thread.currentThread().interrupt();\n                }\n                System.out.println(weakRef.get());\n            }\n        }).start();\n\n        // 这个线程不断读取引用队列，当弱引用指向的对象呗回收时，该引用就会被加入到引用队列中\n        new Thread(() -> {\n            while (true) {\n                Reference<? extends TestClass> poll = QUEUE.poll();\n                if (poll != null) {\n                    System.out.println(\"--- 弱引用对象被jvm回收了 ---- \" + poll);\n                    System.out.println(\"--- 回收对象 ---- \" + poll.get());\n                }\n            }\n        }).start();\n\n        //将强引用指向空指针 那么此时只有一个弱引用指向TestClass对象\n        obj = null;\n\n        try {\n            Thread.currentThread().join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    static class TestClass {\n        private String name;\n\n        public TestClass(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public String toString() {\n            return \"TestClass - \" + name;\n        }\n    }\n}\n```\n\n设置一下虚拟机参数：\n\n```bash\n-verbose:gc -Xms4m -Xmx4m -Xmn2m\n```\n\n运行结果如下：\n\n```bash\n[GC (Allocation Failure)  1017K->464K(3584K), 0.0014345 secs]\n[GC (Allocation Failure)  1483K->536K(3584K), 0.0017221 secs]\n[GC (Allocation Failure)  1560K->648K(3584K), 0.0036572 secs]\nTestClass - Test\nTestClass - Test\nTestClass - Test\n[GC (Allocation Failure)  1621K->984K(3584K), 0.0011455 secs]\n--- 弱引用对象被jvm回收了 ---- java.lang.ref.WeakReference@51a947fe\n--- 回收对象 ---- null\nnull\n...省略n个null和几次GC信息\n[Full GC (Ergonomics)  2964K->2964K(3584K), 0.0025450 secs]\n[Full GC (Allocation Failure)  2964K->2964K(3584K), 0.0021907 secs]\njava.lang.OutOfMemoryError: Java heap space\nDumping heap to java_pid6860.hprof ...\nHeap dump file created [3912229 bytes in 0.011 secs]\nException in thread \"Thread-0\" java.lang.OutOfMemoryError: Java heap space\n\tat weakhashmap.WeakReferenceTest.lambda$main$0(WeakReferenceTest.java:22)\n\tat weakhashmap.WeakReferenceTest$$Lambda$1/764977973.run(Unknown Source)\n\tat java.lang.Thread.run(Thread.java:748)\n```\n\n可以看到，其实弱引用也并不是一发生GC就被回收掉了。\n\n## 应用场景\n\n如果一个对象仅仅是偶尔使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 WeakReference 来引用该对象。 \n\n弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n\n一般来说，很少直接使用WeakReference，而是使用WeakHashMap。在WeakHashMap中，内部有一个引用队列，插入的元素会被包裹成WeakReference，并加入队列中，用来做缓存再合适不过。\n\n在Tomcat的缓存中，其实就用到了WeakHashMap：\n\n```java\npublic final class ConcurrentCache<K,V> {\n    private final int size;\n    private final Map<K,V> eden;\n    private final Map<K,V> longterm;\n\n    public ConcurrentCache(int size) {\n        this.size = size;\n        this.eden = new ConcurrentHashMap<>(size);\n        this.longterm = new WeakHashMap<>(size);\n    }\n\n    public V get(K k) {\n        // 先从eden中取\n        V v = this.eden.get(k);\n        if (v == null) {\n            // 如果取不到再从longterm中取\n            synchronized (longterm) {\n                v = this.longterm.get(k);\n            }\n            // 如果取到则重新放到eden中\n            if (v != null) {\n                this.eden.put(k, v);\n            }\n        }\n        return v;\n    }\n\n    public void put(K k, V v) {\n        if (this.eden.size() >= size) {\n            // 如果eden中的元素数量大于指定容量，将所有元素放到longterm中\n            synchronized (longterm) {\n                this.longterm.putAll(this.eden);\n            }\n            this.eden.clear();\n        }\n        this.eden.put(k, v);\n    }\n}\n```\n\n这里有eden和longterm的两个map，如果对jvm堆了解的话，可以看出tomcat在这里是使用ConcurrentHashMap和WeakHashMap做了类似分代缓存的操作。\n\n在put方法里，在插入键值对时，先检查eden缓存的容量是否超出设定的大小。如果没有则直接放入eden缓存，如果超了则锁定longterm将eden中所有的键值对都放入longterm。再将eden清空并插入该键值对。\n\n在get方法中，也是优先从eden中找对应的key，如果没有则进入longterm缓存中查找，找到后就加入eden缓存并返回。 \n\n经过这样的设计，相对常用的对象都能在eden缓存中找到，不常用（有可能被销毁的对象）的则进入longterm缓存。而longterm的key的实际对象没有其他引用指向它时，gc就会自动回收heap中该弱引用指向的实际对象，并将弱引用放入其引用队列中。\n\n## 弱引用与软引用对比\n\n弱引用与软引用的区别在于：\n\n1. 只具有弱引用的对象拥有更短暂的生命周期。\n2. 被垃圾回收器回收的时机不一样，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。而被软引用关联的对象只有在内存不足时才会被回收。\n3. 弱引用不会影响GC，而软引用会一定程度上对GC造成影响。\n\n相似之处：都是用来描述非必需对象的。\n\n那么什么时候用SoftReference，什么时候用WeakReference呢？\n\n如果缓存的对象是比较大的对象，使用频率相对较高的对象，那么使用SoftReference会更好，因为这样能让缓存对象有更长的生命周期。\n\n如果缓存对象都是比较小的对象，使用频率一般或者相对较低，那么使用WeakReference会更合适。\n\n当然，如果实在不知道选哪个，一般而言，用作缓存时使用WeakHashMap都不会有太大问题。<img src=\"./195.png\" width=\"50\"/>\n\n## 小结\n\n+ 弱引用是比软引用更弱的引用类型 \n+ 弱引用不能延长对象的生命周期，一旦对象只剩下弱引用，它就随时可能会被回收\n+ 可以通过弱引用获取对象的强引用\n+ 弱引用适合用作缓存","source":"_posts/java/reference/weak-reference.md","raw":"---\ntitle: 弱引用\ntags: \n - Java\n - 引用类型\ncategories: 编程\ndate: 2018-12-29 19:57:51\n---\n\n## 定义\n\n弱引用是使用WeakReference创建的引用，弱引用也是用来描述非必需对象的，它是比软引用更弱的引用类型。在发生GC时，只要发现弱引用，不管系统堆空间是否足够，都会将对象进行回收。\n\n## 说明\n\n弱引用，从名字来看就很弱嘛，这种引用指向的对象，一旦在GC时被扫描到，就逃脱不了被回收的命运。<img src=\"/images/0040.png\" width=\"50\"/>\n\n但是，弱引用指向的对象也并不一定就马上会被回收，如果弱引用对象较大，直接进到了老年代，那么就可以苟且偷生到Full GC触发前，所以弱引用对象也可能存在较长的一段时间。一旦一个弱引用对象被垃圾回收器回收，便会加入到一个引用队列中（如果有的话）。\n\n弱引用对应的类为WeakReference，举个栗子：\n\n```java\nString s = new String(\"Frank\");    \nWeakReference<String> weakRef = new WeakReference<String>(s);\ns = null;\n```\n\n这里我们把s设置为null后，字符串对象便只有弱引用指向它。\n\n> 弱可达\n> 如果一个对象与GC Roots之间仅存在弱引用，则称这个对象为`弱可达(weakly reachable)`对象。\n\n> warning 注意\n> 在垃圾回收器回收一个对象前，WeakReference类所提供的get方法会返回其引用对象的强引用，一旦垃圾回收器回收掉该对象之后，get方法将返回null。所以在获取弱引用对象的代码中，一定要判断是否为null，以免出现NullPointerException异常导致应用崩溃。<img src=\"/images/0019.png\" width=\"50\"/>\n\n下面的代码会让s再次持有对象的强引用：\n\n```java\ns = weakRef.get();\n```\n\n如果在weakRef包裹的对象被回收前，用强引用关联该对象，那这个对象又会变成强可达状态。\n\n来看一个简单的栗子了解一下WeakReference引用的对象是何时被回收的：\n\n```java\npublic class WeakReferenceTest {\n    private static final List<Object> TEST_DATA = new LinkedList<>();\n    private static final ReferenceQueue<TestClass> QUEUE = new ReferenceQueue<>();\n\n    public static void main(String[] args) {\n        TestClass obj = new TestClass(\"Test\");\n        WeakReference<TestClass> weakRef = new WeakReference<>(obj, QUEUE);\n        //可以重新获得OOMClass对象，并用一个强引用指向它\n        //oomObj = weakRef.get();\n\n        // 该线程不断读取这个弱引用，并不断往列表里插入数据，以促使系统早点进行GC\n        new Thread(() -> {\n            while (true) {\n                TEST_DATA.add(new byte[1024 * 100]);\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    Thread.currentThread().interrupt();\n                }\n                System.out.println(weakRef.get());\n            }\n        }).start();\n\n        // 这个线程不断读取引用队列，当弱引用指向的对象呗回收时，该引用就会被加入到引用队列中\n        new Thread(() -> {\n            while (true) {\n                Reference<? extends TestClass> poll = QUEUE.poll();\n                if (poll != null) {\n                    System.out.println(\"--- 弱引用对象被jvm回收了 ---- \" + poll);\n                    System.out.println(\"--- 回收对象 ---- \" + poll.get());\n                }\n            }\n        }).start();\n\n        //将强引用指向空指针 那么此时只有一个弱引用指向TestClass对象\n        obj = null;\n\n        try {\n            Thread.currentThread().join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    static class TestClass {\n        private String name;\n\n        public TestClass(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public String toString() {\n            return \"TestClass - \" + name;\n        }\n    }\n}\n```\n\n设置一下虚拟机参数：\n\n```bash\n-verbose:gc -Xms4m -Xmx4m -Xmn2m\n```\n\n运行结果如下：\n\n```bash\n[GC (Allocation Failure)  1017K->464K(3584K), 0.0014345 secs]\n[GC (Allocation Failure)  1483K->536K(3584K), 0.0017221 secs]\n[GC (Allocation Failure)  1560K->648K(3584K), 0.0036572 secs]\nTestClass - Test\nTestClass - Test\nTestClass - Test\n[GC (Allocation Failure)  1621K->984K(3584K), 0.0011455 secs]\n--- 弱引用对象被jvm回收了 ---- java.lang.ref.WeakReference@51a947fe\n--- 回收对象 ---- null\nnull\n...省略n个null和几次GC信息\n[Full GC (Ergonomics)  2964K->2964K(3584K), 0.0025450 secs]\n[Full GC (Allocation Failure)  2964K->2964K(3584K), 0.0021907 secs]\njava.lang.OutOfMemoryError: Java heap space\nDumping heap to java_pid6860.hprof ...\nHeap dump file created [3912229 bytes in 0.011 secs]\nException in thread \"Thread-0\" java.lang.OutOfMemoryError: Java heap space\n\tat weakhashmap.WeakReferenceTest.lambda$main$0(WeakReferenceTest.java:22)\n\tat weakhashmap.WeakReferenceTest$$Lambda$1/764977973.run(Unknown Source)\n\tat java.lang.Thread.run(Thread.java:748)\n```\n\n可以看到，其实弱引用也并不是一发生GC就被回收掉了。\n\n## 应用场景\n\n如果一个对象仅仅是偶尔使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 WeakReference 来引用该对象。 \n\n弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n\n一般来说，很少直接使用WeakReference，而是使用WeakHashMap。在WeakHashMap中，内部有一个引用队列，插入的元素会被包裹成WeakReference，并加入队列中，用来做缓存再合适不过。\n\n在Tomcat的缓存中，其实就用到了WeakHashMap：\n\n```java\npublic final class ConcurrentCache<K,V> {\n    private final int size;\n    private final Map<K,V> eden;\n    private final Map<K,V> longterm;\n\n    public ConcurrentCache(int size) {\n        this.size = size;\n        this.eden = new ConcurrentHashMap<>(size);\n        this.longterm = new WeakHashMap<>(size);\n    }\n\n    public V get(K k) {\n        // 先从eden中取\n        V v = this.eden.get(k);\n        if (v == null) {\n            // 如果取不到再从longterm中取\n            synchronized (longterm) {\n                v = this.longterm.get(k);\n            }\n            // 如果取到则重新放到eden中\n            if (v != null) {\n                this.eden.put(k, v);\n            }\n        }\n        return v;\n    }\n\n    public void put(K k, V v) {\n        if (this.eden.size() >= size) {\n            // 如果eden中的元素数量大于指定容量，将所有元素放到longterm中\n            synchronized (longterm) {\n                this.longterm.putAll(this.eden);\n            }\n            this.eden.clear();\n        }\n        this.eden.put(k, v);\n    }\n}\n```\n\n这里有eden和longterm的两个map，如果对jvm堆了解的话，可以看出tomcat在这里是使用ConcurrentHashMap和WeakHashMap做了类似分代缓存的操作。\n\n在put方法里，在插入键值对时，先检查eden缓存的容量是否超出设定的大小。如果没有则直接放入eden缓存，如果超了则锁定longterm将eden中所有的键值对都放入longterm。再将eden清空并插入该键值对。\n\n在get方法中，也是优先从eden中找对应的key，如果没有则进入longterm缓存中查找，找到后就加入eden缓存并返回。 \n\n经过这样的设计，相对常用的对象都能在eden缓存中找到，不常用（有可能被销毁的对象）的则进入longterm缓存。而longterm的key的实际对象没有其他引用指向它时，gc就会自动回收heap中该弱引用指向的实际对象，并将弱引用放入其引用队列中。\n\n## 弱引用与软引用对比\n\n弱引用与软引用的区别在于：\n\n1. 只具有弱引用的对象拥有更短暂的生命周期。\n2. 被垃圾回收器回收的时机不一样，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。而被软引用关联的对象只有在内存不足时才会被回收。\n3. 弱引用不会影响GC，而软引用会一定程度上对GC造成影响。\n\n相似之处：都是用来描述非必需对象的。\n\n那么什么时候用SoftReference，什么时候用WeakReference呢？\n\n如果缓存的对象是比较大的对象，使用频率相对较高的对象，那么使用SoftReference会更好，因为这样能让缓存对象有更长的生命周期。\n\n如果缓存对象都是比较小的对象，使用频率一般或者相对较低，那么使用WeakReference会更合适。\n\n当然，如果实在不知道选哪个，一般而言，用作缓存时使用WeakHashMap都不会有太大问题。<img src=\"./195.png\" width=\"50\"/>\n\n## 小结\n\n+ 弱引用是比软引用更弱的引用类型 \n+ 弱引用不能延长对象的生命周期，一旦对象只剩下弱引用，它就随时可能会被回收\n+ 可以通过弱引用获取对象的强引用\n+ 弱引用适合用作缓存","slug":"java/reference/weak-reference","published":1,"updated":"2019-06-04T01:29:57.415Z","_id":"cjxze3gxo006k0cvw15ee24g3","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>弱引用是使用WeakReference创建的引用，弱引用也是用来描述非必需对象的，它是比软引用更弱的引用类型。在发生GC时，只要发现弱引用，不管系统堆空间是否足够，都会将对象进行回收。</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>弱引用，从名字来看就很弱嘛，这种引用指向的对象，一旦在GC时被扫描到，就逃脱不了被回收的命运。<img src=\"/images/0040.png\" width=\"50\"></p>\n<p>但是，弱引用指向的对象也并不一定就马上会被回收，如果弱引用对象较大，直接进到了老年代，那么就可以苟且偷生到Full GC触发前，所以弱引用对象也可能存在较长的一段时间。一旦一个弱引用对象被垃圾回收器回收，便会加入到一个引用队列中（如果有的话）。</p>\n<p>弱引用对应的类为WeakReference，举个栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"keyword\">new</span> String(<span class=\"string\">\"Frank\"</span>);    </span><br><span class=\"line\">WeakReference&lt;String&gt; weakRef = <span class=\"keyword\">new</span> WeakReference&lt;String&gt;(s);</span><br><span class=\"line\">s = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>这里我们把s设置为null后，字符串对象便只有弱引用指向它。</p>\n<blockquote>\n<p>弱可达<br>如果一个对象与GC Roots之间仅存在弱引用，则称这个对象为<code>弱可达(weakly reachable)</code>对象。</p>\n</blockquote>\n<blockquote>\n<p>warning 注意<br>在垃圾回收器回收一个对象前，WeakReference类所提供的get方法会返回其引用对象的强引用，一旦垃圾回收器回收掉该对象之后，get方法将返回null。所以在获取弱引用对象的代码中，一定要判断是否为null，以免出现NullPointerException异常导致应用崩溃。<img src=\"/images/0019.png\" width=\"50\"></p>\n</blockquote>\n<p>下面的代码会让s再次持有对象的强引用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = weakRef.get();</span><br></pre></td></tr></table></figure>\n<p>如果在weakRef包裹的对象被回收前，用强引用关联该对象，那这个对象又会变成强可达状态。</p>\n<p>来看一个简单的栗子了解一下WeakReference引用的对象是何时被回收的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WeakReferenceTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> List&lt;Object&gt; TEST_DATA = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ReferenceQueue&lt;TestClass&gt; QUEUE = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        TestClass obj = <span class=\"keyword\">new</span> TestClass(<span class=\"string\">\"Test\"</span>);</span><br><span class=\"line\">        WeakReference&lt;TestClass&gt; weakRef = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(obj, QUEUE);</span><br><span class=\"line\">        <span class=\"comment\">//可以重新获得OOMClass对象，并用一个强引用指向它</span></span><br><span class=\"line\">        <span class=\"comment\">//oomObj = weakRef.get();</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 该线程不断读取这个弱引用，并不断往列表里插入数据，以促使系统早点进行GC</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                TEST_DATA.add(<span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span> * <span class=\"number\">100</span>]);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                    Thread.currentThread().interrupt();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(weakRef.get());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 这个线程不断读取引用队列，当弱引用指向的对象呗回收时，该引用就会被加入到引用队列中</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                Reference&lt;? extends TestClass&gt; poll = QUEUE.poll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (poll != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"--- 弱引用对象被jvm回收了 ---- \"</span> + poll);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"--- 回收对象 ---- \"</span> + poll.get());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//将强引用指向空指针 那么此时只有一个弱引用指向TestClass对象</span></span><br><span class=\"line\">        obj = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.currentThread().join();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestClass</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TestClass</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"TestClass - \"</span> + name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>设置一下虚拟机参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-verbose:gc -Xms4m -Xmx4m -Xmn2m</span><br></pre></td></tr></table></figure>\n<p>运行结果如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure)  1017K-&gt;464K(3584K), 0.0014345 secs]</span><br><span class=\"line\">[GC (Allocation Failure)  1483K-&gt;536K(3584K), 0.0017221 secs]</span><br><span class=\"line\">[GC (Allocation Failure)  1560K-&gt;648K(3584K), 0.0036572 secs]</span><br><span class=\"line\">TestClass - Test</span><br><span class=\"line\">TestClass - Test</span><br><span class=\"line\">TestClass - Test</span><br><span class=\"line\">[GC (Allocation Failure)  1621K-&gt;984K(3584K), 0.0011455 secs]</span><br><span class=\"line\">--- 弱引用对象被jvm回收了 ---- java.lang.ref.WeakReference@51a947fe</span><br><span class=\"line\">--- 回收对象 ---- null</span><br><span class=\"line\">null</span><br><span class=\"line\">...省略n个null和几次GC信息</span><br><span class=\"line\">[Full GC (Ergonomics)  2964K-&gt;2964K(3584K), 0.0025450 secs]</span><br><span class=\"line\">[Full GC (Allocation Failure)  2964K-&gt;2964K(3584K), 0.0021907 secs]</span><br><span class=\"line\">java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">Dumping heap to java_pid6860.hprof ...</span><br><span class=\"line\">Heap dump file created [3912229 bytes <span class=\"keyword\">in</span> 0.011 secs]</span><br><span class=\"line\">Exception <span class=\"keyword\">in</span> thread <span class=\"string\">\"Thread-0\"</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">\tat weakhashmap.WeakReferenceTest.lambda<span class=\"variable\">$main</span><span class=\"variable\">$0</span>(WeakReferenceTest.java:22)</span><br><span class=\"line\">\tat weakhashmap.WeakReferenceTest$<span class=\"variable\">$Lambda</span><span class=\"variable\">$1</span>/764977973.run(Unknown Source)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>\n<p>可以看到，其实弱引用也并不是一发生GC就被回收掉了。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>如果一个对象仅仅是偶尔使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 WeakReference 来引用该对象。 </p>\n<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>\n<p>一般来说，很少直接使用WeakReference，而是使用WeakHashMap。在WeakHashMap中，内部有一个引用队列，插入的元素会被包裹成WeakReference，并加入队列中，用来做缓存再合适不过。</p>\n<p>在Tomcat的缓存中，其实就用到了WeakHashMap：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcurrentCache</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;K,V&gt; eden;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;K,V&gt; longterm;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConcurrentCache</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.size = size;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.eden = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;(size);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.longterm = <span class=\"keyword\">new</span> WeakHashMap&lt;&gt;(size);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(K k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先从eden中取</span></span><br><span class=\"line\">        V v = <span class=\"keyword\">this</span>.eden.get(k);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果取不到再从longterm中取</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (longterm) &#123;</span><br><span class=\"line\">                v = <span class=\"keyword\">this</span>.longterm.get(k);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果取到则重新放到eden中</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (v != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.eden.put(k, v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(K k, V v)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.eden.size() &gt;= size) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果eden中的元素数量大于指定容量，将所有元素放到longterm中</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (longterm) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.longterm.putAll(<span class=\"keyword\">this</span>.eden);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.eden.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.eden.put(k, v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有eden和longterm的两个map，如果对jvm堆了解的话，可以看出tomcat在这里是使用ConcurrentHashMap和WeakHashMap做了类似分代缓存的操作。</p>\n<p>在put方法里，在插入键值对时，先检查eden缓存的容量是否超出设定的大小。如果没有则直接放入eden缓存，如果超了则锁定longterm将eden中所有的键值对都放入longterm。再将eden清空并插入该键值对。</p>\n<p>在get方法中，也是优先从eden中找对应的key，如果没有则进入longterm缓存中查找，找到后就加入eden缓存并返回。 </p>\n<p>经过这样的设计，相对常用的对象都能在eden缓存中找到，不常用（有可能被销毁的对象）的则进入longterm缓存。而longterm的key的实际对象没有其他引用指向它时，gc就会自动回收heap中该弱引用指向的实际对象，并将弱引用放入其引用队列中。</p>\n<h2 id=\"弱引用与软引用对比\"><a href=\"#弱引用与软引用对比\" class=\"headerlink\" title=\"弱引用与软引用对比\"></a>弱引用与软引用对比</h2><p>弱引用与软引用的区别在于：</p>\n<ol>\n<li>只具有弱引用的对象拥有更短暂的生命周期。</li>\n<li>被垃圾回收器回收的时机不一样，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。而被软引用关联的对象只有在内存不足时才会被回收。</li>\n<li>弱引用不会影响GC，而软引用会一定程度上对GC造成影响。</li>\n</ol>\n<p>相似之处：都是用来描述非必需对象的。</p>\n<p>那么什么时候用SoftReference，什么时候用WeakReference呢？</p>\n<p>如果缓存的对象是比较大的对象，使用频率相对较高的对象，那么使用SoftReference会更好，因为这样能让缓存对象有更长的生命周期。</p>\n<p>如果缓存对象都是比较小的对象，使用频率一般或者相对较低，那么使用WeakReference会更合适。</p>\n<p>当然，如果实在不知道选哪个，一般而言，用作缓存时使用WeakHashMap都不会有太大问题。<img src=\"./195.png\" width=\"50\"></p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>弱引用是比软引用更弱的引用类型 </li>\n<li>弱引用不能延长对象的生命周期，一旦对象只剩下弱引用，它就随时可能会被回收</li>\n<li>可以通过弱引用获取对象的强引用</li>\n<li>弱引用适合用作缓存</li>\n</ul>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>弱引用是使用WeakReference创建的引用，弱引用也是用来描述非必需对象的，它是比软引用更弱的引用类型。在发生GC时，只要发现弱引用，不管系统堆空间是否足够，都会将对象进行回收。</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>弱引用，从名字来看就很弱嘛，这种引用指向的对象，一旦在GC时被扫描到，就逃脱不了被回收的命运。<img src=\"/images/0040.png\" width=\"50\"></p>\n<p>但是，弱引用指向的对象也并不一定就马上会被回收，如果弱引用对象较大，直接进到了老年代，那么就可以苟且偷生到Full GC触发前，所以弱引用对象也可能存在较长的一段时间。一旦一个弱引用对象被垃圾回收器回收，便会加入到一个引用队列中（如果有的话）。</p>\n<p>弱引用对应的类为WeakReference，举个栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"keyword\">new</span> String(<span class=\"string\">\"Frank\"</span>);    </span><br><span class=\"line\">WeakReference&lt;String&gt; weakRef = <span class=\"keyword\">new</span> WeakReference&lt;String&gt;(s);</span><br><span class=\"line\">s = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>这里我们把s设置为null后，字符串对象便只有弱引用指向它。</p>\n<blockquote>\n<p>弱可达<br>如果一个对象与GC Roots之间仅存在弱引用，则称这个对象为<code>弱可达(weakly reachable)</code>对象。</p>\n</blockquote>\n<blockquote>\n<p>warning 注意<br>在垃圾回收器回收一个对象前，WeakReference类所提供的get方法会返回其引用对象的强引用，一旦垃圾回收器回收掉该对象之后，get方法将返回null。所以在获取弱引用对象的代码中，一定要判断是否为null，以免出现NullPointerException异常导致应用崩溃。<img src=\"/images/0019.png\" width=\"50\"></p>\n</blockquote>\n<p>下面的代码会让s再次持有对象的强引用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = weakRef.get();</span><br></pre></td></tr></table></figure>\n<p>如果在weakRef包裹的对象被回收前，用强引用关联该对象，那这个对象又会变成强可达状态。</p>\n<p>来看一个简单的栗子了解一下WeakReference引用的对象是何时被回收的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WeakReferenceTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> List&lt;Object&gt; TEST_DATA = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ReferenceQueue&lt;TestClass&gt; QUEUE = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        TestClass obj = <span class=\"keyword\">new</span> TestClass(<span class=\"string\">\"Test\"</span>);</span><br><span class=\"line\">        WeakReference&lt;TestClass&gt; weakRef = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(obj, QUEUE);</span><br><span class=\"line\">        <span class=\"comment\">//可以重新获得OOMClass对象，并用一个强引用指向它</span></span><br><span class=\"line\">        <span class=\"comment\">//oomObj = weakRef.get();</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 该线程不断读取这个弱引用，并不断往列表里插入数据，以促使系统早点进行GC</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                TEST_DATA.add(<span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span> * <span class=\"number\">100</span>]);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                    Thread.currentThread().interrupt();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(weakRef.get());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 这个线程不断读取引用队列，当弱引用指向的对象呗回收时，该引用就会被加入到引用队列中</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                Reference&lt;? extends TestClass&gt; poll = QUEUE.poll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (poll != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"--- 弱引用对象被jvm回收了 ---- \"</span> + poll);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"--- 回收对象 ---- \"</span> + poll.get());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//将强引用指向空指针 那么此时只有一个弱引用指向TestClass对象</span></span><br><span class=\"line\">        obj = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.currentThread().join();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestClass</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TestClass</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"TestClass - \"</span> + name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>设置一下虚拟机参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-verbose:gc -Xms4m -Xmx4m -Xmn2m</span><br></pre></td></tr></table></figure>\n<p>运行结果如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure)  1017K-&gt;464K(3584K), 0.0014345 secs]</span><br><span class=\"line\">[GC (Allocation Failure)  1483K-&gt;536K(3584K), 0.0017221 secs]</span><br><span class=\"line\">[GC (Allocation Failure)  1560K-&gt;648K(3584K), 0.0036572 secs]</span><br><span class=\"line\">TestClass - Test</span><br><span class=\"line\">TestClass - Test</span><br><span class=\"line\">TestClass - Test</span><br><span class=\"line\">[GC (Allocation Failure)  1621K-&gt;984K(3584K), 0.0011455 secs]</span><br><span class=\"line\">--- 弱引用对象被jvm回收了 ---- java.lang.ref.WeakReference@51a947fe</span><br><span class=\"line\">--- 回收对象 ---- null</span><br><span class=\"line\">null</span><br><span class=\"line\">...省略n个null和几次GC信息</span><br><span class=\"line\">[Full GC (Ergonomics)  2964K-&gt;2964K(3584K), 0.0025450 secs]</span><br><span class=\"line\">[Full GC (Allocation Failure)  2964K-&gt;2964K(3584K), 0.0021907 secs]</span><br><span class=\"line\">java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">Dumping heap to java_pid6860.hprof ...</span><br><span class=\"line\">Heap dump file created [3912229 bytes <span class=\"keyword\">in</span> 0.011 secs]</span><br><span class=\"line\">Exception <span class=\"keyword\">in</span> thread <span class=\"string\">\"Thread-0\"</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">\tat weakhashmap.WeakReferenceTest.lambda<span class=\"variable\">$main</span><span class=\"variable\">$0</span>(WeakReferenceTest.java:22)</span><br><span class=\"line\">\tat weakhashmap.WeakReferenceTest$<span class=\"variable\">$Lambda</span><span class=\"variable\">$1</span>/764977973.run(Unknown Source)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>\n<p>可以看到，其实弱引用也并不是一发生GC就被回收掉了。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>如果一个对象仅仅是偶尔使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 WeakReference 来引用该对象。 </p>\n<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>\n<p>一般来说，很少直接使用WeakReference，而是使用WeakHashMap。在WeakHashMap中，内部有一个引用队列，插入的元素会被包裹成WeakReference，并加入队列中，用来做缓存再合适不过。</p>\n<p>在Tomcat的缓存中，其实就用到了WeakHashMap：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcurrentCache</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;K,V&gt; eden;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;K,V&gt; longterm;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConcurrentCache</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.size = size;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.eden = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;(size);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.longterm = <span class=\"keyword\">new</span> WeakHashMap&lt;&gt;(size);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(K k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先从eden中取</span></span><br><span class=\"line\">        V v = <span class=\"keyword\">this</span>.eden.get(k);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果取不到再从longterm中取</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (longterm) &#123;</span><br><span class=\"line\">                v = <span class=\"keyword\">this</span>.longterm.get(k);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果取到则重新放到eden中</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (v != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.eden.put(k, v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(K k, V v)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.eden.size() &gt;= size) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果eden中的元素数量大于指定容量，将所有元素放到longterm中</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (longterm) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.longterm.putAll(<span class=\"keyword\">this</span>.eden);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.eden.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.eden.put(k, v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有eden和longterm的两个map，如果对jvm堆了解的话，可以看出tomcat在这里是使用ConcurrentHashMap和WeakHashMap做了类似分代缓存的操作。</p>\n<p>在put方法里，在插入键值对时，先检查eden缓存的容量是否超出设定的大小。如果没有则直接放入eden缓存，如果超了则锁定longterm将eden中所有的键值对都放入longterm。再将eden清空并插入该键值对。</p>\n<p>在get方法中，也是优先从eden中找对应的key，如果没有则进入longterm缓存中查找，找到后就加入eden缓存并返回。 </p>\n<p>经过这样的设计，相对常用的对象都能在eden缓存中找到，不常用（有可能被销毁的对象）的则进入longterm缓存。而longterm的key的实际对象没有其他引用指向它时，gc就会自动回收heap中该弱引用指向的实际对象，并将弱引用放入其引用队列中。</p>\n<h2 id=\"弱引用与软引用对比\"><a href=\"#弱引用与软引用对比\" class=\"headerlink\" title=\"弱引用与软引用对比\"></a>弱引用与软引用对比</h2><p>弱引用与软引用的区别在于：</p>\n<ol>\n<li>只具有弱引用的对象拥有更短暂的生命周期。</li>\n<li>被垃圾回收器回收的时机不一样，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。而被软引用关联的对象只有在内存不足时才会被回收。</li>\n<li>弱引用不会影响GC，而软引用会一定程度上对GC造成影响。</li>\n</ol>\n<p>相似之处：都是用来描述非必需对象的。</p>\n<p>那么什么时候用SoftReference，什么时候用WeakReference呢？</p>\n<p>如果缓存的对象是比较大的对象，使用频率相对较高的对象，那么使用SoftReference会更好，因为这样能让缓存对象有更长的生命周期。</p>\n<p>如果缓存对象都是比较小的对象，使用频率一般或者相对较低，那么使用WeakReference会更合适。</p>\n<p>当然，如果实在不知道选哪个，一般而言，用作缓存时使用WeakHashMap都不会有太大问题。<img src=\"./195.png\" width=\"50\"></p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>弱引用是比软引用更弱的引用类型 </li>\n<li>弱引用不能延长对象的生命周期，一旦对象只剩下弱引用，它就随时可能会被回收</li>\n<li>可以通过弱引用获取对象的强引用</li>\n<li>弱引用适合用作缓存</li>\n</ul>\n"},{"title":"【Python爬虫】听说你又闹书荒了？豆瓣读书9.0分书籍陪你过五一","date":"2019-04-27T02:25:00.000Z","categorys":["编程"],"_content":"\n## 说明\n\n五一将至，又到了学习的季节。目前流行的各大书单主打的都是豆瓣8.0评分书籍，却很少有人来聊聊这9.0评分的书籍长什么样子。刚好最近学了学python爬虫，那就拿豆瓣读书来练练手。\n\n![](https://i.loli.net/2019/03/14/5c8a580b1789e.png)\n\n## 爬虫\n\n本来思路是直接爬豆瓣的书籍目录，将评分9.0以上的书筛选出来，一打开发现事情并不简单，几千万本书可不好爬 = =，于是转化一下思路，看有没有类似的书单。\n\n![](https://i.loli.net/2019/03/14/5c8a5766a30bc.png)\n\n一搜还真有，找到一个9.0评分的榜单，大大减少了工作量，这样就不用先爬一下整站书籍来筛选了。看了看榜单，应该是某位好心的书友手工整理的，更新时间为2018-12-25，目前一共530本，分为22页，也就是说22次访问就能搞定了，不会给豆瓣的服务器造成压力。\n\n### 目标\n\n目标URL：https://www.douban.com/doulist/1264675/?start=0&sort=seq&playable=0&sub_type=4\n\n数据量：530\n\n预计访问次数：22\n\n数据存储：csv\n\n抓取内容格式：书籍名称 作者 评分 评价人数 出版社 出版年 封面链接\n\n### 代码\n\n有了小目标，接下来就是用刚学的 python 来现学现卖了。\n\n先来定一下步骤：\n\n```py\n\n# 设置headers\n\n# 获取代理\n\n# 获取网页数据\n\n# 解析书籍数据\n\n# 存入csv文件\n\n```\n\n然后一步步来填坑即可，先来设置headers，主要是设置UA来绕过访问限制：\n\n```py\nurl = 'https://www.douban.com/doulist/1264675/?start=0&sort=seq&playable=0&sub_type=4'\n\nlogging.basicConfig(level=logging.DEBUG)\n\nua = UserAgent()\n\n# 设置headers\nheaders = {'User-Agent': ua.random}\n\n```\n\n当然，只设置UA也没法逃过访问限制，IP限制这一关还是存在的，所以需要使用代理来绕开。\n\n![](https://i.loli.net/2019/03/14/5c8a519711460.png)\n\n所以先来爬一爬代理的数据，弄一批能用的代理IP下来：\n\n```py\n# 获取代理数据\ndef get_proxies(proxy_url, dis_url, page=10):\n    proxy_list = []\n    for i in range(1, page + 1):\n        tmp_ua = UserAgent()\n        tmp_headers = {'User-Agent': tmp_ua.random}\n        html_str = get_web_data(proxy_url + str(i), tmp_headers)\n        soup = BeautifulSoup(html_str.content, \"lxml\")\n        ips = soup.find('tbody').find_all('tr')\n        for ip_info in ips:\n            tds = ip_info.find_all('td')\n            ip = tds[0].get_text()\n            port = tds[1].get_text()\n            ip_str = ip + \":\" + port\n            tmp = {\"http\": \"http://\" + ip_str}\n            if check_proxy(dis_url, tmp):\n                logging.info(\"ip:%s is available\", ip_str)\n                proxy_list.append(ip_str)\n        time.sleep(1)\n    return proxy_list\n\n\n# 检测代理ip是否可用\ndef check_proxy(url, proxy):\n    try:\n        tmp_ua = UserAgent()\n        tmp_headers = {'User-Agent': tmp_ua.random}\n        res = requests.get(url, proxies=proxy, timeout=1, headers=tmp_headers)\n    except:\n        return False\n    else:\n        return True\n```\n\n这里其实有两个函数，一个是get_proxies函数，用来从代理页面爬数据，这里选用的是快代理，一个是check_proxy函数，用来检测该ip是否能访问目标页面，如果能访问，则将其添加到可用代理列表。\n\n然后是获取网页内容，这里使用requests模块来获取网页内容：\n\n```py\n# 获取网页数据\ndef get_web_data(url, headers, proxies=[]):\n    try:\n        data = requests.get(url, proxies=proxies, timeout=3, headers=headers)\n    except requests.exceptions.ConnectionError as e:\n        logging.error(\"请求错误，url:\", url)\n        logging.error(\"错误详情：\", e)\n        data = None\n    except:\n        logging.error(\"未知错误，url:\", url)\n        data = None\n    return data\n```\n\n接下来进行网页内容解析，借助一下BeautifulSoup模块和re正则模块来解析网页元素。\n\n```python\n# 解析书籍数据\ndef parse_data(data):\n    if data is None:\n        return None\n    # 处理编码\n    charset = chardet.detect(data.content)\n    data.encoding = charset['encoding']\n\n    # 正则表达式匹配作者出版社信息\n    author_pattern = re.compile(r'(作者: (.*))?[\\s|\\S]*出版社: (.*)[\\s|\\S]*出版年: (.*)')\n\n    # 解析标签\n    soup = BeautifulSoup(data.text, 'lxml')\n    book_list = soup.find_all(\"div\", class_=\"bd doulist-subject\")\n    list = []\n    for book in book_list:\n        book_map = {}\n        book_name = book.find('div', class_='title').get_text().strip()\n        book_map['book_name'] = book_name\n\n        rate_point = book.find('div', class_='rating').find('span', class_='rating_nums').get_text().strip()\n        book_map['rate_point'] = rate_point\n\n        rate_number = book.find('div', class_='rating').find('span', class_='').get_text().strip()[1:-4]\n        book_map['rate_number'] = rate_number\n\n        tmp = book.find('div', class_='abstract').get_text().strip()\n        m = author_pattern.match(tmp)\n        if m != None:\n            author = m.group(1)\n            if author == None:\n                author = ''\n            publisher = m.group(3)\n            publish_date = m.group(4)\n            book_map['author'] = author\n            book_map['publisher'] = publisher\n            book_map['publish_date'] = publish_date\n\n        pic_link = book.find('div', class_='post').a.img['src']\n        book_map['pic_link'] = pic_link\n        list.append(book_map)\n        logging.info(\"书名：《%s》，作者：%s，评分：%s，评分人数：%s，出版社：%s，出版年：%s，封面链接：%s\",\n                     book_name, author, rate_point, rate_number, publisher, publish_date, pic_link)\n    return list\n```\n\n然后将结果存入csv文件中：\n\n```py\n# 存入csv文件\ndef save_to_csv(filename, books):\n    with open(filename, 'a', newline='', encoding='utf-8') as f:\n        writer = csv.DictWriter(f, fieldnames=books[0].keys())\n        for book in books:\n            writer.writerow(book)\n        f.close()\n\n```\n\n这样，我们整体的代码就差不多成型了，全部代码如下：\n\n```py\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\"\"\"\nauth: Frank\ndate: 2019-04-27\ndesc: 爬取豆瓣读书评分9.0以上书籍并存入csv文件\n\n目标URL：https://www.douban.com/doulist/1264675/?start=0&sort=seq&playable=0&sub_type=4\n\n数据量：530\n\n预计访问次数：22\n\n数据存储：csv\n\n抓取内容格式：书籍名称 作者 作者国籍 评分 评价人数 出版社 出版年 封面链接\n\"\"\"\nimport logging\nimport os\nimport random\nimport urllib.robotparser\nimport time\nimport requests\nimport re\nimport chardet\nfrom bs4 import BeautifulSoup\nfrom fake_useragent import UserAgent\nimport csv\n\n\n# 获取网页数据\ndef get_web_data(url, headers, proxies=[]):\n    try:\n        data = requests.get(url, proxies=proxies, timeout=3, headers=headers)\n    except requests.exceptions.ConnectionError as e:\n        logging.error(\"请求错误，url:\", url)\n        logging.error(\"错误详情：\", e)\n        data = None\n    except:\n        logging.error(\"未知错误，url:\", url)\n        data = None\n    return data\n\n\n# 解析书籍数据\ndef parse_data(data):\n    if data is None:\n        return None\n    # 处理编码\n    charset = chardet.detect(data.content)\n    data.encoding = charset['encoding']\n\n    # 正则表达式匹配作者出版社信息\n    author_pattern = re.compile(r'(作者: (.*))?[\\s|\\S]*出版社: (.*)[\\s|\\S]*出版年: (.*)')\n\n    # 解析标签\n    soup = BeautifulSoup(data.text, 'lxml')\n    book_list = soup.find_all(\"div\", class_=\"bd doulist-subject\")\n    list = []\n    for book in book_list:\n        book_map = {}\n        book_name = book.find('div', class_='title').get_text().strip()\n        book_map['book_name'] = book_name\n\n        rate_point = book.find('div', class_='rating').find('span', class_='rating_nums').get_text().strip()\n        book_map['rate_point'] = rate_point\n\n        rate_number = book.find('div', class_='rating').find('span', class_='').get_text().strip()[1:-4]\n        book_map['rate_number'] = rate_number\n\n        tmp = book.find('div', class_='abstract').get_text().strip()\n        m = author_pattern.match(tmp)\n        if m is not None:\n            author = m.group(1)\n            if author is None:\n                author = ''\n            publisher = m.group(3)\n            publish_date = m.group(4)\n            book_map['author'] = author\n            book_map['publisher'] = publisher\n            book_map['publish_date'] = publish_date\n\n        pic_link = book.find('div', class_='post').a.img['src']\n        book_map['pic_link'] = pic_link\n        list.append(book_map)\n        logging.info(\"书名：《%s》，作者：%s，评分：%s，评分人数：%s，出版社：%s，出版年：%s，封面链接：%s\",\n                     book_name, author, rate_point, rate_number, publisher, publish_date, pic_link)\n    return list\n\n\n# 存入csv文件\ndef save_to_csv(filename, books):\n    with open(filename, 'a', newline='', encoding='utf-8') as file:\n        writer = csv.DictWriter(file, fieldnames=books[0].keys())\n        for tmp_book in books:\n            writer.writerow(tmp_book)\n\n\n# 获取代理数据\ndef get_proxies(proxy_url, dis_url, page=10):\n    proxy_list = []\n    for i in range(1, page + 1):\n        tmp_ua = UserAgent()\n        tmp_headers = {'User-Agent': tmp_ua.random}\n        html_str = get_web_data(proxy_url + str(i), tmp_headers)\n        soup = BeautifulSoup(html_str.content, \"lxml\")\n        ips = soup.find('tbody').find_all('tr')\n        for ip_info in ips:\n            tds = ip_info.find_all('td')\n            ip = tds[0].get_text()\n            port = tds[1].get_text()\n            ip_str = ip + \":\" + port\n            tmp = {\"http\": \"http://\" + ip_str}\n            if check_proxy(dis_url, tmp):\n                logging.info(\"ip:%s is available\", ip_str)\n                proxy_list.append(ip_str)\n        time.sleep(1)\n    return proxy_list\n\n\n# 检测代理ip是否可用\ndef check_proxy(url, proxy):\n    try:\n        tmp_ua = UserAgent()\n        tmp_headers = {'User-Agent': tmp_ua.random}\n        res = requests.get(url, proxies=proxy, timeout=1, headers=tmp_headers)\n    except:\n        return False\n    else:\n        return True\n\n\ndef get_random_ip(ip_list):\n    proxy = random.choice(ip_list)\n    proxies = {'http': 'http://' + proxy}\n    return proxies\n\n\nif __name__ == '__main__':\n    logging.basicConfig(level=logging.INFO)\n    url = 'https://www.douban.com/doulist/1264675/?start='\n    file_path = os.path.dirname(os.path.realpath(__file__)) + os.sep + 'douban.csv'\n    f = open(file_path, 'w')\n    f.close()\n\n    # 获取代理\n    proxies = get_proxies(\"https://www.kuaidaili.com/free/intr/\", url, 5)\n\n    # 设置headers\n    ua = UserAgent()\n\n    result_list = []\n    for num in range(0, 530, 25):\n        headers = {'User-Agent': ua.random}\n        logging.info('headers:%s', headers)\n        data = get_web_data(url + str(num), headers, get_random_ip(proxies))\n        book = parse_data(data)\n        save_to_csv(file_path, book)\n        time.sleep(1)\n```\n\n来运行一下：\n\n![](https://i.loli.net/2019/04/30/5cc802f79be50.png)\n\n![](https://i.loli.net/2019/04/30/5cc803435c659.png)\n\n最终爬下来的文件：\n\n![](https://i.loli.net/2019/04/30/5cc802e26a2d5.png)\n\n源码以及爬下来的数据都放到了github：https://github.com/MFrank2016/douban_spider\n\n要运行该文件，除了需要安装import中的模块，还需要安装一个lxml模块才能运行。\n\n## 总结\n\n其实写爬虫的思路都是差不多的，大概分为几步：\n\n1. 查找可用代理ip\n2. 设置UA\n3. 使用代理ip访问网页\n4. 解析网页数据\n5. 存储/分析\n\n这个爬虫还是比较简陋的，在获取代理并校验代理ip可用性这一步花了较多时间，优化的话，可以用多线程来进行代理ip可用性检测，得到一定数量的代理ip后，多线程进行网页访问和数据解析，然后再存储到数据库中。不过要使用多线程的话复杂度就会大大提升了，在这个小爬虫里，因为只需要爬22页数据，所以没有使用的必要。\n\n还有一个重要的问题就是这里没有对异常信息进行处理，运行中途如果出错就会导致前功尽弃，要考虑好大部分异常情况并不容易。\n\n当然，整个过程并没有上文描述的这样简单，调试过程还是花了不少时间，应该没有用过 BeautifulSoup 模块，摸索了不少时间才能初步使用它。\n\n作为python的初学者而言，用python最舒服的感受便是好用的模块确实多，用 BeautifulSoup 模块来进行网页解析确实比直接正则解析要方便的多，而且更容易控制。\n\n个人觉得爬虫只是用来获取数据的一个手段，用python也好，java也好，没有优劣之分，能实现想要的达成的目的即可，用什么语言顺手就用什么语言。将数据爬取下来后，便可以进行后续的数据分析，可视化等工作了。使用工具不是目的，只是手段，这一点我也是花了很长时间才慢慢理解。就像使用爬虫来获取数据来进行数据分析，从数据中挖掘想要的信息并用于指导实践才是真正产生价值的地方。作为技术人员，很容易产生的误区便是把技术当做一切，而不重视业务，殊不知真正创造价值的正是业务的制定者和执行者，技术最终都是为业务服务的。\n\n![](https://i.loli.net/2019/03/08/5c8255c88946b.png)\n\n本文到此就告一段落了，希望能对你有所帮助，也欢迎关注我的公众号进行留言交流。\n\n![](https://i.loli.net/2019/03/14/5c8a58ba229ca.png)","source":"_posts/python/spider/spider-douban-book.md","raw":"---\ntitle: 【Python爬虫】听说你又闹书荒了？豆瓣读书9.0分书籍陪你过五一\ndate: 2019-04-27 10:25\ntags: \n - 爬虫\n - 豆瓣\n - Python\ncategorys:\n - 编程\n---\n\n## 说明\n\n五一将至，又到了学习的季节。目前流行的各大书单主打的都是豆瓣8.0评分书籍，却很少有人来聊聊这9.0评分的书籍长什么样子。刚好最近学了学python爬虫，那就拿豆瓣读书来练练手。\n\n![](https://i.loli.net/2019/03/14/5c8a580b1789e.png)\n\n## 爬虫\n\n本来思路是直接爬豆瓣的书籍目录，将评分9.0以上的书筛选出来，一打开发现事情并不简单，几千万本书可不好爬 = =，于是转化一下思路，看有没有类似的书单。\n\n![](https://i.loli.net/2019/03/14/5c8a5766a30bc.png)\n\n一搜还真有，找到一个9.0评分的榜单，大大减少了工作量，这样就不用先爬一下整站书籍来筛选了。看了看榜单，应该是某位好心的书友手工整理的，更新时间为2018-12-25，目前一共530本，分为22页，也就是说22次访问就能搞定了，不会给豆瓣的服务器造成压力。\n\n### 目标\n\n目标URL：https://www.douban.com/doulist/1264675/?start=0&sort=seq&playable=0&sub_type=4\n\n数据量：530\n\n预计访问次数：22\n\n数据存储：csv\n\n抓取内容格式：书籍名称 作者 评分 评价人数 出版社 出版年 封面链接\n\n### 代码\n\n有了小目标，接下来就是用刚学的 python 来现学现卖了。\n\n先来定一下步骤：\n\n```py\n\n# 设置headers\n\n# 获取代理\n\n# 获取网页数据\n\n# 解析书籍数据\n\n# 存入csv文件\n\n```\n\n然后一步步来填坑即可，先来设置headers，主要是设置UA来绕过访问限制：\n\n```py\nurl = 'https://www.douban.com/doulist/1264675/?start=0&sort=seq&playable=0&sub_type=4'\n\nlogging.basicConfig(level=logging.DEBUG)\n\nua = UserAgent()\n\n# 设置headers\nheaders = {'User-Agent': ua.random}\n\n```\n\n当然，只设置UA也没法逃过访问限制，IP限制这一关还是存在的，所以需要使用代理来绕开。\n\n![](https://i.loli.net/2019/03/14/5c8a519711460.png)\n\n所以先来爬一爬代理的数据，弄一批能用的代理IP下来：\n\n```py\n# 获取代理数据\ndef get_proxies(proxy_url, dis_url, page=10):\n    proxy_list = []\n    for i in range(1, page + 1):\n        tmp_ua = UserAgent()\n        tmp_headers = {'User-Agent': tmp_ua.random}\n        html_str = get_web_data(proxy_url + str(i), tmp_headers)\n        soup = BeautifulSoup(html_str.content, \"lxml\")\n        ips = soup.find('tbody').find_all('tr')\n        for ip_info in ips:\n            tds = ip_info.find_all('td')\n            ip = tds[0].get_text()\n            port = tds[1].get_text()\n            ip_str = ip + \":\" + port\n            tmp = {\"http\": \"http://\" + ip_str}\n            if check_proxy(dis_url, tmp):\n                logging.info(\"ip:%s is available\", ip_str)\n                proxy_list.append(ip_str)\n        time.sleep(1)\n    return proxy_list\n\n\n# 检测代理ip是否可用\ndef check_proxy(url, proxy):\n    try:\n        tmp_ua = UserAgent()\n        tmp_headers = {'User-Agent': tmp_ua.random}\n        res = requests.get(url, proxies=proxy, timeout=1, headers=tmp_headers)\n    except:\n        return False\n    else:\n        return True\n```\n\n这里其实有两个函数，一个是get_proxies函数，用来从代理页面爬数据，这里选用的是快代理，一个是check_proxy函数，用来检测该ip是否能访问目标页面，如果能访问，则将其添加到可用代理列表。\n\n然后是获取网页内容，这里使用requests模块来获取网页内容：\n\n```py\n# 获取网页数据\ndef get_web_data(url, headers, proxies=[]):\n    try:\n        data = requests.get(url, proxies=proxies, timeout=3, headers=headers)\n    except requests.exceptions.ConnectionError as e:\n        logging.error(\"请求错误，url:\", url)\n        logging.error(\"错误详情：\", e)\n        data = None\n    except:\n        logging.error(\"未知错误，url:\", url)\n        data = None\n    return data\n```\n\n接下来进行网页内容解析，借助一下BeautifulSoup模块和re正则模块来解析网页元素。\n\n```python\n# 解析书籍数据\ndef parse_data(data):\n    if data is None:\n        return None\n    # 处理编码\n    charset = chardet.detect(data.content)\n    data.encoding = charset['encoding']\n\n    # 正则表达式匹配作者出版社信息\n    author_pattern = re.compile(r'(作者: (.*))?[\\s|\\S]*出版社: (.*)[\\s|\\S]*出版年: (.*)')\n\n    # 解析标签\n    soup = BeautifulSoup(data.text, 'lxml')\n    book_list = soup.find_all(\"div\", class_=\"bd doulist-subject\")\n    list = []\n    for book in book_list:\n        book_map = {}\n        book_name = book.find('div', class_='title').get_text().strip()\n        book_map['book_name'] = book_name\n\n        rate_point = book.find('div', class_='rating').find('span', class_='rating_nums').get_text().strip()\n        book_map['rate_point'] = rate_point\n\n        rate_number = book.find('div', class_='rating').find('span', class_='').get_text().strip()[1:-4]\n        book_map['rate_number'] = rate_number\n\n        tmp = book.find('div', class_='abstract').get_text().strip()\n        m = author_pattern.match(tmp)\n        if m != None:\n            author = m.group(1)\n            if author == None:\n                author = ''\n            publisher = m.group(3)\n            publish_date = m.group(4)\n            book_map['author'] = author\n            book_map['publisher'] = publisher\n            book_map['publish_date'] = publish_date\n\n        pic_link = book.find('div', class_='post').a.img['src']\n        book_map['pic_link'] = pic_link\n        list.append(book_map)\n        logging.info(\"书名：《%s》，作者：%s，评分：%s，评分人数：%s，出版社：%s，出版年：%s，封面链接：%s\",\n                     book_name, author, rate_point, rate_number, publisher, publish_date, pic_link)\n    return list\n```\n\n然后将结果存入csv文件中：\n\n```py\n# 存入csv文件\ndef save_to_csv(filename, books):\n    with open(filename, 'a', newline='', encoding='utf-8') as f:\n        writer = csv.DictWriter(f, fieldnames=books[0].keys())\n        for book in books:\n            writer.writerow(book)\n        f.close()\n\n```\n\n这样，我们整体的代码就差不多成型了，全部代码如下：\n\n```py\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\"\"\"\nauth: Frank\ndate: 2019-04-27\ndesc: 爬取豆瓣读书评分9.0以上书籍并存入csv文件\n\n目标URL：https://www.douban.com/doulist/1264675/?start=0&sort=seq&playable=0&sub_type=4\n\n数据量：530\n\n预计访问次数：22\n\n数据存储：csv\n\n抓取内容格式：书籍名称 作者 作者国籍 评分 评价人数 出版社 出版年 封面链接\n\"\"\"\nimport logging\nimport os\nimport random\nimport urllib.robotparser\nimport time\nimport requests\nimport re\nimport chardet\nfrom bs4 import BeautifulSoup\nfrom fake_useragent import UserAgent\nimport csv\n\n\n# 获取网页数据\ndef get_web_data(url, headers, proxies=[]):\n    try:\n        data = requests.get(url, proxies=proxies, timeout=3, headers=headers)\n    except requests.exceptions.ConnectionError as e:\n        logging.error(\"请求错误，url:\", url)\n        logging.error(\"错误详情：\", e)\n        data = None\n    except:\n        logging.error(\"未知错误，url:\", url)\n        data = None\n    return data\n\n\n# 解析书籍数据\ndef parse_data(data):\n    if data is None:\n        return None\n    # 处理编码\n    charset = chardet.detect(data.content)\n    data.encoding = charset['encoding']\n\n    # 正则表达式匹配作者出版社信息\n    author_pattern = re.compile(r'(作者: (.*))?[\\s|\\S]*出版社: (.*)[\\s|\\S]*出版年: (.*)')\n\n    # 解析标签\n    soup = BeautifulSoup(data.text, 'lxml')\n    book_list = soup.find_all(\"div\", class_=\"bd doulist-subject\")\n    list = []\n    for book in book_list:\n        book_map = {}\n        book_name = book.find('div', class_='title').get_text().strip()\n        book_map['book_name'] = book_name\n\n        rate_point = book.find('div', class_='rating').find('span', class_='rating_nums').get_text().strip()\n        book_map['rate_point'] = rate_point\n\n        rate_number = book.find('div', class_='rating').find('span', class_='').get_text().strip()[1:-4]\n        book_map['rate_number'] = rate_number\n\n        tmp = book.find('div', class_='abstract').get_text().strip()\n        m = author_pattern.match(tmp)\n        if m is not None:\n            author = m.group(1)\n            if author is None:\n                author = ''\n            publisher = m.group(3)\n            publish_date = m.group(4)\n            book_map['author'] = author\n            book_map['publisher'] = publisher\n            book_map['publish_date'] = publish_date\n\n        pic_link = book.find('div', class_='post').a.img['src']\n        book_map['pic_link'] = pic_link\n        list.append(book_map)\n        logging.info(\"书名：《%s》，作者：%s，评分：%s，评分人数：%s，出版社：%s，出版年：%s，封面链接：%s\",\n                     book_name, author, rate_point, rate_number, publisher, publish_date, pic_link)\n    return list\n\n\n# 存入csv文件\ndef save_to_csv(filename, books):\n    with open(filename, 'a', newline='', encoding='utf-8') as file:\n        writer = csv.DictWriter(file, fieldnames=books[0].keys())\n        for tmp_book in books:\n            writer.writerow(tmp_book)\n\n\n# 获取代理数据\ndef get_proxies(proxy_url, dis_url, page=10):\n    proxy_list = []\n    for i in range(1, page + 1):\n        tmp_ua = UserAgent()\n        tmp_headers = {'User-Agent': tmp_ua.random}\n        html_str = get_web_data(proxy_url + str(i), tmp_headers)\n        soup = BeautifulSoup(html_str.content, \"lxml\")\n        ips = soup.find('tbody').find_all('tr')\n        for ip_info in ips:\n            tds = ip_info.find_all('td')\n            ip = tds[0].get_text()\n            port = tds[1].get_text()\n            ip_str = ip + \":\" + port\n            tmp = {\"http\": \"http://\" + ip_str}\n            if check_proxy(dis_url, tmp):\n                logging.info(\"ip:%s is available\", ip_str)\n                proxy_list.append(ip_str)\n        time.sleep(1)\n    return proxy_list\n\n\n# 检测代理ip是否可用\ndef check_proxy(url, proxy):\n    try:\n        tmp_ua = UserAgent()\n        tmp_headers = {'User-Agent': tmp_ua.random}\n        res = requests.get(url, proxies=proxy, timeout=1, headers=tmp_headers)\n    except:\n        return False\n    else:\n        return True\n\n\ndef get_random_ip(ip_list):\n    proxy = random.choice(ip_list)\n    proxies = {'http': 'http://' + proxy}\n    return proxies\n\n\nif __name__ == '__main__':\n    logging.basicConfig(level=logging.INFO)\n    url = 'https://www.douban.com/doulist/1264675/?start='\n    file_path = os.path.dirname(os.path.realpath(__file__)) + os.sep + 'douban.csv'\n    f = open(file_path, 'w')\n    f.close()\n\n    # 获取代理\n    proxies = get_proxies(\"https://www.kuaidaili.com/free/intr/\", url, 5)\n\n    # 设置headers\n    ua = UserAgent()\n\n    result_list = []\n    for num in range(0, 530, 25):\n        headers = {'User-Agent': ua.random}\n        logging.info('headers:%s', headers)\n        data = get_web_data(url + str(num), headers, get_random_ip(proxies))\n        book = parse_data(data)\n        save_to_csv(file_path, book)\n        time.sleep(1)\n```\n\n来运行一下：\n\n![](https://i.loli.net/2019/04/30/5cc802f79be50.png)\n\n![](https://i.loli.net/2019/04/30/5cc803435c659.png)\n\n最终爬下来的文件：\n\n![](https://i.loli.net/2019/04/30/5cc802e26a2d5.png)\n\n源码以及爬下来的数据都放到了github：https://github.com/MFrank2016/douban_spider\n\n要运行该文件，除了需要安装import中的模块，还需要安装一个lxml模块才能运行。\n\n## 总结\n\n其实写爬虫的思路都是差不多的，大概分为几步：\n\n1. 查找可用代理ip\n2. 设置UA\n3. 使用代理ip访问网页\n4. 解析网页数据\n5. 存储/分析\n\n这个爬虫还是比较简陋的，在获取代理并校验代理ip可用性这一步花了较多时间，优化的话，可以用多线程来进行代理ip可用性检测，得到一定数量的代理ip后，多线程进行网页访问和数据解析，然后再存储到数据库中。不过要使用多线程的话复杂度就会大大提升了，在这个小爬虫里，因为只需要爬22页数据，所以没有使用的必要。\n\n还有一个重要的问题就是这里没有对异常信息进行处理，运行中途如果出错就会导致前功尽弃，要考虑好大部分异常情况并不容易。\n\n当然，整个过程并没有上文描述的这样简单，调试过程还是花了不少时间，应该没有用过 BeautifulSoup 模块，摸索了不少时间才能初步使用它。\n\n作为python的初学者而言，用python最舒服的感受便是好用的模块确实多，用 BeautifulSoup 模块来进行网页解析确实比直接正则解析要方便的多，而且更容易控制。\n\n个人觉得爬虫只是用来获取数据的一个手段，用python也好，java也好，没有优劣之分，能实现想要的达成的目的即可，用什么语言顺手就用什么语言。将数据爬取下来后，便可以进行后续的数据分析，可视化等工作了。使用工具不是目的，只是手段，这一点我也是花了很长时间才慢慢理解。就像使用爬虫来获取数据来进行数据分析，从数据中挖掘想要的信息并用于指导实践才是真正产生价值的地方。作为技术人员，很容易产生的误区便是把技术当做一切，而不重视业务，殊不知真正创造价值的正是业务的制定者和执行者，技术最终都是为业务服务的。\n\n![](https://i.loli.net/2019/03/08/5c8255c88946b.png)\n\n本文到此就告一段落了，希望能对你有所帮助，也欢迎关注我的公众号进行留言交流。\n\n![](https://i.loli.net/2019/03/14/5c8a58ba229ca.png)","slug":"python/spider/spider-douban-book","published":1,"updated":"2019-06-04T01:29:57.497Z","_id":"cjxze3gys007u0cvw6ne5bg40","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>五一将至，又到了学习的季节。目前流行的各大书单主打的都是豆瓣8.0评分书籍，却很少有人来聊聊这9.0评分的书籍长什么样子。刚好最近学了学python爬虫，那就拿豆瓣读书来练练手。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a580b1789e.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h2 id=\"爬虫\"><a href=\"#爬虫\" class=\"headerlink\" title=\"爬虫\"></a>爬虫</h2><p>本来思路是直接爬豆瓣的书籍目录，将评分9.0以上的书筛选出来，一打开发现事情并不简单，几千万本书可不好爬 = =，于是转化一下思路，看有没有类似的书单。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a5766a30bc.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>一搜还真有，找到一个9.0评分的榜单，大大减少了工作量，这样就不用先爬一下整站书籍来筛选了。看了看榜单，应该是某位好心的书友手工整理的，更新时间为2018-12-25，目前一共530本，分为22页，也就是说22次访问就能搞定了，不会给豆瓣的服务器造成压力。</p>\n<h3 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h3><p>目标URL：<a href=\"https://www.douban.com/doulist/1264675/?start=0&amp;sort=seq&amp;playable=0&amp;sub_type=4\" target=\"_blank\" rel=\"noopener\">https://www.douban.com/doulist/1264675/?start=0&amp;sort=seq&amp;playable=0&amp;sub_type=4</a></p>\n<p>数据量：530</p>\n<p>预计访问次数：22</p>\n<p>数据存储：csv</p>\n<p>抓取内容格式：书籍名称 作者 评分 评价人数 出版社 出版年 封面链接</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><p>有了小目标，接下来就是用刚学的 python 来现学现卖了。</p>\n<p>先来定一下步骤：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置headers</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取代理</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取网页数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解析书籍数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 存入csv文件</span></span><br></pre></td></tr></table></figure>\n<p>然后一步步来填坑即可，先来设置headers，主要是设置UA来绕过访问限制：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url = <span class=\"string\">'https://www.douban.com/doulist/1264675/?start=0&amp;sort=seq&amp;playable=0&amp;sub_type=4'</span></span><br><span class=\"line\"></span><br><span class=\"line\">logging.basicConfig(level=logging.DEBUG)</span><br><span class=\"line\"></span><br><span class=\"line\">ua = UserAgent()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置headers</span></span><br><span class=\"line\">headers = &#123;<span class=\"string\">'User-Agent'</span>: ua.random&#125;</span><br></pre></td></tr></table></figure>\n<p>当然，只设置UA也没法逃过访问限制，IP限制这一关还是存在的，所以需要使用代理来绕开。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a519711460.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>所以先来爬一爬代理的数据，弄一批能用的代理IP下来：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取代理数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_proxies</span><span class=\"params\">(proxy_url, dis_url, page=<span class=\"number\">10</span>)</span>:</span></span><br><span class=\"line\">    proxy_list = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, page + <span class=\"number\">1</span>):</span><br><span class=\"line\">        tmp_ua = UserAgent()</span><br><span class=\"line\">        tmp_headers = &#123;<span class=\"string\">'User-Agent'</span>: tmp_ua.random&#125;</span><br><span class=\"line\">        html_str = get_web_data(proxy_url + str(i), tmp_headers)</span><br><span class=\"line\">        soup = BeautifulSoup(html_str.content, <span class=\"string\">\"lxml\"</span>)</span><br><span class=\"line\">        ips = soup.find(<span class=\"string\">'tbody'</span>).find_all(<span class=\"string\">'tr'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ip_info <span class=\"keyword\">in</span> ips:</span><br><span class=\"line\">            tds = ip_info.find_all(<span class=\"string\">'td'</span>)</span><br><span class=\"line\">            ip = tds[<span class=\"number\">0</span>].get_text()</span><br><span class=\"line\">            port = tds[<span class=\"number\">1</span>].get_text()</span><br><span class=\"line\">            ip_str = ip + <span class=\"string\">\":\"</span> + port</span><br><span class=\"line\">            tmp = &#123;<span class=\"string\">\"http\"</span>: <span class=\"string\">\"http://\"</span> + ip_str&#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> check_proxy(dis_url, tmp):</span><br><span class=\"line\">                logging.info(<span class=\"string\">\"ip:%s is available\"</span>, ip_str)</span><br><span class=\"line\">                proxy_list.append(ip_str)</span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> proxy_list</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检测代理ip是否可用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check_proxy</span><span class=\"params\">(url, proxy)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        tmp_ua = UserAgent()</span><br><span class=\"line\">        tmp_headers = &#123;<span class=\"string\">'User-Agent'</span>: tmp_ua.random&#125;</span><br><span class=\"line\">        res = requests.get(url, proxies=proxy, timeout=<span class=\"number\">1</span>, headers=tmp_headers)</span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<p>这里其实有两个函数，一个是get_proxies函数，用来从代理页面爬数据，这里选用的是快代理，一个是check_proxy函数，用来检测该ip是否能访问目标页面，如果能访问，则将其添加到可用代理列表。</p>\n<p>然后是获取网页内容，这里使用requests模块来获取网页内容：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取网页数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_web_data</span><span class=\"params\">(url, headers, proxies=[])</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        data = requests.get(url, proxies=proxies, timeout=<span class=\"number\">3</span>, headers=headers)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> requests.exceptions.ConnectionError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        logging.error(<span class=\"string\">\"请求错误，url:\"</span>, url)</span><br><span class=\"line\">        logging.error(<span class=\"string\">\"错误详情：\"</span>, e)</span><br><span class=\"line\">        data = <span class=\"keyword\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        logging.error(<span class=\"string\">\"未知错误，url:\"</span>, url)</span><br><span class=\"line\">        data = <span class=\"keyword\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data</span><br></pre></td></tr></table></figure>\n<p>接下来进行网页内容解析，借助一下BeautifulSoup模块和re正则模块来解析网页元素。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 解析书籍数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_data</span><span class=\"params\">(data)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> data <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">    <span class=\"comment\"># 处理编码</span></span><br><span class=\"line\">    charset = chardet.detect(data.content)</span><br><span class=\"line\">    data.encoding = charset[<span class=\"string\">'encoding'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 正则表达式匹配作者出版社信息</span></span><br><span class=\"line\">    author_pattern = re.compile(<span class=\"string\">r'(作者: (.*))?[\\s|\\S]*出版社: (.*)[\\s|\\S]*出版年: (.*)'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 解析标签</span></span><br><span class=\"line\">    soup = BeautifulSoup(data.text, <span class=\"string\">'lxml'</span>)</span><br><span class=\"line\">    book_list = soup.find_all(<span class=\"string\">\"div\"</span>, class_=<span class=\"string\">\"bd doulist-subject\"</span>)</span><br><span class=\"line\">    list = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> book <span class=\"keyword\">in</span> book_list:</span><br><span class=\"line\">        book_map = &#123;&#125;</span><br><span class=\"line\">        book_name = book.find(<span class=\"string\">'div'</span>, class_=<span class=\"string\">'title'</span>).get_text().strip()</span><br><span class=\"line\">        book_map[<span class=\"string\">'book_name'</span>] = book_name</span><br><span class=\"line\"></span><br><span class=\"line\">        rate_point = book.find(<span class=\"string\">'div'</span>, class_=<span class=\"string\">'rating'</span>).find(<span class=\"string\">'span'</span>, class_=<span class=\"string\">'rating_nums'</span>).get_text().strip()</span><br><span class=\"line\">        book_map[<span class=\"string\">'rate_point'</span>] = rate_point</span><br><span class=\"line\"></span><br><span class=\"line\">        rate_number = book.find(<span class=\"string\">'div'</span>, class_=<span class=\"string\">'rating'</span>).find(<span class=\"string\">'span'</span>, class_=<span class=\"string\">''</span>).get_text().strip()[<span class=\"number\">1</span>:<span class=\"number\">-4</span>]</span><br><span class=\"line\">        book_map[<span class=\"string\">'rate_number'</span>] = rate_number</span><br><span class=\"line\"></span><br><span class=\"line\">        tmp = book.find(<span class=\"string\">'div'</span>, class_=<span class=\"string\">'abstract'</span>).get_text().strip()</span><br><span class=\"line\">        m = author_pattern.match(tmp)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> m != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            author = m.group(<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> author == <span class=\"keyword\">None</span>:</span><br><span class=\"line\">                author = <span class=\"string\">''</span></span><br><span class=\"line\">            publisher = m.group(<span class=\"number\">3</span>)</span><br><span class=\"line\">            publish_date = m.group(<span class=\"number\">4</span>)</span><br><span class=\"line\">            book_map[<span class=\"string\">'author'</span>] = author</span><br><span class=\"line\">            book_map[<span class=\"string\">'publisher'</span>] = publisher</span><br><span class=\"line\">            book_map[<span class=\"string\">'publish_date'</span>] = publish_date</span><br><span class=\"line\"></span><br><span class=\"line\">        pic_link = book.find(<span class=\"string\">'div'</span>, class_=<span class=\"string\">'post'</span>).a.img[<span class=\"string\">'src'</span>]</span><br><span class=\"line\">        book_map[<span class=\"string\">'pic_link'</span>] = pic_link</span><br><span class=\"line\">        list.append(book_map)</span><br><span class=\"line\">        logging.info(<span class=\"string\">\"书名：《%s》，作者：%s，评分：%s，评分人数：%s，出版社：%s，出版年：%s，封面链接：%s\"</span>,</span><br><span class=\"line\">                     book_name, author, rate_point, rate_number, publisher, publish_date, pic_link)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list</span><br></pre></td></tr></table></figure>\n<p>然后将结果存入csv文件中：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 存入csv文件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">save_to_csv</span><span class=\"params\">(filename, books)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> open(filename, <span class=\"string\">'a'</span>, newline=<span class=\"string\">''</span>, encoding=<span class=\"string\">'utf-8'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        writer = csv.DictWriter(f, fieldnames=books[<span class=\"number\">0</span>].keys())</span><br><span class=\"line\">        <span class=\"keyword\">for</span> book <span class=\"keyword\">in</span> books:</span><br><span class=\"line\">            writer.writerow(book)</span><br><span class=\"line\">        f.close()</span><br></pre></td></tr></table></figure>\n<p>这样，我们整体的代码就差不多成型了，全部代码如下：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">auth: Frank</span></span><br><span class=\"line\"><span class=\"string\">date: 2019-04-27</span></span><br><span class=\"line\"><span class=\"string\">desc: 爬取豆瓣读书评分9.0以上书籍并存入csv文件</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">目标URL：https://www.douban.com/doulist/1264675/?start=0&amp;sort=seq&amp;playable=0&amp;sub_type=4</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">数据量：530</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">预计访问次数：22</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">数据存储：csv</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">抓取内容格式：书籍名称 作者 作者国籍 评分 评价人数 出版社 出版年 封面链接</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib.robotparser</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"keyword\">import</span> chardet</span><br><span class=\"line\"><span class=\"keyword\">from</span> bs4 <span class=\"keyword\">import</span> BeautifulSoup</span><br><span class=\"line\"><span class=\"keyword\">from</span> fake_useragent <span class=\"keyword\">import</span> UserAgent</span><br><span class=\"line\"><span class=\"keyword\">import</span> csv</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取网页数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_web_data</span><span class=\"params\">(url, headers, proxies=[])</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        data = requests.get(url, proxies=proxies, timeout=<span class=\"number\">3</span>, headers=headers)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> requests.exceptions.ConnectionError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        logging.error(<span class=\"string\">\"请求错误，url:\"</span>, url)</span><br><span class=\"line\">        logging.error(<span class=\"string\">\"错误详情：\"</span>, e)</span><br><span class=\"line\">        data = <span class=\"keyword\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        logging.error(<span class=\"string\">\"未知错误，url:\"</span>, url)</span><br><span class=\"line\">        data = <span class=\"keyword\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解析书籍数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_data</span><span class=\"params\">(data)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> data <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">    <span class=\"comment\"># 处理编码</span></span><br><span class=\"line\">    charset = chardet.detect(data.content)</span><br><span class=\"line\">    data.encoding = charset[<span class=\"string\">'encoding'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 正则表达式匹配作者出版社信息</span></span><br><span class=\"line\">    author_pattern = re.compile(<span class=\"string\">r'(作者: (.*))?[\\s|\\S]*出版社: (.*)[\\s|\\S]*出版年: (.*)'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 解析标签</span></span><br><span class=\"line\">    soup = BeautifulSoup(data.text, <span class=\"string\">'lxml'</span>)</span><br><span class=\"line\">    book_list = soup.find_all(<span class=\"string\">\"div\"</span>, class_=<span class=\"string\">\"bd doulist-subject\"</span>)</span><br><span class=\"line\">    list = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> book <span class=\"keyword\">in</span> book_list:</span><br><span class=\"line\">        book_map = &#123;&#125;</span><br><span class=\"line\">        book_name = book.find(<span class=\"string\">'div'</span>, class_=<span class=\"string\">'title'</span>).get_text().strip()</span><br><span class=\"line\">        book_map[<span class=\"string\">'book_name'</span>] = book_name</span><br><span class=\"line\"></span><br><span class=\"line\">        rate_point = book.find(<span class=\"string\">'div'</span>, class_=<span class=\"string\">'rating'</span>).find(<span class=\"string\">'span'</span>, class_=<span class=\"string\">'rating_nums'</span>).get_text().strip()</span><br><span class=\"line\">        book_map[<span class=\"string\">'rate_point'</span>] = rate_point</span><br><span class=\"line\"></span><br><span class=\"line\">        rate_number = book.find(<span class=\"string\">'div'</span>, class_=<span class=\"string\">'rating'</span>).find(<span class=\"string\">'span'</span>, class_=<span class=\"string\">''</span>).get_text().strip()[<span class=\"number\">1</span>:<span class=\"number\">-4</span>]</span><br><span class=\"line\">        book_map[<span class=\"string\">'rate_number'</span>] = rate_number</span><br><span class=\"line\"></span><br><span class=\"line\">        tmp = book.find(<span class=\"string\">'div'</span>, class_=<span class=\"string\">'abstract'</span>).get_text().strip()</span><br><span class=\"line\">        m = author_pattern.match(tmp)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> m <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            author = m.group(<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> author <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">                author = <span class=\"string\">''</span></span><br><span class=\"line\">            publisher = m.group(<span class=\"number\">3</span>)</span><br><span class=\"line\">            publish_date = m.group(<span class=\"number\">4</span>)</span><br><span class=\"line\">            book_map[<span class=\"string\">'author'</span>] = author</span><br><span class=\"line\">            book_map[<span class=\"string\">'publisher'</span>] = publisher</span><br><span class=\"line\">            book_map[<span class=\"string\">'publish_date'</span>] = publish_date</span><br><span class=\"line\"></span><br><span class=\"line\">        pic_link = book.find(<span class=\"string\">'div'</span>, class_=<span class=\"string\">'post'</span>).a.img[<span class=\"string\">'src'</span>]</span><br><span class=\"line\">        book_map[<span class=\"string\">'pic_link'</span>] = pic_link</span><br><span class=\"line\">        list.append(book_map)</span><br><span class=\"line\">        logging.info(<span class=\"string\">\"书名：《%s》，作者：%s，评分：%s，评分人数：%s，出版社：%s，出版年：%s，封面链接：%s\"</span>,</span><br><span class=\"line\">                     book_name, author, rate_point, rate_number, publisher, publish_date, pic_link)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 存入csv文件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">save_to_csv</span><span class=\"params\">(filename, books)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> open(filename, <span class=\"string\">'a'</span>, newline=<span class=\"string\">''</span>, encoding=<span class=\"string\">'utf-8'</span>) <span class=\"keyword\">as</span> file:</span><br><span class=\"line\">        writer = csv.DictWriter(file, fieldnames=books[<span class=\"number\">0</span>].keys())</span><br><span class=\"line\">        <span class=\"keyword\">for</span> tmp_book <span class=\"keyword\">in</span> books:</span><br><span class=\"line\">            writer.writerow(tmp_book)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取代理数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_proxies</span><span class=\"params\">(proxy_url, dis_url, page=<span class=\"number\">10</span>)</span>:</span></span><br><span class=\"line\">    proxy_list = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, page + <span class=\"number\">1</span>):</span><br><span class=\"line\">        tmp_ua = UserAgent()</span><br><span class=\"line\">        tmp_headers = &#123;<span class=\"string\">'User-Agent'</span>: tmp_ua.random&#125;</span><br><span class=\"line\">        html_str = get_web_data(proxy_url + str(i), tmp_headers)</span><br><span class=\"line\">        soup = BeautifulSoup(html_str.content, <span class=\"string\">\"lxml\"</span>)</span><br><span class=\"line\">        ips = soup.find(<span class=\"string\">'tbody'</span>).find_all(<span class=\"string\">'tr'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ip_info <span class=\"keyword\">in</span> ips:</span><br><span class=\"line\">            tds = ip_info.find_all(<span class=\"string\">'td'</span>)</span><br><span class=\"line\">            ip = tds[<span class=\"number\">0</span>].get_text()</span><br><span class=\"line\">            port = tds[<span class=\"number\">1</span>].get_text()</span><br><span class=\"line\">            ip_str = ip + <span class=\"string\">\":\"</span> + port</span><br><span class=\"line\">            tmp = &#123;<span class=\"string\">\"http\"</span>: <span class=\"string\">\"http://\"</span> + ip_str&#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> check_proxy(dis_url, tmp):</span><br><span class=\"line\">                logging.info(<span class=\"string\">\"ip:%s is available\"</span>, ip_str)</span><br><span class=\"line\">                proxy_list.append(ip_str)</span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> proxy_list</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检测代理ip是否可用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check_proxy</span><span class=\"params\">(url, proxy)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        tmp_ua = UserAgent()</span><br><span class=\"line\">        tmp_headers = &#123;<span class=\"string\">'User-Agent'</span>: tmp_ua.random&#125;</span><br><span class=\"line\">        res = requests.get(url, proxies=proxy, timeout=<span class=\"number\">1</span>, headers=tmp_headers)</span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_random_ip</span><span class=\"params\">(ip_list)</span>:</span></span><br><span class=\"line\">    proxy = random.choice(ip_list)</span><br><span class=\"line\">    proxies = &#123;<span class=\"string\">'http'</span>: <span class=\"string\">'http://'</span> + proxy&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> proxies</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    logging.basicConfig(level=logging.INFO)</span><br><span class=\"line\">    url = <span class=\"string\">'https://www.douban.com/doulist/1264675/?start='</span></span><br><span class=\"line\">    file_path = os.path.dirname(os.path.realpath(__file__)) + os.sep + <span class=\"string\">'douban.csv'</span></span><br><span class=\"line\">    f = open(file_path, <span class=\"string\">'w'</span>)</span><br><span class=\"line\">    f.close()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 获取代理</span></span><br><span class=\"line\">    proxies = get_proxies(<span class=\"string\">\"https://www.kuaidaili.com/free/intr/\"</span>, url, <span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 设置headers</span></span><br><span class=\"line\">    ua = UserAgent()</span><br><span class=\"line\"></span><br><span class=\"line\">    result_list = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">530</span>, <span class=\"number\">25</span>):</span><br><span class=\"line\">        headers = &#123;<span class=\"string\">'User-Agent'</span>: ua.random&#125;</span><br><span class=\"line\">        logging.info(<span class=\"string\">'headers:%s'</span>, headers)</span><br><span class=\"line\">        data = get_web_data(url + str(num), headers, get_random_ip(proxies))</span><br><span class=\"line\">        book = parse_data(data)</span><br><span class=\"line\">        save_to_csv(file_path, book)</span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<p>来运行一下：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/30/5cc802f79be50.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/30/5cc803435c659.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>最终爬下来的文件：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/30/5cc802e26a2d5.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>源码以及爬下来的数据都放到了github：<a href=\"https://github.com/MFrank2016/douban_spider\" target=\"_blank\" rel=\"noopener\">https://github.com/MFrank2016/douban_spider</a></p>\n<p>要运行该文件，除了需要安装import中的模块，还需要安装一个lxml模块才能运行。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>其实写爬虫的思路都是差不多的，大概分为几步：</p>\n<ol>\n<li>查找可用代理ip</li>\n<li>设置UA</li>\n<li>使用代理ip访问网页</li>\n<li>解析网页数据</li>\n<li>存储/分析</li>\n</ol>\n<p>这个爬虫还是比较简陋的，在获取代理并校验代理ip可用性这一步花了较多时间，优化的话，可以用多线程来进行代理ip可用性检测，得到一定数量的代理ip后，多线程进行网页访问和数据解析，然后再存储到数据库中。不过要使用多线程的话复杂度就会大大提升了，在这个小爬虫里，因为只需要爬22页数据，所以没有使用的必要。</p>\n<p>还有一个重要的问题就是这里没有对异常信息进行处理，运行中途如果出错就会导致前功尽弃，要考虑好大部分异常情况并不容易。</p>\n<p>当然，整个过程并没有上文描述的这样简单，调试过程还是花了不少时间，应该没有用过 BeautifulSoup 模块，摸索了不少时间才能初步使用它。</p>\n<p>作为python的初学者而言，用python最舒服的感受便是好用的模块确实多，用 BeautifulSoup 模块来进行网页解析确实比直接正则解析要方便的多，而且更容易控制。</p>\n<p>个人觉得爬虫只是用来获取数据的一个手段，用python也好，java也好，没有优劣之分，能实现想要的达成的目的即可，用什么语言顺手就用什么语言。将数据爬取下来后，便可以进行后续的数据分析，可视化等工作了。使用工具不是目的，只是手段，这一点我也是花了很长时间才慢慢理解。就像使用爬虫来获取数据来进行数据分析，从数据中挖掘想要的信息并用于指导实践才是真正产生价值的地方。作为技术人员，很容易产生的误区便是把技术当做一切，而不重视业务，殊不知真正创造价值的正是业务的制定者和执行者，技术最终都是为业务服务的。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/08/5c8255c88946b.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>本文到此就告一段落了，希望能对你有所帮助，也欢迎关注我的公众号进行留言交流。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a58ba229ca.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>五一将至，又到了学习的季节。目前流行的各大书单主打的都是豆瓣8.0评分书籍，却很少有人来聊聊这9.0评分的书籍长什么样子。刚好最近学了学python爬虫，那就拿豆瓣读书来练练手。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a580b1789e.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h2 id=\"爬虫\"><a href=\"#爬虫\" class=\"headerlink\" title=\"爬虫\"></a>爬虫</h2><p>本来思路是直接爬豆瓣的书籍目录，将评分9.0以上的书筛选出来，一打开发现事情并不简单，几千万本书可不好爬 = =，于是转化一下思路，看有没有类似的书单。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a5766a30bc.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>一搜还真有，找到一个9.0评分的榜单，大大减少了工作量，这样就不用先爬一下整站书籍来筛选了。看了看榜单，应该是某位好心的书友手工整理的，更新时间为2018-12-25，目前一共530本，分为22页，也就是说22次访问就能搞定了，不会给豆瓣的服务器造成压力。</p>\n<h3 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h3><p>目标URL：<a href=\"https://www.douban.com/doulist/1264675/?start=0&amp;sort=seq&amp;playable=0&amp;sub_type=4\" target=\"_blank\" rel=\"noopener\">https://www.douban.com/doulist/1264675/?start=0&amp;sort=seq&amp;playable=0&amp;sub_type=4</a></p>\n<p>数据量：530</p>\n<p>预计访问次数：22</p>\n<p>数据存储：csv</p>\n<p>抓取内容格式：书籍名称 作者 评分 评价人数 出版社 出版年 封面链接</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><p>有了小目标，接下来就是用刚学的 python 来现学现卖了。</p>\n<p>先来定一下步骤：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置headers</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取代理</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取网页数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解析书籍数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 存入csv文件</span></span><br></pre></td></tr></table></figure>\n<p>然后一步步来填坑即可，先来设置headers，主要是设置UA来绕过访问限制：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url = <span class=\"string\">'https://www.douban.com/doulist/1264675/?start=0&amp;sort=seq&amp;playable=0&amp;sub_type=4'</span></span><br><span class=\"line\"></span><br><span class=\"line\">logging.basicConfig(level=logging.DEBUG)</span><br><span class=\"line\"></span><br><span class=\"line\">ua = UserAgent()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置headers</span></span><br><span class=\"line\">headers = &#123;<span class=\"string\">'User-Agent'</span>: ua.random&#125;</span><br></pre></td></tr></table></figure>\n<p>当然，只设置UA也没法逃过访问限制，IP限制这一关还是存在的，所以需要使用代理来绕开。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a519711460.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>所以先来爬一爬代理的数据，弄一批能用的代理IP下来：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取代理数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_proxies</span><span class=\"params\">(proxy_url, dis_url, page=<span class=\"number\">10</span>)</span>:</span></span><br><span class=\"line\">    proxy_list = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, page + <span class=\"number\">1</span>):</span><br><span class=\"line\">        tmp_ua = UserAgent()</span><br><span class=\"line\">        tmp_headers = &#123;<span class=\"string\">'User-Agent'</span>: tmp_ua.random&#125;</span><br><span class=\"line\">        html_str = get_web_data(proxy_url + str(i), tmp_headers)</span><br><span class=\"line\">        soup = BeautifulSoup(html_str.content, <span class=\"string\">\"lxml\"</span>)</span><br><span class=\"line\">        ips = soup.find(<span class=\"string\">'tbody'</span>).find_all(<span class=\"string\">'tr'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ip_info <span class=\"keyword\">in</span> ips:</span><br><span class=\"line\">            tds = ip_info.find_all(<span class=\"string\">'td'</span>)</span><br><span class=\"line\">            ip = tds[<span class=\"number\">0</span>].get_text()</span><br><span class=\"line\">            port = tds[<span class=\"number\">1</span>].get_text()</span><br><span class=\"line\">            ip_str = ip + <span class=\"string\">\":\"</span> + port</span><br><span class=\"line\">            tmp = &#123;<span class=\"string\">\"http\"</span>: <span class=\"string\">\"http://\"</span> + ip_str&#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> check_proxy(dis_url, tmp):</span><br><span class=\"line\">                logging.info(<span class=\"string\">\"ip:%s is available\"</span>, ip_str)</span><br><span class=\"line\">                proxy_list.append(ip_str)</span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> proxy_list</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检测代理ip是否可用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check_proxy</span><span class=\"params\">(url, proxy)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        tmp_ua = UserAgent()</span><br><span class=\"line\">        tmp_headers = &#123;<span class=\"string\">'User-Agent'</span>: tmp_ua.random&#125;</span><br><span class=\"line\">        res = requests.get(url, proxies=proxy, timeout=<span class=\"number\">1</span>, headers=tmp_headers)</span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<p>这里其实有两个函数，一个是get_proxies函数，用来从代理页面爬数据，这里选用的是快代理，一个是check_proxy函数，用来检测该ip是否能访问目标页面，如果能访问，则将其添加到可用代理列表。</p>\n<p>然后是获取网页内容，这里使用requests模块来获取网页内容：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取网页数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_web_data</span><span class=\"params\">(url, headers, proxies=[])</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        data = requests.get(url, proxies=proxies, timeout=<span class=\"number\">3</span>, headers=headers)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> requests.exceptions.ConnectionError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        logging.error(<span class=\"string\">\"请求错误，url:\"</span>, url)</span><br><span class=\"line\">        logging.error(<span class=\"string\">\"错误详情：\"</span>, e)</span><br><span class=\"line\">        data = <span class=\"keyword\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        logging.error(<span class=\"string\">\"未知错误，url:\"</span>, url)</span><br><span class=\"line\">        data = <span class=\"keyword\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data</span><br></pre></td></tr></table></figure>\n<p>接下来进行网页内容解析，借助一下BeautifulSoup模块和re正则模块来解析网页元素。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 解析书籍数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_data</span><span class=\"params\">(data)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> data <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">    <span class=\"comment\"># 处理编码</span></span><br><span class=\"line\">    charset = chardet.detect(data.content)</span><br><span class=\"line\">    data.encoding = charset[<span class=\"string\">'encoding'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 正则表达式匹配作者出版社信息</span></span><br><span class=\"line\">    author_pattern = re.compile(<span class=\"string\">r'(作者: (.*))?[\\s|\\S]*出版社: (.*)[\\s|\\S]*出版年: (.*)'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 解析标签</span></span><br><span class=\"line\">    soup = BeautifulSoup(data.text, <span class=\"string\">'lxml'</span>)</span><br><span class=\"line\">    book_list = soup.find_all(<span class=\"string\">\"div\"</span>, class_=<span class=\"string\">\"bd doulist-subject\"</span>)</span><br><span class=\"line\">    list = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> book <span class=\"keyword\">in</span> book_list:</span><br><span class=\"line\">        book_map = &#123;&#125;</span><br><span class=\"line\">        book_name = book.find(<span class=\"string\">'div'</span>, class_=<span class=\"string\">'title'</span>).get_text().strip()</span><br><span class=\"line\">        book_map[<span class=\"string\">'book_name'</span>] = book_name</span><br><span class=\"line\"></span><br><span class=\"line\">        rate_point = book.find(<span class=\"string\">'div'</span>, class_=<span class=\"string\">'rating'</span>).find(<span class=\"string\">'span'</span>, class_=<span class=\"string\">'rating_nums'</span>).get_text().strip()</span><br><span class=\"line\">        book_map[<span class=\"string\">'rate_point'</span>] = rate_point</span><br><span class=\"line\"></span><br><span class=\"line\">        rate_number = book.find(<span class=\"string\">'div'</span>, class_=<span class=\"string\">'rating'</span>).find(<span class=\"string\">'span'</span>, class_=<span class=\"string\">''</span>).get_text().strip()[<span class=\"number\">1</span>:<span class=\"number\">-4</span>]</span><br><span class=\"line\">        book_map[<span class=\"string\">'rate_number'</span>] = rate_number</span><br><span class=\"line\"></span><br><span class=\"line\">        tmp = book.find(<span class=\"string\">'div'</span>, class_=<span class=\"string\">'abstract'</span>).get_text().strip()</span><br><span class=\"line\">        m = author_pattern.match(tmp)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> m != <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            author = m.group(<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> author == <span class=\"keyword\">None</span>:</span><br><span class=\"line\">                author = <span class=\"string\">''</span></span><br><span class=\"line\">            publisher = m.group(<span class=\"number\">3</span>)</span><br><span class=\"line\">            publish_date = m.group(<span class=\"number\">4</span>)</span><br><span class=\"line\">            book_map[<span class=\"string\">'author'</span>] = author</span><br><span class=\"line\">            book_map[<span class=\"string\">'publisher'</span>] = publisher</span><br><span class=\"line\">            book_map[<span class=\"string\">'publish_date'</span>] = publish_date</span><br><span class=\"line\"></span><br><span class=\"line\">        pic_link = book.find(<span class=\"string\">'div'</span>, class_=<span class=\"string\">'post'</span>).a.img[<span class=\"string\">'src'</span>]</span><br><span class=\"line\">        book_map[<span class=\"string\">'pic_link'</span>] = pic_link</span><br><span class=\"line\">        list.append(book_map)</span><br><span class=\"line\">        logging.info(<span class=\"string\">\"书名：《%s》，作者：%s，评分：%s，评分人数：%s，出版社：%s，出版年：%s，封面链接：%s\"</span>,</span><br><span class=\"line\">                     book_name, author, rate_point, rate_number, publisher, publish_date, pic_link)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list</span><br></pre></td></tr></table></figure>\n<p>然后将结果存入csv文件中：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 存入csv文件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">save_to_csv</span><span class=\"params\">(filename, books)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> open(filename, <span class=\"string\">'a'</span>, newline=<span class=\"string\">''</span>, encoding=<span class=\"string\">'utf-8'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        writer = csv.DictWriter(f, fieldnames=books[<span class=\"number\">0</span>].keys())</span><br><span class=\"line\">        <span class=\"keyword\">for</span> book <span class=\"keyword\">in</span> books:</span><br><span class=\"line\">            writer.writerow(book)</span><br><span class=\"line\">        f.close()</span><br></pre></td></tr></table></figure>\n<p>这样，我们整体的代码就差不多成型了，全部代码如下：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">auth: Frank</span></span><br><span class=\"line\"><span class=\"string\">date: 2019-04-27</span></span><br><span class=\"line\"><span class=\"string\">desc: 爬取豆瓣读书评分9.0以上书籍并存入csv文件</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">目标URL：https://www.douban.com/doulist/1264675/?start=0&amp;sort=seq&amp;playable=0&amp;sub_type=4</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">数据量：530</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">预计访问次数：22</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">数据存储：csv</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">抓取内容格式：书籍名称 作者 作者国籍 评分 评价人数 出版社 出版年 封面链接</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib.robotparser</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"keyword\">import</span> chardet</span><br><span class=\"line\"><span class=\"keyword\">from</span> bs4 <span class=\"keyword\">import</span> BeautifulSoup</span><br><span class=\"line\"><span class=\"keyword\">from</span> fake_useragent <span class=\"keyword\">import</span> UserAgent</span><br><span class=\"line\"><span class=\"keyword\">import</span> csv</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取网页数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_web_data</span><span class=\"params\">(url, headers, proxies=[])</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        data = requests.get(url, proxies=proxies, timeout=<span class=\"number\">3</span>, headers=headers)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> requests.exceptions.ConnectionError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        logging.error(<span class=\"string\">\"请求错误，url:\"</span>, url)</span><br><span class=\"line\">        logging.error(<span class=\"string\">\"错误详情：\"</span>, e)</span><br><span class=\"line\">        data = <span class=\"keyword\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        logging.error(<span class=\"string\">\"未知错误，url:\"</span>, url)</span><br><span class=\"line\">        data = <span class=\"keyword\">None</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解析书籍数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_data</span><span class=\"params\">(data)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> data <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">    <span class=\"comment\"># 处理编码</span></span><br><span class=\"line\">    charset = chardet.detect(data.content)</span><br><span class=\"line\">    data.encoding = charset[<span class=\"string\">'encoding'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 正则表达式匹配作者出版社信息</span></span><br><span class=\"line\">    author_pattern = re.compile(<span class=\"string\">r'(作者: (.*))?[\\s|\\S]*出版社: (.*)[\\s|\\S]*出版年: (.*)'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 解析标签</span></span><br><span class=\"line\">    soup = BeautifulSoup(data.text, <span class=\"string\">'lxml'</span>)</span><br><span class=\"line\">    book_list = soup.find_all(<span class=\"string\">\"div\"</span>, class_=<span class=\"string\">\"bd doulist-subject\"</span>)</span><br><span class=\"line\">    list = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> book <span class=\"keyword\">in</span> book_list:</span><br><span class=\"line\">        book_map = &#123;&#125;</span><br><span class=\"line\">        book_name = book.find(<span class=\"string\">'div'</span>, class_=<span class=\"string\">'title'</span>).get_text().strip()</span><br><span class=\"line\">        book_map[<span class=\"string\">'book_name'</span>] = book_name</span><br><span class=\"line\"></span><br><span class=\"line\">        rate_point = book.find(<span class=\"string\">'div'</span>, class_=<span class=\"string\">'rating'</span>).find(<span class=\"string\">'span'</span>, class_=<span class=\"string\">'rating_nums'</span>).get_text().strip()</span><br><span class=\"line\">        book_map[<span class=\"string\">'rate_point'</span>] = rate_point</span><br><span class=\"line\"></span><br><span class=\"line\">        rate_number = book.find(<span class=\"string\">'div'</span>, class_=<span class=\"string\">'rating'</span>).find(<span class=\"string\">'span'</span>, class_=<span class=\"string\">''</span>).get_text().strip()[<span class=\"number\">1</span>:<span class=\"number\">-4</span>]</span><br><span class=\"line\">        book_map[<span class=\"string\">'rate_number'</span>] = rate_number</span><br><span class=\"line\"></span><br><span class=\"line\">        tmp = book.find(<span class=\"string\">'div'</span>, class_=<span class=\"string\">'abstract'</span>).get_text().strip()</span><br><span class=\"line\">        m = author_pattern.match(tmp)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> m <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            author = m.group(<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> author <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">                author = <span class=\"string\">''</span></span><br><span class=\"line\">            publisher = m.group(<span class=\"number\">3</span>)</span><br><span class=\"line\">            publish_date = m.group(<span class=\"number\">4</span>)</span><br><span class=\"line\">            book_map[<span class=\"string\">'author'</span>] = author</span><br><span class=\"line\">            book_map[<span class=\"string\">'publisher'</span>] = publisher</span><br><span class=\"line\">            book_map[<span class=\"string\">'publish_date'</span>] = publish_date</span><br><span class=\"line\"></span><br><span class=\"line\">        pic_link = book.find(<span class=\"string\">'div'</span>, class_=<span class=\"string\">'post'</span>).a.img[<span class=\"string\">'src'</span>]</span><br><span class=\"line\">        book_map[<span class=\"string\">'pic_link'</span>] = pic_link</span><br><span class=\"line\">        list.append(book_map)</span><br><span class=\"line\">        logging.info(<span class=\"string\">\"书名：《%s》，作者：%s，评分：%s，评分人数：%s，出版社：%s，出版年：%s，封面链接：%s\"</span>,</span><br><span class=\"line\">                     book_name, author, rate_point, rate_number, publisher, publish_date, pic_link)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 存入csv文件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">save_to_csv</span><span class=\"params\">(filename, books)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> open(filename, <span class=\"string\">'a'</span>, newline=<span class=\"string\">''</span>, encoding=<span class=\"string\">'utf-8'</span>) <span class=\"keyword\">as</span> file:</span><br><span class=\"line\">        writer = csv.DictWriter(file, fieldnames=books[<span class=\"number\">0</span>].keys())</span><br><span class=\"line\">        <span class=\"keyword\">for</span> tmp_book <span class=\"keyword\">in</span> books:</span><br><span class=\"line\">            writer.writerow(tmp_book)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取代理数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_proxies</span><span class=\"params\">(proxy_url, dis_url, page=<span class=\"number\">10</span>)</span>:</span></span><br><span class=\"line\">    proxy_list = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, page + <span class=\"number\">1</span>):</span><br><span class=\"line\">        tmp_ua = UserAgent()</span><br><span class=\"line\">        tmp_headers = &#123;<span class=\"string\">'User-Agent'</span>: tmp_ua.random&#125;</span><br><span class=\"line\">        html_str = get_web_data(proxy_url + str(i), tmp_headers)</span><br><span class=\"line\">        soup = BeautifulSoup(html_str.content, <span class=\"string\">\"lxml\"</span>)</span><br><span class=\"line\">        ips = soup.find(<span class=\"string\">'tbody'</span>).find_all(<span class=\"string\">'tr'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ip_info <span class=\"keyword\">in</span> ips:</span><br><span class=\"line\">            tds = ip_info.find_all(<span class=\"string\">'td'</span>)</span><br><span class=\"line\">            ip = tds[<span class=\"number\">0</span>].get_text()</span><br><span class=\"line\">            port = tds[<span class=\"number\">1</span>].get_text()</span><br><span class=\"line\">            ip_str = ip + <span class=\"string\">\":\"</span> + port</span><br><span class=\"line\">            tmp = &#123;<span class=\"string\">\"http\"</span>: <span class=\"string\">\"http://\"</span> + ip_str&#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> check_proxy(dis_url, tmp):</span><br><span class=\"line\">                logging.info(<span class=\"string\">\"ip:%s is available\"</span>, ip_str)</span><br><span class=\"line\">                proxy_list.append(ip_str)</span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> proxy_list</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检测代理ip是否可用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check_proxy</span><span class=\"params\">(url, proxy)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        tmp_ua = UserAgent()</span><br><span class=\"line\">        tmp_headers = &#123;<span class=\"string\">'User-Agent'</span>: tmp_ua.random&#125;</span><br><span class=\"line\">        res = requests.get(url, proxies=proxy, timeout=<span class=\"number\">1</span>, headers=tmp_headers)</span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_random_ip</span><span class=\"params\">(ip_list)</span>:</span></span><br><span class=\"line\">    proxy = random.choice(ip_list)</span><br><span class=\"line\">    proxies = &#123;<span class=\"string\">'http'</span>: <span class=\"string\">'http://'</span> + proxy&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> proxies</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    logging.basicConfig(level=logging.INFO)</span><br><span class=\"line\">    url = <span class=\"string\">'https://www.douban.com/doulist/1264675/?start='</span></span><br><span class=\"line\">    file_path = os.path.dirname(os.path.realpath(__file__)) + os.sep + <span class=\"string\">'douban.csv'</span></span><br><span class=\"line\">    f = open(file_path, <span class=\"string\">'w'</span>)</span><br><span class=\"line\">    f.close()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 获取代理</span></span><br><span class=\"line\">    proxies = get_proxies(<span class=\"string\">\"https://www.kuaidaili.com/free/intr/\"</span>, url, <span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 设置headers</span></span><br><span class=\"line\">    ua = UserAgent()</span><br><span class=\"line\"></span><br><span class=\"line\">    result_list = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, <span class=\"number\">530</span>, <span class=\"number\">25</span>):</span><br><span class=\"line\">        headers = &#123;<span class=\"string\">'User-Agent'</span>: ua.random&#125;</span><br><span class=\"line\">        logging.info(<span class=\"string\">'headers:%s'</span>, headers)</span><br><span class=\"line\">        data = get_web_data(url + str(num), headers, get_random_ip(proxies))</span><br><span class=\"line\">        book = parse_data(data)</span><br><span class=\"line\">        save_to_csv(file_path, book)</span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<p>来运行一下：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/30/5cc802f79be50.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/30/5cc803435c659.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>最终爬下来的文件：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/30/5cc802e26a2d5.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>源码以及爬下来的数据都放到了github：<a href=\"https://github.com/MFrank2016/douban_spider\" target=\"_blank\" rel=\"noopener\">https://github.com/MFrank2016/douban_spider</a></p>\n<p>要运行该文件，除了需要安装import中的模块，还需要安装一个lxml模块才能运行。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>其实写爬虫的思路都是差不多的，大概分为几步：</p>\n<ol>\n<li>查找可用代理ip</li>\n<li>设置UA</li>\n<li>使用代理ip访问网页</li>\n<li>解析网页数据</li>\n<li>存储/分析</li>\n</ol>\n<p>这个爬虫还是比较简陋的，在获取代理并校验代理ip可用性这一步花了较多时间，优化的话，可以用多线程来进行代理ip可用性检测，得到一定数量的代理ip后，多线程进行网页访问和数据解析，然后再存储到数据库中。不过要使用多线程的话复杂度就会大大提升了，在这个小爬虫里，因为只需要爬22页数据，所以没有使用的必要。</p>\n<p>还有一个重要的问题就是这里没有对异常信息进行处理，运行中途如果出错就会导致前功尽弃，要考虑好大部分异常情况并不容易。</p>\n<p>当然，整个过程并没有上文描述的这样简单，调试过程还是花了不少时间，应该没有用过 BeautifulSoup 模块，摸索了不少时间才能初步使用它。</p>\n<p>作为python的初学者而言，用python最舒服的感受便是好用的模块确实多，用 BeautifulSoup 模块来进行网页解析确实比直接正则解析要方便的多，而且更容易控制。</p>\n<p>个人觉得爬虫只是用来获取数据的一个手段，用python也好，java也好，没有优劣之分，能实现想要的达成的目的即可，用什么语言顺手就用什么语言。将数据爬取下来后，便可以进行后续的数据分析，可视化等工作了。使用工具不是目的，只是手段，这一点我也是花了很长时间才慢慢理解。就像使用爬虫来获取数据来进行数据分析，从数据中挖掘想要的信息并用于指导实践才是真正产生价值的地方。作为技术人员，很容易产生的误区便是把技术当做一切，而不重视业务，殊不知真正创造价值的正是业务的制定者和执行者，技术最终都是为业务服务的。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/08/5c8255c88946b.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>本文到此就告一段落了，希望能对你有所帮助，也欢迎关注我的公众号进行留言交流。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a58ba229ca.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>"},{"title":"【Spring源码解读】bean标签中的属性（二）abstract 属性和 parent 属性","date":"2019-04-22T13:08:55.000Z","categorys":["Spring"],"_content":"\n## abstract 属性说明\n\n`abstract` 在java的语义里是代表抽象的意思，用来说明被修饰的类是抽象类。在Spring中bean标签里的 `abstract` 的含义其实也差不多，表示当前bean是一个抽象的bean，从而不会为它生成实例化对象。\n\n声明一个bean，但是又不让它实例化？？？\n\n![](https://i.loli.net/2019/03/14/5c89ad2f033c1.png)\n\n莫方，存在即合理，`abstract` 属性存在必定有其存在的意义，且听我慢慢道来。\n\n## parent 属性说明\n\n在此之前，我们先说一下另一个属性： `parent` ，顾名思义，就是一个认爸爸的属性，用来表明当前的bean的老爸是谁，这样就能顺利的继承它的遗产。。。emmm，说错了，继承它的属性。就像这样：\n\n```xml\n<bean id=\"abstractBean\" class=\"com.frank.spring.bean.parent.ParentBean\" abstract=\"true\">\n    <property name=\"name\" value=\"Frank\" />\n    <property name=\"age\" value=\"18\" />\n</bean>\n\n<bean id=\"childBean\" class=\"com.frank.spring.bean.parent.ChildBean\" parent=\"abstractBean\">\n    <property name=\"name\" value=\"son\"/>\n    <property name=\"height\" value=\"180\"/>\n</bean>\n```\n\n这样我们就有了一个父bean和一个子bean，在`childBean`中，我们只设置了name和height属性，但由于在xml文件中，通过`parent`属性给它安排了一个老爸是`abstractBean`，所以默认会继承它的age属性的值，也就是18。在子bean中，可以覆盖父bean中的属性，比如这里的name，在childBean中就重新设置了值。\n\n![](https://i.loli.net/2019/04/22/5cbdbe8bb22cd.png)\n\n来测试一下：\n\n```java\n@Test\npublic void testAbstract() {\n    ApplicationContext context = new ClassPathXmlApplicationContext(\"test-bean.xml\");\n    ChildBean childBean = (ChildBean) context.getBean(\"childBean\");\n    Assert.assertEquals(childBean.getName(), \"son\");\n    Assert.assertEquals(childBean.getAge(), Integer.valueOf(18));\n    Assert.assertEquals(childBean.getHeight(), Integer.valueOf(180));\n}\n```\n\n以下是ParentBean和ChildBean的定义：\n\n```java\npublic class ParentBean {\n    private String name;\n    private Integer age;\n\n    //省略getter和setter方法\n}\n\npublic class ChildBean {\n    private String name;\n    private Integer age;\n    private Integer height;\n\n    //省略getter和setter方法\n}\n```\n\n聪明的你一定发现了，这两个类并不一定要有实际的继承关系，可以是两个普通的类。甚至，`parent`属性所指向的bean可以不用设置某个具体的类，而只设置它是属性，就像这样：\n\n```xml\n<bean id=\"abstractParent\" abstract=\"true\">\n    <property name=\"name\" value=\"Frank\" />\n    <property name=\"age\" value=\"18\" />\n</bean>\n\n<bean id=\"testChild\" class=\"com.frank.spring.bean.parent.ChildBean\" parent=\"abstractParent\">\n    <property name=\"name\" value=\"son\"/>\n    <property name=\"height\" value=\"180\"/>\n</bean>\n```\n\n```java\n@Test\npublic void testAbstractParent() {\n    ApplicationContext context = new ClassPathXmlApplicationContext(\"test-bean.xml\");\n    ChildBean childBean = (ChildBean) context.getBean(\"testChild\");\n    Assert.assertEquals(childBean.getName(), \"son\");\n    Assert.assertEquals(childBean.getAge(), Integer.valueOf(18));\n    Assert.assertEquals(childBean.getHeight(), Integer.valueOf(180));\n}\n```\n\n可以看到这次我们设置的`abstractParent`并没有为其指定类名，我们也能将它做为`parent`属性的值。\n\n## abstract 属性的作用\n\n在Spring中， `abstract` 属性一般是用来声明抽象bean，将一些公共的属性放到一块，这样就能减少重复的代码。所以在标签中，可以这样设置：\n\n```xml\n<bean id=\"abstractBean\" class=\"com.frank.spring.bean.parent.ParentBean\" abstract=\"true\">\n    <property name=\"name\" value=\"Frank\" />\n    <property name=\"age\" value=\"18\" />\n</bean>\n\n<bean id=\"childA\" class=\"com.frank.spring.bean.parent.ChildBean\" parent=\"abstractBean\">\n    <property name=\"name\" value=\"GG\"/>\n    <property name=\"height\" value=\"180\"/>\n</bean>\n\n<bean id=\"childB\" class=\"com.frank.spring.bean.parent.ChildBean\" parent=\"abstractBean\">\n    <property name=\"name\" value=\"DD\"/>\n    <property name=\"height\" value=\"185\"/>\n</bean>\n```\n\n这样，`abstractBean`就起到了一个模板的作用，可以减少重复定义，这里只有简单的几个属性，所以可能看起来不是很直观，可以想象一下，如果abstractBean中有一二十个公用属性，是不是可以少写不少代码呢？\n\n## 总结\n\n`abstract` 和 `parent` 属性可以当做用来减少xml重复代码的方法，可以将一些bean的公共属性抽取出来，放到一个公共的bean中，然后使用上面的栗子进行配置，来让xml文件更加简洁。\n\n值得注意的是，`parent`属性配置的bean之间，并不一定需要有实际的继承关系，更多的是属性的继承。被设置为`parent`的bean甚至可以不用映射到某一个具体的类，而仅仅将其当做属性模板来使用。\n\n文章持续更新中，欢迎关注我的公众号留言交流。\n\n![](https://i.loli.net/2019/03/14/5c8a58ba229ca.png)","source":"_posts/java/spring/source-code-analysis/spring-bean-attribute-abstract.md","raw":"---\ntitle: 【Spring源码解读】bean标签中的属性（二）abstract 属性和 parent 属性\ndate: 2019-04-22 21:08:55\ntags:\n- Spring\n- 源码解读\ncategorys:\n- Spring\n---\n\n## abstract 属性说明\n\n`abstract` 在java的语义里是代表抽象的意思，用来说明被修饰的类是抽象类。在Spring中bean标签里的 `abstract` 的含义其实也差不多，表示当前bean是一个抽象的bean，从而不会为它生成实例化对象。\n\n声明一个bean，但是又不让它实例化？？？\n\n![](https://i.loli.net/2019/03/14/5c89ad2f033c1.png)\n\n莫方，存在即合理，`abstract` 属性存在必定有其存在的意义，且听我慢慢道来。\n\n## parent 属性说明\n\n在此之前，我们先说一下另一个属性： `parent` ，顾名思义，就是一个认爸爸的属性，用来表明当前的bean的老爸是谁，这样就能顺利的继承它的遗产。。。emmm，说错了，继承它的属性。就像这样：\n\n```xml\n<bean id=\"abstractBean\" class=\"com.frank.spring.bean.parent.ParentBean\" abstract=\"true\">\n    <property name=\"name\" value=\"Frank\" />\n    <property name=\"age\" value=\"18\" />\n</bean>\n\n<bean id=\"childBean\" class=\"com.frank.spring.bean.parent.ChildBean\" parent=\"abstractBean\">\n    <property name=\"name\" value=\"son\"/>\n    <property name=\"height\" value=\"180\"/>\n</bean>\n```\n\n这样我们就有了一个父bean和一个子bean，在`childBean`中，我们只设置了name和height属性，但由于在xml文件中，通过`parent`属性给它安排了一个老爸是`abstractBean`，所以默认会继承它的age属性的值，也就是18。在子bean中，可以覆盖父bean中的属性，比如这里的name，在childBean中就重新设置了值。\n\n![](https://i.loli.net/2019/04/22/5cbdbe8bb22cd.png)\n\n来测试一下：\n\n```java\n@Test\npublic void testAbstract() {\n    ApplicationContext context = new ClassPathXmlApplicationContext(\"test-bean.xml\");\n    ChildBean childBean = (ChildBean) context.getBean(\"childBean\");\n    Assert.assertEquals(childBean.getName(), \"son\");\n    Assert.assertEquals(childBean.getAge(), Integer.valueOf(18));\n    Assert.assertEquals(childBean.getHeight(), Integer.valueOf(180));\n}\n```\n\n以下是ParentBean和ChildBean的定义：\n\n```java\npublic class ParentBean {\n    private String name;\n    private Integer age;\n\n    //省略getter和setter方法\n}\n\npublic class ChildBean {\n    private String name;\n    private Integer age;\n    private Integer height;\n\n    //省略getter和setter方法\n}\n```\n\n聪明的你一定发现了，这两个类并不一定要有实际的继承关系，可以是两个普通的类。甚至，`parent`属性所指向的bean可以不用设置某个具体的类，而只设置它是属性，就像这样：\n\n```xml\n<bean id=\"abstractParent\" abstract=\"true\">\n    <property name=\"name\" value=\"Frank\" />\n    <property name=\"age\" value=\"18\" />\n</bean>\n\n<bean id=\"testChild\" class=\"com.frank.spring.bean.parent.ChildBean\" parent=\"abstractParent\">\n    <property name=\"name\" value=\"son\"/>\n    <property name=\"height\" value=\"180\"/>\n</bean>\n```\n\n```java\n@Test\npublic void testAbstractParent() {\n    ApplicationContext context = new ClassPathXmlApplicationContext(\"test-bean.xml\");\n    ChildBean childBean = (ChildBean) context.getBean(\"testChild\");\n    Assert.assertEquals(childBean.getName(), \"son\");\n    Assert.assertEquals(childBean.getAge(), Integer.valueOf(18));\n    Assert.assertEquals(childBean.getHeight(), Integer.valueOf(180));\n}\n```\n\n可以看到这次我们设置的`abstractParent`并没有为其指定类名，我们也能将它做为`parent`属性的值。\n\n## abstract 属性的作用\n\n在Spring中， `abstract` 属性一般是用来声明抽象bean，将一些公共的属性放到一块，这样就能减少重复的代码。所以在标签中，可以这样设置：\n\n```xml\n<bean id=\"abstractBean\" class=\"com.frank.spring.bean.parent.ParentBean\" abstract=\"true\">\n    <property name=\"name\" value=\"Frank\" />\n    <property name=\"age\" value=\"18\" />\n</bean>\n\n<bean id=\"childA\" class=\"com.frank.spring.bean.parent.ChildBean\" parent=\"abstractBean\">\n    <property name=\"name\" value=\"GG\"/>\n    <property name=\"height\" value=\"180\"/>\n</bean>\n\n<bean id=\"childB\" class=\"com.frank.spring.bean.parent.ChildBean\" parent=\"abstractBean\">\n    <property name=\"name\" value=\"DD\"/>\n    <property name=\"height\" value=\"185\"/>\n</bean>\n```\n\n这样，`abstractBean`就起到了一个模板的作用，可以减少重复定义，这里只有简单的几个属性，所以可能看起来不是很直观，可以想象一下，如果abstractBean中有一二十个公用属性，是不是可以少写不少代码呢？\n\n## 总结\n\n`abstract` 和 `parent` 属性可以当做用来减少xml重复代码的方法，可以将一些bean的公共属性抽取出来，放到一个公共的bean中，然后使用上面的栗子进行配置，来让xml文件更加简洁。\n\n值得注意的是，`parent`属性配置的bean之间，并不一定需要有实际的继承关系，更多的是属性的继承。被设置为`parent`的bean甚至可以不用映射到某一个具体的类，而仅仅将其当做属性模板来使用。\n\n文章持续更新中，欢迎关注我的公众号留言交流。\n\n![](https://i.loli.net/2019/03/14/5c8a58ba229ca.png)","slug":"java/spring/source-code-analysis/spring-bean-attribute-abstract","published":1,"updated":"2019-06-04T01:29:57.416Z","_id":"cjxze3h0g00810cvwbwcrrdjh","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"abstract-属性说明\"><a href=\"#abstract-属性说明\" class=\"headerlink\" title=\"abstract 属性说明\"></a>abstract 属性说明</h2><p><code>abstract</code> 在java的语义里是代表抽象的意思，用来说明被修饰的类是抽象类。在Spring中bean标签里的 <code>abstract</code> 的含义其实也差不多，表示当前bean是一个抽象的bean，从而不会为它生成实例化对象。</p>\n<p>声明一个bean，但是又不让它实例化？？？</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c89ad2f033c1.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>莫方，存在即合理，<code>abstract</code> 属性存在必定有其存在的意义，且听我慢慢道来。</p>\n<h2 id=\"parent-属性说明\"><a href=\"#parent-属性说明\" class=\"headerlink\" title=\"parent 属性说明\"></a>parent 属性说明</h2><p>在此之前，我们先说一下另一个属性： <code>parent</code> ，顾名思义，就是一个认爸爸的属性，用来表明当前的bean的老爸是谁，这样就能顺利的继承它的遗产。。。emmm，说错了，继承它的属性。就像这样：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"abstractBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.frank.spring.bean.parent.ParentBean\"</span> <span class=\"attr\">abstract</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Frank\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"age\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"18\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"childBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.frank.spring.bean.parent.ChildBean\"</span> <span class=\"attr\">parent</span>=<span class=\"string\">\"abstractBean\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"son\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"height\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"180\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这样我们就有了一个父bean和一个子bean，在<code>childBean</code>中，我们只设置了name和height属性，但由于在xml文件中，通过<code>parent</code>属性给它安排了一个老爸是<code>abstractBean</code>，所以默认会继承它的age属性的值，也就是18。在子bean中，可以覆盖父bean中的属性，比如这里的name，在childBean中就重新设置了值。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/22/5cbdbe8bb22cd.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>来测试一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testAbstract</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ApplicationContext context = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"test-bean.xml\"</span>);</span><br><span class=\"line\">    ChildBean childBean = (ChildBean) context.getBean(<span class=\"string\">\"childBean\"</span>);</span><br><span class=\"line\">    Assert.assertEquals(childBean.getName(), <span class=\"string\">\"son\"</span>);</span><br><span class=\"line\">    Assert.assertEquals(childBean.getAge(), Integer.valueOf(<span class=\"number\">18</span>));</span><br><span class=\"line\">    Assert.assertEquals(childBean.getHeight(), Integer.valueOf(<span class=\"number\">180</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以下是ParentBean和ChildBean的定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParentBean</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//省略getter和setter方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChildBean</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer height;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//省略getter和setter方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>聪明的你一定发现了，这两个类并不一定要有实际的继承关系，可以是两个普通的类。甚至，<code>parent</code>属性所指向的bean可以不用设置某个具体的类，而只设置它是属性，就像这样：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"abstractParent\"</span> <span class=\"attr\">abstract</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Frank\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"age\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"18\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testChild\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.frank.spring.bean.parent.ChildBean\"</span> <span class=\"attr\">parent</span>=<span class=\"string\">\"abstractParent\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"son\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"height\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"180\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testAbstractParent</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ApplicationContext context = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"test-bean.xml\"</span>);</span><br><span class=\"line\">    ChildBean childBean = (ChildBean) context.getBean(<span class=\"string\">\"testChild\"</span>);</span><br><span class=\"line\">    Assert.assertEquals(childBean.getName(), <span class=\"string\">\"son\"</span>);</span><br><span class=\"line\">    Assert.assertEquals(childBean.getAge(), Integer.valueOf(<span class=\"number\">18</span>));</span><br><span class=\"line\">    Assert.assertEquals(childBean.getHeight(), Integer.valueOf(<span class=\"number\">180</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到这次我们设置的<code>abstractParent</code>并没有为其指定类名，我们也能将它做为<code>parent</code>属性的值。</p>\n<h2 id=\"abstract-属性的作用\"><a href=\"#abstract-属性的作用\" class=\"headerlink\" title=\"abstract 属性的作用\"></a>abstract 属性的作用</h2><p>在Spring中， <code>abstract</code> 属性一般是用来声明抽象bean，将一些公共的属性放到一块，这样就能减少重复的代码。所以在标签中，可以这样设置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"abstractBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.frank.spring.bean.parent.ParentBean\"</span> <span class=\"attr\">abstract</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Frank\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"age\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"18\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"childA\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.frank.spring.bean.parent.ChildBean\"</span> <span class=\"attr\">parent</span>=<span class=\"string\">\"abstractBean\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"GG\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"height\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"180\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"childB\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.frank.spring.bean.parent.ChildBean\"</span> <span class=\"attr\">parent</span>=<span class=\"string\">\"abstractBean\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"DD\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"height\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"185\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这样，<code>abstractBean</code>就起到了一个模板的作用，可以减少重复定义，这里只有简单的几个属性，所以可能看起来不是很直观，可以想象一下，如果abstractBean中有一二十个公用属性，是不是可以少写不少代码呢？</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><code>abstract</code> 和 <code>parent</code> 属性可以当做用来减少xml重复代码的方法，可以将一些bean的公共属性抽取出来，放到一个公共的bean中，然后使用上面的栗子进行配置，来让xml文件更加简洁。</p>\n<p>值得注意的是，<code>parent</code>属性配置的bean之间，并不一定需要有实际的继承关系，更多的是属性的继承。被设置为<code>parent</code>的bean甚至可以不用映射到某一个具体的类，而仅仅将其当做属性模板来使用。</p>\n<p>文章持续更新中，欢迎关注我的公众号留言交流。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a58ba229ca.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"abstract-属性说明\"><a href=\"#abstract-属性说明\" class=\"headerlink\" title=\"abstract 属性说明\"></a>abstract 属性说明</h2><p><code>abstract</code> 在java的语义里是代表抽象的意思，用来说明被修饰的类是抽象类。在Spring中bean标签里的 <code>abstract</code> 的含义其实也差不多，表示当前bean是一个抽象的bean，从而不会为它生成实例化对象。</p>\n<p>声明一个bean，但是又不让它实例化？？？</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c89ad2f033c1.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>莫方，存在即合理，<code>abstract</code> 属性存在必定有其存在的意义，且听我慢慢道来。</p>\n<h2 id=\"parent-属性说明\"><a href=\"#parent-属性说明\" class=\"headerlink\" title=\"parent 属性说明\"></a>parent 属性说明</h2><p>在此之前，我们先说一下另一个属性： <code>parent</code> ，顾名思义，就是一个认爸爸的属性，用来表明当前的bean的老爸是谁，这样就能顺利的继承它的遗产。。。emmm，说错了，继承它的属性。就像这样：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"abstractBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.frank.spring.bean.parent.ParentBean\"</span> <span class=\"attr\">abstract</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Frank\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"age\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"18\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"childBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.frank.spring.bean.parent.ChildBean\"</span> <span class=\"attr\">parent</span>=<span class=\"string\">\"abstractBean\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"son\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"height\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"180\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这样我们就有了一个父bean和一个子bean，在<code>childBean</code>中，我们只设置了name和height属性，但由于在xml文件中，通过<code>parent</code>属性给它安排了一个老爸是<code>abstractBean</code>，所以默认会继承它的age属性的值，也就是18。在子bean中，可以覆盖父bean中的属性，比如这里的name，在childBean中就重新设置了值。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/04/22/5cbdbe8bb22cd.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>来测试一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testAbstract</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ApplicationContext context = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"test-bean.xml\"</span>);</span><br><span class=\"line\">    ChildBean childBean = (ChildBean) context.getBean(<span class=\"string\">\"childBean\"</span>);</span><br><span class=\"line\">    Assert.assertEquals(childBean.getName(), <span class=\"string\">\"son\"</span>);</span><br><span class=\"line\">    Assert.assertEquals(childBean.getAge(), Integer.valueOf(<span class=\"number\">18</span>));</span><br><span class=\"line\">    Assert.assertEquals(childBean.getHeight(), Integer.valueOf(<span class=\"number\">180</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以下是ParentBean和ChildBean的定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParentBean</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//省略getter和setter方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChildBean</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer height;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//省略getter和setter方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>聪明的你一定发现了，这两个类并不一定要有实际的继承关系，可以是两个普通的类。甚至，<code>parent</code>属性所指向的bean可以不用设置某个具体的类，而只设置它是属性，就像这样：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"abstractParent\"</span> <span class=\"attr\">abstract</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Frank\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"age\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"18\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testChild\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.frank.spring.bean.parent.ChildBean\"</span> <span class=\"attr\">parent</span>=<span class=\"string\">\"abstractParent\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"son\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"height\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"180\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testAbstractParent</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ApplicationContext context = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"test-bean.xml\"</span>);</span><br><span class=\"line\">    ChildBean childBean = (ChildBean) context.getBean(<span class=\"string\">\"testChild\"</span>);</span><br><span class=\"line\">    Assert.assertEquals(childBean.getName(), <span class=\"string\">\"son\"</span>);</span><br><span class=\"line\">    Assert.assertEquals(childBean.getAge(), Integer.valueOf(<span class=\"number\">18</span>));</span><br><span class=\"line\">    Assert.assertEquals(childBean.getHeight(), Integer.valueOf(<span class=\"number\">180</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到这次我们设置的<code>abstractParent</code>并没有为其指定类名，我们也能将它做为<code>parent</code>属性的值。</p>\n<h2 id=\"abstract-属性的作用\"><a href=\"#abstract-属性的作用\" class=\"headerlink\" title=\"abstract 属性的作用\"></a>abstract 属性的作用</h2><p>在Spring中， <code>abstract</code> 属性一般是用来声明抽象bean，将一些公共的属性放到一块，这样就能减少重复的代码。所以在标签中，可以这样设置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"abstractBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.frank.spring.bean.parent.ParentBean\"</span> <span class=\"attr\">abstract</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Frank\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"age\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"18\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"childA\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.frank.spring.bean.parent.ChildBean\"</span> <span class=\"attr\">parent</span>=<span class=\"string\">\"abstractBean\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"GG\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"height\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"180\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"childB\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.frank.spring.bean.parent.ChildBean\"</span> <span class=\"attr\">parent</span>=<span class=\"string\">\"abstractBean\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"DD\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"height\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"185\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这样，<code>abstractBean</code>就起到了一个模板的作用，可以减少重复定义，这里只有简单的几个属性，所以可能看起来不是很直观，可以想象一下，如果abstractBean中有一二十个公用属性，是不是可以少写不少代码呢？</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><code>abstract</code> 和 <code>parent</code> 属性可以当做用来减少xml重复代码的方法，可以将一些bean的公共属性抽取出来，放到一个公共的bean中，然后使用上面的栗子进行配置，来让xml文件更加简洁。</p>\n<p>值得注意的是，<code>parent</code>属性配置的bean之间，并不一定需要有实际的继承关系，更多的是属性的继承。被设置为<code>parent</code>的bean甚至可以不用映射到某一个具体的类，而仅仅将其当做属性模板来使用。</p>\n<p>文章持续更新中，欢迎关注我的公众号留言交流。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/14/5c8a58ba229ca.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>"},{"title":"【Spring源码解读】bean标签中的属性（一）scope 属性","date":"2019-03-05T13:28:43.000Z","categorys":["Spring"],"_content":"\n## scope 属性说明\n\n在spring中，在xml中定义`bean`时，`scope`属性是用来声明`bean`的作用域的。对于这个属性，你也许已经很熟悉了，`singleton`和`prototype`信手捏来，甚至还能说出`request`、`session`、`global session`，scope不就只有这么几个值吗。\n\nemmm，话不要说太满，容易打脸。常见的各类博客中，一般只会介绍上面说到的几种可能值，但翻一翻官方的说明，你就会发现，事情并没有这么简单。\n\n![](https://i.loli.net/2019/03/07/5c8073af8fd16.png)\n\n这是官方文档中的介绍，scope属性一共有六种可能值，惊不惊喜，意不意外。\n\n![](https://i.loli.net/2019/03/07/5c80742434d0e.png)\n\n下面，就让我们来一一看看各个值代表的意义。\n\n### singleton\n\n`singleton`是scope属性的默认值，当我们把bean的scope属性设置为`singleton`时，代表将对该bean使用单例模式，单例想必大家都熟悉，也就是说每次使用该bean的id从容器中获取该bean的时候，都将会返回同一个bean实例。但这里的单例跟设计模式里的单例还有一些小区别。\n\n设计模式中的单例是通过硬编码，给某个类仅创建一个静态对象，并且只暴露一个接口来获取这个对象实例，因此，设计模式中的单例是相对`ClassLoader`而言的，同一个类加载器下只会有一个实例。\n\n下面就是经典的使用`double-check`实现的懒加载代码：\n\n```java\npublic class Singleton{\n    private static volatile Singleton FRANK;\n\n    public static Singleton getInstance(){\n        if (FRANK == null){\n            synchronized(this){\n                if (FRANK == null) FRANK = new Singleton();\n            }\n        }\n        return FRANK;\n    }\n}\n```\n\n但是在Spring中，`singleton单例`指的是每次从同一个IOC容器中返回同一个bean对象，单例的有效范围是IOC容器，而不是`ClassLoader`。IOC容器会将这个bean实例缓存起来，以供后续使用。\n\n![20190307095059.png](https://i.loli.net/2019/03/07/5c8079052f7de.png)\n\n下面做一个小实验验证一下：\n\n先写一个测试类：\n\n```java\npublic class TestScope {\n\t@Test\n\tpublic void testSingleton(){\n\t\tApplicationContext context = new ClassPathXmlApplicationContext(\"test-bean.xml\");\n\t\tTestBean bean = (TestBean) context.getBean(\"testBean\");\n\t\tAssert.assertEquals(bean.getNum() , 0);\n\t\tbean.add();\n\t\tAssert.assertEquals(bean.getNum() , 1);\n\n\t\tTestBean bean1 = (TestBean) context.getBean(\"testBean\");\n\t\tAssert.assertEquals(bean1.getNum() , 1);\n\t\tbean1.add();\n\t\tAssert.assertEquals(bean1.getNum() , 2);\n\n\t\tApplicationContext context1 = new ClassPathXmlApplicationContext(\"test-bean.xml\");\n\t\tTestBean bean2 = (TestBean) context1.getBean(\"testBean\");\n\t\tAssert.assertEquals(bean2.getNum() , 0);\n\t\tbean2.add();\n\t\tAssert.assertEquals(bean2.getNum() , 1);\n\t}\n}\n```\n\n```java\npublic class TestBean {\n\tprivate int num;\n\n\tpublic int getNum() {\n\t\treturn num;\n\t}\n\n\tpublic void setNum(int num) {\n\t\tthis.num = num;\n\t}\n\n\tpublic void add(){\n\t\tnum++;\n\t}\n}\n```\n\n这是相应的配置文件`test-bean.xml`\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN 2.0//EN\" \"http://www.springframework.org/dtd/spring-beans-2.0.dtd\">\n\n<beans>\n\t<bean id=\"testBean\" class=\"com.frank.spring.bean.scope.TestBean\" scope=\"singleton\"/>\n</beans>\n```\n\n`testBean`的`scope`为`singleton`，而变量`bean`和`bean1`所指向的实例都是从同一个IOC容器中获取的，所以获取的是同一个bean实例，因此分别对`bean`和`bean1`调用add方法后，num的值就会变成2。而`bean2`是从另一个IOC容器中获取的，所以它是一个新的实例，`num`的值便成了初始值0，调用`add`方法后，num的值变成了1。这样也验证了上面所说的`singleton`单例含义，指的是每一个IOC容器中仅存在一个实例。\n\n### prototype\n\n接下来是另一个常用的scope：`prototype`。与`singleton`相反，设置为`prototype`的bean，每次调用容器的`getBean`方法或注入到另一个bean中时，都会返回一个新的实例。\n\n![20190307191454.png](https://i.loli.net/2019/03/07/5c80fd2fc8df9.png)\n\n与其他的`scope`类型不同的是，Spring并不会管理设置为`prototype`的bean的整个生命周期，获取相关bean时，容器会实例化，或者装配相关的`prototype-bean`实例，然后返回给客户端，但不会保存`prototype-bean`的实例。所以，尽管所有的bean对象都会调用配置的初始化方法，但是`prototype-bean`并不会调用其配置的destroy方法。所以清理工作必须由客户端进行。所以，Spring容器对`prototype-bean` 的管理在一定程度上类似于 `new` 操作，对象创建后的事情将全部由客户端处理。\n\n仍旧用一个小栗子来进行测试：\n\n我们将上面的xml文件进行修改：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN 2.0//EN\" \"http://www.springframework.org/dtd/spring-beans-2.0.dtd\">\n\n<beans>\n\t<bean id=\"testBean\" class=\"com.frank.spring.bean.scope.TestBean\" scope=\"prototype\"/>\n</beans>\n```\n\n```java\n@Test\npublic void testPrototype(){\n    ApplicationContext context = new ClassPathXmlApplicationContext(\"test-bean.xml\");\n    TestBean bean = (TestBean) context.getBean(\"testBean\");\n    Assert.assertEquals(bean.getNum() , 0);\n    bean.add();\n    Assert.assertEquals(bean.getNum() , 1);\n\n    TestBean bean1 = (TestBean) context.getBean(\"testBean\");\n    Assert.assertEquals(bean1.getNum() , 0);\n    bean1.add();\n    Assert.assertEquals(bean1.getNum() , 1);\n}\n```\n\n这里两次从同一个IOC容器中获取`testBean`，得到了两个不同的bean实例，这就是`prototype`的作用。\n\n接着，我们配置一个初始化方法和销毁方法，来测试一下：\n\n给TestBean类加两个方法：\n\n```java\npublic class TestBean {\n\tprivate int num;\n\n\tpublic void init(){\n\t\tSystem.out.println(\"init TestBean\");\n\t}\n\n\tpublic void destroy(){\n\t\tSystem.out.println(\"destroy TestBean\");\n\t}\n\n\tpublic int getNum() {\n\t\treturn num;\n\t}\n\n\tpublic void setNum(int num) {\n\t\tthis.num = num;\n\t}\n\n\tpublic void add(){\n\t\tnum++;\n\t}\n}\n```\n\n然后在配置文件里设置它的初始化方法和销毁方法：\n\n```xml\n<beans>\n\t<bean id=\"testBean\" class=\"com.frank.spring.bean.scope.TestBean\" scope=\"prototype\"  init-method=\"init\"  destroy-method=\"destroy\"/>\n</beans>\n```\n\n还是用之前的测试方法：\n\n```java\n@Test\npublic void testPrototype(){\n    ApplicationContext context = new ClassPathXmlApplicationContext(\"test-bean.xml\");\n    TestBean bean = (TestBean) context.getBean(\"testBean\");\n    Assert.assertEquals(bean.getNum() , 0);\n    bean.add();\n    Assert.assertEquals(bean.getNum() , 1);\n\n    TestBean bean1 = (TestBean) context.getBean(\"testBean\");\n    Assert.assertEquals(bean1.getNum() , 0);\n    bean1.add();\n    Assert.assertEquals(bean1.getNum() , 1);\n}\n```\n\n输出如下：\n\n```\ninit TestBean\ninit TestBean\n```\n\n可以看到，仅仅输出了初始化方法`init`中的内容，而没有输出销毁方法`destroy`中的内容，所以，对于`prototype-bean`而言，在xml中配置`destroy-method`属性是没有意义的，容器在创建这个bean实例后就抛弃它了，如果它持有的资源需要释放，则需要客户端进行手动释放才行。这大概就是亲生和领养的区别吧。\n\n![](https://i.loli.net/2019/03/07/5c81044d154bf.png)\n\n另外，如果将一个`prototype-bean`注入到一个`singleton-bean`中，那么每次从容器中获取的`singleton-bean`对应`prototype-bean`都是同一个，因为依赖注入仅会进行一次。\n\n## Request && Session && Application && WebSocket Scopes\n\n![](https://i.loli.net/2019/03/07/5c8106f6ae617.png)\n\n`request` 和 `session` 这两个你也许有所耳闻，但是 `application` 和 `websocket` 是什么鬼？竟然还有这样的神仙scope？？莫方，让我们来一探究竟。\n\n这几个类型的scope都只能在web环境下使用，如果使用 `ClassPathXmlApplicationContext` 来加载使用了该属性的bean，那么就会抛出异常。就像这样：\n\n```java\njava.lang.IllegalStateException: No Scope registered for scope name 'request'\n```\n\n下面让我们依次来看看这几个值的作用。\n\n### request\n\n如果将scope属性设置为 `request` 代表该bean的作用域为单个请求，请求结束，则bean将被销毁，第二次请求将会创建一个新的bean实例，让我们来验证一下。方便起见，创建一个springboot应用，然后创建一个配置类并指定其扫描的xml：\n\n```java\n@Configuration\n@ImportResource(locations = {\"classpath:application-bean.xml\"})\npublic class WebConfiguration {\n}\n```\n\n以下是xml中的内容：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n            http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\">\n    <bean id=\"testBean\" class=\"com.frank.springboothello.model.TestBean\" scope=\"request\" >\n        <aop:scoped-proxy/>\n    </bean>\n</beans>\n```\n\n下面是controller的内容：\n\n```java\n@RestController\npublic class HelloController {\n\n    @Autowired\n    private TestBean testBean;\n\n    @Autowired\n    private TestBean testBean1;\n\n    @GetMapping(\"/testBean\")\n    public void testBean(){\n        System.out.println(\"==========request start==========\");\n        System.out.println(testBean.getNum());\n        testBean.add();\n        System.out.println(testBean.getNum());\n        System.out.println(testBean1.getNum());\n        testBean1.add();\n        System.out.println(testBean1.getNum());\n        System.out.println(\"==========request end==========\");\n    }\n}\n```\n\n这里还是使用之前的TestBean，也许细心的你会发现，这里有一个乱入的家伙：\n\n```xml\n<aop:scoped-proxy/>\n```\n\n![20190308093050.png](https://i.loli.net/2019/03/08/5c81c5cc0999a.png)\n\n这是个什么东西？？？\n\n这里其实是声明对该bean使用代理模式，这样做的话，容器在注入该bean的时候，将会使用`CGLib动态代理`为它创建一个代理对象，该对象拥有与原Bean相同的public接口并暴露，代理对象每次调用时，会从相应作用域范围内（这里是`request`）获取真正的`TestBean`对象。\n\n那么，为什么要这样做呢？\n\n因为被注入的bean（`testBean`）和目标bean（`HelloController`）的生命周期不一样，而同一个容器内的bean注入只会发生一次，你想想，`HelloController`是`singleton`的，只会实例化一次，如果不使用代理对象，就意味着我们只能将同一个`request-bean`注入到这个`singleton-bean`中，那之后的每次访问，都将调用同一个`testBean`实例，这不是我们想要的结果。我们希望`HelloController`是容器范围内单例的，同时想要一个作用域为 `Http Request` 的`testBean`实例，这时候，代理对象就扮演着不可或缺的角色了。\n\n另外，值得一提的是，如果我们对一个`scope`为`prototype`的bean使用`<aop:scoped-proxy/>`的话，那么每次调用该bean的方法都会创建一个新的实例，关于这一点，大家可以自行验证。\n\n![](https://i.loli.net/2019/03/08/5c8254687adf6.png)\n\n代理方式默认是`CGLib`，并且只有`public`方法会被代理，`private`方法是不会被代理的。如果我们想要使用基于`JDK`的代理来创建代理对象，那么只需要将aop标签中的`proxy-target-class`属性设置为false即可，就像这样：\n\n```xml\n<aop:scoped-proxy proxy-target-class=\"false\"/>\n```\n\n但有个条件，那就是这个bean必须要实现某个接口。\n\n我们再来跑一下代码验证一下，启动！\n\n![20190308092733.png](https://i.loli.net/2019/03/08/5c81c5066975f.png)\n\n\n接下来访问几次`http://127.0.0.1:8080/testBean`，输出如下：\n\n```java\n==========request start==========\n0\n1\n1\n2\n==========request end==========\n==========request start==========\n0\n1\n1\n2\n==========request end==========\n```\n\n嗯，一切都在掌控范围之内。\n\n### session\n\n跟`request`类似，但它的生命周期更长一些，是在同一次会话范围内有效，也就是说如果不关闭浏览器，不管刷新多少次，都会访问同一个bean。\n\n我们将上面的xml稍作改动：\n\n```xml\n<bean id=\"testBean\" class=\"com.frank.springboothello.model.TestBean\" scope=\"session\" >\n    <aop:scoped-proxy/>\n</bean>\n```\n\n再也运行一下，然后在页面刷新几次：\n\n```java\n==========request start==========\n0\n1\n1\n2\n==========request end==========\n==========request start==========\n2\n3\n3\n4\n==========request end==========\n==========request start==========\n4\n5\n5\n6\n==========request end==========\n```\n\n可以看到，num的值一直的增加，可见我们访问的是同一个bean实例。\n\n然后，我们使用另一个浏览器继续访问该页面：\n\n```java\n==========request start==========\n0\n1\n1\n2\n==========request end==========\n==========request start==========\n2\n3\n3\n4\n==========request end==========\n```\n\n发现num又从0开始计数了。这样就验证了我们对`session`作用域的想法。\n\n### application\n\n`application`的作用域比`session`又要更广一些，`session`作用域是针对一个 `Http Session`，而a`pplication`作用域，则是针对一个 `ServletContext` ，有点类似 `singleton`，但是`singleton`代表的是每个IOC容器中仅有一个实例，而同一个web应用中，是可能会有多个IOC容器的，但一个Web应用只会有一个 `ServletContext`，所以 `application` 才是web应用中货真价实的单例模式。\n\n![](https://i.loli.net/2019/03/08/5c8215620925e.png)\n\n来测试一下，继续修改上面的xml文件：\n\n```xml\n<bean id=\"testBean\" class=\"com.frank.springboothello.model.TestBean\" scope=\"application\" >\n    <aop:scoped-proxy/>\n</bean>\n```\n\n然后再次启动后，疯狂访问。\n\n```java\n==========request start==========\n0\n1\n1\n2\n==========request end==========\n==========request start==========\n2\n3\n3\n4\n==========request end==========\n==========request start==========\n4\n5\n5\n6\n==========request end==========\n```\n\n换个浏览器继续访问：\n\n```java\n==========request start==========\n6\n7\n7\n8\n==========request end==========\n==========request start==========\n8\n9\n9\n10\n==========request end==========\n```\n\n嗯，验证完毕。\n\n![](https://i.loli.net/2019/03/08/5c82552a6af48.png)\n\n### websocket\n\n`websocket` 的作用范围是 `WebSocket` ，即在整个 `WebSocket` 中有效。\n\nemmmm，说实话，这个验证起来有点麻烦，摸索了半天没有找到正确姿势，所以。。。。如果有知道如何验证这一点的小伙伴欢迎留言补充。\n\n![](https://i.loli.net/2019/03/08/5c824b40b64cd.png)\n\n### global session\n\n也许你会发现，很多博客中说的 `global session` 怎么不见了？？\n\n这你就不知道了吧，因为在最新版本（5.2.0.BUILD-SNAPSHOT）中`global session`早就被移除了。\n\n所以以后再有人问你，scope属性有哪几种可能值，分别代表什么含义的时候，就可以理直气壮的把这篇文章甩他脸上了。\n\n![20190308191406.png](https://i.loli.net/2019/03/08/5c824e7fcae16.png)\n\n## 总结\n\n关于 scope 的介绍到此就告一段落了，来做一个小结：\n\n1. singleton：单例模式，每次获取都返回同一个实例，相对于同一个IOC容器而言。\n2. prototype：原型模式，每次获取返回不同实例，创建后的生命周期不再由IOC容器管理。\n3. request：作用域为同一个 Http Request。\n4. session：作用域为同一个 Http Session。\n5. application：作用域为同一个WEB容器，可以看做Web应用中的单例模式。\n6. websocket：作用域为同一个WebSocket应用。\n\n希望这篇文章能对你有帮助，如果觉得还不错的话，记得分享给身边的小伙伴哦。\n\n让我们红尘作伴，活得潇潇洒洒。\n\n![](https://i.loli.net/2019/03/08/5c8255c88946b.png)","source":"_posts/java/spring/source-code-analysis/spring-bean-attribute-scope.md","raw":"---\ntitle: 【Spring源码解读】bean标签中的属性（一）scope 属性\ndate: 2019-03-05 21:28:43\ntags:\n- Spring\n- 源码解读\ncategorys:\n- Spring\n---\n\n## scope 属性说明\n\n在spring中，在xml中定义`bean`时，`scope`属性是用来声明`bean`的作用域的。对于这个属性，你也许已经很熟悉了，`singleton`和`prototype`信手捏来，甚至还能说出`request`、`session`、`global session`，scope不就只有这么几个值吗。\n\nemmm，话不要说太满，容易打脸。常见的各类博客中，一般只会介绍上面说到的几种可能值，但翻一翻官方的说明，你就会发现，事情并没有这么简单。\n\n![](https://i.loli.net/2019/03/07/5c8073af8fd16.png)\n\n这是官方文档中的介绍，scope属性一共有六种可能值，惊不惊喜，意不意外。\n\n![](https://i.loli.net/2019/03/07/5c80742434d0e.png)\n\n下面，就让我们来一一看看各个值代表的意义。\n\n### singleton\n\n`singleton`是scope属性的默认值，当我们把bean的scope属性设置为`singleton`时，代表将对该bean使用单例模式，单例想必大家都熟悉，也就是说每次使用该bean的id从容器中获取该bean的时候，都将会返回同一个bean实例。但这里的单例跟设计模式里的单例还有一些小区别。\n\n设计模式中的单例是通过硬编码，给某个类仅创建一个静态对象，并且只暴露一个接口来获取这个对象实例，因此，设计模式中的单例是相对`ClassLoader`而言的，同一个类加载器下只会有一个实例。\n\n下面就是经典的使用`double-check`实现的懒加载代码：\n\n```java\npublic class Singleton{\n    private static volatile Singleton FRANK;\n\n    public static Singleton getInstance(){\n        if (FRANK == null){\n            synchronized(this){\n                if (FRANK == null) FRANK = new Singleton();\n            }\n        }\n        return FRANK;\n    }\n}\n```\n\n但是在Spring中，`singleton单例`指的是每次从同一个IOC容器中返回同一个bean对象，单例的有效范围是IOC容器，而不是`ClassLoader`。IOC容器会将这个bean实例缓存起来，以供后续使用。\n\n![20190307095059.png](https://i.loli.net/2019/03/07/5c8079052f7de.png)\n\n下面做一个小实验验证一下：\n\n先写一个测试类：\n\n```java\npublic class TestScope {\n\t@Test\n\tpublic void testSingleton(){\n\t\tApplicationContext context = new ClassPathXmlApplicationContext(\"test-bean.xml\");\n\t\tTestBean bean = (TestBean) context.getBean(\"testBean\");\n\t\tAssert.assertEquals(bean.getNum() , 0);\n\t\tbean.add();\n\t\tAssert.assertEquals(bean.getNum() , 1);\n\n\t\tTestBean bean1 = (TestBean) context.getBean(\"testBean\");\n\t\tAssert.assertEquals(bean1.getNum() , 1);\n\t\tbean1.add();\n\t\tAssert.assertEquals(bean1.getNum() , 2);\n\n\t\tApplicationContext context1 = new ClassPathXmlApplicationContext(\"test-bean.xml\");\n\t\tTestBean bean2 = (TestBean) context1.getBean(\"testBean\");\n\t\tAssert.assertEquals(bean2.getNum() , 0);\n\t\tbean2.add();\n\t\tAssert.assertEquals(bean2.getNum() , 1);\n\t}\n}\n```\n\n```java\npublic class TestBean {\n\tprivate int num;\n\n\tpublic int getNum() {\n\t\treturn num;\n\t}\n\n\tpublic void setNum(int num) {\n\t\tthis.num = num;\n\t}\n\n\tpublic void add(){\n\t\tnum++;\n\t}\n}\n```\n\n这是相应的配置文件`test-bean.xml`\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN 2.0//EN\" \"http://www.springframework.org/dtd/spring-beans-2.0.dtd\">\n\n<beans>\n\t<bean id=\"testBean\" class=\"com.frank.spring.bean.scope.TestBean\" scope=\"singleton\"/>\n</beans>\n```\n\n`testBean`的`scope`为`singleton`，而变量`bean`和`bean1`所指向的实例都是从同一个IOC容器中获取的，所以获取的是同一个bean实例，因此分别对`bean`和`bean1`调用add方法后，num的值就会变成2。而`bean2`是从另一个IOC容器中获取的，所以它是一个新的实例，`num`的值便成了初始值0，调用`add`方法后，num的值变成了1。这样也验证了上面所说的`singleton`单例含义，指的是每一个IOC容器中仅存在一个实例。\n\n### prototype\n\n接下来是另一个常用的scope：`prototype`。与`singleton`相反，设置为`prototype`的bean，每次调用容器的`getBean`方法或注入到另一个bean中时，都会返回一个新的实例。\n\n![20190307191454.png](https://i.loli.net/2019/03/07/5c80fd2fc8df9.png)\n\n与其他的`scope`类型不同的是，Spring并不会管理设置为`prototype`的bean的整个生命周期，获取相关bean时，容器会实例化，或者装配相关的`prototype-bean`实例，然后返回给客户端，但不会保存`prototype-bean`的实例。所以，尽管所有的bean对象都会调用配置的初始化方法，但是`prototype-bean`并不会调用其配置的destroy方法。所以清理工作必须由客户端进行。所以，Spring容器对`prototype-bean` 的管理在一定程度上类似于 `new` 操作，对象创建后的事情将全部由客户端处理。\n\n仍旧用一个小栗子来进行测试：\n\n我们将上面的xml文件进行修改：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN 2.0//EN\" \"http://www.springframework.org/dtd/spring-beans-2.0.dtd\">\n\n<beans>\n\t<bean id=\"testBean\" class=\"com.frank.spring.bean.scope.TestBean\" scope=\"prototype\"/>\n</beans>\n```\n\n```java\n@Test\npublic void testPrototype(){\n    ApplicationContext context = new ClassPathXmlApplicationContext(\"test-bean.xml\");\n    TestBean bean = (TestBean) context.getBean(\"testBean\");\n    Assert.assertEquals(bean.getNum() , 0);\n    bean.add();\n    Assert.assertEquals(bean.getNum() , 1);\n\n    TestBean bean1 = (TestBean) context.getBean(\"testBean\");\n    Assert.assertEquals(bean1.getNum() , 0);\n    bean1.add();\n    Assert.assertEquals(bean1.getNum() , 1);\n}\n```\n\n这里两次从同一个IOC容器中获取`testBean`，得到了两个不同的bean实例，这就是`prototype`的作用。\n\n接着，我们配置一个初始化方法和销毁方法，来测试一下：\n\n给TestBean类加两个方法：\n\n```java\npublic class TestBean {\n\tprivate int num;\n\n\tpublic void init(){\n\t\tSystem.out.println(\"init TestBean\");\n\t}\n\n\tpublic void destroy(){\n\t\tSystem.out.println(\"destroy TestBean\");\n\t}\n\n\tpublic int getNum() {\n\t\treturn num;\n\t}\n\n\tpublic void setNum(int num) {\n\t\tthis.num = num;\n\t}\n\n\tpublic void add(){\n\t\tnum++;\n\t}\n}\n```\n\n然后在配置文件里设置它的初始化方法和销毁方法：\n\n```xml\n<beans>\n\t<bean id=\"testBean\" class=\"com.frank.spring.bean.scope.TestBean\" scope=\"prototype\"  init-method=\"init\"  destroy-method=\"destroy\"/>\n</beans>\n```\n\n还是用之前的测试方法：\n\n```java\n@Test\npublic void testPrototype(){\n    ApplicationContext context = new ClassPathXmlApplicationContext(\"test-bean.xml\");\n    TestBean bean = (TestBean) context.getBean(\"testBean\");\n    Assert.assertEquals(bean.getNum() , 0);\n    bean.add();\n    Assert.assertEquals(bean.getNum() , 1);\n\n    TestBean bean1 = (TestBean) context.getBean(\"testBean\");\n    Assert.assertEquals(bean1.getNum() , 0);\n    bean1.add();\n    Assert.assertEquals(bean1.getNum() , 1);\n}\n```\n\n输出如下：\n\n```\ninit TestBean\ninit TestBean\n```\n\n可以看到，仅仅输出了初始化方法`init`中的内容，而没有输出销毁方法`destroy`中的内容，所以，对于`prototype-bean`而言，在xml中配置`destroy-method`属性是没有意义的，容器在创建这个bean实例后就抛弃它了，如果它持有的资源需要释放，则需要客户端进行手动释放才行。这大概就是亲生和领养的区别吧。\n\n![](https://i.loli.net/2019/03/07/5c81044d154bf.png)\n\n另外，如果将一个`prototype-bean`注入到一个`singleton-bean`中，那么每次从容器中获取的`singleton-bean`对应`prototype-bean`都是同一个，因为依赖注入仅会进行一次。\n\n## Request && Session && Application && WebSocket Scopes\n\n![](https://i.loli.net/2019/03/07/5c8106f6ae617.png)\n\n`request` 和 `session` 这两个你也许有所耳闻，但是 `application` 和 `websocket` 是什么鬼？竟然还有这样的神仙scope？？莫方，让我们来一探究竟。\n\n这几个类型的scope都只能在web环境下使用，如果使用 `ClassPathXmlApplicationContext` 来加载使用了该属性的bean，那么就会抛出异常。就像这样：\n\n```java\njava.lang.IllegalStateException: No Scope registered for scope name 'request'\n```\n\n下面让我们依次来看看这几个值的作用。\n\n### request\n\n如果将scope属性设置为 `request` 代表该bean的作用域为单个请求，请求结束，则bean将被销毁，第二次请求将会创建一个新的bean实例，让我们来验证一下。方便起见，创建一个springboot应用，然后创建一个配置类并指定其扫描的xml：\n\n```java\n@Configuration\n@ImportResource(locations = {\"classpath:application-bean.xml\"})\npublic class WebConfiguration {\n}\n```\n\n以下是xml中的内容：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n            http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\">\n    <bean id=\"testBean\" class=\"com.frank.springboothello.model.TestBean\" scope=\"request\" >\n        <aop:scoped-proxy/>\n    </bean>\n</beans>\n```\n\n下面是controller的内容：\n\n```java\n@RestController\npublic class HelloController {\n\n    @Autowired\n    private TestBean testBean;\n\n    @Autowired\n    private TestBean testBean1;\n\n    @GetMapping(\"/testBean\")\n    public void testBean(){\n        System.out.println(\"==========request start==========\");\n        System.out.println(testBean.getNum());\n        testBean.add();\n        System.out.println(testBean.getNum());\n        System.out.println(testBean1.getNum());\n        testBean1.add();\n        System.out.println(testBean1.getNum());\n        System.out.println(\"==========request end==========\");\n    }\n}\n```\n\n这里还是使用之前的TestBean，也许细心的你会发现，这里有一个乱入的家伙：\n\n```xml\n<aop:scoped-proxy/>\n```\n\n![20190308093050.png](https://i.loli.net/2019/03/08/5c81c5cc0999a.png)\n\n这是个什么东西？？？\n\n这里其实是声明对该bean使用代理模式，这样做的话，容器在注入该bean的时候，将会使用`CGLib动态代理`为它创建一个代理对象，该对象拥有与原Bean相同的public接口并暴露，代理对象每次调用时，会从相应作用域范围内（这里是`request`）获取真正的`TestBean`对象。\n\n那么，为什么要这样做呢？\n\n因为被注入的bean（`testBean`）和目标bean（`HelloController`）的生命周期不一样，而同一个容器内的bean注入只会发生一次，你想想，`HelloController`是`singleton`的，只会实例化一次，如果不使用代理对象，就意味着我们只能将同一个`request-bean`注入到这个`singleton-bean`中，那之后的每次访问，都将调用同一个`testBean`实例，这不是我们想要的结果。我们希望`HelloController`是容器范围内单例的，同时想要一个作用域为 `Http Request` 的`testBean`实例，这时候，代理对象就扮演着不可或缺的角色了。\n\n另外，值得一提的是，如果我们对一个`scope`为`prototype`的bean使用`<aop:scoped-proxy/>`的话，那么每次调用该bean的方法都会创建一个新的实例，关于这一点，大家可以自行验证。\n\n![](https://i.loli.net/2019/03/08/5c8254687adf6.png)\n\n代理方式默认是`CGLib`，并且只有`public`方法会被代理，`private`方法是不会被代理的。如果我们想要使用基于`JDK`的代理来创建代理对象，那么只需要将aop标签中的`proxy-target-class`属性设置为false即可，就像这样：\n\n```xml\n<aop:scoped-proxy proxy-target-class=\"false\"/>\n```\n\n但有个条件，那就是这个bean必须要实现某个接口。\n\n我们再来跑一下代码验证一下，启动！\n\n![20190308092733.png](https://i.loli.net/2019/03/08/5c81c5066975f.png)\n\n\n接下来访问几次`http://127.0.0.1:8080/testBean`，输出如下：\n\n```java\n==========request start==========\n0\n1\n1\n2\n==========request end==========\n==========request start==========\n0\n1\n1\n2\n==========request end==========\n```\n\n嗯，一切都在掌控范围之内。\n\n### session\n\n跟`request`类似，但它的生命周期更长一些，是在同一次会话范围内有效，也就是说如果不关闭浏览器，不管刷新多少次，都会访问同一个bean。\n\n我们将上面的xml稍作改动：\n\n```xml\n<bean id=\"testBean\" class=\"com.frank.springboothello.model.TestBean\" scope=\"session\" >\n    <aop:scoped-proxy/>\n</bean>\n```\n\n再也运行一下，然后在页面刷新几次：\n\n```java\n==========request start==========\n0\n1\n1\n2\n==========request end==========\n==========request start==========\n2\n3\n3\n4\n==========request end==========\n==========request start==========\n4\n5\n5\n6\n==========request end==========\n```\n\n可以看到，num的值一直的增加，可见我们访问的是同一个bean实例。\n\n然后，我们使用另一个浏览器继续访问该页面：\n\n```java\n==========request start==========\n0\n1\n1\n2\n==========request end==========\n==========request start==========\n2\n3\n3\n4\n==========request end==========\n```\n\n发现num又从0开始计数了。这样就验证了我们对`session`作用域的想法。\n\n### application\n\n`application`的作用域比`session`又要更广一些，`session`作用域是针对一个 `Http Session`，而a`pplication`作用域，则是针对一个 `ServletContext` ，有点类似 `singleton`，但是`singleton`代表的是每个IOC容器中仅有一个实例，而同一个web应用中，是可能会有多个IOC容器的，但一个Web应用只会有一个 `ServletContext`，所以 `application` 才是web应用中货真价实的单例模式。\n\n![](https://i.loli.net/2019/03/08/5c8215620925e.png)\n\n来测试一下，继续修改上面的xml文件：\n\n```xml\n<bean id=\"testBean\" class=\"com.frank.springboothello.model.TestBean\" scope=\"application\" >\n    <aop:scoped-proxy/>\n</bean>\n```\n\n然后再次启动后，疯狂访问。\n\n```java\n==========request start==========\n0\n1\n1\n2\n==========request end==========\n==========request start==========\n2\n3\n3\n4\n==========request end==========\n==========request start==========\n4\n5\n5\n6\n==========request end==========\n```\n\n换个浏览器继续访问：\n\n```java\n==========request start==========\n6\n7\n7\n8\n==========request end==========\n==========request start==========\n8\n9\n9\n10\n==========request end==========\n```\n\n嗯，验证完毕。\n\n![](https://i.loli.net/2019/03/08/5c82552a6af48.png)\n\n### websocket\n\n`websocket` 的作用范围是 `WebSocket` ，即在整个 `WebSocket` 中有效。\n\nemmmm，说实话，这个验证起来有点麻烦，摸索了半天没有找到正确姿势，所以。。。。如果有知道如何验证这一点的小伙伴欢迎留言补充。\n\n![](https://i.loli.net/2019/03/08/5c824b40b64cd.png)\n\n### global session\n\n也许你会发现，很多博客中说的 `global session` 怎么不见了？？\n\n这你就不知道了吧，因为在最新版本（5.2.0.BUILD-SNAPSHOT）中`global session`早就被移除了。\n\n所以以后再有人问你，scope属性有哪几种可能值，分别代表什么含义的时候，就可以理直气壮的把这篇文章甩他脸上了。\n\n![20190308191406.png](https://i.loli.net/2019/03/08/5c824e7fcae16.png)\n\n## 总结\n\n关于 scope 的介绍到此就告一段落了，来做一个小结：\n\n1. singleton：单例模式，每次获取都返回同一个实例，相对于同一个IOC容器而言。\n2. prototype：原型模式，每次获取返回不同实例，创建后的生命周期不再由IOC容器管理。\n3. request：作用域为同一个 Http Request。\n4. session：作用域为同一个 Http Session。\n5. application：作用域为同一个WEB容器，可以看做Web应用中的单例模式。\n6. websocket：作用域为同一个WebSocket应用。\n\n希望这篇文章能对你有帮助，如果觉得还不错的话，记得分享给身边的小伙伴哦。\n\n让我们红尘作伴，活得潇潇洒洒。\n\n![](https://i.loli.net/2019/03/08/5c8255c88946b.png)","slug":"java/spring/source-code-analysis/spring-bean-attribute-scope","published":1,"updated":"2019-06-04T01:29:57.422Z","_id":"cjxze3h0g00820cvwd3l93uzw","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"scope-属性说明\"><a href=\"#scope-属性说明\" class=\"headerlink\" title=\"scope 属性说明\"></a>scope 属性说明</h2><p>在spring中，在xml中定义<code>bean</code>时，<code>scope</code>属性是用来声明<code>bean</code>的作用域的。对于这个属性，你也许已经很熟悉了，<code>singleton</code>和<code>prototype</code>信手捏来，甚至还能说出<code>request</code>、<code>session</code>、<code>global session</code>，scope不就只有这么几个值吗。</p>\n<p>emmm，话不要说太满，容易打脸。常见的各类博客中，一般只会介绍上面说到的几种可能值，但翻一翻官方的说明，你就会发现，事情并没有这么简单。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/07/5c8073af8fd16.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>这是官方文档中的介绍，scope属性一共有六种可能值，惊不惊喜，意不意外。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/07/5c80742434d0e.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>下面，就让我们来一一看看各个值代表的意义。</p>\n<h3 id=\"singleton\"><a href=\"#singleton\" class=\"headerlink\" title=\"singleton\"></a>singleton</h3><p><code>singleton</code>是scope属性的默认值，当我们把bean的scope属性设置为<code>singleton</code>时，代表将对该bean使用单例模式，单例想必大家都熟悉，也就是说每次使用该bean的id从容器中获取该bean的时候，都将会返回同一个bean实例。但这里的单例跟设计模式里的单例还有一些小区别。</p>\n<p>设计模式中的单例是通过硬编码，给某个类仅创建一个静态对象，并且只暴露一个接口来获取这个对象实例，因此，设计模式中的单例是相对<code>ClassLoader</code>而言的，同一个类加载器下只会有一个实例。</p>\n<p>下面就是经典的使用<code>double-check</code>实现的懒加载代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Singleton FRANK;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (FRANK == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (FRANK == <span class=\"keyword\">null</span>) FRANK = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> FRANK;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是在Spring中，<code>singleton单例</code>指的是每次从同一个IOC容器中返回同一个bean对象，单例的有效范围是IOC容器，而不是<code>ClassLoader</code>。IOC容器会将这个bean实例缓存起来，以供后续使用。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/07/5c8079052f7de.png\" alt=\"20190307095059.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190307095059.png</div>\n            </figure>\n<p>下面做一个小实验验证一下：</p>\n<p>先写一个测试类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestScope</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testSingleton</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tApplicationContext context = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"test-bean.xml\"</span>);</span><br><span class=\"line\">\t\tTestBean bean = (TestBean) context.getBean(<span class=\"string\">\"testBean\"</span>);</span><br><span class=\"line\">\t\tAssert.assertEquals(bean.getNum() , <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tbean.add();</span><br><span class=\"line\">\t\tAssert.assertEquals(bean.getNum() , <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tTestBean bean1 = (TestBean) context.getBean(<span class=\"string\">\"testBean\"</span>);</span><br><span class=\"line\">\t\tAssert.assertEquals(bean1.getNum() , <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tbean1.add();</span><br><span class=\"line\">\t\tAssert.assertEquals(bean1.getNum() , <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tApplicationContext context1 = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"test-bean.xml\"</span>);</span><br><span class=\"line\">\t\tTestBean bean2 = (TestBean) context1.getBean(<span class=\"string\">\"testBean\"</span>);</span><br><span class=\"line\">\t\tAssert.assertEquals(bean2.getNum() , <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tbean2.add();</span><br><span class=\"line\">\t\tAssert.assertEquals(bean2.getNum() , <span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBean</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> num;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getNum</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> num;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setNum</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.num = num;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tnum++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是相应的配置文件<code>test-bean.xml</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN 2.0//EN\" \"http://www.springframework.org/dtd/spring-beans-2.0.dtd\"&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.frank.spring.bean.scope.TestBean\"</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"singleton\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>testBean</code>的<code>scope</code>为<code>singleton</code>，而变量<code>bean</code>和<code>bean1</code>所指向的实例都是从同一个IOC容器中获取的，所以获取的是同一个bean实例，因此分别对<code>bean</code>和<code>bean1</code>调用add方法后，num的值就会变成2。而<code>bean2</code>是从另一个IOC容器中获取的，所以它是一个新的实例，<code>num</code>的值便成了初始值0，调用<code>add</code>方法后，num的值变成了1。这样也验证了上面所说的<code>singleton</code>单例含义，指的是每一个IOC容器中仅存在一个实例。</p>\n<h3 id=\"prototype\"><a href=\"#prototype\" class=\"headerlink\" title=\"prototype\"></a>prototype</h3><p>接下来是另一个常用的scope：<code>prototype</code>。与<code>singleton</code>相反，设置为<code>prototype</code>的bean，每次调用容器的<code>getBean</code>方法或注入到另一个bean中时，都会返回一个新的实例。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/07/5c80fd2fc8df9.png\" alt=\"20190307191454.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190307191454.png</div>\n            </figure>\n<p>与其他的<code>scope</code>类型不同的是，Spring并不会管理设置为<code>prototype</code>的bean的整个生命周期，获取相关bean时，容器会实例化，或者装配相关的<code>prototype-bean</code>实例，然后返回给客户端，但不会保存<code>prototype-bean</code>的实例。所以，尽管所有的bean对象都会调用配置的初始化方法，但是<code>prototype-bean</code>并不会调用其配置的destroy方法。所以清理工作必须由客户端进行。所以，Spring容器对<code>prototype-bean</code> 的管理在一定程度上类似于 <code>new</code> 操作，对象创建后的事情将全部由客户端处理。</p>\n<p>仍旧用一个小栗子来进行测试：</p>\n<p>我们将上面的xml文件进行修改：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN 2.0//EN\" \"http://www.springframework.org/dtd/spring-beans-2.0.dtd\"&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.frank.spring.bean.scope.TestBean\"</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"prototype\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testPrototype</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ApplicationContext context = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"test-bean.xml\"</span>);</span><br><span class=\"line\">    TestBean bean = (TestBean) context.getBean(<span class=\"string\">\"testBean\"</span>);</span><br><span class=\"line\">    Assert.assertEquals(bean.getNum() , <span class=\"number\">0</span>);</span><br><span class=\"line\">    bean.add();</span><br><span class=\"line\">    Assert.assertEquals(bean.getNum() , <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    TestBean bean1 = (TestBean) context.getBean(<span class=\"string\">\"testBean\"</span>);</span><br><span class=\"line\">    Assert.assertEquals(bean1.getNum() , <span class=\"number\">0</span>);</span><br><span class=\"line\">    bean1.add();</span><br><span class=\"line\">    Assert.assertEquals(bean1.getNum() , <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里两次从同一个IOC容器中获取<code>testBean</code>，得到了两个不同的bean实例，这就是<code>prototype</code>的作用。</p>\n<p>接着，我们配置一个初始化方法和销毁方法，来测试一下：</p>\n<p>给TestBean类加两个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBean</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> num;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"init TestBean\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"destroy TestBean\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getNum</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> num;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setNum</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.num = num;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tnum++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在配置文件里设置它的初始化方法和销毁方法：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.frank.spring.bean.scope.TestBean\"</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"prototype\"</span>  <span class=\"attr\">init-method</span>=<span class=\"string\">\"init\"</span>  <span class=\"attr\">destroy-method</span>=<span class=\"string\">\"destroy\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>还是用之前的测试方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testPrototype</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ApplicationContext context = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"test-bean.xml\"</span>);</span><br><span class=\"line\">    TestBean bean = (TestBean) context.getBean(<span class=\"string\">\"testBean\"</span>);</span><br><span class=\"line\">    Assert.assertEquals(bean.getNum() , <span class=\"number\">0</span>);</span><br><span class=\"line\">    bean.add();</span><br><span class=\"line\">    Assert.assertEquals(bean.getNum() , <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    TestBean bean1 = (TestBean) context.getBean(<span class=\"string\">\"testBean\"</span>);</span><br><span class=\"line\">    Assert.assertEquals(bean1.getNum() , <span class=\"number\">0</span>);</span><br><span class=\"line\">    bean1.add();</span><br><span class=\"line\">    Assert.assertEquals(bean1.getNum() , <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init TestBean</span><br><span class=\"line\">init TestBean</span><br></pre></td></tr></table></figure>\n<p>可以看到，仅仅输出了初始化方法<code>init</code>中的内容，而没有输出销毁方法<code>destroy</code>中的内容，所以，对于<code>prototype-bean</code>而言，在xml中配置<code>destroy-method</code>属性是没有意义的，容器在创建这个bean实例后就抛弃它了，如果它持有的资源需要释放，则需要客户端进行手动释放才行。这大概就是亲生和领养的区别吧。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/07/5c81044d154bf.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>另外，如果将一个<code>prototype-bean</code>注入到一个<code>singleton-bean</code>中，那么每次从容器中获取的<code>singleton-bean</code>对应<code>prototype-bean</code>都是同一个，因为依赖注入仅会进行一次。</p>\n<h2 id=\"Request-amp-amp-Session-amp-amp-Application-amp-amp-WebSocket-Scopes\"><a href=\"#Request-amp-amp-Session-amp-amp-Application-amp-amp-WebSocket-Scopes\" class=\"headerlink\" title=\"Request &amp;&amp; Session &amp;&amp; Application &amp;&amp; WebSocket Scopes\"></a>Request &amp;&amp; Session &amp;&amp; Application &amp;&amp; WebSocket Scopes</h2><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/07/5c8106f6ae617.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p><code>request</code> 和 <code>session</code> 这两个你也许有所耳闻，但是 <code>application</code> 和 <code>websocket</code> 是什么鬼？竟然还有这样的神仙scope？？莫方，让我们来一探究竟。</p>\n<p>这几个类型的scope都只能在web环境下使用，如果使用 <code>ClassPathXmlApplicationContext</code> 来加载使用了该属性的bean，那么就会抛出异常。就像这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.IllegalStateException: No Scope registered <span class=\"keyword\">for</span> scope name <span class=\"string\">'request'</span></span><br></pre></td></tr></table></figure>\n<p>下面让我们依次来看看这几个值的作用。</p>\n<h3 id=\"request\"><a href=\"#request\" class=\"headerlink\" title=\"request\"></a>request</h3><p>如果将scope属性设置为 <code>request</code> 代表该bean的作用域为单个请求，请求结束，则bean将被销毁，第二次请求将会创建一个新的bean实例，让我们来验证一下。方便起见，创建一个springboot应用，然后创建一个配置类并指定其扫描的xml：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ImportResource</span>(locations = &#123;<span class=\"string\">\"classpath:application-bean.xml\"</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebConfiguration</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以下是xml中的内容：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span> <span class=\"attr\">xmlns:aop</span>=<span class=\"string\">\"http://www.springframework.org/schema/aop\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">            http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.frank.springboothello.model.TestBean\"</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"request\"</span> &gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">aop:scoped-proxy</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>下面是controller的内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestBean testBean;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestBean testBean1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/testBean\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testBean</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"==========request start==========\"</span>);</span><br><span class=\"line\">        System.out.println(testBean.getNum());</span><br><span class=\"line\">        testBean.add();</span><br><span class=\"line\">        System.out.println(testBean.getNum());</span><br><span class=\"line\">        System.out.println(testBean1.getNum());</span><br><span class=\"line\">        testBean1.add();</span><br><span class=\"line\">        System.out.println(testBean1.getNum());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"==========request end==========\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里还是使用之前的TestBean，也许细心的你会发现，这里有一个乱入的家伙：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:scoped-proxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/08/5c81c5cc0999a.png\" alt=\"20190308093050.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190308093050.png</div>\n            </figure>\n<p>这是个什么东西？？？</p>\n<p>这里其实是声明对该bean使用代理模式，这样做的话，容器在注入该bean的时候，将会使用<code>CGLib动态代理</code>为它创建一个代理对象，该对象拥有与原Bean相同的public接口并暴露，代理对象每次调用时，会从相应作用域范围内（这里是<code>request</code>）获取真正的<code>TestBean</code>对象。</p>\n<p>那么，为什么要这样做呢？</p>\n<p>因为被注入的bean（<code>testBean</code>）和目标bean（<code>HelloController</code>）的生命周期不一样，而同一个容器内的bean注入只会发生一次，你想想，<code>HelloController</code>是<code>singleton</code>的，只会实例化一次，如果不使用代理对象，就意味着我们只能将同一个<code>request-bean</code>注入到这个<code>singleton-bean</code>中，那之后的每次访问，都将调用同一个<code>testBean</code>实例，这不是我们想要的结果。我们希望<code>HelloController</code>是容器范围内单例的，同时想要一个作用域为 <code>Http Request</code> 的<code>testBean</code>实例，这时候，代理对象就扮演着不可或缺的角色了。</p>\n<p>另外，值得一提的是，如果我们对一个<code>scope</code>为<code>prototype</code>的bean使用<code>&lt;aop:scoped-proxy/&gt;</code>的话，那么每次调用该bean的方法都会创建一个新的实例，关于这一点，大家可以自行验证。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/08/5c8254687adf6.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>代理方式默认是<code>CGLib</code>，并且只有<code>public</code>方法会被代理，<code>private</code>方法是不会被代理的。如果我们想要使用基于<code>JDK</code>的代理来创建代理对象，那么只需要将aop标签中的<code>proxy-target-class</code>属性设置为false即可，就像这样：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:scoped-proxy</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">\"false\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>但有个条件，那就是这个bean必须要实现某个接口。</p>\n<p>我们再来跑一下代码验证一下，启动！</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/08/5c81c5066975f.png\" alt=\"20190308092733.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190308092733.png</div>\n            </figure>\n<p>接下来访问几次<code>http://127.0.0.1:8080/testBean</code>，输出如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==========request start==========</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\">==========request end==========</span><br><span class=\"line\">==========request start==========</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\">==========request end==========</span><br></pre></td></tr></table></figure>\n<p>嗯，一切都在掌控范围之内。</p>\n<h3 id=\"session\"><a href=\"#session\" class=\"headerlink\" title=\"session\"></a>session</h3><p>跟<code>request</code>类似，但它的生命周期更长一些，是在同一次会话范围内有效，也就是说如果不关闭浏览器，不管刷新多少次，都会访问同一个bean。</p>\n<p>我们将上面的xml稍作改动：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.frank.springboothello.model.TestBean\"</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"session\"</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">aop:scoped-proxy</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>再也运行一下，然后在页面刷新几次：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==========request start==========</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\">==========request end==========</span><br><span class=\"line\">==========request start==========</span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\">==========request end==========</span><br><span class=\"line\">==========request start==========</span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\">==========request end==========</span><br></pre></td></tr></table></figure>\n<p>可以看到，num的值一直的增加，可见我们访问的是同一个bean实例。</p>\n<p>然后，我们使用另一个浏览器继续访问该页面：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==========request start==========</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\">==========request end==========</span><br><span class=\"line\">==========request start==========</span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\">==========request end==========</span><br></pre></td></tr></table></figure>\n<p>发现num又从0开始计数了。这样就验证了我们对<code>session</code>作用域的想法。</p>\n<h3 id=\"application\"><a href=\"#application\" class=\"headerlink\" title=\"application\"></a>application</h3><p><code>application</code>的作用域比<code>session</code>又要更广一些，<code>session</code>作用域是针对一个 <code>Http Session</code>，而a<code>pplication</code>作用域，则是针对一个 <code>ServletContext</code> ，有点类似 <code>singleton</code>，但是<code>singleton</code>代表的是每个IOC容器中仅有一个实例，而同一个web应用中，是可能会有多个IOC容器的，但一个Web应用只会有一个 <code>ServletContext</code>，所以 <code>application</code> 才是web应用中货真价实的单例模式。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/08/5c8215620925e.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>来测试一下，继续修改上面的xml文件：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.frank.springboothello.model.TestBean\"</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"application\"</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">aop:scoped-proxy</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后再次启动后，疯狂访问。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==========request start==========</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\">==========request end==========</span><br><span class=\"line\">==========request start==========</span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\">==========request end==========</span><br><span class=\"line\">==========request start==========</span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\">==========request end==========</span><br></pre></td></tr></table></figure>\n<p>换个浏览器继续访问：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==========request start==========</span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\">==========request end==========</span><br><span class=\"line\">==========request start==========</span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\">==========request end==========</span><br></pre></td></tr></table></figure>\n<p>嗯，验证完毕。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/08/5c82552a6af48.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h3 id=\"websocket\"><a href=\"#websocket\" class=\"headerlink\" title=\"websocket\"></a>websocket</h3><p><code>websocket</code> 的作用范围是 <code>WebSocket</code> ，即在整个 <code>WebSocket</code> 中有效。</p>\n<p>emmmm，说实话，这个验证起来有点麻烦，摸索了半天没有找到正确姿势，所以。。。。如果有知道如何验证这一点的小伙伴欢迎留言补充。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/08/5c824b40b64cd.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h3 id=\"global-session\"><a href=\"#global-session\" class=\"headerlink\" title=\"global session\"></a>global session</h3><p>也许你会发现，很多博客中说的 <code>global session</code> 怎么不见了？？</p>\n<p>这你就不知道了吧，因为在最新版本（5.2.0.BUILD-SNAPSHOT）中<code>global session</code>早就被移除了。</p>\n<p>所以以后再有人问你，scope属性有哪几种可能值，分别代表什么含义的时候，就可以理直气壮的把这篇文章甩他脸上了。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/08/5c824e7fcae16.png\" alt=\"20190308191406.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190308191406.png</div>\n            </figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>关于 scope 的介绍到此就告一段落了，来做一个小结：</p>\n<ol>\n<li>singleton：单例模式，每次获取都返回同一个实例，相对于同一个IOC容器而言。</li>\n<li>prototype：原型模式，每次获取返回不同实例，创建后的生命周期不再由IOC容器管理。</li>\n<li>request：作用域为同一个 Http Request。</li>\n<li>session：作用域为同一个 Http Session。</li>\n<li>application：作用域为同一个WEB容器，可以看做Web应用中的单例模式。</li>\n<li>websocket：作用域为同一个WebSocket应用。</li>\n</ol>\n<p>希望这篇文章能对你有帮助，如果觉得还不错的话，记得分享给身边的小伙伴哦。</p>\n<p>让我们红尘作伴，活得潇潇洒洒。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/08/5c8255c88946b.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"scope-属性说明\"><a href=\"#scope-属性说明\" class=\"headerlink\" title=\"scope 属性说明\"></a>scope 属性说明</h2><p>在spring中，在xml中定义<code>bean</code>时，<code>scope</code>属性是用来声明<code>bean</code>的作用域的。对于这个属性，你也许已经很熟悉了，<code>singleton</code>和<code>prototype</code>信手捏来，甚至还能说出<code>request</code>、<code>session</code>、<code>global session</code>，scope不就只有这么几个值吗。</p>\n<p>emmm，话不要说太满，容易打脸。常见的各类博客中，一般只会介绍上面说到的几种可能值，但翻一翻官方的说明，你就会发现，事情并没有这么简单。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/07/5c8073af8fd16.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>这是官方文档中的介绍，scope属性一共有六种可能值，惊不惊喜，意不意外。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/07/5c80742434d0e.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>下面，就让我们来一一看看各个值代表的意义。</p>\n<h3 id=\"singleton\"><a href=\"#singleton\" class=\"headerlink\" title=\"singleton\"></a>singleton</h3><p><code>singleton</code>是scope属性的默认值，当我们把bean的scope属性设置为<code>singleton</code>时，代表将对该bean使用单例模式，单例想必大家都熟悉，也就是说每次使用该bean的id从容器中获取该bean的时候，都将会返回同一个bean实例。但这里的单例跟设计模式里的单例还有一些小区别。</p>\n<p>设计模式中的单例是通过硬编码，给某个类仅创建一个静态对象，并且只暴露一个接口来获取这个对象实例，因此，设计模式中的单例是相对<code>ClassLoader</code>而言的，同一个类加载器下只会有一个实例。</p>\n<p>下面就是经典的使用<code>double-check</code>实现的懒加载代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Singleton FRANK;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (FRANK == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (FRANK == <span class=\"keyword\">null</span>) FRANK = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> FRANK;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是在Spring中，<code>singleton单例</code>指的是每次从同一个IOC容器中返回同一个bean对象，单例的有效范围是IOC容器，而不是<code>ClassLoader</code>。IOC容器会将这个bean实例缓存起来，以供后续使用。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/07/5c8079052f7de.png\" alt=\"20190307095059.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190307095059.png</div>\n            </figure>\n<p>下面做一个小实验验证一下：</p>\n<p>先写一个测试类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestScope</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testSingleton</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tApplicationContext context = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"test-bean.xml\"</span>);</span><br><span class=\"line\">\t\tTestBean bean = (TestBean) context.getBean(<span class=\"string\">\"testBean\"</span>);</span><br><span class=\"line\">\t\tAssert.assertEquals(bean.getNum() , <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tbean.add();</span><br><span class=\"line\">\t\tAssert.assertEquals(bean.getNum() , <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tTestBean bean1 = (TestBean) context.getBean(<span class=\"string\">\"testBean\"</span>);</span><br><span class=\"line\">\t\tAssert.assertEquals(bean1.getNum() , <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tbean1.add();</span><br><span class=\"line\">\t\tAssert.assertEquals(bean1.getNum() , <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tApplicationContext context1 = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"test-bean.xml\"</span>);</span><br><span class=\"line\">\t\tTestBean bean2 = (TestBean) context1.getBean(<span class=\"string\">\"testBean\"</span>);</span><br><span class=\"line\">\t\tAssert.assertEquals(bean2.getNum() , <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tbean2.add();</span><br><span class=\"line\">\t\tAssert.assertEquals(bean2.getNum() , <span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBean</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> num;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getNum</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> num;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setNum</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.num = num;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tnum++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是相应的配置文件<code>test-bean.xml</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN 2.0//EN\" \"http://www.springframework.org/dtd/spring-beans-2.0.dtd\"&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.frank.spring.bean.scope.TestBean\"</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"singleton\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>testBean</code>的<code>scope</code>为<code>singleton</code>，而变量<code>bean</code>和<code>bean1</code>所指向的实例都是从同一个IOC容器中获取的，所以获取的是同一个bean实例，因此分别对<code>bean</code>和<code>bean1</code>调用add方法后，num的值就会变成2。而<code>bean2</code>是从另一个IOC容器中获取的，所以它是一个新的实例，<code>num</code>的值便成了初始值0，调用<code>add</code>方法后，num的值变成了1。这样也验证了上面所说的<code>singleton</code>单例含义，指的是每一个IOC容器中仅存在一个实例。</p>\n<h3 id=\"prototype\"><a href=\"#prototype\" class=\"headerlink\" title=\"prototype\"></a>prototype</h3><p>接下来是另一个常用的scope：<code>prototype</code>。与<code>singleton</code>相反，设置为<code>prototype</code>的bean，每次调用容器的<code>getBean</code>方法或注入到另一个bean中时，都会返回一个新的实例。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/07/5c80fd2fc8df9.png\" alt=\"20190307191454.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190307191454.png</div>\n            </figure>\n<p>与其他的<code>scope</code>类型不同的是，Spring并不会管理设置为<code>prototype</code>的bean的整个生命周期，获取相关bean时，容器会实例化，或者装配相关的<code>prototype-bean</code>实例，然后返回给客户端，但不会保存<code>prototype-bean</code>的实例。所以，尽管所有的bean对象都会调用配置的初始化方法，但是<code>prototype-bean</code>并不会调用其配置的destroy方法。所以清理工作必须由客户端进行。所以，Spring容器对<code>prototype-bean</code> 的管理在一定程度上类似于 <code>new</code> 操作，对象创建后的事情将全部由客户端处理。</p>\n<p>仍旧用一个小栗子来进行测试：</p>\n<p>我们将上面的xml文件进行修改：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN 2.0//EN\" \"http://www.springframework.org/dtd/spring-beans-2.0.dtd\"&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.frank.spring.bean.scope.TestBean\"</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"prototype\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testPrototype</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ApplicationContext context = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"test-bean.xml\"</span>);</span><br><span class=\"line\">    TestBean bean = (TestBean) context.getBean(<span class=\"string\">\"testBean\"</span>);</span><br><span class=\"line\">    Assert.assertEquals(bean.getNum() , <span class=\"number\">0</span>);</span><br><span class=\"line\">    bean.add();</span><br><span class=\"line\">    Assert.assertEquals(bean.getNum() , <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    TestBean bean1 = (TestBean) context.getBean(<span class=\"string\">\"testBean\"</span>);</span><br><span class=\"line\">    Assert.assertEquals(bean1.getNum() , <span class=\"number\">0</span>);</span><br><span class=\"line\">    bean1.add();</span><br><span class=\"line\">    Assert.assertEquals(bean1.getNum() , <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里两次从同一个IOC容器中获取<code>testBean</code>，得到了两个不同的bean实例，这就是<code>prototype</code>的作用。</p>\n<p>接着，我们配置一个初始化方法和销毁方法，来测试一下：</p>\n<p>给TestBean类加两个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBean</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> num;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"init TestBean\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"destroy TestBean\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getNum</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> num;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setNum</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.num = num;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tnum++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在配置文件里设置它的初始化方法和销毁方法：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.frank.spring.bean.scope.TestBean\"</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"prototype\"</span>  <span class=\"attr\">init-method</span>=<span class=\"string\">\"init\"</span>  <span class=\"attr\">destroy-method</span>=<span class=\"string\">\"destroy\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>还是用之前的测试方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testPrototype</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ApplicationContext context = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"test-bean.xml\"</span>);</span><br><span class=\"line\">    TestBean bean = (TestBean) context.getBean(<span class=\"string\">\"testBean\"</span>);</span><br><span class=\"line\">    Assert.assertEquals(bean.getNum() , <span class=\"number\">0</span>);</span><br><span class=\"line\">    bean.add();</span><br><span class=\"line\">    Assert.assertEquals(bean.getNum() , <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    TestBean bean1 = (TestBean) context.getBean(<span class=\"string\">\"testBean\"</span>);</span><br><span class=\"line\">    Assert.assertEquals(bean1.getNum() , <span class=\"number\">0</span>);</span><br><span class=\"line\">    bean1.add();</span><br><span class=\"line\">    Assert.assertEquals(bean1.getNum() , <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init TestBean</span><br><span class=\"line\">init TestBean</span><br></pre></td></tr></table></figure>\n<p>可以看到，仅仅输出了初始化方法<code>init</code>中的内容，而没有输出销毁方法<code>destroy</code>中的内容，所以，对于<code>prototype-bean</code>而言，在xml中配置<code>destroy-method</code>属性是没有意义的，容器在创建这个bean实例后就抛弃它了，如果它持有的资源需要释放，则需要客户端进行手动释放才行。这大概就是亲生和领养的区别吧。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/07/5c81044d154bf.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>另外，如果将一个<code>prototype-bean</code>注入到一个<code>singleton-bean</code>中，那么每次从容器中获取的<code>singleton-bean</code>对应<code>prototype-bean</code>都是同一个，因为依赖注入仅会进行一次。</p>\n<h2 id=\"Request-amp-amp-Session-amp-amp-Application-amp-amp-WebSocket-Scopes\"><a href=\"#Request-amp-amp-Session-amp-amp-Application-amp-amp-WebSocket-Scopes\" class=\"headerlink\" title=\"Request &amp;&amp; Session &amp;&amp; Application &amp;&amp; WebSocket Scopes\"></a>Request &amp;&amp; Session &amp;&amp; Application &amp;&amp; WebSocket Scopes</h2><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/07/5c8106f6ae617.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p><code>request</code> 和 <code>session</code> 这两个你也许有所耳闻，但是 <code>application</code> 和 <code>websocket</code> 是什么鬼？竟然还有这样的神仙scope？？莫方，让我们来一探究竟。</p>\n<p>这几个类型的scope都只能在web环境下使用，如果使用 <code>ClassPathXmlApplicationContext</code> 来加载使用了该属性的bean，那么就会抛出异常。就像这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.IllegalStateException: No Scope registered <span class=\"keyword\">for</span> scope name <span class=\"string\">'request'</span></span><br></pre></td></tr></table></figure>\n<p>下面让我们依次来看看这几个值的作用。</p>\n<h3 id=\"request\"><a href=\"#request\" class=\"headerlink\" title=\"request\"></a>request</h3><p>如果将scope属性设置为 <code>request</code> 代表该bean的作用域为单个请求，请求结束，则bean将被销毁，第二次请求将会创建一个新的bean实例，让我们来验证一下。方便起见，创建一个springboot应用，然后创建一个配置类并指定其扫描的xml：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ImportResource</span>(locations = &#123;<span class=\"string\">\"classpath:application-bean.xml\"</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebConfiguration</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以下是xml中的内容：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span> <span class=\"attr\">xmlns:aop</span>=<span class=\"string\">\"http://www.springframework.org/schema/aop\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">            http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.frank.springboothello.model.TestBean\"</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"request\"</span> &gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">aop:scoped-proxy</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>下面是controller的内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestBean testBean;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestBean testBean1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/testBean\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testBean</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"==========request start==========\"</span>);</span><br><span class=\"line\">        System.out.println(testBean.getNum());</span><br><span class=\"line\">        testBean.add();</span><br><span class=\"line\">        System.out.println(testBean.getNum());</span><br><span class=\"line\">        System.out.println(testBean1.getNum());</span><br><span class=\"line\">        testBean1.add();</span><br><span class=\"line\">        System.out.println(testBean1.getNum());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"==========request end==========\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里还是使用之前的TestBean，也许细心的你会发现，这里有一个乱入的家伙：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:scoped-proxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/08/5c81c5cc0999a.png\" alt=\"20190308093050.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190308093050.png</div>\n            </figure>\n<p>这是个什么东西？？？</p>\n<p>这里其实是声明对该bean使用代理模式，这样做的话，容器在注入该bean的时候，将会使用<code>CGLib动态代理</code>为它创建一个代理对象，该对象拥有与原Bean相同的public接口并暴露，代理对象每次调用时，会从相应作用域范围内（这里是<code>request</code>）获取真正的<code>TestBean</code>对象。</p>\n<p>那么，为什么要这样做呢？</p>\n<p>因为被注入的bean（<code>testBean</code>）和目标bean（<code>HelloController</code>）的生命周期不一样，而同一个容器内的bean注入只会发生一次，你想想，<code>HelloController</code>是<code>singleton</code>的，只会实例化一次，如果不使用代理对象，就意味着我们只能将同一个<code>request-bean</code>注入到这个<code>singleton-bean</code>中，那之后的每次访问，都将调用同一个<code>testBean</code>实例，这不是我们想要的结果。我们希望<code>HelloController</code>是容器范围内单例的，同时想要一个作用域为 <code>Http Request</code> 的<code>testBean</code>实例，这时候，代理对象就扮演着不可或缺的角色了。</p>\n<p>另外，值得一提的是，如果我们对一个<code>scope</code>为<code>prototype</code>的bean使用<code>&lt;aop:scoped-proxy/&gt;</code>的话，那么每次调用该bean的方法都会创建一个新的实例，关于这一点，大家可以自行验证。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/08/5c8254687adf6.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>代理方式默认是<code>CGLib</code>，并且只有<code>public</code>方法会被代理，<code>private</code>方法是不会被代理的。如果我们想要使用基于<code>JDK</code>的代理来创建代理对象，那么只需要将aop标签中的<code>proxy-target-class</code>属性设置为false即可，就像这样：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:scoped-proxy</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">\"false\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>但有个条件，那就是这个bean必须要实现某个接口。</p>\n<p>我们再来跑一下代码验证一下，启动！</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/08/5c81c5066975f.png\" alt=\"20190308092733.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190308092733.png</div>\n            </figure>\n<p>接下来访问几次<code>http://127.0.0.1:8080/testBean</code>，输出如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==========request start==========</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\">==========request end==========</span><br><span class=\"line\">==========request start==========</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\">==========request end==========</span><br></pre></td></tr></table></figure>\n<p>嗯，一切都在掌控范围之内。</p>\n<h3 id=\"session\"><a href=\"#session\" class=\"headerlink\" title=\"session\"></a>session</h3><p>跟<code>request</code>类似，但它的生命周期更长一些，是在同一次会话范围内有效，也就是说如果不关闭浏览器，不管刷新多少次，都会访问同一个bean。</p>\n<p>我们将上面的xml稍作改动：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.frank.springboothello.model.TestBean\"</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"session\"</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">aop:scoped-proxy</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>再也运行一下，然后在页面刷新几次：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==========request start==========</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\">==========request end==========</span><br><span class=\"line\">==========request start==========</span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\">==========request end==========</span><br><span class=\"line\">==========request start==========</span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\">==========request end==========</span><br></pre></td></tr></table></figure>\n<p>可以看到，num的值一直的增加，可见我们访问的是同一个bean实例。</p>\n<p>然后，我们使用另一个浏览器继续访问该页面：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==========request start==========</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\">==========request end==========</span><br><span class=\"line\">==========request start==========</span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\">==========request end==========</span><br></pre></td></tr></table></figure>\n<p>发现num又从0开始计数了。这样就验证了我们对<code>session</code>作用域的想法。</p>\n<h3 id=\"application\"><a href=\"#application\" class=\"headerlink\" title=\"application\"></a>application</h3><p><code>application</code>的作用域比<code>session</code>又要更广一些，<code>session</code>作用域是针对一个 <code>Http Session</code>，而a<code>pplication</code>作用域，则是针对一个 <code>ServletContext</code> ，有点类似 <code>singleton</code>，但是<code>singleton</code>代表的是每个IOC容器中仅有一个实例，而同一个web应用中，是可能会有多个IOC容器的，但一个Web应用只会有一个 <code>ServletContext</code>，所以 <code>application</code> 才是web应用中货真价实的单例模式。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/08/5c8215620925e.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>来测试一下，继续修改上面的xml文件：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.frank.springboothello.model.TestBean\"</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"application\"</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">aop:scoped-proxy</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后再次启动后，疯狂访问。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==========request start==========</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\">==========request end==========</span><br><span class=\"line\">==========request start==========</span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\">==========request end==========</span><br><span class=\"line\">==========request start==========</span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\">==========request end==========</span><br></pre></td></tr></table></figure>\n<p>换个浏览器继续访问：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==========request start==========</span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\">==========request end==========</span><br><span class=\"line\">==========request start==========</span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\">==========request end==========</span><br></pre></td></tr></table></figure>\n<p>嗯，验证完毕。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/08/5c82552a6af48.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h3 id=\"websocket\"><a href=\"#websocket\" class=\"headerlink\" title=\"websocket\"></a>websocket</h3><p><code>websocket</code> 的作用范围是 <code>WebSocket</code> ，即在整个 <code>WebSocket</code> 中有效。</p>\n<p>emmmm，说实话，这个验证起来有点麻烦，摸索了半天没有找到正确姿势，所以。。。。如果有知道如何验证这一点的小伙伴欢迎留言补充。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/08/5c824b40b64cd.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h3 id=\"global-session\"><a href=\"#global-session\" class=\"headerlink\" title=\"global session\"></a>global session</h3><p>也许你会发现，很多博客中说的 <code>global session</code> 怎么不见了？？</p>\n<p>这你就不知道了吧，因为在最新版本（5.2.0.BUILD-SNAPSHOT）中<code>global session</code>早就被移除了。</p>\n<p>所以以后再有人问你，scope属性有哪几种可能值，分别代表什么含义的时候，就可以理直气壮的把这篇文章甩他脸上了。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/08/5c824e7fcae16.png\" alt=\"20190308191406.png\" title=\"\">\n                </div>\n                <div class=\"image-caption\">20190308191406.png</div>\n            </figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>关于 scope 的介绍到此就告一段落了，来做一个小结：</p>\n<ol>\n<li>singleton：单例模式，每次获取都返回同一个实例，相对于同一个IOC容器而言。</li>\n<li>prototype：原型模式，每次获取返回不同实例，创建后的生命周期不再由IOC容器管理。</li>\n<li>request：作用域为同一个 Http Request。</li>\n<li>session：作用域为同一个 Http Session。</li>\n<li>application：作用域为同一个WEB容器，可以看做Web应用中的单例模式。</li>\n<li>websocket：作用域为同一个WebSocket应用。</li>\n</ol>\n<p>希望这篇文章能对你有帮助，如果觉得还不错的话，记得分享给身边的小伙伴哦。</p>\n<p>让我们红尘作伴，活得潇潇洒洒。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/03/08/5c8255c88946b.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>"},{"title":"【Spring源码解读】bean标签中的属性","date":"2019-03-05T01:25:05.000Z","categorys":["Spring"],"_content":"\n## 说明\n\n今天在阅读Spring源码的时候，发现在加载xml中的bean时，解析了很多标签，其中有常用的如：scope、autowire、lazy-init、init-method、destroy-method等等。但还有很多很少用甚至没用过的标签，看来对这个经常使用的框架，还是知之甚少，本着探索的精神，决定将bean中所有相关标签的作用做一次整理，以便完善自己的知识体系。\n\n另外，说明一下，使用的Spring源码版本为当前最新版本`5.2.0.BUILD-SNAPSHOT`，跟老版本中的相关代码可能会有少数差异。\n\n## bean标签中属性的解析 \n\nSpring中对bean标签属性解析的代码位于类：BeanDefinitionParserDelegate 的 parseBeanDefinitionAttributes 方法中，源码如下\n\n```java\npublic AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,\n        @Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) {\n\n    // 解析 singleton 属性，当前版本已不支持该属性，如使用将会抛出异常\n    if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {\n        error(\"Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration\", ele);\n    }\n    // 解析 scope 属性\n    else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {\n        bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));\n    }\n    else if (containingBean != null) {\n        // 如果当前 bean 没有设置 scope 属性且当前 bean 是其他 bean 的内部 bean，则设置为其外部 bean 的 scope 属性值\n        bd.setScope(containingBean.getScope());\n    }\n\n    // 解析 abstract 属性\n    if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {\n        bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));\n    }\n\n    // 解析 lazy-init 属性\n    String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);\n    if (isDefaultValue(lazyInit)) {\n        lazyInit = this.defaults.getLazyInit();\n    }\n    bd.setLazyInit(TRUE_VALUE.equals(lazyInit));\n\n    // 解析 autowire 属性\n    String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);\n    bd.setAutowireMode(getAutowireMode(autowire));\n\n    // 解析 depends-on 属性\n    if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {\n        String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);\n        bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));\n    }\n\n    // 解析 autowire-candidate 属性\n    String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);\n    if (isDefaultValue(autowireCandidate)) {\n        String candidatePattern = this.defaults.getAutowireCandidates();\n        if (candidatePattern != null) {\n            String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);\n            bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));\n        }\n    }\n    else {\n        bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));\n    }\n\n    // 解析 primary 属性\n    if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {\n        bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));\n    }\n\n    // 解析 init-method 属性\n    if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {\n        String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);\n        bd.setInitMethodName(initMethodName);\n    }\n    else if (this.defaults.getInitMethod() != null) {\n        // 如果没有设置该属性，则设置为默认值\n        bd.setInitMethodName(this.defaults.getInitMethod());\n        bd.setEnforceInitMethod(false);\n    }\n\n    // 解析 destroy-method 属性\n    if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {\n        String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);\n        bd.setDestroyMethodName(destroyMethodName);\n    }\n    else if (this.defaults.getDestroyMethod() != null) {\n        bd.setDestroyMethodName(this.defaults.getDestroyMethod());\n        bd.setEnforceDestroyMethod(false);\n    }\n\n    // 解析 factory-method 属性\n    if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {\n        bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));\n    }\n    \n    // 解析 factory-bean 属性\n    if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {\n        bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));\n    }\n\n    return bd;\n}\n```\n\n里面可以看到对 bean 标签中的很多属性进行了解析，接下来的几篇里，就来看看每个属性的作用。（第一个已经废弃的属性就不说了🙅‍）\n","source":"_posts/java/spring/source-code-analysis/spring-bean-attribute.md","raw":"---\ntitle: 【Spring源码解读】bean标签中的属性\ndate: 2019-03-05 09:25:05\ntags:\n- Spring\n- 源码解读\ncategorys:\n- Spring\n---\n\n## 说明\n\n今天在阅读Spring源码的时候，发现在加载xml中的bean时，解析了很多标签，其中有常用的如：scope、autowire、lazy-init、init-method、destroy-method等等。但还有很多很少用甚至没用过的标签，看来对这个经常使用的框架，还是知之甚少，本着探索的精神，决定将bean中所有相关标签的作用做一次整理，以便完善自己的知识体系。\n\n另外，说明一下，使用的Spring源码版本为当前最新版本`5.2.0.BUILD-SNAPSHOT`，跟老版本中的相关代码可能会有少数差异。\n\n## bean标签中属性的解析 \n\nSpring中对bean标签属性解析的代码位于类：BeanDefinitionParserDelegate 的 parseBeanDefinitionAttributes 方法中，源码如下\n\n```java\npublic AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,\n        @Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) {\n\n    // 解析 singleton 属性，当前版本已不支持该属性，如使用将会抛出异常\n    if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {\n        error(\"Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration\", ele);\n    }\n    // 解析 scope 属性\n    else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {\n        bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));\n    }\n    else if (containingBean != null) {\n        // 如果当前 bean 没有设置 scope 属性且当前 bean 是其他 bean 的内部 bean，则设置为其外部 bean 的 scope 属性值\n        bd.setScope(containingBean.getScope());\n    }\n\n    // 解析 abstract 属性\n    if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {\n        bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));\n    }\n\n    // 解析 lazy-init 属性\n    String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);\n    if (isDefaultValue(lazyInit)) {\n        lazyInit = this.defaults.getLazyInit();\n    }\n    bd.setLazyInit(TRUE_VALUE.equals(lazyInit));\n\n    // 解析 autowire 属性\n    String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);\n    bd.setAutowireMode(getAutowireMode(autowire));\n\n    // 解析 depends-on 属性\n    if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {\n        String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);\n        bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));\n    }\n\n    // 解析 autowire-candidate 属性\n    String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);\n    if (isDefaultValue(autowireCandidate)) {\n        String candidatePattern = this.defaults.getAutowireCandidates();\n        if (candidatePattern != null) {\n            String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);\n            bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));\n        }\n    }\n    else {\n        bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));\n    }\n\n    // 解析 primary 属性\n    if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {\n        bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));\n    }\n\n    // 解析 init-method 属性\n    if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {\n        String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);\n        bd.setInitMethodName(initMethodName);\n    }\n    else if (this.defaults.getInitMethod() != null) {\n        // 如果没有设置该属性，则设置为默认值\n        bd.setInitMethodName(this.defaults.getInitMethod());\n        bd.setEnforceInitMethod(false);\n    }\n\n    // 解析 destroy-method 属性\n    if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {\n        String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);\n        bd.setDestroyMethodName(destroyMethodName);\n    }\n    else if (this.defaults.getDestroyMethod() != null) {\n        bd.setDestroyMethodName(this.defaults.getDestroyMethod());\n        bd.setEnforceDestroyMethod(false);\n    }\n\n    // 解析 factory-method 属性\n    if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {\n        bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));\n    }\n    \n    // 解析 factory-bean 属性\n    if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {\n        bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));\n    }\n\n    return bd;\n}\n```\n\n里面可以看到对 bean 标签中的很多属性进行了解析，接下来的几篇里，就来看看每个属性的作用。（第一个已经废弃的属性就不说了🙅‍）\n","slug":"java/spring/source-code-analysis/spring-bean-attribute","published":1,"updated":"2019-06-04T01:29:57.423Z","_id":"cjxze3h0q00840cvwzteqlyfa","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>今天在阅读Spring源码的时候，发现在加载xml中的bean时，解析了很多标签，其中有常用的如：scope、autowire、lazy-init、init-method、destroy-method等等。但还有很多很少用甚至没用过的标签，看来对这个经常使用的框架，还是知之甚少，本着探索的精神，决定将bean中所有相关标签的作用做一次整理，以便完善自己的知识体系。</p>\n<p>另外，说明一下，使用的Spring源码版本为当前最新版本<code>5.2.0.BUILD-SNAPSHOT</code>，跟老版本中的相关代码可能会有少数差异。</p>\n<h2 id=\"bean标签中属性的解析\"><a href=\"#bean标签中属性的解析\" class=\"headerlink\" title=\"bean标签中属性的解析\"></a>bean标签中属性的解析</h2><p>Spring中对bean标签属性解析的代码位于类：BeanDefinitionParserDelegate 的 parseBeanDefinitionAttributes 方法中，源码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> AbstractBeanDefinition <span class=\"title\">parseBeanDefinitionAttributes</span><span class=\"params\">(Element ele, String beanName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        @Nullable BeanDefinition containingBean, AbstractBeanDefinition bd)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解析 singleton 属性，当前版本已不支持该属性，如使用将会抛出异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ele.hasAttribute(SINGLETON_ATTRIBUTE)) &#123;</span><br><span class=\"line\">        error(<span class=\"string\">\"Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration\"</span>, ele);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 解析 scope 属性</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ele.hasAttribute(SCOPE_ATTRIBUTE)) &#123;</span><br><span class=\"line\">        bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (containingBean != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前 bean 没有设置 scope 属性且当前 bean 是其他 bean 的内部 bean，则设置为其外部 bean 的 scope 属性值</span></span><br><span class=\"line\">        bd.setScope(containingBean.getScope());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解析 abstract 属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) &#123;</span><br><span class=\"line\">        bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解析 lazy-init 属性</span></span><br><span class=\"line\">    String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDefaultValue(lazyInit)) &#123;</span><br><span class=\"line\">        lazyInit = <span class=\"keyword\">this</span>.defaults.getLazyInit();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bd.setLazyInit(TRUE_VALUE.equals(lazyInit));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解析 autowire 属性</span></span><br><span class=\"line\">    String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);</span><br><span class=\"line\">    bd.setAutowireMode(getAutowireMode(autowire));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解析 depends-on 属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) &#123;</span><br><span class=\"line\">        String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);</span><br><span class=\"line\">        bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解析 autowire-candidate 属性</span></span><br><span class=\"line\">    String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDefaultValue(autowireCandidate)) &#123;</span><br><span class=\"line\">        String candidatePattern = <span class=\"keyword\">this</span>.defaults.getAutowireCandidates();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (candidatePattern != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);</span><br><span class=\"line\">            bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解析 primary 属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ele.hasAttribute(PRIMARY_ATTRIBUTE)) &#123;</span><br><span class=\"line\">        bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解析 init-method 属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) &#123;</span><br><span class=\"line\">        String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);</span><br><span class=\"line\">        bd.setInitMethodName(initMethodName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.defaults.getInitMethod() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果没有设置该属性，则设置为默认值</span></span><br><span class=\"line\">        bd.setInitMethodName(<span class=\"keyword\">this</span>.defaults.getInitMethod());</span><br><span class=\"line\">        bd.setEnforceInitMethod(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解析 destroy-method 属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) &#123;</span><br><span class=\"line\">        String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);</span><br><span class=\"line\">        bd.setDestroyMethodName(destroyMethodName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.defaults.getDestroyMethod() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        bd.setDestroyMethodName(<span class=\"keyword\">this</span>.defaults.getDestroyMethod());</span><br><span class=\"line\">        bd.setEnforceDestroyMethod(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解析 factory-method 属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) &#123;</span><br><span class=\"line\">        bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 解析 factory-bean 属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) &#123;</span><br><span class=\"line\">        bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bd;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>里面可以看到对 bean 标签中的很多属性进行了解析，接下来的几篇里，就来看看每个属性的作用。（第一个已经废弃的属性就不说了🙅‍）</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>今天在阅读Spring源码的时候，发现在加载xml中的bean时，解析了很多标签，其中有常用的如：scope、autowire、lazy-init、init-method、destroy-method等等。但还有很多很少用甚至没用过的标签，看来对这个经常使用的框架，还是知之甚少，本着探索的精神，决定将bean中所有相关标签的作用做一次整理，以便完善自己的知识体系。</p>\n<p>另外，说明一下，使用的Spring源码版本为当前最新版本<code>5.2.0.BUILD-SNAPSHOT</code>，跟老版本中的相关代码可能会有少数差异。</p>\n<h2 id=\"bean标签中属性的解析\"><a href=\"#bean标签中属性的解析\" class=\"headerlink\" title=\"bean标签中属性的解析\"></a>bean标签中属性的解析</h2><p>Spring中对bean标签属性解析的代码位于类：BeanDefinitionParserDelegate 的 parseBeanDefinitionAttributes 方法中，源码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> AbstractBeanDefinition <span class=\"title\">parseBeanDefinitionAttributes</span><span class=\"params\">(Element ele, String beanName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        @Nullable BeanDefinition containingBean, AbstractBeanDefinition bd)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解析 singleton 属性，当前版本已不支持该属性，如使用将会抛出异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ele.hasAttribute(SINGLETON_ATTRIBUTE)) &#123;</span><br><span class=\"line\">        error(<span class=\"string\">\"Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration\"</span>, ele);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 解析 scope 属性</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ele.hasAttribute(SCOPE_ATTRIBUTE)) &#123;</span><br><span class=\"line\">        bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (containingBean != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前 bean 没有设置 scope 属性且当前 bean 是其他 bean 的内部 bean，则设置为其外部 bean 的 scope 属性值</span></span><br><span class=\"line\">        bd.setScope(containingBean.getScope());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解析 abstract 属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) &#123;</span><br><span class=\"line\">        bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解析 lazy-init 属性</span></span><br><span class=\"line\">    String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDefaultValue(lazyInit)) &#123;</span><br><span class=\"line\">        lazyInit = <span class=\"keyword\">this</span>.defaults.getLazyInit();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bd.setLazyInit(TRUE_VALUE.equals(lazyInit));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解析 autowire 属性</span></span><br><span class=\"line\">    String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);</span><br><span class=\"line\">    bd.setAutowireMode(getAutowireMode(autowire));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解析 depends-on 属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) &#123;</span><br><span class=\"line\">        String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);</span><br><span class=\"line\">        bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解析 autowire-candidate 属性</span></span><br><span class=\"line\">    String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDefaultValue(autowireCandidate)) &#123;</span><br><span class=\"line\">        String candidatePattern = <span class=\"keyword\">this</span>.defaults.getAutowireCandidates();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (candidatePattern != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);</span><br><span class=\"line\">            bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解析 primary 属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ele.hasAttribute(PRIMARY_ATTRIBUTE)) &#123;</span><br><span class=\"line\">        bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解析 init-method 属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) &#123;</span><br><span class=\"line\">        String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);</span><br><span class=\"line\">        bd.setInitMethodName(initMethodName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.defaults.getInitMethod() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果没有设置该属性，则设置为默认值</span></span><br><span class=\"line\">        bd.setInitMethodName(<span class=\"keyword\">this</span>.defaults.getInitMethod());</span><br><span class=\"line\">        bd.setEnforceInitMethod(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解析 destroy-method 属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) &#123;</span><br><span class=\"line\">        String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);</span><br><span class=\"line\">        bd.setDestroyMethodName(destroyMethodName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.defaults.getDestroyMethod() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        bd.setDestroyMethodName(<span class=\"keyword\">this</span>.defaults.getDestroyMethod());</span><br><span class=\"line\">        bd.setEnforceDestroyMethod(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解析 factory-method 属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) &#123;</span><br><span class=\"line\">        bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 解析 factory-bean 属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) &#123;</span><br><span class=\"line\">        bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bd;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>里面可以看到对 bean 标签中的很多属性进行了解析，接下来的几篇里，就来看看每个属性的作用。（第一个已经废弃的属性就不说了🙅‍）</p>\n"},{"title":"【Mysql】Mysql索引为什么这么快？","date":"2019-06-04T01:31:52.000Z","categorys":["数据库"],"_content":"\n## 说明\n\n","source":"_posts/mysql/index/mysql-index-01.md","raw":"---\ntitle: 【Mysql】Mysql索引为什么这么快？\ndate: 2019-06-04 09:31:52\ntags:\n - mysql\n - 索引\ncategorys:\n - 数据库\n---\n\n## 说明\n\n","slug":"mysql/index/mysql-index-01","published":1,"updated":"2019-06-04T01:41:06.712Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxzito2m0000eus6yxhwf2r8","content":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2>","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2>"},{"title":"【Mysql】如果在Mysql中插入1000万条数据","date":"2019-06-04T01:37:41.000Z","categorys":["数据库"],"_content":"\n阅读本文大约需要：5分钟，本文口感：冰镇🍉\n\n## 说明\n\n看到这个标题，也许你的第一反应会是：？？？，莫名其妙插一千万条数据干嘛？嫌mysql空间太大？\n\n![](https://i.loli.net/2019/05/18/5cdf6539270f631562.jpg)\n\n莫方，自有妙用。想想看，如果你有一个上亿的项目，emmmm，别误会，我是说有可能会发展到上亿数据的项目，比如活动的领取记录表，虽然每次活动可能只有几万甚至几十万条数据，但是如果这个活动系统中创建的活动很多，一个月的数据增长量也许会达到百万甚至千万级别，一年下来，数据量可能就真上亿了。\n\n对于Mysql数据库来说，当数据量达到千万的量级时，可能就会发生一些变化，比如某些sql可能就会因为没有命中索引而十分缓慢，在一个上千万数据的表中进行非最左前缀模糊匹配时，你就会知道什么叫做绝望。所以初期看起来运行良好的程序，等到数据量增大到一定程度时，就容易变得十分缓慢。所以设计一个比较重要的数据表时，用假数据来跑一跑看sql的执行效率是个不错的选择。\n\n于是便有了本篇的话题，如何往Mysql中插入一千万条数据？\n\n## 初期准备\n\nMysql版本为8.0.11：\n\n![](https://i.loli.net/2019/06/05/5cf71abecc5be80960.png)\n\n默认存储引擎为InnoDB：\n\n![](https://i.loli.net/2019/06/05/5cf71e71d75b790847.png)\n\n先创建一个测试用的数据库以及测试用的一张表：\n\n![](https://i.loli.net/2019/06/05/5cf71c9e7335f90543.png)\n\n```sql\ncreate database if not exists test_db default charset utf8 collate utf8_general_ci;\n```\n\n上面这句就是创建数据库的命令，`if not exists` 代表如果不存在则创建，如果已存在则不执行。`default charset utf8 collate utf8_general_ci` 则为设置数据库的默认字符集为`utf8`，设置默认的字符比较规则为`utf8_general_ci`。\n\n说到字符集和比较规则，顺便提一句，每种字符集对应若干种比较规则，每种字符集都有默认的比较规则，`utf8_general_ci`是`utf8`的默认比较规则，`_ci`结尾代表这种比较规则不区分大小写。\n\n接下来创建测试用的表：\n\n![](https://i.loli.net/2019/06/10/5cfdb4f13ab8761814.png)\n\n```sql\ncreate table `order_detail` (\n    `id` bigint(11) not null auto_increment,\n    `order_no` varchar(50) not null comment '订单号',\n    `commodity_id` bigint(11) not null comment '商品id',\n    `amount` decimal(20,6) not null comment '订单金额',\n    `buyer_id` bigint(11) not null comment '付款人id',\n    `status` int(2) not null comment '订单状态',\n    `created_time` datetime not null comment '创建时间',\n    `updated_time` datetime not null comment '更新时间', \n    primary key(`id`)\n) engine InnoDB charset utf8mb4 collate utf8mb4_unicode_ci;\n```\n\n这里先不加索引，后续会比较有索引和没有索引的情况下，插入数据的效率。\n\n## 暴力插入法\n\n不管是啥，盘它就是了，撸起袖子就是干。新建一个 `springboot` 项目，","source":"_posts/mysql/index/how-to-insert-10-million-pieces-of-data-into-mysql.md","raw":"---\ntitle: 【Mysql】如果在Mysql中插入1000万条数据\ndate: 2019-06-04 09:37:41\ntags:\n - mysql\n - 测试\ncategorys:\n - 数据库\n---\n\n阅读本文大约需要：5分钟，本文口感：冰镇🍉\n\n## 说明\n\n看到这个标题，也许你的第一反应会是：？？？，莫名其妙插一千万条数据干嘛？嫌mysql空间太大？\n\n![](https://i.loli.net/2019/05/18/5cdf6539270f631562.jpg)\n\n莫方，自有妙用。想想看，如果你有一个上亿的项目，emmmm，别误会，我是说有可能会发展到上亿数据的项目，比如活动的领取记录表，虽然每次活动可能只有几万甚至几十万条数据，但是如果这个活动系统中创建的活动很多，一个月的数据增长量也许会达到百万甚至千万级别，一年下来，数据量可能就真上亿了。\n\n对于Mysql数据库来说，当数据量达到千万的量级时，可能就会发生一些变化，比如某些sql可能就会因为没有命中索引而十分缓慢，在一个上千万数据的表中进行非最左前缀模糊匹配时，你就会知道什么叫做绝望。所以初期看起来运行良好的程序，等到数据量增大到一定程度时，就容易变得十分缓慢。所以设计一个比较重要的数据表时，用假数据来跑一跑看sql的执行效率是个不错的选择。\n\n于是便有了本篇的话题，如何往Mysql中插入一千万条数据？\n\n## 初期准备\n\nMysql版本为8.0.11：\n\n![](https://i.loli.net/2019/06/05/5cf71abecc5be80960.png)\n\n默认存储引擎为InnoDB：\n\n![](https://i.loli.net/2019/06/05/5cf71e71d75b790847.png)\n\n先创建一个测试用的数据库以及测试用的一张表：\n\n![](https://i.loli.net/2019/06/05/5cf71c9e7335f90543.png)\n\n```sql\ncreate database if not exists test_db default charset utf8 collate utf8_general_ci;\n```\n\n上面这句就是创建数据库的命令，`if not exists` 代表如果不存在则创建，如果已存在则不执行。`default charset utf8 collate utf8_general_ci` 则为设置数据库的默认字符集为`utf8`，设置默认的字符比较规则为`utf8_general_ci`。\n\n说到字符集和比较规则，顺便提一句，每种字符集对应若干种比较规则，每种字符集都有默认的比较规则，`utf8_general_ci`是`utf8`的默认比较规则，`_ci`结尾代表这种比较规则不区分大小写。\n\n接下来创建测试用的表：\n\n![](https://i.loli.net/2019/06/10/5cfdb4f13ab8761814.png)\n\n```sql\ncreate table `order_detail` (\n    `id` bigint(11) not null auto_increment,\n    `order_no` varchar(50) not null comment '订单号',\n    `commodity_id` bigint(11) not null comment '商品id',\n    `amount` decimal(20,6) not null comment '订单金额',\n    `buyer_id` bigint(11) not null comment '付款人id',\n    `status` int(2) not null comment '订单状态',\n    `created_time` datetime not null comment '创建时间',\n    `updated_time` datetime not null comment '更新时间', \n    primary key(`id`)\n) engine InnoDB charset utf8mb4 collate utf8mb4_unicode_ci;\n```\n\n这里先不加索引，后续会比较有索引和没有索引的情况下，插入数据的效率。\n\n## 暴力插入法\n\n不管是啥，盘它就是了，撸起袖子就是干。新建一个 `springboot` 项目，","slug":"mysql/index/how-to-insert-10-million-pieces-of-data-into-mysql","published":1,"updated":"2019-07-12T03:03:58.135Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxzito4f0001eus69s0s8g0q","content":"<p>阅读本文大约需要：5分钟，本文口感：冰镇🍉</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>看到这个标题，也许你的第一反应会是：？？？，莫名其妙插一千万条数据干嘛？嫌mysql空间太大？</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/18/5cdf6539270f631562.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>莫方，自有妙用。想想看，如果你有一个上亿的项目，emmmm，别误会，我是说有可能会发展到上亿数据的项目，比如活动的领取记录表，虽然每次活动可能只有几万甚至几十万条数据，但是如果这个活动系统中创建的活动很多，一个月的数据增长量也许会达到百万甚至千万级别，一年下来，数据量可能就真上亿了。</p>\n<p>对于Mysql数据库来说，当数据量达到千万的量级时，可能就会发生一些变化，比如某些sql可能就会因为没有命中索引而十分缓慢，在一个上千万数据的表中进行非最左前缀模糊匹配时，你就会知道什么叫做绝望。所以初期看起来运行良好的程序，等到数据量增大到一定程度时，就容易变得十分缓慢。所以设计一个比较重要的数据表时，用假数据来跑一跑看sql的执行效率是个不错的选择。</p>\n<p>于是便有了本篇的话题，如何往Mysql中插入一千万条数据？</p>\n<h2 id=\"初期准备\"><a href=\"#初期准备\" class=\"headerlink\" title=\"初期准备\"></a>初期准备</h2><p>Mysql版本为8.0.11：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/06/05/5cf71abecc5be80960.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>默认存储引擎为InnoDB：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/06/05/5cf71e71d75b790847.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>先创建一个测试用的数据库以及测试用的一张表：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/06/05/5cf71c9e7335f90543.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">database</span> <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"keyword\">exists</span> test_db <span class=\"keyword\">default</span> <span class=\"keyword\">charset</span> utf8 <span class=\"keyword\">collate</span> utf8_general_ci;</span><br></pre></td></tr></table></figure>\n<p>上面这句就是创建数据库的命令，<code>if not exists</code> 代表如果不存在则创建，如果已存在则不执行。<code>default charset utf8 collate utf8_general_ci</code> 则为设置数据库的默认字符集为<code>utf8</code>，设置默认的字符比较规则为<code>utf8_general_ci</code>。</p>\n<p>说到字符集和比较规则，顺便提一句，每种字符集对应若干种比较规则，每种字符集都有默认的比较规则，<code>utf8_general_ci</code>是<code>utf8</code>的默认比较规则，<code>_ci</code>结尾代表这种比较规则不区分大小写。</p>\n<p>接下来创建测试用的表：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/06/10/5cfdb4f13ab8761814.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> <span class=\"string\">`order_detail`</span> (</span><br><span class=\"line\">    <span class=\"string\">`id`</span> <span class=\"built_in\">bigint</span>(<span class=\"number\">11</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span> auto_increment,</span><br><span class=\"line\">    <span class=\"string\">`order_no`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">50</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span> <span class=\"keyword\">comment</span> <span class=\"string\">'订单号'</span>,</span><br><span class=\"line\">    <span class=\"string\">`commodity_id`</span> <span class=\"built_in\">bigint</span>(<span class=\"number\">11</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span> <span class=\"keyword\">comment</span> <span class=\"string\">'商品id'</span>,</span><br><span class=\"line\">    <span class=\"string\">`amount`</span> <span class=\"built_in\">decimal</span>(<span class=\"number\">20</span>,<span class=\"number\">6</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span> <span class=\"keyword\">comment</span> <span class=\"string\">'订单金额'</span>,</span><br><span class=\"line\">    <span class=\"string\">`buyer_id`</span> <span class=\"built_in\">bigint</span>(<span class=\"number\">11</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span> <span class=\"keyword\">comment</span> <span class=\"string\">'付款人id'</span>,</span><br><span class=\"line\">    <span class=\"string\">`status`</span> <span class=\"built_in\">int</span>(<span class=\"number\">2</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span> <span class=\"keyword\">comment</span> <span class=\"string\">'订单状态'</span>,</span><br><span class=\"line\">    <span class=\"string\">`created_time`</span> datetime <span class=\"keyword\">not</span> <span class=\"literal\">null</span> <span class=\"keyword\">comment</span> <span class=\"string\">'创建时间'</span>,</span><br><span class=\"line\">    <span class=\"string\">`updated_time`</span> datetime <span class=\"keyword\">not</span> <span class=\"literal\">null</span> <span class=\"keyword\">comment</span> <span class=\"string\">'更新时间'</span>, </span><br><span class=\"line\">    primary <span class=\"keyword\">key</span>(<span class=\"string\">`id`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">engine</span> <span class=\"keyword\">InnoDB</span> <span class=\"keyword\">charset</span> utf8mb4 <span class=\"keyword\">collate</span> utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>\n<p>这里先不加索引，后续会比较有索引和没有索引的情况下，插入数据的效率。</p>\n<h2 id=\"暴力插入法\"><a href=\"#暴力插入法\" class=\"headerlink\" title=\"暴力插入法\"></a>暴力插入法</h2><p>不管是啥，盘它就是了，撸起袖子就是干。新建一个 <code>springboot</code> 项目，</p>\n","site":{"data":{"menu":{"Home":"/","Gallery":"/gallery/","Archives":"/archives/"}}},"excerpt":"","more":"<p>阅读本文大约需要：5分钟，本文口感：冰镇🍉</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>看到这个标题，也许你的第一反应会是：？？？，莫名其妙插一千万条数据干嘛？嫌mysql空间太大？</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/05/18/5cdf6539270f631562.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>莫方，自有妙用。想想看，如果你有一个上亿的项目，emmmm，别误会，我是说有可能会发展到上亿数据的项目，比如活动的领取记录表，虽然每次活动可能只有几万甚至几十万条数据，但是如果这个活动系统中创建的活动很多，一个月的数据增长量也许会达到百万甚至千万级别，一年下来，数据量可能就真上亿了。</p>\n<p>对于Mysql数据库来说，当数据量达到千万的量级时，可能就会发生一些变化，比如某些sql可能就会因为没有命中索引而十分缓慢，在一个上千万数据的表中进行非最左前缀模糊匹配时，你就会知道什么叫做绝望。所以初期看起来运行良好的程序，等到数据量增大到一定程度时，就容易变得十分缓慢。所以设计一个比较重要的数据表时，用假数据来跑一跑看sql的执行效率是个不错的选择。</p>\n<p>于是便有了本篇的话题，如何往Mysql中插入一千万条数据？</p>\n<h2 id=\"初期准备\"><a href=\"#初期准备\" class=\"headerlink\" title=\"初期准备\"></a>初期准备</h2><p>Mysql版本为8.0.11：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/06/05/5cf71abecc5be80960.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>默认存储引擎为InnoDB：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/06/05/5cf71e71d75b790847.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>先创建一个测试用的数据库以及测试用的一张表：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/06/05/5cf71c9e7335f90543.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">database</span> <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"keyword\">exists</span> test_db <span class=\"keyword\">default</span> <span class=\"keyword\">charset</span> utf8 <span class=\"keyword\">collate</span> utf8_general_ci;</span><br></pre></td></tr></table></figure>\n<p>上面这句就是创建数据库的命令，<code>if not exists</code> 代表如果不存在则创建，如果已存在则不执行。<code>default charset utf8 collate utf8_general_ci</code> 则为设置数据库的默认字符集为<code>utf8</code>，设置默认的字符比较规则为<code>utf8_general_ci</code>。</p>\n<p>说到字符集和比较规则，顺便提一句，每种字符集对应若干种比较规则，每种字符集都有默认的比较规则，<code>utf8_general_ci</code>是<code>utf8</code>的默认比较规则，<code>_ci</code>结尾代表这种比较规则不区分大小写。</p>\n<p>接下来创建测试用的表：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://i.loli.net/2019/06/10/5cfdb4f13ab8761814.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> <span class=\"string\">`order_detail`</span> (</span><br><span class=\"line\">    <span class=\"string\">`id`</span> <span class=\"built_in\">bigint</span>(<span class=\"number\">11</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span> auto_increment,</span><br><span class=\"line\">    <span class=\"string\">`order_no`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">50</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span> <span class=\"keyword\">comment</span> <span class=\"string\">'订单号'</span>,</span><br><span class=\"line\">    <span class=\"string\">`commodity_id`</span> <span class=\"built_in\">bigint</span>(<span class=\"number\">11</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span> <span class=\"keyword\">comment</span> <span class=\"string\">'商品id'</span>,</span><br><span class=\"line\">    <span class=\"string\">`amount`</span> <span class=\"built_in\">decimal</span>(<span class=\"number\">20</span>,<span class=\"number\">6</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span> <span class=\"keyword\">comment</span> <span class=\"string\">'订单金额'</span>,</span><br><span class=\"line\">    <span class=\"string\">`buyer_id`</span> <span class=\"built_in\">bigint</span>(<span class=\"number\">11</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span> <span class=\"keyword\">comment</span> <span class=\"string\">'付款人id'</span>,</span><br><span class=\"line\">    <span class=\"string\">`status`</span> <span class=\"built_in\">int</span>(<span class=\"number\">2</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span> <span class=\"keyword\">comment</span> <span class=\"string\">'订单状态'</span>,</span><br><span class=\"line\">    <span class=\"string\">`created_time`</span> datetime <span class=\"keyword\">not</span> <span class=\"literal\">null</span> <span class=\"keyword\">comment</span> <span class=\"string\">'创建时间'</span>,</span><br><span class=\"line\">    <span class=\"string\">`updated_time`</span> datetime <span class=\"keyword\">not</span> <span class=\"literal\">null</span> <span class=\"keyword\">comment</span> <span class=\"string\">'更新时间'</span>, </span><br><span class=\"line\">    primary <span class=\"keyword\">key</span>(<span class=\"string\">`id`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">engine</span> <span class=\"keyword\">InnoDB</span> <span class=\"keyword\">charset</span> utf8mb4 <span class=\"keyword\">collate</span> utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>\n<p>这里先不加索引，后续会比较有索引和没有索引的情况下，插入数据的效率。</p>\n<h2 id=\"暴力插入法\"><a href=\"#暴力插入法\" class=\"headerlink\" title=\"暴力插入法\"></a>暴力插入法</h2><p>不管是啥，盘它就是了，撸起袖子就是干。新建一个 <code>springboot</code> 项目，</p>\n"}],"PostAsset":[{"_id":"source/_posts/leetcode/day3-longest-substring-without-repeating-characters/day3-step-7.png","slug":"day3-step-7.png","post":"cjxze3gkw000c0cvwhvfuzczx","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_ECCF05DEC924-1.jpeg","slug":"IMG_ECCF05DEC924-1.jpeg","post":"cjxze3gno000t0cvwe73qcbbe","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/complete-knapsack-problem/IMG_6B67BF7CC3A7-1.jpeg","slug":"IMG_6B67BF7CC3A7-1.jpeg","post":"cjxze3gno000q0cvw8bbq0vax","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/example4.png","slug":"example4.png","post":"cjxze3gpc001y0cvw806qtrv7","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_04E34B950C69-1.jpeg","slug":"IMG_04E34B950C69-1.jpeg","post":"cjxze3gno000t0cvwe73qcbbe","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_CD2E7F29F646-1.jpeg","slug":"IMG_CD2E7F29F646-1.jpeg","post":"cjxze3gno000t0cvwe73qcbbe","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_F047D511640B-1.jpeg","slug":"IMG_F047D511640B-1.jpeg","post":"cjxze3gno000t0cvwe73qcbbe","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_482BA28A5E66-1.jpeg","slug":"IMG_482BA28A5E66-1.jpeg","post":"cjxze3gno000t0cvwe73qcbbe","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_E5B595A5513F-1.jpeg","slug":"IMG_E5B595A5513F-1.jpeg","post":"cjxze3gno000t0cvwe73qcbbe","modified":0,"renderable":0},{"_id":"source/_posts/shell/gotossh-update/login-server3.gif","slug":"login-server3.gif","post":"cjxze3gpc00250cvwda23pozc","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/fib.png","slug":"fib.png","post":"cjxze3gpc001y0cvw806qtrv7","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/solution1-3.png","slug":"solution1-3.png","post":"cjxze3gpc001y0cvw806qtrv7","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/solution2-2.png","slug":"solution2-2.png","post":"cjxze3gpc001y0cvw806qtrv7","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/solution2-1.png","slug":"solution2-1.png","post":"cjxze3gpc001y0cvw806qtrv7","modified":0,"renderable":0},{"_id":"source/_posts/shell/gotossh-update/login-server4.gif","slug":"login-server4.gif","post":"cjxze3gpc00250cvwda23pozc","modified":0,"renderable":0},{"_id":"source/_posts/shell/gotossh-v3-md/login-and-view-the-log.gif","slug":"login-and-view-the-log.gif","post":"cjxze3gq600340cvwa3a902j4","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-environment-mac/2-jdk-mac.png","slug":"2-jdk-mac.png","post":"cjxze3guc00400cvw3xggpta5","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day1-two-sum/exhaust-algorithm.png","slug":"exhaust-algorithm.png","post":"cjxze3gkw000a0cvw568fw4pv","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day1-two-sum/map-solution.png","slug":"map-solution.png","post":"cjxze3gkw000a0cvw568fw4pv","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/complete-knapsack-problem/CodeCogsEqn.png","slug":"CodeCogsEqn.png","post":"cjxze3gno000q0cvw8bbq0vax","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/complete-knapsack-problem/IMG_510B188AF928-1.jpeg","slug":"IMG_510B188AF928-1.jpeg","post":"cjxze3gno000q0cvw8bbq0vax","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/complete-knapsack-problem/IMG_5E156B07E228-1.jpeg","slug":"IMG_5E156B07E228-1.jpeg","post":"cjxze3gno000q0cvw8bbq0vax","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day2-add-two-numbers/result-5.png","slug":"result-5.png","post":"cjxze3gno000r0cvwwkqf9oyy","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day2-add-two-numbers/solution-1.png","slug":"solution-1.png","post":"cjxze3gno000r0cvwwkqf9oyy","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day2-add-two-numbers/solution-2.png","slug":"solution-2.png","post":"cjxze3gno000r0cvwwkqf9oyy","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day2-add-two-numbers/solution-3.png","slug":"solution-3.png","post":"cjxze3gno000r0cvwwkqf9oyy","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day2-add-two-numbers/solution-4.png","slug":"solution-4.png","post":"cjxze3gno000r0cvwwkqf9oyy","modified":0,"renderable":0},{"_id":"source/_posts/shell/gotossh-update/jump.gif","slug":"jump.gif","post":"cjxze3gpc00250cvwda23pozc","modified":0,"renderable":0},{"_id":"source/_posts/shell/gotossh-update/scp-server3-log.gif","slug":"scp-server3-log.gif","post":"cjxze3gpc00250cvwda23pozc","modified":0,"renderable":0},{"_id":"source/_posts/shell/gotossh-update/scp-server4-log.gif","slug":"scp-server4-log.gif","post":"cjxze3gpc00250cvwda23pozc","modified":0,"renderable":0},{"_id":"source/_posts/shell/gotossh-update/server3-log.gif","slug":"server3-log.gif","post":"cjxze3gpc00250cvwda23pozc","modified":0,"renderable":0},{"_id":"source/_posts/shell/gotossh-update/server4-log.gif","slug":"server4-log.gif","post":"cjxze3gpc00250cvwda23pozc","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day3-longest-substring-without-repeating-characters/day3-step-1.png","slug":"day3-step-1.png","post":"cjxze3gkw000c0cvwhvfuzczx","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day3-longest-substring-without-repeating-characters/day3-step-2.png","slug":"day3-step-2.png","post":"cjxze3gkw000c0cvwhvfuzczx","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day3-longest-substring-without-repeating-characters/day3-step-3.png","slug":"day3-step-3.png","post":"cjxze3gkw000c0cvwhvfuzczx","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day3-longest-substring-without-repeating-characters/day3-step-4.png","slug":"day3-step-4.png","post":"cjxze3gkw000c0cvwhvfuzczx","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day3-longest-substring-without-repeating-characters/day3-step-5.png","slug":"day3-step-5.png","post":"cjxze3gkw000c0cvwhvfuzczx","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day3-longest-substring-without-repeating-characters/day3-step-6.png","slug":"day3-step-6.png","post":"cjxze3gkw000c0cvwhvfuzczx","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day3-longest-substring-without-repeating-characters/day3-step-8.png","slug":"day3-step-8.png","post":"cjxze3gkw000c0cvwhvfuzczx","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day3-longest-substring-without-repeating-characters/day3-submit-1.png","slug":"day3-submit-1.png","post":"cjxze3gkw000c0cvwhvfuzczx","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day3-longest-substring-without-repeating-characters/day3-submit-2.png","slug":"day3-submit-2.png","post":"cjxze3gkw000c0cvwhvfuzczx","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-environment-mac/3-jdk-mac.png","slug":"3-jdk-mac.png","post":"cjxze3guc00400cvw3xggpta5","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_007B2F2632D2-1.jpeg","slug":"IMG_007B2F2632D2-1.jpeg","post":"cjxze3gno000t0cvwe73qcbbe","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_13B30A586085-1.jpeg","slug":"IMG_13B30A586085-1.jpeg","post":"cjxze3gno000t0cvwe73qcbbe","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_142D1BF09ED7-1.jpeg","slug":"IMG_142D1BF09ED7-1.jpeg","post":"cjxze3gno000t0cvwe73qcbbe","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_16ACD9FB2E1C-1.jpeg","slug":"IMG_16ACD9FB2E1C-1.jpeg","post":"cjxze3gno000t0cvwe73qcbbe","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_2ABCC82C89F7-1.jpeg","slug":"IMG_2ABCC82C89F7-1.jpeg","post":"cjxze3gno000t0cvwe73qcbbe","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_339C2E86CD88-1.jpeg","slug":"IMG_339C2E86CD88-1.jpeg","post":"cjxze3gno000t0cvwe73qcbbe","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_37EAFFF048DB-1.jpeg","slug":"IMG_37EAFFF048DB-1.jpeg","post":"cjxze3gno000t0cvwe73qcbbe","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_9B418BF0E7A5-1.jpeg","slug":"IMG_9B418BF0E7A5-1.jpeg","post":"cjxze3gno000t0cvwe73qcbbe","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/dp-01-knapsack-problem/IMG_BFE9B7063670-1.jpeg","slug":"IMG_BFE9B7063670-1.jpeg","post":"cjxze3gno000t0cvwe73qcbbe","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/example1.png","slug":"example1.png","post":"cjxze3gpc001y0cvw806qtrv7","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/example2.png","slug":"example2.png","post":"cjxze3gpc001y0cvw806qtrv7","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/example3.png","slug":"example3.png","post":"cjxze3gpc001y0cvw806qtrv7","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/example5.png","slug":"example5.png","post":"cjxze3gpc001y0cvw806qtrv7","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/result1.png","slug":"result1.png","post":"cjxze3gpc001y0cvw806qtrv7","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/result2.png","slug":"result2.png","post":"cjxze3gpc001y0cvw806qtrv7","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/result3.png","slug":"result3.png","post":"cjxze3gpc001y0cvw806qtrv7","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/solution1-1.png","slug":"solution1-1.png","post":"cjxze3gpc001y0cvw806qtrv7","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/solution1-2.png","slug":"solution1-2.png","post":"cjxze3gpc001y0cvw806qtrv7","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/day4-regular-expression-matching/solution1-4.png","slug":"solution1-4.png","post":"cjxze3gpc001y0cvw806qtrv7","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-ide/java-ide-2.png","slug":"java-ide-2.png","post":"cjxze3gvg004l0cvwekducab4","modified":0,"renderable":0},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/carbon (5).png","slug":"carbon (5).png","post":"cjxze3gwa00550cvwlu8qcz9r","modified":0,"renderable":0},{"_id":"source/_posts/shell/gotossh-v3-md/list-all-the-commands.gif","slug":"list-all-the-commands.gif","post":"cjxze3gq600340cvwa3a902j4","modified":0,"renderable":0},{"_id":"source/_posts/shell/gotossh-v3-md/list-all-the-servers.gif","slug":"list-all-the-servers.gif","post":"cjxze3gq600340cvwa3a902j4","modified":0,"renderable":0},{"_id":"source/_posts/shell/gotossh-v3-md/login-and-view-the-log2.gif","slug":"login-and-view-the-log2.gif","post":"cjxze3gq600340cvwa3a902j4","modified":0,"renderable":0},{"_id":"source/_posts/shell/gotossh-v3-md/login-jump-server.gif","slug":"login-jump-server.gif","post":"cjxze3gq600340cvwa3a902j4","modified":0,"renderable":0},{"_id":"source/_posts/shell/gotossh-v3-md/login-online-server-and-view-the-log.gif","slug":"login-online-server-and-view-the-log.gif","post":"cjxze3gq600340cvwa3a902j4","modified":0,"renderable":0},{"_id":"source/_posts/shell/gotossh-v3-md/login-online-server.gif","slug":"login-online-server.gif","post":"cjxze3gq600340cvwa3a902j4","modified":0,"renderable":0},{"_id":"source/_posts/shell/gotossh-v3-md/login.gif","slug":"login.gif","post":"cjxze3gq600340cvwa3a902j4","modified":0,"renderable":0},{"_id":"source/_posts/shell/gotossh-v3-md/scp-jump-server-log.gif","slug":"scp-jump-server-log.gif","post":"cjxze3gq600340cvwa3a902j4","modified":0,"renderable":0},{"_id":"source/_posts/shell/gotossh-v3-md/scp-online-server-file.gif","slug":"scp-online-server-file.gif","post":"cjxze3gq600340cvwa3a902j4","modified":0,"renderable":0},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/carbon.png","slug":"carbon.png","post":"cjxze3gwa00550cvwlu8qcz9r","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-environment-mac/4-jdk-mac.png","slug":"4-jdk-mac.png","post":"cjxze3guc00400cvw3xggpta5","modified":0,"renderable":0},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/carbon (6).png","slug":"carbon (6).png","post":"cjxze3gwa00550cvwlu8qcz9r","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-started/java-started-1.png","slug":"java-started-1.png","post":"cjxze3gx400600cvw5txb31od","modified":0,"renderable":0},{"_id":"source/_posts/java/jvm/reachable/accessibility1.jpg","slug":"accessibility1.jpg","post":"cjxze3gwk00590cvwnvqe92ba","modified":0,"renderable":0},{"_id":"source/_posts/java/jvm/reachable/accessibility2.png","slug":"accessibility2.png","post":"cjxze3gwk00590cvwnvqe92ba","modified":0,"renderable":0},{"_id":"source/_posts/java/reference/reference-code-detail/reference-1.png","slug":"reference-1.png","post":"cjxze3gwu005t0cvw8r0uapym","modified":0,"renderable":0},{"_id":"source/_posts/java/reference/reference-code-detail/reference-2.png","slug":"reference-2.png","post":"cjxze3gwu005t0cvw8r0uapym","modified":0,"renderable":0},{"_id":"source/_posts/java/reference/soft-reference-code-detail/soft-reference-2.png","slug":"soft-reference-2.png","post":"cjxze3gxe00670cvwchtc3rmu","modified":0,"renderable":0},{"_id":"source/_posts/java/reference/soft-reference-code-detail/soft-reference-3.png","slug":"soft-reference-3.png","post":"cjxze3gxe00670cvwchtc3rmu","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-simple-example/java-simple-example-1.png","slug":"java-simple-example-1.png","post":"cjxze3gw0004r0cvwam3xiz7c","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-simple-example/java-simple-example-2.png","slug":"java-simple-example-2.png","post":"cjxze3gw0004r0cvwam3xiz7c","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-simple-example/java-simple-example-3.png","slug":"java-simple-example-3.png","post":"cjxze3gw0004r0cvwam3xiz7c","modified":0,"renderable":0},{"_id":"source/_posts/java/collection/weakhashmap-code-detail/0038.png","slug":"0038.png","post":"cjxze3guw004a0cvw1sd62ppr","modified":0,"renderable":0},{"_id":"source/_posts/java/collection/weakhashmap-code-detail/weakhashmap-1.png","slug":"weakhashmap-1.png","post":"cjxze3guw004a0cvw1sd62ppr","modified":0,"renderable":0},{"_id":"source/_posts/java/collection/weakhashmap-code-detail/weakhashmap-2.png","slug":"weakhashmap-2.png","post":"cjxze3guw004a0cvw1sd62ppr","modified":0,"renderable":0},{"_id":"source/_posts/java/collection/weakhashmap-code-detail/weakhashmap-3.png","slug":"weakhashmap-3.png","post":"cjxze3guw004a0cvw1sd62ppr","modified":0,"renderable":0},{"_id":"source/_posts/java/collection/weakhashmap-code-detail/weakhashmap-4.png","slug":"weakhashmap-4.png","post":"cjxze3guw004a0cvw1sd62ppr","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-ide/java-ide-1.png","slug":"java-ide-1.png","post":"cjxze3gvg004l0cvwekducab4","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-ide/java-ide-3.png","slug":"java-ide-3.png","post":"cjxze3gvg004l0cvwekducab4","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-ide/java-ide-4.png","slug":"java-ide-4.png","post":"cjxze3gvg004l0cvwekducab4","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-ide/java-ide-5.png","slug":"java-ide-5.png","post":"cjxze3gvg004l0cvwekducab4","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-ide/java-ide-6.png","slug":"java-ide-6.png","post":"cjxze3gvg004l0cvwekducab4","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-ide/java-ide-7.png","slug":"java-ide-7.png","post":"cjxze3gvg004l0cvwekducab4","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-ide/java-ide-8.png","slug":"java-ide-8.png","post":"cjxze3gvg004l0cvwekducab4","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-ide/java-ide-9.png","slug":"java-ide-9.png","post":"cjxze3gvg004l0cvwekducab4","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-environment-windows/1-jdk-windows.png","slug":"1-jdk-windows.png","post":"cjxze3gwu005q0cvwu5jx6eyy","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-environment-windows/2-jdk-windows.png","slug":"2-jdk-windows.png","post":"cjxze3gwu005q0cvwu5jx6eyy","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-environment-windows/3-jdk-windows.png","slug":"3-jdk-windows.png","post":"cjxze3gwu005q0cvwu5jx6eyy","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-environment-windows/4-jdk-windows.png","slug":"4-jdk-windows.png","post":"cjxze3gwu005q0cvwu5jx6eyy","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-environment-windows/5-jdk-windows.png","slug":"5-jdk-windows.png","post":"cjxze3gwu005q0cvwu5jx6eyy","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-environment-windows/6-jdk-windows.png","slug":"6-jdk-windows.png","post":"cjxze3gwu005q0cvwu5jx6eyy","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-environment-windows/7-jdk-windows.png","slug":"7-jdk-windows.png","post":"cjxze3gwu005q0cvwu5jx6eyy","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-environment-windows/8-jdk-windows.png","slug":"8-jdk-windows.png","post":"cjxze3gwu005q0cvwu5jx6eyy","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-environment-windows/9-jdk-windows.png","slug":"9-jdk-windows.png","post":"cjxze3gwu005q0cvwu5jx6eyy","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-environment-mac/1-jdk-mac.png","slug":"1-jdk-mac.png","post":"cjxze3guc00400cvw3xggpta5","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-environment-mac/10-jdk-mac.png","slug":"10-jdk-mac.png","post":"cjxze3guc00400cvw3xggpta5","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-environment-mac/11-jdk-mac.png","slug":"11-jdk-mac.png","post":"cjxze3guc00400cvw3xggpta5","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-environment-mac/12-jdk-mac.png","slug":"12-jdk-mac.png","post":"cjxze3guc00400cvw3xggpta5","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-environment-mac/13-jdk-mac.png","slug":"13-jdk-mac.png","post":"cjxze3guc00400cvw3xggpta5","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-environment-mac/14-jdk-mac.png","slug":"14-jdk-mac.png","post":"cjxze3guc00400cvw3xggpta5","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-environment-mac/15-jdk-mac.png","slug":"15-jdk-mac.png","post":"cjxze3guc00400cvw3xggpta5","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-environment-mac/16-jdk-mac.png","slug":"16-jdk-mac.png","post":"cjxze3guc00400cvw3xggpta5","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-environment-mac/5-jdk-mac.png","slug":"5-jdk-mac.png","post":"cjxze3guc00400cvw3xggpta5","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-environment-mac/6-jdk-mac.png","slug":"6-jdk-mac.png","post":"cjxze3guc00400cvw3xggpta5","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-environment-mac/7-jdk-mac.png","slug":"7-jdk-mac.png","post":"cjxze3guc00400cvw3xggpta5","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-environment-mac/8-jdk-mac.png","slug":"8-jdk-mac.png","post":"cjxze3guc00400cvw3xggpta5","modified":0,"renderable":0},{"_id":"source/_posts/java/introduction/java-environment-mac/9-jdk-mac.png","slug":"9-jdk-mac.png","post":"cjxze3guc00400cvw3xggpta5","modified":0,"renderable":0},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/5cdf6a292b1d070453.png","slug":"5cdf6a292b1d070453.png","post":"cjxze3gwa00550cvwlu8qcz9r","modified":0,"renderable":0},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/5cdf6a655276187010.png","slug":"5cdf6a655276187010.png","post":"cjxze3gwa00550cvwlu8qcz9r","modified":0,"renderable":0},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/5cdf7daf74e9241031.png","slug":"5cdf7daf74e9241031.png","post":"cjxze3gwa00550cvwlu8qcz9r","modified":0,"renderable":0},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/5cdf7e9f2047e23793.png","slug":"5cdf7e9f2047e23793.png","post":"cjxze3gwa00550cvwlu8qcz9r","modified":0,"renderable":0},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/5cdf7ec98fddd17705.png","slug":"5cdf7ec98fddd17705.png","post":"cjxze3gwa00550cvwlu8qcz9r","modified":0,"renderable":0},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/5cdf7f0e86fbc84596.png","slug":"5cdf7f0e86fbc84596.png","post":"cjxze3gwa00550cvwlu8qcz9r","modified":0,"renderable":0},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/5cdf7f4a7282234332.png","slug":"5cdf7f4a7282234332.png","post":"cjxze3gwa00550cvwlu8qcz9r","modified":0,"renderable":0},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/black_smile.jpg","slug":"black_smile.jpg","post":"cjxze3gwa00550cvwlu8qcz9r","modified":0,"renderable":0},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/carbon (1).png","slug":"carbon (1).png","post":"cjxze3gwa00550cvwlu8qcz9r","modified":0,"renderable":0},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/carbon (2).png","slug":"carbon (2).png","post":"cjxze3gwa00550cvwlu8qcz9r","modified":0,"renderable":0},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/carbon (3).png","slug":"carbon (3).png","post":"cjxze3gwa00550cvwlu8qcz9r","modified":0,"renderable":0},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/carbon (4).png","slug":"carbon (4).png","post":"cjxze3gwa00550cvwlu8qcz9r","modified":0,"renderable":0},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/carbon (7).png","slug":"carbon (7).png","post":"cjxze3gwa00550cvwlu8qcz9r","modified":0,"renderable":0},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/carbon (8).png","slug":"carbon (8).png","post":"cjxze3gwa00550cvwlu8qcz9r","modified":0,"renderable":0},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/carbon (9).png","slug":"carbon (9).png","post":"cjxze3gwa00550cvwlu8qcz9r","modified":0,"renderable":0},{"_id":"source/_posts/java/problem/the-correct-operation-of-arrays/e8df70b9feab81ccabe8a2821dc2e9880cddc9e4f2ce-zo9QsQ_fw658.jpeg","slug":"e8df70b9feab81ccabe8a2821dc2e9880cddc9e4f2ce-zo9QsQ_fw658.jpeg","post":"cjxze3gwa00550cvwlu8qcz9r","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjxze3gkc00020cvw5rji4j8t","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gkm00060cvwiyvpldvp"},{"post_id":"cjxze3gkw00090cvwyi34fcxb","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gl6000e0cvwgypj8de5"},{"post_id":"cjxze3gkw000a0cvw568fw4pv","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gl6000f0cvwyuallpgm"},{"post_id":"cjxze3gkw000c0cvwhvfuzczx","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gl6000h0cvw5o56kjrs"},{"post_id":"cjxze3gno000q0cvw8bbq0vax","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gny000w0cvw819dkovu"},{"post_id":"cjxze3gno000r0cvwwkqf9oyy","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gny000z0cvwr7yxcw4j"},{"post_id":"cjxze3gno000t0cvwe73qcbbe","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gny00130cvwbzxnittg"},{"post_id":"cjxze3gny000v0cvwgt26h3po","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3go800160cvwvpvpdnho"},{"post_id":"cjxze3gny000y0cvwnr1uuwpf","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3goj001a0cvwl2gjmmq9"},{"post_id":"cjxze3gny00120cvw478hhvpu","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3goo001d0cvway222s7s"},{"post_id":"cjxze3gp1001m0cvwfjpg2c8v","category_id":"cjxze3gox001h0cvw3ibxwq3f","_id":"cjxze3gpa001v0cvwbeufxq57"},{"post_id":"cjxze3gon001c0cvwdh9ove76","category_id":"cjxze3gox001h0cvw3ibxwq3f","_id":"cjxze3gpc001z0cvw7glgq96p"},{"post_id":"cjxze3gp3001o0cvwij3yvuhz","category_id":"cjxze3gox001h0cvw3ibxwq3f","_id":"cjxze3gpc00220cvwp1pkxi7e"},{"post_id":"cjxze3gp7001s0cvwuas8bs7g","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gpc00260cvw1z8ch3ga"},{"post_id":"cjxze3goy001j0cvwm6jvsgrz","category_id":"cjxze3gox001h0cvw3ibxwq3f","_id":"cjxze3gpc00280cvw4m6xvo63"},{"post_id":"cjxze3gp9001u0cvwva2wpd1b","category_id":"cjxze3gox001h0cvw3ibxwq3f","_id":"cjxze3gpm002a0cvwh91u3bsu"},{"post_id":"cjxze3gpc001y0cvw806qtrv7","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gpm002d0cvwgayx09jt"},{"post_id":"cjxze3gqg00350cvwvkwr261w","category_id":"cjxze3gox001h0cvw3ibxwq3f","_id":"cjxze3gqg003a0cvwlqas5nyl"},{"post_id":"cjxze3gt8003c0cvwedynwmt3","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gti003h0cvwbf722oct"},{"post_id":"cjxze3gt8003d0cvwb0lqwidg","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gti003j0cvwzom4lnkc"},{"post_id":"cjxze3gti003f0cvww7vef0nc","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gts003n0cvw0lag136x"},{"post_id":"cjxze3gti003g0cvwmpx266el","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gts003q0cvw7xpbog9r"},{"post_id":"cjxze3gti003i0cvw5iyp6f9l","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gts003u0cvw2e9q7xny"},{"post_id":"cjxze3gti003m0cvwyjtapemc","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gu2003x0cvwrdsablep"},{"post_id":"cjxze3gts003p0cvwtocl9s2y","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3guc00410cvw2oonxii9"},{"post_id":"cjxze3gts003t0cvw5vjgjxgw","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gum00440cvwwqi7f7jg"},{"post_id":"cjxze3gu2003w0cvwfcifyf9a","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3guw00480cvwexpi3l9m"},{"post_id":"cjxze3guc00400cvw3xggpta5","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3guw004b0cvwat0k1omn"},{"post_id":"cjxze3gum00430cvwm6fg8irc","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gv6004f0cvw2qa2059j"},{"post_id":"cjxze3guw00470cvw56eqtear","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gvg004i0cvw67kaxp9c"},{"post_id":"cjxze3guw004a0cvw1sd62ppr","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gvq004m0cvwglygse20"},{"post_id":"cjxze3gv6004e0cvwngbasiic","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gvq004p0cvwmlbudvhv"},{"post_id":"cjxze3gvg004h0cvwzl1jzq7d","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gw0004s0cvwb6oxg92w"},{"post_id":"cjxze3gvg004l0cvwekducab4","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gw0004w0cvwm55xmmnm"},{"post_id":"cjxze3gvq004o0cvw41jihbeh","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gw0004z0cvwqpwk3ax7"},{"post_id":"cjxze3gw0004r0cvwam3xiz7c","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gwa00530cvw08hpmj13"},{"post_id":"cjxze3gw0004v0cvwlyvez3vo","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gwa00560cvwo9rybat9"},{"post_id":"cjxze3gw0004y0cvwi4cslmm4","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gwk005a0cvwf0s94j08"},{"post_id":"cjxze3gwa00520cvwciw7wbfl","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gwk005d0cvw05ae0xac"},{"post_id":"cjxze3gwa00550cvwlu8qcz9r","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gwk005h0cvw7fpcjf5m"},{"post_id":"cjxze3gwk00590cvwnvqe92ba","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gwu005k0cvw7jb41a2n"},{"post_id":"cjxze3gwk005c0cvwle6qbx0f","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gwu005n0cvwl8r3qgse"},{"post_id":"cjxze3gwk005g0cvwp414mbt1","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gwu005r0cvw2gknos4v"},{"post_id":"cjxze3gwu005j0cvw0opodqas","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gx4005u0cvwu82p57jo"},{"post_id":"cjxze3gwu005m0cvwpr9rtcrz","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gx4005y0cvwvzv2d0lu"},{"post_id":"cjxze3gwu005q0cvwu5jx6eyy","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gx400610cvw7bxtwisd"},{"post_id":"cjxze3gwu005t0cvw8r0uapym","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gx400650cvwfjz2979o"},{"post_id":"cjxze3gx4005x0cvwc2nksy7c","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gxe00680cvw1k6xqepi"},{"post_id":"cjxze3gx400600cvw5txb31od","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gxe006c0cvwa27h8hnh"},{"post_id":"cjxze3gx400640cvwg6sj2kyp","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gxe006f0cvwf0lmfx4d"},{"post_id":"cjxze3gxe00670cvwchtc3rmu","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gxo006i0cvwacdtsrab"},{"post_id":"cjxze3gxe006b0cvwp2lb0o4u","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gxo006l0cvwtybr871o"},{"post_id":"cjxze3gxe006e0cvwctmnxum0","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gxo006n0cvwxj2xb417"},{"post_id":"cjxze3gxe006h0cvwsozru4mv","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gxo006p0cvwp9u1w4ut"},{"post_id":"cjxze3gxo006k0cvw15ee24g3","category_id":"cjxze3gkm00030cvw03u1c4h3","_id":"cjxze3gxy006r0cvwb3g4ji7o"}],"PostTag":[{"post_id":"cjxze3gkc00020cvw5rji4j8t","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gkm00070cvwo6ylyc91"},{"post_id":"cjxze3gkc00020cvw5rji4j8t","tag_id":"cjxze3gkm00050cvwq95rzjxp","_id":"cjxze3gkm00080cvw5am5goz7"},{"post_id":"cjxze3gkw00090cvwyi34fcxb","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gkw000b0cvw72s1fagk"},{"post_id":"cjxze3gkw000a0cvw568fw4pv","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3glg000j0cvw9h5p1juf"},{"post_id":"cjxze3gkw000a0cvw568fw4pv","tag_id":"cjxze3gl6000d0cvwsiiku4fc","_id":"cjxze3glg000k0cvw3u2b140f"},{"post_id":"cjxze3gkw000a0cvw568fw4pv","tag_id":"cjxze3gl6000g0cvwnlxa0o1r","_id":"cjxze3glg000m0cvwjnt513kr"},{"post_id":"cjxze3gkw000c0cvwhvfuzczx","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3glq000n0cvw21ls3sqt"},{"post_id":"cjxze3gkw000c0cvwhvfuzczx","tag_id":"cjxze3gl6000d0cvwsiiku4fc","_id":"cjxze3glq000o0cvw8j7biykt"},{"post_id":"cjxze3gkw000c0cvwhvfuzczx","tag_id":"cjxze3gl6000g0cvwnlxa0o1r","_id":"cjxze3glq000p0cvwqsq183ob"},{"post_id":"cjxze3gno000r0cvwwkqf9oyy","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gno000u0cvwo008ehkd"},{"post_id":"cjxze3gno000r0cvwwkqf9oyy","tag_id":"cjxze3gl6000d0cvwsiiku4fc","_id":"cjxze3gny000x0cvwzwz1q0uh"},{"post_id":"cjxze3gno000r0cvwwkqf9oyy","tag_id":"cjxze3gl6000g0cvwnlxa0o1r","_id":"cjxze3gny00110cvwcwqlw297"},{"post_id":"cjxze3gny000v0cvwgt26h3po","tag_id":"cjxze3gl6000d0cvwsiiku4fc","_id":"cjxze3go800140cvwu2cgetb9"},{"post_id":"cjxze3gny000v0cvwgt26h3po","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3go800180cvwsmn74t3n"},{"post_id":"cjxze3gny000v0cvwgt26h3po","tag_id":"cjxze3gl6000g0cvwnlxa0o1r","_id":"cjxze3gom001b0cvwcor08c7j"},{"post_id":"cjxze3gny00120cvw478hhvpu","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gos001f0cvwn9qadaqk"},{"post_id":"cjxze3gny00120cvw478hhvpu","tag_id":"cjxze3gl6000d0cvwsiiku4fc","_id":"cjxze3goy001i0cvw34ipb0oo"},{"post_id":"cjxze3gny00120cvw478hhvpu","tag_id":"cjxze3gno000s0cvwdxmcay2w","_id":"cjxze3gp1001l0cvwa385b6mo"},{"post_id":"cjxze3gny00120cvw478hhvpu","tag_id":"cjxze3gny00100cvwch3drroo","_id":"cjxze3gp3001n0cvwos3z2cmo"},{"post_id":"cjxze3gno000q0cvw8bbq0vax","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gp7001r0cvwcyoh0i5l"},{"post_id":"cjxze3gno000q0cvw8bbq0vax","tag_id":"cjxze3gl6000d0cvwsiiku4fc","_id":"cjxze3gp9001t0cvw4mcxoakj"},{"post_id":"cjxze3gno000q0cvw8bbq0vax","tag_id":"cjxze3gno000s0cvwdxmcay2w","_id":"cjxze3gpc001x0cvwbdrjno5l"},{"post_id":"cjxze3gno000q0cvw8bbq0vax","tag_id":"cjxze3gny00100cvwch3drroo","_id":"cjxze3gpc00200cvwmxgf2cf3"},{"post_id":"cjxze3got001g0cvwfuw9w55m","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gpc00230cvwt4ebdqdj"},{"post_id":"cjxze3got001g0cvwfuw9w55m","tag_id":"cjxze3gl6000d0cvwsiiku4fc","_id":"cjxze3gpc00270cvwywlxuowf"},{"post_id":"cjxze3got001g0cvwfuw9w55m","tag_id":"cjxze3gno000s0cvwdxmcay2w","_id":"cjxze3gpm00290cvw7ddloigy"},{"post_id":"cjxze3got001g0cvwfuw9w55m","tag_id":"cjxze3gny00100cvwch3drroo","_id":"cjxze3gpm002c0cvwvqhv5v5y"},{"post_id":"cjxze3gno000t0cvwe73qcbbe","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gpm002e0cvwgg5kyyiw"},{"post_id":"cjxze3gno000t0cvwe73qcbbe","tag_id":"cjxze3gl6000d0cvwsiiku4fc","_id":"cjxze3gpm002g0cvw03cxeljl"},{"post_id":"cjxze3gno000t0cvwe73qcbbe","tag_id":"cjxze3gno000s0cvwdxmcay2w","_id":"cjxze3gpm002h0cvw7j4v289k"},{"post_id":"cjxze3gno000t0cvwe73qcbbe","tag_id":"cjxze3gny00100cvwch3drroo","_id":"cjxze3gpm002j0cvw59phh4jc"},{"post_id":"cjxze3gny000y0cvwnr1uuwpf","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gpm002k0cvwxn10m4bk"},{"post_id":"cjxze3gny000y0cvwnr1uuwpf","tag_id":"cjxze3gl6000d0cvwsiiku4fc","_id":"cjxze3gpm002m0cvw66bxqw9s"},{"post_id":"cjxze3gny000y0cvwnr1uuwpf","tag_id":"cjxze3gno000s0cvwdxmcay2w","_id":"cjxze3gpm002n0cvw72yglcma"},{"post_id":"cjxze3gny000y0cvwnr1uuwpf","tag_id":"cjxze3gny00100cvwch3drroo","_id":"cjxze3gpm002o0cvwvny1lufz"},{"post_id":"cjxze3gp9001u0cvwva2wpd1b","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gpw002p0cvwob5rus7p"},{"post_id":"cjxze3gp9001u0cvwva2wpd1b","tag_id":"cjxze3gkm00050cvwq95rzjxp","_id":"cjxze3gpw002q0cvw7rri7sri"},{"post_id":"cjxze3gpc001y0cvw806qtrv7","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gpw002r0cvw2dkcdspa"},{"post_id":"cjxze3gpc001y0cvw806qtrv7","tag_id":"cjxze3gl6000d0cvwsiiku4fc","_id":"cjxze3gpw002s0cvwie3d3tnk"},{"post_id":"cjxze3gpc001y0cvw806qtrv7","tag_id":"cjxze3gl6000g0cvwnlxa0o1r","_id":"cjxze3gpw002t0cvw3blvke9u"},{"post_id":"cjxze3gpc001y0cvw806qtrv7","tag_id":"cjxze3gno000s0cvwdxmcay2w","_id":"cjxze3gpw002u0cvw5cq2glot"},{"post_id":"cjxze3go800150cvwdwa9ptzw","tag_id":"cjxze3gp6001q0cvwiulqag9j","_id":"cjxze3gpw002v0cvww059lzru"},{"post_id":"cjxze3go800150cvwdwa9ptzw","tag_id":"cjxze3gpb001w0cvw0v7tcas1","_id":"cjxze3gpw002w0cvwkle7xm9l"},{"post_id":"cjxze3go800190cvwzwkcwhnc","tag_id":"cjxze3gpc00240cvw9q6z7ynb","_id":"cjxze3gpw002x0cvw0rn2t2pi"},{"post_id":"cjxze3gon001c0cvwdh9ove76","tag_id":"cjxze3gpm002b0cvwhhzmcln7","_id":"cjxze3gpw002y0cvwcr8xt0qb"},{"post_id":"cjxze3gon001c0cvwdh9ove76","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gpw002z0cvwzdi3y24r"},{"post_id":"cjxze3gon001c0cvwdh9ove76","tag_id":"cjxze3gkm00050cvwq95rzjxp","_id":"cjxze3gpw00300cvwiycfq6l4"},{"post_id":"cjxze3gp1001m0cvwfjpg2c8v","tag_id":"cjxze3gpm002f0cvwstkbsaln","_id":"cjxze3gpw00310cvwmgygabj5"},{"post_id":"cjxze3gp3001o0cvwij3yvuhz","tag_id":"cjxze3gpm002b0cvwhhzmcln7","_id":"cjxze3gpw00320cvwwxvlh24l"},{"post_id":"cjxze3gp7001s0cvwuas8bs7g","tag_id":"cjxze3gpm002l0cvw92dv9uxt","_id":"cjxze3gpw00330cvw5y8c4sgv"},{"post_id":"cjxze3gqg00350cvwvkwr261w","tag_id":"cjxze3gpm002b0cvwhhzmcln7","_id":"cjxze3gqg00370cvwoqzhf937"},{"post_id":"cjxze3gqg00350cvwvkwr261w","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gqg00390cvwsnxm3uy6"},{"post_id":"cjxze3gqg00350cvwvkwr261w","tag_id":"cjxze3gkm00050cvwq95rzjxp","_id":"cjxze3gqg003b0cvw6aen9bzn"},{"post_id":"cjxze3gti003g0cvwmpx266el","tag_id":"cjxze3gti003e0cvw250yxgxm","_id":"cjxze3gti003l0cvwpvhudmi7"},{"post_id":"cjxze3gt8003c0cvwedynwmt3","tag_id":"cjxze3gti003e0cvw250yxgxm","_id":"cjxze3gts003o0cvw0iap9926"},{"post_id":"cjxze3gti003m0cvwyjtapemc","tag_id":"cjxze3gti003k0cvwfhhsg1v4","_id":"cjxze3gts003s0cvwylp11yan"},{"post_id":"cjxze3gti003m0cvwyjtapemc","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gu2003v0cvwj6mtm5p0"},{"post_id":"cjxze3gt8003d0cvwb0lqwidg","tag_id":"cjxze3gti003k0cvwfhhsg1v4","_id":"cjxze3guc003z0cvwitfp1qqa"},{"post_id":"cjxze3gt8003d0cvwb0lqwidg","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3guc00420cvwqbp86nha"},{"post_id":"cjxze3gts003p0cvwtocl9s2y","tag_id":"cjxze3gti003k0cvwfhhsg1v4","_id":"cjxze3guw00460cvwe07uji5n"},{"post_id":"cjxze3gts003p0cvwtocl9s2y","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3guw00490cvwv3vktczw"},{"post_id":"cjxze3gts003t0cvw5vjgjxgw","tag_id":"cjxze3gti003k0cvwfhhsg1v4","_id":"cjxze3gv6004c0cvwfqjh8duc"},{"post_id":"cjxze3gts003t0cvw5vjgjxgw","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gvg004g0cvwfok3cjf2"},{"post_id":"cjxze3gti003f0cvww7vef0nc","tag_id":"cjxze3gti003e0cvw250yxgxm","_id":"cjxze3gvg004j0cvwcydly4np"},{"post_id":"cjxze3gti003i0cvw5iyp6f9l","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gvq004n0cvw8gu58h01"},{"post_id":"cjxze3gti003i0cvw5iyp6f9l","tag_id":"cjxze3gu2003y0cvw9ou7z8nn","_id":"cjxze3gvq004q0cvw88my9pt4"},{"post_id":"cjxze3gum00430cvwm6fg8irc","tag_id":"cjxze3gti003k0cvwfhhsg1v4","_id":"cjxze3gw0004u0cvw6tbr6ou0"},{"post_id":"cjxze3gum00430cvwm6fg8irc","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gw0004x0cvw85fkfdvo"},{"post_id":"cjxze3guw00470cvw56eqtear","tag_id":"cjxze3gum00450cvwpih78czb","_id":"cjxze3gwa00510cvw25lk76dr"},{"post_id":"cjxze3guw00470cvw56eqtear","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gwa00540cvwo839x6la"},{"post_id":"cjxze3gu2003w0cvwfcifyf9a","tag_id":"cjxze3gum00450cvwpih78czb","_id":"cjxze3gwk00580cvwbd813yle"},{"post_id":"cjxze3gu2003w0cvwfcifyf9a","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gwk005b0cvw97ys54ul"},{"post_id":"cjxze3gu2003w0cvwfcifyf9a","tag_id":"cjxze3gpm002l0cvw92dv9uxt","_id":"cjxze3gwk005e0cvw39y6t6c3"},{"post_id":"cjxze3gv6004e0cvwngbasiic","tag_id":"cjxze3gum00450cvwpih78czb","_id":"cjxze3gwk005i0cvwf0pcsncx"},{"post_id":"cjxze3gv6004e0cvwngbasiic","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gwu005l0cvwnk70gz7g"},{"post_id":"cjxze3guc00400cvw3xggpta5","tag_id":"cjxze3gum00450cvwpih78czb","_id":"cjxze3gwu005p0cvw260fcj4c"},{"post_id":"cjxze3guc00400cvw3xggpta5","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gwu005s0cvw6jra76el"},{"post_id":"cjxze3guc00400cvw3xggpta5","tag_id":"cjxze3gpm002l0cvw92dv9uxt","_id":"cjxze3gx4005w0cvwhdq01th0"},{"post_id":"cjxze3gvg004l0cvwekducab4","tag_id":"cjxze3gum00450cvwpih78czb","_id":"cjxze3gx4005z0cvwbu1u9kqb"},{"post_id":"cjxze3gvg004l0cvwekducab4","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gx400630cvwgost56nq"},{"post_id":"cjxze3gvg004l0cvwekducab4","tag_id":"cjxze3gpm002l0cvw92dv9uxt","_id":"cjxze3gxe00660cvw66q5qrmg"},{"post_id":"cjxze3guw004a0cvw1sd62ppr","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gxe006a0cvwwld2vclu"},{"post_id":"cjxze3guw004a0cvw1sd62ppr","tag_id":"cjxze3gvg004k0cvw8we8eozq","_id":"cjxze3gxe006d0cvwk4lsaox7"},{"post_id":"cjxze3gw0004r0cvwam3xiz7c","tag_id":"cjxze3gum00450cvwpih78czb","_id":"cjxze3gxe006g0cvwltcv3a4y"},{"post_id":"cjxze3gw0004r0cvwam3xiz7c","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gxo006j0cvwiwxz1og0"},{"post_id":"cjxze3gw0004v0cvwlyvez3vo","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gxo006m0cvw5b8g81at"},{"post_id":"cjxze3gvg004h0cvwzl1jzq7d","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gxo006o0cvw8q83y8hd"},{"post_id":"cjxze3gvg004h0cvwzl1jzq7d","tag_id":"cjxze3gw0004t0cvw0901ra1p","_id":"cjxze3gxy006q0cvw8c4c2ki2"},{"post_id":"cjxze3gwa00520cvwciw7wbfl","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gxy006s0cvwf7b32ky3"},{"post_id":"cjxze3gwa00520cvwciw7wbfl","tag_id":"cjxze3gkm00050cvwq95rzjxp","_id":"cjxze3gxy006t0cvw12mhd6ao"},{"post_id":"cjxze3gvq004o0cvw41jihbeh","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gxy006u0cvw4gzc2eyr"},{"post_id":"cjxze3gvq004o0cvw41jihbeh","tag_id":"cjxze3gw000500cvwdew7u6up","_id":"cjxze3gxy006v0cvwht9wgxmq"},{"post_id":"cjxze3gwk00590cvwnvqe92ba","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gxy006w0cvwnnty0hf1"},{"post_id":"cjxze3gw0004y0cvwi4cslmm4","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gxy006x0cvwbxz9760y"},{"post_id":"cjxze3gw0004y0cvwi4cslmm4","tag_id":"cjxze3gwk00570cvw3tsp3f4g","_id":"cjxze3gxy006y0cvwqwzkwlyh"},{"post_id":"cjxze3gwa00550cvwlu8qcz9r","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gxy006z0cvwoyu2xfmz"},{"post_id":"cjxze3gwa00550cvwlu8qcz9r","tag_id":"cjxze3gwk005f0cvwndtuwpns","_id":"cjxze3gxy00700cvwelhk1y9c"},{"post_id":"cjxze3gwu005q0cvwu5jx6eyy","tag_id":"cjxze3gum00450cvwpih78czb","_id":"cjxze3gxy00710cvwzcrfdd6q"},{"post_id":"cjxze3gwu005q0cvwu5jx6eyy","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gxy00720cvwas4u8v2g"},{"post_id":"cjxze3gwu005q0cvwu5jx6eyy","tag_id":"cjxze3gpm002l0cvw92dv9uxt","_id":"cjxze3gxy00730cvw9l12y7eo"},{"post_id":"cjxze3gwk005c0cvwle6qbx0f","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gxy00740cvw7awr5x0h"},{"post_id":"cjxze3gwk005c0cvwle6qbx0f","tag_id":"cjxze3gwu005o0cvwp058wfzd","_id":"cjxze3gxy00750cvwp0b8r4ye"},{"post_id":"cjxze3gwu005t0cvw8r0uapym","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gxy00760cvwgv7zwz3d"},{"post_id":"cjxze3gwu005t0cvw8r0uapym","tag_id":"cjxze3gwu005o0cvwp058wfzd","_id":"cjxze3gxy00770cvwhagpvrsx"},{"post_id":"cjxze3gx4005x0cvwc2nksy7c","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gy800780cvwjx3qyjka"},{"post_id":"cjxze3gx4005x0cvwc2nksy7c","tag_id":"cjxze3gwu005o0cvwp058wfzd","_id":"cjxze3gy800790cvwz2c3zdzq"},{"post_id":"cjxze3gwk005g0cvwp414mbt1","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gy8007a0cvwehg4s8i1"},{"post_id":"cjxze3gwk005g0cvwp414mbt1","tag_id":"cjxze3gwu005o0cvwp058wfzd","_id":"cjxze3gy8007b0cvw1s4sj53y"},{"post_id":"cjxze3gx400600cvw5txb31od","tag_id":"cjxze3gum00450cvwpih78czb","_id":"cjxze3gy8007c0cvwyd7a44wl"},{"post_id":"cjxze3gx400600cvw5txb31od","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gy8007d0cvw6ga2zuc6"},{"post_id":"cjxze3gx400640cvwg6sj2kyp","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gy8007e0cvw2xlxqd87"},{"post_id":"cjxze3gx400640cvwg6sj2kyp","tag_id":"cjxze3gwu005o0cvwp058wfzd","_id":"cjxze3gy8007f0cvw7ocp48er"},{"post_id":"cjxze3gwu005j0cvw0opodqas","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gy8007g0cvw9m9appem"},{"post_id":"cjxze3gwu005j0cvw0opodqas","tag_id":"cjxze3gwu005o0cvwp058wfzd","_id":"cjxze3gy8007h0cvw0cur4c2m"},{"post_id":"cjxze3gxe00670cvwchtc3rmu","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gy8007i0cvwqkiqgp7e"},{"post_id":"cjxze3gxe00670cvwchtc3rmu","tag_id":"cjxze3gwu005o0cvwp058wfzd","_id":"cjxze3gy8007j0cvwweineiha"},{"post_id":"cjxze3gxe006b0cvwp2lb0o4u","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gy8007k0cvwku8opn7b"},{"post_id":"cjxze3gxe006b0cvwp2lb0o4u","tag_id":"cjxze3gwu005o0cvwp058wfzd","_id":"cjxze3gy8007l0cvw9qdijyhh"},{"post_id":"cjxze3gwu005m0cvwpr9rtcrz","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gy8007m0cvw360ww6z0"},{"post_id":"cjxze3gwu005m0cvwpr9rtcrz","tag_id":"cjxze3gwu005o0cvwp058wfzd","_id":"cjxze3gyi007n0cvwg7og8o2l"},{"post_id":"cjxze3gxe006e0cvwctmnxum0","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gyi007o0cvwyx0dg4o7"},{"post_id":"cjxze3gxe006e0cvwctmnxum0","tag_id":"cjxze3gwu005o0cvwp058wfzd","_id":"cjxze3gyi007p0cvwdjs5xyts"},{"post_id":"cjxze3gxe006h0cvwsozru4mv","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gyi007q0cvwzgisu7tj"},{"post_id":"cjxze3gxe006h0cvwsozru4mv","tag_id":"cjxze3gwu005o0cvwp058wfzd","_id":"cjxze3gyi007r0cvw7pv6xd33"},{"post_id":"cjxze3gxo006k0cvw15ee24g3","tag_id":"cjxze3gkm00040cvw81dh5yg3","_id":"cjxze3gyi007s0cvwox4oybx4"},{"post_id":"cjxze3gxo006k0cvw15ee24g3","tag_id":"cjxze3gwu005o0cvwp058wfzd","_id":"cjxze3gyi007t0cvw6mw01dve"},{"post_id":"cjxze3gys007u0cvw6ne5bg40","tag_id":"cjxze3gys007v0cvwwakp22q7","_id":"cjxze3gzw007y0cvwun98f0la"},{"post_id":"cjxze3gys007u0cvw6ne5bg40","tag_id":"cjxze3gz2007w0cvwyq7g5r48","_id":"cjxze3gzw007z0cvwa4vi34vq"},{"post_id":"cjxze3gys007u0cvw6ne5bg40","tag_id":"cjxze3gzc007x0cvwzvs5uxlr","_id":"cjxze3h0600800cvweiv5hbn5"},{"post_id":"cjxze3h0g00810cvwbwcrrdjh","tag_id":"cjxze3h0g00830cvwt1g3373o","_id":"cjxze3h1k00870cvw12pgotpk"},{"post_id":"cjxze3h0g00810cvwbwcrrdjh","tag_id":"cjxze3h1000850cvwccubi2vg","_id":"cjxze3h1k00880cvwukztw0rm"},{"post_id":"cjxze3h0g00820cvwd3l93uzw","tag_id":"cjxze3h0g00830cvwt1g3373o","_id":"cjxze3h1k008b0cvw8ujx4qgs"},{"post_id":"cjxze3h0g00820cvwd3l93uzw","tag_id":"cjxze3h1000850cvwccubi2vg","_id":"cjxze3h1k008c0cvw8d7wngr3"},{"post_id":"cjxze3h0q00840cvwzteqlyfa","tag_id":"cjxze3h0g00830cvwt1g3373o","_id":"cjxze3h1k008e0cvw43z12zut"},{"post_id":"cjxze3h0q00840cvwzteqlyfa","tag_id":"cjxze3h1000850cvwccubi2vg","_id":"cjxze3h1u008f0cvwymhpizde"},{"post_id":"cjxzito2m0000eus6yxhwf2r8","tag_id":"cjxze3gp6001q0cvwiulqag9j","_id":"cjxzito7h0004eus6ws6gj1cj"},{"post_id":"cjxzito2m0000eus6yxhwf2r8","tag_id":"cjxzito6r0002eus63nl4o0wt","_id":"cjxzito7j0005eus6mw39rplb"},{"post_id":"cjxzito4f0001eus69s0s8g0q","tag_id":"cjxze3gp6001q0cvwiulqag9j","_id":"cjxzito7p0006eus64vini0d5"},{"post_id":"cjxzito4f0001eus69s0s8g0q","tag_id":"cjxzito7f0003eus6j7l6bstp","_id":"cjxzito7s0007eus6tl82bgkx"}],"Tag":[{"name":"Java","_id":"cjxze3gkm00040cvw81dh5yg3"},{"name":"多线程","_id":"cjxze3gkm00050cvwq95rzjxp"},{"name":"算法","_id":"cjxze3gl6000d0cvwsiiku4fc"},{"name":"LeetCode","_id":"cjxze3gl6000g0cvwnlxa0o1r"},{"name":"动态规划","_id":"cjxze3gno000s0cvwdxmcay2w"},{"name":"背包问题","_id":"cjxze3gny00100cvwch3drroo"},{"name":"mysql","_id":"cjxze3gp6001q0cvwiulqag9j"},{"name":"数据库","_id":"cjxze3gpb001w0cvw0v7tcas1"},{"name":"RabbitMQ","_id":"cjxze3gpc00240cvw9q6z7ynb"},{"name":"摘要","_id":"cjxze3gpm002b0cvwhhzmcln7"},{"name":"读书笔记","_id":"cjxze3gpm002f0cvwstkbsaln"},{"name":"环境搭建","_id":"cjxze3gpm002l0cvw92dv9uxt"},{"name":"领域驱动","_id":"cjxze3gti003e0cvw250yxgxm"},{"name":"Java基础","_id":"cjxze3gti003k0cvwfhhsg1v4"},{"name":"面试","_id":"cjxze3gu2003y0cvw9ou7z8nn"},{"name":"Java入门","_id":"cjxze3gum00450cvwpih78czb"},{"name":"Java集合","_id":"cjxze3gvg004k0cvw8we8eozq"},{"name":"垃圾回收","_id":"cjxze3gw0004t0cvw0901ra1p"},{"name":"内存泄漏","_id":"cjxze3gw000500cvwdew7u6up"},{"name":"虚拟机","_id":"cjxze3gwk00570cvw3tsp3f4g"},{"name":"常见问题","_id":"cjxze3gwk005f0cvwndtuwpns"},{"name":"引用类型","_id":"cjxze3gwu005o0cvwp058wfzd"},{"name":"爬虫","_id":"cjxze3gys007v0cvwwakp22q7"},{"name":"豆瓣","_id":"cjxze3gz2007w0cvwyq7g5r48"},{"name":"Python","_id":"cjxze3gzc007x0cvwzvs5uxlr"},{"name":"Spring","_id":"cjxze3h0g00830cvwt1g3373o"},{"name":"源码解读","_id":"cjxze3h1000850cvwccubi2vg"},{"name":"索引","_id":"cjxzito6r0002eus63nl4o0wt"},{"name":"测试","_id":"cjxzito7f0003eus6j7l6bstp"}]}}
