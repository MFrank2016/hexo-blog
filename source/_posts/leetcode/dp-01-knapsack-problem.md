---
title: 【动态规划】0/1 背包问题
date: 2019-03-10 21:23:14
tags: 
 - Java
 - 算法
 - 动态规划
categories: 编程
---

## 说明

前面用`动态规划`解决了正则表达式的问题，感觉还是不过瘾，总觉得对于`动态规划`的理解还没有到位，所以趁热打铁，继续研究几个`动态规划`的经典问题，希望能够借此加深对`动态规划`的理解。

## 0/1背包问题

假设你是一名探险家，背着背包来野外探险，有一天，你发现一个洞穴，这个洞穴外表看起来其貌不扬，可是洞穴里面，也表里如一，但这并没有阻止你前进的步伐，你坚定不移的往前探索，希望能发现一些奇奇怪怪的东西，终于，皇天不负有心人，你在洞穴的尽头，发现了一堆不世出的珠宝，凭借你惊人的阅历，一眼便看出了它们各自的价值，正准备将它们收入囊中，但是却不小心触碰到一个机关，洞穴马上就要崩塌了，在此危机时刻，你只有一个背包，你必须尽快做出抉择，选择最值钱的珠宝塞到你的背包，让背包中珠宝的总价值最大。

emmm，好了，啰里啰嗦了大半天，我还是来精简一下问题吧。简而言之，你只有一个背包，总容量为c，有n个可待选择的物品，每个物品只有一件，它们都有各自的重量和价值，你需要从中选择合适的组合来使得你背包中的物品总价值最大。

## 问题分析

那还不简单，不管是什么，先往背包里塞，塞满赶紧走，狗命要紧，狗命要紧。。。

![20190310214935.png](https://i.loli.net/2019/03/10/5c8515f07c869.png)

好了好了，开个玩笑，言归正传。

简单起见，我们来将上面的问题具体化，举一个更具体的栗子：

假设有5个物品，它们的价值(v)和重量(w)如下图：

![](https://i.loli.net/2019/03/10/5c851ee47f9c2.jpeg)

背包总容量为10，现在要从中选择物品装入背包中，要求物品的重量不能超过背包的容量，并且最后放在背包中物品的总价值最大。

emmm，那为什么叫做`0/1背包`呢？为什么不叫`1/2背包`，`2/3背包`？？？

仔细想想，这里每个物品只有一个，对于每个物品而言，只有两种选择，盘它或者不盘，盘它记为1，不盘记为0，我们不能将物品进行分割，比如只拿半个是不允许的。这就是这个问题被称为`0/1背包`问题的原因。

所以选还是不选，这是个问题。

让我们先来体验一下将珠宝装入背包的感觉，为了方便起见，用xi代表第i个珠宝的选择（xi = 1 代表选择该珠宝，0则代表不选），vi代表第i个珠宝的价值，wi代表第i个珠宝的重量。于是我们就有了这样的限制条件：

![](https://i.loli.net/2019/03/10/5c851ebfd4687.jpeg)

我们的初始状态是背包容量为10，背包内物品总价值为0，接下来，我们就要开始做选择了。对于1号珠宝，当前容量为10，容纳它的重量2绰绰有余，因此有两种选择，选它或者不选。我们选择一个珠宝的时候，背包的容量会减少，但是里面的物品总价值会增加。就像下面这样：

![](https://i.loli.net/2019/03/10/5c851f2254a64.jpeg)

这样就分出了两种情况，我们继续进行选择，如果我们选择了珠宝1，那么对于珠宝2，当前剩余容量为8，大于珠宝2的容量3，因此也有两种选择，选或者不选。

![](https://i.loli.net/2019/03/10/5c8524cc69459.jpeg)

现在，我们得到了四个可能结果，我们每做出一个选择，就会将上面的每一种可能分裂成两种可能，后续的选择也是如此，最终，我们会得到如下的一张决策图：

![](https://i.loli.net/2019/03/10/5c85286b617f4.jpeg)

这里被涂上色的方框代表我们的最终待选结果，本来应该有16个待选结果，但有三个结果由于容量不足以容纳下最后一个珠宝，所以就没有继续进行裂变。

然后，我们从这些结果中，找出价值最大的那个，也就是13，这就是我们的选择，根据这个选择，依次找到它的所有路径，便可以知道该选哪几个珠宝，最终结果是：珠宝4，珠宝2，珠宝1。

## 分治法

接下来，我们就来分析一下，如何将它扩展到一般情况。为了实现这个目的，我们需要将问题进行抽象并建模，然后将其划分为更小的子问题，找出递推关系式，这是分治思想中很重要的一步。

1. 抽象问题，背包问题抽象为寻找组合（x1,x2,x3...xn，其中xi取0或1，表示第i个物品取或者不取），vi代表第i个物品的价值，wi代表第i个物品的重量，总物品数为n，背包容量为c。
2. 建模，问题即求max(x1v1 + x2v2 + x3v3 + ... + xnvn)。
3. 约束条件，x1w1 + x2w2 + x3w3 + ... + xnwn < c
4. 定义函数KS(i,j)：代表当前背包剩余容量为j时，前i个物品最佳组合所对应的价值；

那这里的递推关系式是怎样的呢？对于第i个物品，有两种可能：

1. 背包剩余容量不足以容纳该物品，此时背包的价值与前i-1个物品的价值是一样的，KS(i,j) = KS(i-1,j)
2. 背包剩余容量可以装下该商品，此时需要进行判断，因为装了该商品不一定能使最终组合达到最大价值，如果不装该商品，则价值为：KS(i-1,j)，如果装了该商品，则价值为KS(i-1,j-wi) + vi，从两者中选择较大的那个，所以就得出了递推关系式：

![](https://i.loli.net/2019/03/12/5c87b64eb1a66.jpeg)

所以，就可以很容易的写出递归解法了：

```java
public class Solution{
    int[] vs = {0,2,4,3,7};
    int[] ws = {0,2,3,5,5};

    @Test
    public void testKnapsack1() {
        int result = ks(4,10);
        System.out.println(result);
    }

    private int ks(int i, int c){
        int result = 0;
        if (i == 0 || c == 0){
            // 初始条件
            result = 0;
        } else if(ws[i] > c){
            // 装不下该珠宝
            result = ks(i-1, c);
        } else {
            // 可以装下
            int tmp1 = ks(i-1, c);
            int tmp2 = ks(i-1, c-ws[i]) + vs[i];
            result = Math.max(tmp1, tmp2);
        }
        return result;
    }
}
```

这里为了方便处理，将数组ws和vs都增加了一个补位数0，防止数组越界，输出结果：

```
13
```

这样，我们就轻松加愉快的解决了这个问题。

## 动态规划解法

### 自上而下记忆法

就像上一篇里的解法一样，自上而下的解法与分治法的区别就是增加了一个数组用来存储计算的中间结果来减少重复计算。这里，我们只需要多定义一个二维数组。

![](https://i.loli.net/2019/03/12/5c87c27322752.jpeg)

表格中，每一个格子都代表着一个子问题，我们最终的问题是求最右下角的格子的值，也就是`i=4,j=10`时的值。这里，我们的初始条件便是i=0或者j=0时对应的ks值为0，这很好理解，如果可选物品为0，或者剩余容量为0，那么最大价值自然也是0。代码如下：

```java
public class Solution{
    int[] vs = {0,2,4,3,7};
    int[] ws = {0,2,3,5,5};
    Integer[][] results = new Integer[5][11];

    @Test
    public void testKnapsack2() {
        int result = ks2(4,10);
        System.out.println(result);
    }

    private int ks2(int i, int c){
        int result = 0;
        // 如果该结果已经被计算，那么直接返回
        if (results[i][c] != null) return results[i][c];
        if (i == 0 || c == 0){
            // 初始条件
            result = 0;
        } else if(ws[i] > c){
            // 装不下该珠宝
            result = ks(i-1, c);
        } else {
            // 可以装下
            int tmp1 = ks(i-1, c);
            int tmp2 = ks(i-1, c-ws[i]) + vs[i];
            result = Math.max(tmp1, tmp2);
            results[i][c] = result;
        }
        return result;
    }
}
```

可以看到，其实只比分治多了三行代码。



### 自下而上填表法

接下来，我们用自下而上的方法来解一下这道题，思路很简单，就是不断的填表，回想一下上一篇中的斐波拉契数列的自下而上解法，这里将使用同样的方式来解决。还是使用上面的表格，我们开始一行行填表。

![](https://i.loli.net/2019/03/12/5c87c45b5d9bf.jpeg)

当i=1时，即只有珠宝1可供选择，那么如果容量足够的话，最大价值自然就是珠宝1的价值了。

![](https://i.loli.net/2019/03/12/5c87c4c11104c.jpeg)

当i=2时，有两个物品可供选择，此时应用上面的递推关系式进行判断即可。这里以i=2,j=3为例进行分析：

![](https://i.loli.net/2019/03/12/5c87c673e6c36.jpeg)

剩下的格子使用相同的方法进行填充即可：

![](https://i.loli.net/2019/03/12/5c87c75ba58ce.jpeg)

这样，我们就得到了最后的结果：13。根据结果，我们可以反向找出各个物品的选择，寻找的方法很简单，就是从i=4,j=10开始寻找，如果ks(i-1,j)=ks(i,j)，说明第i个物品没有被选中，从ks(i-1,j)继续寻找。否则，表示第i个物品已被选中，则从ks(i-1,j-wi)开始寻找。

![](https://i.loli.net/2019/03/12/5c87c9244d3c9.jpeg)

转化成代码：

```java
public class Solution{
    int[] vs = {0,2,4,3,7};
    int[] ws = {0,2,3,5,5};
    Integer[][] results = new Integer[5][11];
    
    @Test
    public void testKnapsack3() {
        int result = ks3(4,10);
        System.out.println(result);
    }

    private int ks3(int i, int j){
        // 初始化
        for (int m = 0; m <= i; m++){
            results[m][0] = 0;
        }
        for (int m = 0; m <= j; m++){
            results[0][m] = 0;
        }
        // 开始填表
        for (int m = 1; m <= i; m++){
            for (int n = 1; n <= j; n++){
                if (n < ws[m]){
                    // 装不进去
                    results[m][n] = results[m-1][n];
                } else {
                    // 容量足够
                    if (results[m-1][n] > results[m-1][n-ws[m]] + vs[m]){
                        // 不装该珠宝，最优价值更大
                        results[m][n] = results[m-1][n];
                    } else {
                        results[m][n] = results[m-1][n-ws[m]] + vs[m];
                    }
                }
            }
        }
        return results[i][j];
    }
}
```

嗯，完美解决。时间复杂度即填表耗时O(n * c)，这里用了一个二维数组来存储子问题的解，所以空间复杂度为O(n * c);

## 总结

回过头再看看上面的分析，会发现动态规划里最关键的问题其实是寻找原问题的子问题，并写出递推表达式，只要完成了这一步，代码部分都是水到渠成的事情了。

那么问题来了，怎样把问题拆分成子问题呢？

emmm，这个问题有点超纲了，我也没有掌握到诀窍，具体情况具体分析吧，但是很多经典的问题都有其经典的套路，其它问题都可以归结到这些问题上面来，可以看做是它们的变种和延伸，把这些经典的问题吃透的话，自然能举一反三。比如采药问题，本质上就是01背包问题，而硬币问题，本质上就是完全背包问题。而硬币找零问题，本质上就是接下来要介绍的完全背包问题。

个人认为，算法题不在于刷多少个，而在于归纳总结，就跟做数学题一样，总有一些范式和套路，不管形式如何变化，其本质是一样的，万变不离其宗，说的就是这么回事。

本篇到此就告一段落了，如果觉得有收获，不要吝啬你的赞哦，也欢迎留言交流。