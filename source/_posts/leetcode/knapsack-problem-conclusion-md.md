---
title: 【动态规划】一次搞定三种背包问题
date: 2019-05-07 19:56:03
tags:
 - Java
 - 算法
 - 动态规划
 - 背包问题
categories: 编程
---

## 前文链接

[【动态规划】01背包问题](https://www.cnblogs.com/mfrank/p/10533701.html)

[【动态规划】01背包问题【续】](https://www.cnblogs.com/mfrank/p/10587463.html)

[【动态规划】完全背包问题](https://www.cnblogs.com/mfrank/p/10803417.html)

[【动态规划】多重背包问题](https://www.cnblogs.com/mfrank/p/10816837.html)

## 说明

看完前面四篇关于背包问题的文章，你会发现背包问题其实也不过如此，而且它们之间有很多相似的地方，本篇文章就来揭开它们面纱，将背包问题彻底搞定。

## 三种背包问题的比较

先来回顾一下三个背包问题的定义：

> 01背包：
> 有N件物品和一个容量为V的背包，第i件物品消耗的容量为Ci，价值为Wi，求解放入哪些物品可以使得背包中总价值最大。

> 完全背包：
> 有N种物品和一个容量为V的背包，每种物品都有无限件可用，第i件物品消耗的容量为Ci，价值为Wi，求解放入哪些物品可以使得背包中总价值最大。

> 多重背包：
> 有N种物品和一个容量为V的背包，第i种物品最多有Mi件可用，每件物品消耗的容量为Ci，价值为Wi，求解入哪些物品可以使得背包中总价值最大。

三种背包问题都有一个共同的限制，那就是背包容量，背包的容量是有限的，这便限制了物品的选择，而三种背包问题的共同目的，便是让背包中的物品价值最大。

不同的地方在于物品数量的限制，01背包问题中，每种物品只有一个，对于每种物品而言，便只有选和不选两个选择。完全背包问题中，每种物品有无限多个，所以可选的范围要大很多。在多重背包问题中，每种物品都有各自的数量限制。

三种背包问题虽然对于物品数量的限制不一样，但都可以转化为01背包问题来进行思考。在完全背包问题中，虽然每种物品都可以选择无限个，但由于背包容量有限，实际上每种物品可以选择的数量也是有限的，那么将每种物品都看做是 V/Ci 种只有一件的不同物品，不就成了01背包问题吗？对于多重背包也是如此，只是每种物品的膨胀数量变成了 min{Mi, V/Ci}。

所以说，01背包问题是所有背包问题的基础，弄懂了01背包问题后，完全背包和多重背包就没有什么难的地方了。

下面我们来对比一下三种背包问题的状态转移方程，以便更好的理解它们之间的联系：

01背包的状态转移方程：

```
F[i,v] = max{F[i-1,v], F[i-1,v-Ci] + Wi}
```

完全背包的状态转移方程：

```
F[i,v] = max{F[i-1,v-kCi] + kWi | 0 <= kCi <= v}
```

多重背包的状态转移方程：

```
F[i,v] = max{F[i-1,v-kCi] + kWi | 0 <= k <= Mi}
```

把这三个方程放到一起，便能很清晰的看到它们之间的关系了，三种背包问题都是基于子问题来选取价值最大的一个，只是选择的范围不一样。

01背包考虑的是选和不选，所有只需要比较两种策略的最大值即可，而完全背包和多重背包要考虑的是选几个的问题。

这样说也许还是不够形象，举个栗子就能比较好的说明了：

假设背包容量为10，有两个物品可选，价值分别为：3，2，容量占用分别为，4，3。

初始状态：

![](https://i.loli.net/2019/05/11/5cd684433922b.jpeg)

01背包的填表法：

![](https://i.loli.net/2019/05/11/5cd6864f6eb81.jpeg)

完全背包的填表法：

![](https://i.loli.net/2019/05/11/5cd6864d1d669.jpeg)

多重背包的填表法：

假设两种物品的可选数量分别为：2，1.

![](https://i.loli.net/2019/05/11/5cd6864e5627b.jpeg)

下面再来看看三种背包问题的一维数组解决方案。

01背包：

```
for i <- 1 to N
    for v <- V to Ci
        F[v] = max{F[v],F[v-Ci] + Wi}
```

将其核心部分抽象出来：

```
def ZeroOneKnapsack(F,C,W)
    for v <- V to C
        F[v] = max{F[v],F[v-C] + W}
```

则01背包问题可以表示为：

```
for i <- 1 to N
    ZeroOneKnapsack(F,Ci,Wi)
```

> N代表物品数量，Ci代表第i个物品占用的容量，V代表背包总容量，Wi代表第i个物品的价值，下同。

完全背包：

```
for i <- 1 to N
    for v <- Ci to V
        F[v] = max{F[v],F[v-Ci] + Wi}
```

将其核心部分抽象出来：

```
def CompleteKnapsack(F,C,W)
    for v <- C to V
        F[v] = max{F[v],F[v-C] + W}
```

则完全背包问题的解可以表示为：

```
for i <- 1 to N
    CompleteKnapsack(F,Ci,Wi)
```

多重背包：

```
for i <- 1 to N
    if v < Ci * Mi
        F[v] = max{F[v],F[v-Ci] + Wi}
    else
        for v <- Ci to V
            k <- 1
            while k < M && v > Ci * k
                F[v] = max{F[v],F[v-Ci*k] + Wi*k}
                k++
```

抽象出核心逻辑：

```
def MultiKnapsack(F,C,W,M)
    if C * M >= V
        CompleteKnapsack(F,C,W)
        return
    else
        k <- 1
        while k < M
            ZeroOneKnapsack(F,KC,KW)
            k++
        return
```

则多重背包问题的解可以表示为：

```
for i <- 1 to N
    MultiKnapsack(F,Ci,Wi,Mi)
```

> Mi 代表第i件物品最多可选数量

## 混合背包问题

现在我们来考虑一种更为复杂的情况，如果可选的物品同时具有上述三种特性，即：有的物品只能选一个，有的物品可以选择任意多个，有的物品只能选择有限多个，那么此时该如何决策呢？

其实有了上面的总结和抽象，这种混合背包问题就小菜一碟了。

回顾一下上面的三种背包问题的抽象解，就会发现他们每次都只会考虑一种物品，区别只在于第i个物品的可选策略。所以对于混合背包问题，同样也可以一个一个物品考虑，如果这个物品是最多选一个，那么就采用01背包的解决策略，如果是可以选择任意多个，那么就使用完全背包的解决策略，如果只能选择有限多个，那么就使用多重背包的解决策略。

伪代码如下：

```
for i <- 1 to N
    if 第i件物品属于01背包
        ZeroOneKnapsack(F,Ci,Wi)
    else if 第i件物品属于完全背包
        CompleteKnapsack(F,Ci,Wi)
    else if 第i件物品属于多重背包
        MultiKnapsack(F,Ci,Wi,Mi)
```

## 总结

到此为止，我们就已经比较完美的解决了三种背包问题，顺便还解决了一下混合背包问题。虽然条件各不相同，但是解题思路却很相似，相信经过这一篇文章的总结，你对于背包问题也会有更好的理解，并且领会到这种抽象问题的好处。

当然，更深层次的背包问题还有很多，比如二维费用问题，物品依赖问题，鉴于博主学疏才浅，暂时也没有探索的兴趣，所以就不一一进行说明了，有兴趣的话可以自行搜索相关内容。

![](https://i.loli.net/2019/03/14/5c8a580b1789e.png)

如果本文对你有帮助，不要吝啬你的点赞哦。也欢迎关注我的公众号进行留言交流。

![](https://i.loli.net/2019/03/14/5c8a58ba229ca.png)

文末再赠送一个小福利，关注公众号并回复： `python电子书大全`  即可无套路获得上百本python电子书资源。