---
title: 《Java并发编程的艺术》读书笔记
tags: 
 - Java
 - 多线程
categories: 阅读
date: 2019-01-03 08:06:15
---
> 书籍作者：方腾飞 魏鹏 程晓明

## 第一章 并发编程的挑战

1.1 上下文切换

1. 时间片一般是几十毫秒。

```bash
疑问：时间片与CPU的哪个属性有关？
```

2. 任务从保存到再加载的过程就是一次上下文切换。

```bash
疑问：多个线程不没有产生竞争、阻塞或等待，也会发生上下文切换吗？
```

3. 使用`Lmbench3`可以测量上下文切换的时长。
4. 使用`vmstat`可以测量上下文切换的次数。
5. 减少上下文切换的方法：
   1. 无锁并发编程
   2. CAS算法
   3. 使用最少线程
   4. 协程

1.2 死锁

避免死锁的常见方法：

1. 避免一个线程同时获取多个锁。
2. 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
3. 尝试使用定时锁，使用`lock.tryLock(timeout)`来替代使用内部锁机制。
4. 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。

1.3 资源限制的挑战

1. 资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或者软件资源。
2. 在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变成并发执行，但是如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。
3. 对于硬件资源限制，可以考虑使用集群并行执行程序。对于软件资源限制，可以考虑使用资源池将资源进行复用。
   
## 第二章 Java并发机制的底层实现原理

2.1 volatile的应用

1. 用volatile修饰的共享变量进行写操作的时候，虚拟机会在其代码中插入`Lock`前缀指令，该指令在多核处理器下会引发两件事情：
   1. 将当前处理器缓存行的数据写回到系统内存。
   2. 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。

```bash
这部分内容在《Java多线程实战指南》里说的更加详细
```

2.2 synchronized的实现原理与应用

1. `JVM`基于进入和退出`Monitor`对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用`monitorenter`和`monitorexit`指令实现的，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。
2. `synchronized`用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节。

| 长度     | 内容                   | 说明                             |
| -------- | ---------------------- | -------------------------------- |
| 32/64bit | Mark Word              | 存储对象的hashCode或锁信息等     |
| 32/64bit | Class Metadata Address | 存储到对象类型数据的指针         |
| 32/64bit | Array length           | 数组的长度（如果当前对象是数组） |

3. Java 对象头里的`Mark Word`里默认存储对象的`HashCode`、分代年龄和锁标记位。
4. 锁一共有4种状态，级别从低到高分别是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。
5. 锁可以升级但不能降级。
6. 偏向锁：当一个线程访问同步块时并获取锁时，会在对象头和栈帧中的所记录里存储锁偏向的线程id，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的`Mark Word`里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已获得了锁。如果测试失败，则需要再测试一下`Mark Word`中偏向锁的标志位是否设置为1（表示当前为偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。
7. 偏向锁使用的是等到发生竞争后才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。
8. 偏向锁的撤销需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停持有偏向锁的线程，然后检测该线程是否仍处于同步代码块，如果不处于，则将对象头中的`Mark Word`信息设置为无锁状态，如果线程仍处于同步块，则会将该偏向锁升级为轻量级锁，然后唤醒暂停的线程。如下图：
   
![](https://ask.qcloudimg.com/http-save/yehe-1174983/cm2p35nftf.png?imageView2/2/w/1620)

![](https://ask.qcloudimg.com/http-save/yehe-1174983/qeqp98u8so.png?imageView2/2/w/1620)

9. 偏向锁在Java6和Java7中是默认启用的，如果有必要可以使用JVM参数来关闭偏向锁：`-XX:-UseBiasedLocking=false`，则程序会默认进入轻量级锁状态。
10. 轻量级锁加锁：JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的`Mark Word`复制到锁记录中，官方称为`Displaced Mark Word`。然后线程尝试使用CAS将对象头中的`Mark Word`替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。
11. 轻量级锁解锁：使用原子的CAS操作将`Displaced Mark Word`替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。

![](https://ask.qcloudimg.com/http-save/yehe-1174983/hr3330qo7g.png?imageView2/2/w/1620)
![](https://ask.qcloudimg.com/http-save/yehe-1174983/acgacyts24.png?imageView2/2/w/1620)
![](https://ask.qcloudimg.com/http-save/yehe-1174983/ro5yr0z6y9.png?imageView2/2/w/1620)

|锁类型|优点|缺点|适用场景|
|---|---|---|---|
|偏向锁|加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距|如果线程间存在锁竞争，会带来额外的锁撤销的消耗|适用于只有一个线程访问同步块场景|
|轻量级锁|竞争的线程不会阻塞，提高了程序的相应速度|如果始终得不到锁竞争的线程，使用自旋会消耗CPU|追求响应时间，同步块执行速度非常快|
|重量级锁|线程竞争不使用自旋，不会消耗CPU|线程阻塞，响应时间缓慢|追求吞吐量，同步块执行时间较长|

2.3 原子操作的实现原理

1. 第一个机制是通过总线锁保证原子性。
2. 第二个机制是通过缓存锁定来保证原子性。
3. Java中可以通过锁和循环CAS的方式来实现原子操作。
4. CAS实现原子操作的三大问题
   1. ABA问题：如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。解决思路：在变量前面加上版本号，每次变量更新的时候把版本号加1.当前可以使用`AtomicStampedReference`来解决ABA问题。
   2. 循环时间长开销大。
   3. 只能保证一个共享变量的原子操作。可以使用`AtomicReference`类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS。